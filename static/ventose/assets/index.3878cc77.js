var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
function normalizeStyle(value) {
  if (isArray$c(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$4(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString$4(value)) {
    return value;
  } else if (isObject$4(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$4(value)) {
    res = value;
  } else if (isArray$c(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props3) {
  if (!props3)
    return null;
  let { class: klass, style: style2 } = props3;
  if (klass && !isString$4(klass)) {
    props3.class = normalizeClass(klass);
  }
  if (style2) {
    props3.style = normalizeStyle(style2);
  }
  return props3;
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i2 = 0; equal && i2 < a2.length; i2++) {
    equal = looseEqual(a2[i2], b2[i2]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$2(a2);
  let bValidType = isDate$2(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol$2(a2);
  bValidType = isSymbol$2(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray$c(a2);
  bValidType = isArray$c(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$4(a2);
  bValidType = isObject$4(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key2 in a2) {
      const aHasKey = a2.hasOwnProperty(key2);
      const bHasKey = b2.hasOwnProperty(key2);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$4(val) ? val : val == null ? "" : isArray$c(val) || isObject$4(val) && (val.toString === objectToString$2 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap$3(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
        entries[`${key2} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet$3(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$4(val) && !isArray$c(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE$2 = /^on[^a-z]/;
const isOn$1 = (key2) => onRE$2.test(key2);
const isModelListener = (key2) => key2.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$e = Object.prototype.hasOwnProperty;
const hasOwn$3 = (val, key2) => hasOwnProperty$e.call(val, key2);
const isArray$c = Array.isArray;
const isMap$3 = (val) => toTypeString(val) === "[object Map]";
const isSet$3 = (val) => toTypeString(val) === "[object Set]";
const isDate$2 = (val) => toTypeString(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$4 = (val) => typeof val === "string";
const isSymbol$2 = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$4(val) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key2) => isString$4(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction$2 = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE$2 = /-(\w)/g;
const camelize$2 = cacheStringFunction$2((str) => {
  return str.replace(camelizeRE$2, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE$1 = /\B([A-Z])/g;
const hyphenate$1 = cacheStringFunction$2((str) => str.replace(hyphenateRE$1, "-$1").toLowerCase());
const capitalize = cacheStringFunction$2((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction$2((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key2, value) => {
  Object.defineProperty(obj, key2, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$1 = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last3 = this.parent.scopes.pop();
        if (last3 && last3 !== this) {
          this.parent.scopes[this.index] = last3;
          last3.index = this.index;
        }
      }
      this.parent = void 0;
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent2 = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent2) {
      if (parent2 === this) {
        return;
      }
      parent2 = parent2.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend$1(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last3 = trackStack.pop();
  shouldTrack = last3 === void 0 ? true : last3;
}
function track(target, type4, key2) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$1(target, type4, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type4 === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$c(target)) {
    const newLength = toNumber$1(newValue);
    depsMap.forEach((dep, key3) => {
      if (key3 === "length" || key3 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type4) {
      case "add":
        if (!isArray$c(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$3(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$c(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$3(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$c(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$2)
);
const get$5 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args2) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key2](...args2);
      if (res === -1 || res === false) {
        return arr[key2](...args2.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args2) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args2);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get4(target, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_isShallow") {
      return shallow;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$c(target);
    if (!isReadonly2 && targetIsArray && hasOwn$3(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol$2(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key2) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$2 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key2, value, receiver) {
    let oldValue = target[key2];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$c(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$c(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$3(target, key2);
    const result = Reflect.set(target, key2, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key2, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key2) {
  const hadKey = hasOwn$3(target, key2);
  target[key2];
  const result = Reflect.deleteProperty(target, key2);
  if (result && hadKey) {
    trigger$1(target, "delete", key2, void 0);
  }
  return result;
}
function has$4(target, key2) {
  const result = Reflect.has(target, key2);
  if (!isSymbol$2(key2) || !builtInSymbols.has(key2)) {
    track(target, "has", key2);
  }
  return result;
}
function ownKeys$2(target) {
  track(target, "iterate", isArray$c(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$5,
  set: set$2,
  deleteProperty,
  has: has$4,
  ownKeys: ownKeys$2
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key2) {
    return true;
  },
  deleteProperty(target, key2) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$1({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto$1 = (v2) => Reflect.getPrototypeOf(v2);
function get$1$1(target, key2, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (key2 !== rawKey) {
      track(rawTarget, "get", key2);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto$1(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
  if (has2.call(rawTarget, key2)) {
    return wrap(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$1$1(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (!isReadonly2) {
    if (key2 !== rawKey) {
      track(rawTarget, "has", key2);
    }
    track(rawTarget, "has", rawKey);
  }
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size$1(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto$1(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger$1(target, "add", value, value);
  }
  return this;
}
function set$1$1(key2, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get4 } = getProto$1(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get4.call(target, key2);
  target.set(key2, value);
  if (!hadKey) {
    trigger$1(target, "add", key2, value);
  } else if (hasChanged(value, oldValue)) {
    trigger$1(target, "set", key2, value);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get4 } = getProto$1(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get4 ? get4.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger$1(target, "delete", key2, void 0);
  }
  return result;
}
function clear$1() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key2) => {
      return callback.call(thisArg, wrap(value), wrap(key2), observed);
    });
  };
}
function createIterableMethod(method4, isReadonly2, isShallow2) {
  return function(...args2) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$3(rawTarget);
    const isPair = method4 === "entries" || method4 === Symbol.iterator && targetIsMap;
    const isKeyOnly = method4 === "keys" && targetIsMap;
    const innerIterator = target[method4](...args2);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type4) {
  return function(...args2) {
    return type4 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, false, true);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add,
    set: set$1$1,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key2) {
      return has$1$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1$1(this, key2, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key2) {
      return has$1$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method4) => {
    mutableInstrumentations2[method4] = createIterableMethod(method4, false, false);
    readonlyInstrumentations2[method4] = createIterableMethod(method4, true, false);
    shallowInstrumentations2[method4] = createIterableMethod(method4, false, true);
    shallowReadonlyInstrumentations2[method4] = createIterableMethod(method4, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$3(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive$1 = (value) => isObject$4(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef$1(value, false);
}
function shallowRef(value) {
  return createRef$1(value, true);
}
function createRef$1(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive$1(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive$1(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
  set: (target, key2, value, receiver) => {
    const oldValue = target[key2];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key2, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get4, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get4;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object4) {
  const ret = isArray$c(object4) ? new Array(object4.length) : {};
  for (const key2 in object4) {
    ret[key2] = toRef(object4, key2);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object4, key2, defaultValue) {
  const val = object4[key2];
  return isRef(val) ? val : new ObjectRefImpl(object4, key2, defaultValue);
}
var _a;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args2) {
  return;
}
function callWithErrorHandling(fn, instance, type4, args2) {
  let res;
  try {
    res = args2 ? fn(...args2) : fn();
  } catch (err) {
    handleError(err, instance, type4);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type4, args2) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type4, args2);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type4);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type4, args2));
  }
  return values;
}
function handleError(err, instance, type4, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type4;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError$1(err, type4, contextVNode, throwInDev);
}
function logError$1(err, type4, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$c(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff2 = getId(a2) - getId(b2);
  if (diff2 === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff2;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools;
let buffer$1 = [];
function setDevtoolsHook(hook, target) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer$1.forEach(({ event: event2, args: args2 }) => devtools.emit(event2, ...args2));
    buffer$1 = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer$1 = [];
      }
    }, 3e3);
  } else {
    buffer$1 = [];
  }
}
function emit$1(instance, event2, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props3 = instance.vnode.props || EMPTY_OBJ;
  let args2 = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props3) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number4, trim: trim2 } = props3[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args2 = rawArgs.map((a2) => isString$4(a2) ? a2.trim() : a2);
    }
    if (number4) {
      args2 = rawArgs.map(toNumber$1);
    }
  }
  let handlerName;
  let handler5 = props3[handlerName = toHandlerKey(event2)] || props3[handlerName = toHandlerKey(camelize$2(event2))];
  if (!handler5 && isModelListener2) {
    handler5 = props3[handlerName = toHandlerKey(hyphenate$1(event2))];
  }
  if (handler5) {
    callWithAsyncErrorHandling(handler5, instance, 6, args2);
  }
  const onceHandler = props3[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args2);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached2 = cache.get(comp);
  if (cached2 !== void 0) {
    return cached2;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$c(raw)) {
    raw.forEach((key2) => normalized[key2] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key2) {
  if (!options || !isOn$1(key2)) {
    return false;
  }
  key2 = key2.slice(2).replace(/Once$/, "");
  return hasOwn$3(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$3(options, hyphenate$1(key2)) || hasOwn$3(options, key2);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args2) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args2);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props: props3, propsOptions: [propsOptions], slots, attrs, emit, render: render14, renderCache, data: data9, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev2 = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render14.call(proxyToUse, proxyToUse, renderCache, props3, setupState, data9, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render15 = Component;
      if (false)
        ;
      result = normalizeVNode(render15.length > 1 ? render15(props3, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render15(props3, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment$1);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode(child)) {
      if (child.type !== Comment$1 || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key2 in attrs) {
    if (key2 === "class" || key2 === "style" || isOn$1(key2)) {
      (res || (res = {}))[key2] = attrs[key2];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props3) => {
  const res = {};
  for (const key2 in attrs) {
    if (!isModelListener(key2) || !(key2.slice(9) in props3)) {
      res[key2] = attrs[key2];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key2 = dynamicProps[i2];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key2 = nextKeys[i2];
    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent: parent2 }, el) {
  while (parent2 && parent2.subTree === vnode) {
    (vnode = parent2.vnode).el = el;
    parent2 = parent2.parent;
  }
}
const isSuspense = (type4) => type4.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name2) {
  const eventListener = vnode.props && vnode.props[name2];
  if (isFunction$3(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch2, o: { createElement } } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch2(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch2(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch2, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch2(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch2(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch2(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch2(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch2(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch2(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch2(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch2(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parent2, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const { p: patch2, m: move, um: unmount, n: next2, o: { parentNode, remove: remove2 } } = rendererInternals;
  const timeout = toNumber$1(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent: parent2,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next2(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent3 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent3) {
        if (parent3.pendingBranch) {
          parent3.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent3 = parent3.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next2(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch2(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        true
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type4) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type4);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next2(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          parentNode(hydratedEl || instance.subTree.el),
          hydratedEl ? null : next2(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment$1);
}
function normalizeSuspenseSlot(s2) {
  let block;
  if (isFunction$3(s2)) {
    const trackBlock = isBlockTreeEnabled && s2._c;
    if (trackBlock) {
      s2._d = false;
      openBlock();
    }
    s2 = s2();
    if (trackBlock) {
      s2._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$c(s2)) {
    const singleChild = filterSingleRoot(s2);
    s2 = singleChild;
  }
  s2 = normalizeVNode(s2);
  if (block && !s2.dynamicChildren) {
    s2.dynamicChildren = block.filter((c2) => c2 !== s2);
  }
  return s2;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$c(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key2, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key2] = value;
  }
}
function inject(key2, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key2 in provides) {
      return provides[key2];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source2, cb, options) {
  return doWatch(source2, cb, options);
}
function doWatch(source2, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source2)) {
    getter = () => source2.value;
    forceTrigger = isShallow(source2);
  } else if (isReactive(source2)) {
    getter = () => source2;
    deep = true;
  } else if (isArray$c(source2)) {
    isMultiSource = true;
    forceTrigger = source2.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source2.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$3(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$3(source2)) {
    if (cb) {
      getter = () => callWithErrorHandling(source2, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup2) {
          cleanup2();
        }
        return callWithAsyncErrorHandling(source2, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup2;
  let onCleanup = (fn) => {
    cleanup2 = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source2.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup2) {
          cleanup2();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source2, value, options) {
  const publicThis = this.proxy;
  const getter = isString$4(source2) ? source2.includes(".") ? createPathGetter(publicThis, source2) : () => publicThis[source2] : source2.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$4(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$c(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet$3(value) || isMap$3(value)) {
    value.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else if (isPlainObject$2(value)) {
    for (const key2 in value) {
      traverse(value[key2], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props3, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment$1) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props3);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key2 = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key2;
        } else if (key2 !== prevTransitionKey) {
          prevTransitionKey = key2;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment$1 && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment$1) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props3, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props3;
  const key2 = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args2) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args2);
  };
  const callAsyncHook = (hook, args2) => {
    const done = args2[1];
    callHook2(hook, args2);
    if (isArray$c(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key2];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key3 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key3] === vnode) {
          delete leavingVNodesCache[key3];
        }
      };
      leavingVNodesCache[key3] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props3, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key2 = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key2));
    } else if (keepComment || child.type !== Comment$1) {
      ret.push(key2 != null ? cloneVNode(child, { key: key2 }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$3(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source2) {
  if (isFunction$3(source2)) {
    source2 = { loader: source2 };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source2;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent2) {
  const { ref: ref2, props: props3, children, ce } = parent2.vnode;
  const vnode = createVNode(comp, props3, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent2.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props3, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current2 = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch2, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch2(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key2) => {
        const name2 = getComponentName(vnode.type);
        if (name2 && (!filter || !filter(name2))) {
          pruneCacheEntry(key2);
        }
      });
    }
    function pruneCacheEntry(key2) {
      const cached2 = cache.get(key2);
      if (!current2 || cached2.type !== current2.type) {
        unmount(cached2);
      } else if (current2) {
        resetShapeFlag(current2);
      }
      cache.delete(key2);
      keys2.delete(key2);
    }
    watch(
      () => [props3.include, props3.exclude],
      ([include, exclude]) => {
        include && pruneCache((name2) => matches(include, name2));
        exclude && pruneCache((name2) => !matches(exclude, name2));
      },
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached2) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached2.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached2);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current2 = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current2 = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name2 = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max: max3 } = props3;
      if (include && (!name2 || !matches(include, name2)) || exclude && name2 && matches(exclude, name2)) {
        current2 = vnode;
        return rawVNode;
      }
      const key2 = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key2);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key2;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key2);
        keys2.add(key2);
      } else {
        keys2.add(key2);
        if (max3 && keys2.size > parseInt(max3, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current2 = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern4, name2) {
  if (isArray$c(pattern4)) {
    return pattern4.some((p2) => matches(p2, name2));
  } else if (isString$4(pattern4)) {
    return pattern4.split(",").includes(name2);
  } else if (pattern4.test) {
    return pattern4.test(name2);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type4, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current2 = target;
    while (current2) {
      if (current2.isDeactivated) {
        return;
      }
      current2 = current2.parent;
    }
    return hook();
  });
  injectHook(type4, wrappedHook, target);
  if (target) {
    let current2 = target.parent;
    while (current2 && current2.parent) {
      if (isKeepAlive(current2.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type4, target, current2);
      }
      current2 = current2.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type4, target, keepAliveRoot) {
  const injected = injectHook(type4, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type4], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type4, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type4] || (target[type4] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args2) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type4, args2);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args2) => hook(...args2), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$4(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type4, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type4 === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name2 || selfName === camelize$2(name2) || selfName === capitalize(camelize$2(name2)))) {
        return Component;
      }
    }
    const res = resolve(instance[type4] || Component[type4], name2) || resolve(instance.appContext[type4], name2);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize$2(name2)] || registry[capitalize(camelize$2(name2))]);
}
function renderList(source2, renderItem, cache, index2) {
  let ret;
  const cached2 = cache && cache[index2];
  if (isArray$c(source2) || isString$4(source2)) {
    ret = new Array(source2.length);
    for (let i2 = 0, l2 = source2.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source2[i2], i2, void 0, cached2 && cached2[i2]);
    }
  } else if (typeof source2 === "number") {
    ret = new Array(source2);
    for (let i2 = 0; i2 < source2; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached2 && cached2[i2]);
    }
  } else if (isObject$4(source2)) {
    if (source2[Symbol.iterator]) {
      ret = Array.from(source2, (item, i2) => renderItem(item, i2, void 0, cached2 && cached2[i2]));
    } else {
      const keys2 = Object.keys(source2);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key2 = keys2[i2];
        ret[i2] = renderItem(source2[key2], key2, i2, cached2 && cached2[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$c(slot)) {
      for (let j2 = 0; j2 < slot.length; j2++) {
        slots[slot[j2].name] = slot[j2].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args2) => {
        const res = slot.fn(...args2);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name2, props3 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props3.name = name2;
    return createVNode("slot", props3, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props3));
  const rendered = createBlock(Fragment, {
    key: props3.key || validSlotContent && validSlotContent.key || `_${name2}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment$1)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key2 in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key2) ? `on:${key2}` : toHandlerKey(key2)] = obj[key2];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$3(state, key2);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key2) {
    const { ctx, setupState, data: data9, props: props3, accessCache, type: type4, appContext } = instance;
    let normalizedProps;
    if (key2[0] !== "$") {
      const n2 = accessCache[key2];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key2];
          case 2:
            return data9[key2];
          case 4:
            return ctx[key2];
          case 3:
            return props3[key2];
        }
      } else if (hasSetupBinding(setupState, key2)) {
        accessCache[key2] = 1;
        return setupState[key2];
      } else if (data9 !== EMPTY_OBJ && hasOwn$3(data9, key2)) {
        accessCache[key2] = 2;
        return data9[key2];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$3(normalizedProps, key2)) {
        accessCache[key2] = 3;
        return props3[key2];
      } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (shouldCacheAccess) {
        accessCache[key2] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key2];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key2 === "$attrs") {
        track(instance, "get", key2);
      }
      return publicGetter(instance);
    } else if ((cssModule = type4.__cssModules) && (cssModule = cssModule[key2])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$3(ctx, key2)) {
      accessCache[key2] = 4;
      return ctx[key2];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$3(globalProperties, key2)) {
      {
        return globalProperties[key2];
      }
    } else
      ;
  },
  set({ _: instance }, key2, value) {
    const { data: data9, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key2)) {
      setupState[key2] = value;
      return true;
    } else if (data9 !== EMPTY_OBJ && hasOwn$3(data9, key2)) {
      data9[key2] = value;
      return true;
    } else if (hasOwn$3(instance.props, key2)) {
      return false;
    }
    if (key2[0] === "$" && key2.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key2] = value;
      }
    }
    return true;
  },
  has({ _: { data: data9, setupState, accessCache, ctx, appContext, propsOptions } }, key2) {
    let normalizedProps;
    return !!accessCache[key2] || data9 !== EMPTY_OBJ && hasOwn$3(data9, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$3(normalizedProps, key2) || hasOwn$3(ctx, key2) || hasOwn$3(publicPropertiesMap, key2) || hasOwn$3(appContext.config.globalProperties, key2);
  },
  defineProperty(target, key2, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key2] = 0;
    } else if (hasOwn$3(descriptor, "value")) {
      this.set(target, key2, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key2, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1({}, PublicInstanceProxyHandlers, {
  get(target, key2) {
    if (key2 === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key2, target);
  },
  has(_2, key2) {
    const has2 = key2[0] !== "_" && !isGloballyWhitelisted(key2);
    return has2;
  }
});
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created: created4,
    beforeMount,
    mounted: mounted6,
    beforeUpdate,
    updated: updated4,
    activated,
    deactivated: deactivated2,
    beforeDestroy,
    beforeUnmount: beforeUnmount6,
    destroyed,
    unmounted,
    render: render14,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components: components2,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key2 in methods) {
      const methodHandler = methods[key2];
      if (isFunction$3(methodHandler)) {
        {
          ctx[key2] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data9 = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data9))
      ;
    else {
      instance.data = reactive(data9);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key2 in computedOptions) {
      const opt = computedOptions[key2];
      const get4 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get4,
        set: set2
      });
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key2 in watchOptions) {
      createWatcher(watchOptions[key2], ctx, publicThis, key2);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key2) => {
      provide(key2, provides[key2]);
    });
  }
  if (created4) {
    callHook$1(created4, instance, "c");
  }
  function registerLifecycleHook(register3, hook) {
    if (isArray$c(hook)) {
      hook.forEach((_hook) => register3(_hook.bind(publicThis)));
    } else if (hook) {
      register3(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted6);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated4);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated2);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount6);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$c(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key2) => {
        Object.defineProperty(exposed, key2, {
          get: () => publicThis[key2],
          set: (val) => publicThis[key2] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render14 && instance.render === NOOP) {
    instance.render = render14;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components2)
    instance.components = components2;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$c(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key2 in injectOptions) {
    const opt = injectOptions[key2];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key2, opt.default, true);
      } else {
        injected = inject(opt.from || key2);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
    } else {
      ctx[key2] = injected;
    }
  }
}
function callHook$1(hook, instance, type4) {
  callWithAsyncErrorHandling(isArray$c(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type4);
}
function createWatcher(raw, ctx, publicThis, key2) {
  const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
  if (isString$4(raw)) {
    const handler5 = ctx[raw];
    if (isFunction$3(handler5)) {
      watch(getter, handler5);
    }
  } else if (isFunction$3(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$c(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
    } else {
      const handler5 = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler5)) {
        watch(getter, handler5, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached2 = cache.get(base2);
  let resolved;
  if (cached2) {
    resolved = cached2;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  if (isObject$4(base2)) {
    cache.set(base2, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions(to, m2, strats, true));
  }
  for (const key2 in from) {
    if (asMixin && key2 === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
      to[key2] = strat ? strat(to[key2], from[key2]) : from[key2];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(isFunction$3(to) ? to.call(this, this) : to, isFunction$3(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$c(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key2 in from) {
    merged[key2] = mergeAsArray$1(to[key2], from[key2]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props3 = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props3, attrs);
  for (const key2 in instance.propsOptions[0]) {
    if (!(key2 in props3)) {
      props3[key2] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props3 : shallowReactive(props3);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props3;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props: props3, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props3);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key2 = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key2)) {
          continue;
        }
        const value = rawProps[key2];
        if (options) {
          if (hasOwn$3(attrs, key2)) {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$2(key2);
            props3[camelizedKey] = resolvePropValue$1(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props3, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key2 in rawCurrentProps) {
      if (!rawProps || !hasOwn$3(rawProps, key2) && ((kebabKey = hyphenate$1(key2)) === key2 || !hasOwn$3(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key2] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props3[key2] = resolvePropValue$1(options, rawCurrentProps, key2, void 0, instance, true);
          }
        } else {
          delete props3[key2];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key2 in attrs) {
        if (!rawProps || !hasOwn$3(rawProps, key2) && true) {
          delete attrs[key2];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props3, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key2 in rawProps) {
      if (isReservedProp(key2)) {
        continue;
      }
      const value = rawProps[key2];
      let camelKey;
      if (options && hasOwn$3(options, camelKey = camelize$2(key2))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props3[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key2)) {
        if (!(key2 in attrs) || value !== attrs[key2]) {
          attrs[key2] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props3);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key2 = needCastKeys[i2];
      props3[key2] = resolvePropValue$1(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn$3(castValues, key2));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue$1(options, props3, key2, value, instance, isAbsent) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn$3(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key2 in propsDefaults) {
          value = propsDefaults[key2];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key2] = defaultValue.call(null, props3);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate$1(key2))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached2 = cache.get(comp);
  if (cached2) {
    return cached2;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props3, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props3);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$c(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize$2(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key2 in raw) {
      const normalizedKey = camelize$2(key2);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key2];
        const prop = normalized[normalizedKey] = isArray$c(opt) || isFunction$3(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$3(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key2) {
  if (key2[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match2 ? match2[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type4, expectedTypes) {
  if (isArray$c(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type4));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type4) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
const normalizeSlotValue = (value) => isArray$c(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key2, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args2) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args2));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key2 in rawSlots) {
    if (isInternalKey(key2))
      continue;
    const value = rawSlots[key2];
    if (isFunction$3(value)) {
      slots[key2] = normalizeSlot(key2, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key2] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      instance.slots = toRaw(children);
      def(children, "_", type4);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type4 = children._;
    if (type4) {
      if (optimized && type4 === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type4 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key2 in slots) {
      if (!isInternalKey(key2) && !(key2 in deletionComparisonTarget)) {
        delete slots[key2];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render14, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context2 = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context2.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context2,
      _instance: null,
      version: version$2,
      get config() {
        return context2.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context2.mixins.includes(mixin)) {
            context2.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name2, component) {
        if (!component) {
          return context2.components[name2];
        }
        context2.components[name2] = component;
        return app;
      },
      directive(name2, directive) {
        if (!directive) {
          return context2.directives[name2];
        }
        context2.directives[name2] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context2;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render14(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render14(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key2, value) {
        context2.provides[key2] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$c(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$c(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$4(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$3(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$4(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$3(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$c(existing) && remove(existing, refValue);
          } else {
            if (!isArray$c(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$3(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$3(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch2, o: { patchProp: patchProp2, createText, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch2(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type: type4, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type4) {
      case Text$2:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment$1:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type: type4, props: props3, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type4 === "input" && dirs || type4 === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props3) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key2 in props3) {
            if (forcePatchValue && key2.endsWith("value") || isOn$1(key2) && !isReservedProp(key2)) {
              patchProp2(el, key2, null, props3[key2], false, void 0, parentComponent);
            }
          }
        } else if (props3.onClick) {
          patchProp2(el, "onClick", null, props3.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props3 && props3.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props3 && props3.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props3 && (props3.innerHTML || props3.textContent))) {
        let next2 = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        while (next2) {
          hasMismatch = true;
          const cur = next2;
          next2 = next2.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l2 = children.length;
    for (let i2 = 0; i2 < l2; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text$2 && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch2(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next2 = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next2 && isComment(next2) && next2.data === "]") {
      return nextSibling(vnode.anchor = next2);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next2);
      return next2;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next3 = nextSibling(node);
        if (next3 && next3 !== end) {
          remove2(next3);
        } else {
          break;
        }
      }
    }
    const next2 = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch2(null, vnode, container, next2, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next2;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match2 = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match2++;
        if (node.data === "]") {
          if (match2 === 0) {
            return nextSibling(node);
          } else {
            match2--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch2 = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type4, ref: ref2, shapeFlag } = n2;
    switch (type4) {
      case Text$2:
        processText(n1, n2, container, anchor);
        break;
      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type4.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type4.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next2;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next2;
    while (el && el !== anchor) {
      next2 = hostNextSibling(el);
      hostRemove(el);
      el = next2;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type: type4, props: props3, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props3 && props3.is, props3);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type4 !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    if (props3) {
      for (const key2 in props3) {
        if (key2 !== "value" && !isReservedProp(key2)) {
          hostPatchProp(el, key2, null, props3[key2], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props3) {
        hostPatchProp(el, "value", null, props3.value);
      }
      if (vnodeHook = props3.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props3 && props3.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch2(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key2 = propsToUpdate[i2];
            const prev2 = oldProps[key2];
            const next2 = newProps[key2];
            if (next2 !== prev2 || key2 === "value") {
              hostPatchProp(el, key2, prev2, next2, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch2(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key2 in oldProps) {
          if (!isReservedProp(key2) && !(key2 in newProps)) {
            hostPatchProp(el, key2, oldProps[key2], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key2 in newProps) {
        if (isReservedProp(key2))
          continue;
        const next2 = newProps[key2];
        const prev2 = oldProps[key2];
        if (next2 !== prev2 && key2 !== "value") {
          hostPatchProp(el, key2, prev2, next2, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props3 } = initialVNode;
        const { bm, m: m2, parent: parent2 } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props3 && props3.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent2, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch2(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props3 && props3.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next: next2, bu, u: u2, parent: parent2, vnode } = instance;
        let originNext = next2;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next2) {
          next2.el = vnode.el;
          updateComponentPreRender(instance, next2, optimized);
        } else {
          next2 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent2, next2, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch2(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next2.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, next2, vnode), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch2(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch2(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch2(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch2(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved2 = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved2 = true;
          }
          patch2(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch2(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved2) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type4, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type4.move(vnode, container, anchor, internals);
      return;
    }
    if (type4 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type4 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type: type4, props: props3, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props3 && props3.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type4 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type4 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props3 && props3.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type4, el, anchor, transition } = vnode;
    if (type4 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type4 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next2;
    while (cur !== end) {
      next2 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next2;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render14 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch2(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch2,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render14,
    hydrate: hydrate2,
    createApp: createAppAPI(render14, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$c(ch1) && isArray$c(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text$2) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type4) => type4.__isTeleport;
const isTeleportDisabled = (props3) => props3 && (props3.disabled || props3.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props3, select) => {
  const targetSelector = props3 && props3.to;
  if (isString$4(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props: props3 } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props3)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props3 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props3)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol(void 0);
const Text$2 = Symbol(void 0);
const Comment$1 = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type4, props3, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type4, props3, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type4, props3, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type4, props3, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$4(ref2) || isRef(ref2) || isFunction$3(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type4, props3 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type4 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type4,
    props: props3,
    key: props3 && normalizeKey(props3),
    ref: props3 && normalizeRef(props3),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type4.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$4(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type4, props3 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type4 || type4 === NULL_DYNAMIC_COMPONENT) {
    type4 = Comment$1;
  }
  if (isVNode(type4)) {
    const cloned = cloneVNode(type4, props3, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type4)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type4)) {
    type4 = type4.__vccOpts;
  }
  if (props3) {
    props3 = guardReactiveProps(props3);
    let { class: klass, style: style2 } = props3;
    if (klass && !isString$4(klass)) {
      props3.class = normalizeClass(klass);
    }
    if (isObject$4(style2)) {
      if (isProxy(style2) && !isArray$c(style2)) {
        style2 = extend$1({}, style2);
      }
      props3.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$4(type4) ? 1 : isSuspense(type4) ? 128 : isTeleport(type4) ? 64 : isObject$4(type4) ? 4 : isFunction$3(type4) ? 2 : 0;
  return createBaseVNode(type4, props3, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props3) {
  if (!props3)
    return null;
  return isProxy(props3) || InternalObjectKey in props3 ? extend$1({}, props3) : props3;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props: props3, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props3 || {}, extraProps) : props3;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$c(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text$2, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment$1);
  } else if (isArray$c(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text$2, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type4 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$c(children)) {
    type4 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type4 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type4 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type4 = 16;
      children = [createTextVNode(children)];
    } else {
      type4 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type4;
}
function mergeProps(...args2) {
  const ret = {};
  for (let i2 = 0; i2 < args2.length; i2++) {
    const toMerge = args2[i2];
    for (const key2 in toMerge) {
      if (key2 === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key2 === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key2)) {
        const existing = ret[key2];
        const incoming = toMerge[key2];
        if (incoming && existing !== incoming && !(isArray$c(existing) && existing.includes(incoming))) {
          ret[key2] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key2 !== "") {
        ret[key2] = toMerge[key2];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1$1 = 0;
function createComponentInstance(vnode, parent2, suspense) {
  const type4 = vnode.type;
  const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1$1++,
    vnode,
    type: type4,
    parent: parent2,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent2 ? parent2.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type4, appContext),
    emitsOptions: normalizeEmitsOptions(type4, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type4.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent2 ? parent2.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props: props3, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props3, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup: setup219 } = Component;
  if (setup219) {
    const setupContext = instance.setupContext = setup219.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup219, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(extend$1({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key2) {
      track(instance, "get", "$attrs");
      return target[key2];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key2) {
        if (key2 in target) {
          return target[key2];
        } else if (key2 in publicPropertiesMap) {
          return publicPropertiesMap[key2](instance);
        }
      },
      has(target, key2) {
        return key2 in target || key2 in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$3(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function withDefaults(props3, defaults2) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function mergeDefaults(raw, defaults2) {
  const props3 = isArray$c(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key2 in defaults2) {
    const opt = props3[key2];
    if (opt) {
      if (isArray$c(opt) || isFunction$3(opt)) {
        props3[key2] = { type: opt, default: defaults2[key2] };
      } else {
        opt.default = defaults2[key2];
      }
    } else if (opt === null) {
      props3[key2] = { default: defaults2[key2] };
    } else
      ;
  }
  return props3;
}
function createPropsRestProxy(props3, excludedKeys) {
  const ret = {};
  for (const key2 in props3) {
    if (!excludedKeys.includes(key2)) {
      Object.defineProperty(ret, key2, {
        enumerable: true,
        get: () => props3[key2]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e2) => {
      setCurrentInstance(ctx);
      throw e2;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h$1(type4, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$c(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type4, null, [propsOrChildren]);
      }
      return createVNode(type4, propsOrChildren);
    } else {
      return createVNode(type4, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type4, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render14, cache, index2) {
  const cached2 = cache[index2];
  if (cached2 && isMemoSame(cached2, memo)) {
    return cached2;
  }
  const ret = render14();
  ret.memo = memo.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached2, memo) {
  const prev2 = cached2.memo;
  if (prev2.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev2.length; i2++) {
    if (hasChanged(prev2[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached2);
  }
  return true;
}
const version$2 = "3.2.45";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent2, anchor) => {
    parent2.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent2 = child.parentNode;
    if (parent2) {
      parent2.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props3) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props3 && props3.multiple != null) {
      el.setAttribute("multiple", props3.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  insertStaticContent(content, parent2, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent2.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent2.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent2.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent2.firstChild,
      anchor ? anchor.previousSibling : parent2.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev2, next2) {
  const style2 = el.style;
  const isCssString = isString$4(next2);
  if (next2 && !isCssString) {
    for (const key2 in next2) {
      setStyle$1(style2, key2, next2[key2]);
    }
    if (prev2 && !isString$4(prev2)) {
      for (const key2 in prev2) {
        if (next2[key2] == null) {
          setStyle$1(style2, key2, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev2 !== next2) {
        style2.cssText = next2;
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle$1(style2, name2, val) {
  if (isArray$c(val)) {
    val.forEach((v2) => setStyle$1(style2, name2, v2));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style2.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style2, name2);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate$1(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached2 = prefixCache[rawName];
  if (cached2) {
    return cached2;
  }
  let name2 = camelize$2(rawName);
  if (name2 !== "filter" && name2 in style2) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key2, value, isSVG, instance) {
  if (isSVG && key2.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
    } else {
      el.setAttributeNS(xlinkNS, key2, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key2);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key2 === "innerHTML" || key2 === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key2] = value == null ? "" : value;
    return;
  }
  if (key2 === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key2);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type4 = typeof el[key2];
    if (type4 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type4 === "string") {
      value = "";
      needRemove = true;
    } else if (type4 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key2] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key2);
}
function addEventListener$3(el, event2, handler5, options) {
  el.addEventListener(event2, handler5, options);
}
function removeEventListener$2(el, event2, handler5, options) {
  el.removeEventListener(event2, handler5, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener$3(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$2(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event2 = name2[2] === ":" ? name2.slice(3) : hyphenate$1(name2.slice(2));
  return [event2, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    if (!e2._vts) {
      e2._vts = Date.now();
    } else if (e2._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$c(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key2 === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key2 === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn$1(key2)) {
    if (!isModelListener(key2)) {
      patchEvent(el, key2, prevValue, nextValue, parentComponent);
    }
  } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
    patchDOMProp(el, key2, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key2 === "true-value") {
      el._trueValue = nextValue;
    } else if (key2 === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key2, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key2, value, isSVG) {
  if (isSVG) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      return true;
    }
    if (key2 in el && nativeOnRE.test(key2) && isFunction$3(value)) {
      return true;
    }
    return false;
  }
  if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate") {
    return false;
  }
  if (key2 === "form") {
    return false;
  }
  if (key2 === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key2 === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key2) && isString$4(value)) {
    return false;
  }
  return key2 in el;
}
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render$a(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    new MutationObserver((mutations) => {
      for (const m2 of mutations) {
        this._setAttr(m2.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props: props3, styles } = def2;
      let numberProps;
      if (props3 && !isArray$c(props3)) {
        for (const key2 in props3) {
          const opt = props3[key2];
          if (opt === Number || opt && opt.type === Number) {
            if (key2 in this._props) {
              this._props[key2] = toNumber$1(this._props[key2]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$2(key2)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props: props3 } = def2;
    const declaredPropKeys = isArray$c(props3) ? props3 : Object.keys(props3 || {});
    for (const key2 of Object.keys(this)) {
      if (key2[0] !== "_" && declaredPropKeys.includes(key2)) {
        this._setProp(key2, this[key2], true, false);
      }
    }
    for (const key2 of declaredPropKeys.map(camelize$2)) {
      Object.defineProperty(this, key2, {
        get() {
          return this._getProp(key2);
        },
        set(val) {
          this._setProp(key2, val);
        }
      });
    }
  }
  _setAttr(key2) {
    let value = this.getAttribute(key2);
    const camelKey = camelize$2(key2);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber$1(value);
    }
    this._setProp(camelKey, value, false);
  }
  _getProp(key2) {
    return this._props[key2];
  }
  _setProp(key2, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key2]) {
      this._props[key2] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate$1(key2), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate$1(key2), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate$1(key2));
        }
      }
    }
  }
  _update() {
    render$a(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$1({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        const dispatch2 = (event2, args2) => {
          this.dispatchEvent(new CustomEvent(event2, {
            detail: args2
          }));
        };
        instance.emit = (event2, ...args2) => {
          dispatch2(event2, args2);
          if (hyphenate$1(event2) !== event2) {
            dispatch2(hyphenate$1(event2), args2);
          }
        };
        let parent2 = this;
        while (parent2 = parent2 && (parent2.parentNode || parent2.host)) {
          if (parent2 instanceof VueElement) {
            instance.parent = parent2._instance;
            instance.provides = parent2._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css2) => {
        const s2 = document.createElement("style");
        s2.textContent = css2;
        this.shadowRoot.appendChild(s2);
      });
    }
  }
}
function useCssModule(name2 = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name2];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style2 = el.style;
    for (const key2 in vars) {
      style2.setProperty(`--${key2}`, vars[key2]);
    }
  }
}
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const Transition$1 = (props3, { slots }) => h$1(BaseTransition, resolveTransitionProps(props3), slots);
Transition$1.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition$1.props = /* @__PURE__ */ extend$1({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args2 = []) => {
  if (isArray$c(hook)) {
    hook.forEach((h2) => h2(...args2));
  } else if (hook) {
    hook(...args2);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$c(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps3 = {};
  for (const key2 in rawProps) {
    if (!(key2 in DOMTransitionPropsValidators)) {
      baseProps3[key2] = rawProps[key2];
    }
  }
  if (rawProps.css === false) {
    return baseProps3;
  }
  const { name: name2 = "v", type: type4, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps3;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type4, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps3, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type4, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$4(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type4, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type4) {
    return resolve2();
  }
  const endEvent = type4 + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd3);
    resolveIfNotStale();
  };
  const onEnd3 = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd3);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type4 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type4 = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type4 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type4 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type4 ? type4 === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type4 === TRANSITION$1 && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION$1}Property`).toString());
  return {
    type: type4,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props3, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props3.moveClass || `${props3.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style2 = el.style;
        addTransitionClass(el, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb = el._moveCb = (e2) => {
          if (e2 && e2.target !== el) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props3);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone3 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone3.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone3.classList.add(c2));
  clone3.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone3);
  const { hasTransform } = getTransitionInfo(clone3);
  container.removeChild(clone3);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$c(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart$1(e2) {
  e2.target.composing = true;
}
function onCompositionEnd$1(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number: number4 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number4 || vnode.props && vnode.props.type === "number";
    addEventListener$3(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber$1(domValue);
      }
      el._assign(domValue);
    });
    if (trim2) {
      addEventListener$3(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$3(el, "compositionstart", onCompositionStart$1);
      addEventListener$3(el, "compositionend", onCompositionEnd$1);
      addEventListener$3(el, "change", onCompositionEnd$1);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number4 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number4 || el.type === "number") && toNumber$1(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _2, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener$3(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue$5(el);
      const checked = el.checked;
      const assign2 = el._assign;
      if (isArray$c(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet$3(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$c(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet$3(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener$3(el, "change", () => {
      el._assign(getValue$5(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number: number4 } }, vnode) {
    const isSetModel = isSet$3(value);
    addEventListener$3(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map((o2) => number4 ? toNumber$1(getValue$5(o2)) : getValue$5(o2));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple2 = el.multiple;
  if (isMultiple2 && !isArray$c(value) && !isSet$3(value)) {
    return;
  }
  for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
    const option = el.options[i2];
    const optionValue = getValue$5(option);
    if (isMultiple2) {
      if (isArray$c(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue$5(option), value)) {
        if (el.selectedIndex !== i2)
          el.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple2 && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue$5(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key2 = checked ? "_trueValue" : "_falseValue";
  return key2 in el ? el[key2] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type4) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type4) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$c(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet$3(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  return (event2, ...args2) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event2, modifiers))
        return;
    }
    return fn(event2, ...args2);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event2) => {
    if (!("key" in event2)) {
      return;
    }
    const eventKey = hyphenate$1(event2.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event2);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$a = (...args2) => {
  ensureRenderer().render(...args2);
};
const hydrate = (...args2) => {
  ensureHydrationRenderer().hydrate(...args2);
};
const createApp = (...args2) => {
  const app = ensureRenderer().createApp(...args2);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args2) => {
  const app = ensureHydrationRenderer().createApp(...args2);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$4(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const runtimeDom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Transition: Transition$1,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate,
  initDirectivesForSSR,
  render: render$a,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize: camelize$2,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment: Comment$1,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text: Text$2,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h: h$1,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs,
  useSSRContext,
  useSlots,
  useTransitionState,
  version: version$2,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
}
function createCompilerError(code, loc, messages2, additionalMessage) {
  const msg = code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const FRAGMENT = Symbol(``);
const TELEPORT = Symbol(``);
const SUSPENSE = Symbol(``);
const KEEP_ALIVE = Symbol(``);
const BASE_TRANSITION = Symbol(``);
const OPEN_BLOCK = Symbol(``);
const CREATE_BLOCK = Symbol(``);
const CREATE_ELEMENT_BLOCK = Symbol(``);
const CREATE_VNODE = Symbol(``);
const CREATE_ELEMENT_VNODE = Symbol(``);
const CREATE_COMMENT = Symbol(``);
const CREATE_TEXT = Symbol(``);
const CREATE_STATIC = Symbol(``);
const RESOLVE_COMPONENT = Symbol(``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(``);
const RESOLVE_DIRECTIVE = Symbol(``);
const RESOLVE_FILTER = Symbol(``);
const WITH_DIRECTIVES = Symbol(``);
const RENDER_LIST = Symbol(``);
const RENDER_SLOT = Symbol(``);
const CREATE_SLOTS = Symbol(``);
const TO_DISPLAY_STRING = Symbol(``);
const MERGE_PROPS = Symbol(``);
const NORMALIZE_CLASS = Symbol(``);
const NORMALIZE_STYLE = Symbol(``);
const NORMALIZE_PROPS = Symbol(``);
const GUARD_REACTIVE_PROPS = Symbol(``);
const TO_HANDLERS = Symbol(``);
const CAMELIZE = Symbol(``);
const CAPITALIZE = Symbol(``);
const TO_HANDLER_KEY = Symbol(``);
const SET_BLOCK_TRACKING = Symbol(``);
const PUSH_SCOPE_ID = Symbol(``);
const POP_SCOPE_ID = Symbol(``);
const WITH_CTX = Symbol(``);
const UNREF = Symbol(``);
const IS_REF = Symbol(``);
const WITH_MEMO = Symbol(``);
const IS_MEMO_SAME = Symbol(``);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s2) => {
    helperNameMap[s2] = helpers[s2];
  });
}
const locStub = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
  return {
    type: 0,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc
  };
}
function createVNodeCall(context2, tag, props3, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context2) {
    if (isBlock) {
      context2.helper(OPEN_BLOCK);
      context2.helper(getVNodeBlockHelper(context2.inSSR, isComponent2));
    } else {
      context2.helper(getVNodeHelper(context2.inSSR, isComponent2));
    }
    if (directives) {
      context2.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props: props3,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key2, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString$4(key2) ? createSimpleExpression(key2, true) : key2,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args2 = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args2
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index2, value, isVNode2 = false) {
  return {
    type: 20,
    index: index2,
    value,
    isVNode: isVNode2,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
const isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate$1(expected);
function isCoreComponent(tag) {
  if (isBuiltInType(tag, "Teleport")) {
    return TELEPORT;
  } else if (isBuiltInType(tag, "Suspense")) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, "KeepAlive")) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, "BaseTransition")) {
    return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name2) => !nonIdentifierRE.test(name2);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const isMemberExpressionBrowser = (path2) => {
  path2 = path2.trim().replace(whitespaceRE, (s2) => s2.trim());
  let state = 0;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i2 = 0; i2 < path2.length; i2++) {
    const char = path2.charAt(i2);
    switch (state) {
      case 0:
        if (char === "[") {
          stateStack.push(state);
          state = 1;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2;
          currentOpenParensCount++;
        } else if (!(i2 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i2 === path2.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpression = isMemberExpressionBrowser;
function getInnerRange(loc, offset3, length) {
  const source2 = loc.source.slice(offset3, offset3 + length);
  const newLoc = {
    source: source2,
    start: advancePositionWithClone(loc.start, loc.source, offset3),
    end: loc.end
  };
  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset3 + length);
  }
  return newLoc;
}
function advancePositionWithClone(pos2, source2, numberOfCharacters = source2.length) {
  return advancePositionWithMutation(extend$1({}, pos2), source2, numberOfCharacters);
}
function advancePositionWithMutation(pos2, source2, numberOfCharacters = source2.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i2 = 0; i2 < numberOfCharacters; i2++) {
    if (source2.charCodeAt(i2) === 10) {
      linesCount++;
      lastNewLinePos = i2;
    }
  }
  pos2.offset += numberOfCharacters;
  pos2.line += linesCount;
  pos2.column = lastNewLinePos === -1 ? pos2.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos2;
}
function findDir(node, name2, allowEmpty = false) {
  for (let i2 = 0; i2 < node.props.length; i2++) {
    const p2 = node.props[i2];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString$4(name2) ? p2.name === name2 : name2.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node, name2, dynamicOnly = false, allowEmpty = false) {
  for (let i2 = 0; i2 < node.props.length; i2++) {
    const p2 = node.props[i2];
    if (p2.type === 6) {
      if (dynamicOnly)
        continue;
      if (p2.name === name2 && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name2)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name2) {
  return !!(arg && isStaticExp(arg) && arg.content === name2);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic)
  );
}
function isText(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props3, callPath = []) {
  if (props3 && !isString$4(props3) && props3.type === 14) {
    const callee = props3.callee;
    if (!isString$4(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(props3.arguments[0], callPath.concat(props3));
    }
  }
  return [props3, callPath];
}
function injectProp(node, prop, context2) {
  let propsWithInjection;
  let props3 = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props3 && !isString$4(props3) && props3.type === 14) {
    const ret = getUnnormalizedProps(props3);
    props3 = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props3 == null || isString$4(props3)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props3.type === 14) {
    const first = props3.arguments[0];
    if (!isString$4(first) && first.type === 15) {
      if (!hasProp$1(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props3.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props3
        ]);
      } else {
        props3.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props3);
  } else if (props3.type === 15) {
    if (!hasProp$1(prop, props3)) {
      props3.properties.unshift(prop);
    }
    propsWithInjection = props3;
  } else {
    propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props3
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp$1(prop, props3) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props3.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
  }
  return result;
}
function toValidAssetId(name2, type4) {
  return `_${type4}_${name2.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name2.charCodeAt(replaceValue).toString();
  })}`;
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function makeBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function getCompatValue(key2, context2) {
  const config = context2.options ? context2.options.compatConfig : context2.compatConfig;
  const value = config && config[key2];
  if (key2 === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key2, context2) {
  const mode = getCompatValue("MODE", context2);
  const value = getCompatValue(key2, context2);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key2, context2, loc, ...args2) {
  const enabled = isCompatEnabled(key2, context2);
  return enabled;
}
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
};
const defaultParserOptions = {
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: NO,
  isPreTag: NO,
  isCustomElement: NO,
  decodeEntities: (rawText) => rawText.replace(decodeRE, (_2, p1) => decodeMap[p1]),
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false
};
function baseParse(content, options = {}) {
  const context2 = createParserContext(content, options);
  const start = getCursor(context2);
  return createRoot(parseChildren(context2, 0, []), getSelection(context2, start));
}
function createParserContext(content, rawOptions) {
  const options = extend$1({}, defaultParserOptions);
  let key2;
  for (key2 in rawOptions) {
    options[key2] = rawOptions[key2] === void 0 ? defaultParserOptions[key2] : rawOptions[key2];
  }
  return {
    options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}
function parseChildren(context2, mode, ancestors) {
  const parent2 = last$2(ancestors);
  const ns = parent2 ? parent2.ns : 0;
  const nodes = [];
  while (!isEnd(context2, mode, ancestors)) {
    const s2 = context2.source;
    let node = void 0;
    if (mode === 0 || mode === 1) {
      if (!context2.inVPre && startsWith(s2, context2.options.delimiters[0])) {
        node = parseInterpolation(context2, mode);
      } else if (mode === 0 && s2[0] === "<") {
        if (s2.length === 1) {
          emitError(context2, 5, 1);
        } else if (s2[1] === "!") {
          if (startsWith(s2, "<!--")) {
            node = parseComment(context2);
          } else if (startsWith(s2, "<!DOCTYPE")) {
            node = parseBogusComment(context2);
          } else if (startsWith(s2, "<![CDATA[")) {
            if (ns !== 0) {
              node = parseCDATA(context2, ancestors);
            } else {
              emitError(context2, 1);
              node = parseBogusComment(context2);
            }
          } else {
            emitError(context2, 11);
            node = parseBogusComment(context2);
          }
        } else if (s2[1] === "/") {
          if (s2.length === 2) {
            emitError(context2, 5, 2);
          } else if (s2[2] === ">") {
            emitError(context2, 14, 2);
            advanceBy(context2, 3);
            continue;
          } else if (/[a-z]/i.test(s2[2])) {
            emitError(context2, 23);
            parseTag(context2, 1, parent2);
            continue;
          } else {
            emitError(context2, 12, 2);
            node = parseBogusComment(context2);
          }
        } else if (/[a-z]/i.test(s2[1])) {
          node = parseElement(context2, ancestors);
          if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context2) && node && node.tag === "template" && !node.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
            node = node.children;
          }
        } else if (s2[1] === "?") {
          emitError(context2, 21, 1);
          node = parseBogusComment(context2);
        } else {
          emitError(context2, 12, 1);
        }
      }
    }
    if (!node) {
      node = parseText(context2, mode);
    }
    if (isArray$c(node)) {
      for (let i2 = 0; i2 < node.length; i2++) {
        pushNode(nodes, node[i2]);
      }
    } else {
      pushNode(nodes, node);
    }
  }
  let removedWhitespace = false;
  if (mode !== 2 && mode !== 1) {
    const shouldCondense = context2.options.whitespace !== "preserve";
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if (node.type === 2) {
        if (!context2.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev2 = nodes[i2 - 1];
            const next2 = nodes[i2 + 1];
            if (!prev2 || !next2 || shouldCondense && (prev2.type === 3 && next2.type === 3 || prev2.type === 3 && next2.type === 1 || prev2.type === 1 && next2.type === 3 || prev2.type === 1 && next2.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i2] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else {
          node.content = node.content.replace(/\r\n/g, "\n");
        }
      } else if (node.type === 3 && !context2.options.comments) {
        removedWhitespace = true;
        nodes[i2] = null;
      }
    }
    if (context2.inPre && parent2 && context2.options.isPreTag(parent2.tag)) {
      const first = nodes[0];
      if (first && first.type === 2) {
        first.content = first.content.replace(/^\r?\n/, "");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
  if (node.type === 2) {
    const prev2 = last$2(nodes);
    if (prev2 && prev2.type === 2 && prev2.loc.end.offset === node.loc.start.offset) {
      prev2.content += node.content;
      prev2.loc.end = node.loc.end;
      prev2.loc.source += node.loc.source;
      return;
    }
  }
  nodes.push(node);
}
function parseCDATA(context2, ancestors) {
  advanceBy(context2, 9);
  const nodes = parseChildren(context2, 3, ancestors);
  if (context2.source.length === 0) {
    emitError(context2, 6);
  } else {
    advanceBy(context2, 3);
  }
  return nodes;
}
function parseComment(context2) {
  const start = getCursor(context2);
  let content;
  const match2 = /--(\!)?>/.exec(context2.source);
  if (!match2) {
    content = context2.source.slice(4);
    advanceBy(context2, context2.source.length);
    emitError(context2, 7);
  } else {
    if (match2.index <= 3) {
      emitError(context2, 0);
    }
    if (match2[1]) {
      emitError(context2, 10);
    }
    content = context2.source.slice(4, match2.index);
    const s2 = context2.source.slice(0, match2.index);
    let prevIndex = 1, nestedIndex = 0;
    while ((nestedIndex = s2.indexOf("<!--", prevIndex)) !== -1) {
      advanceBy(context2, nestedIndex - prevIndex + 1);
      if (nestedIndex + 4 < s2.length) {
        emitError(context2, 16);
      }
      prevIndex = nestedIndex + 1;
    }
    advanceBy(context2, match2.index + match2[0].length - prevIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context2, start)
  };
}
function parseBogusComment(context2) {
  const start = getCursor(context2);
  const contentStart = context2.source[1] === "?" ? 1 : 2;
  let content;
  const closeIndex = context2.source.indexOf(">");
  if (closeIndex === -1) {
    content = context2.source.slice(contentStart);
    advanceBy(context2, context2.source.length);
  } else {
    content = context2.source.slice(contentStart, closeIndex);
    advanceBy(context2, closeIndex + 1);
  }
  return {
    type: 3,
    content,
    loc: getSelection(context2, start)
  };
}
function parseElement(context2, ancestors) {
  const wasInPre = context2.inPre;
  const wasInVPre = context2.inVPre;
  const parent2 = last$2(ancestors);
  const element = parseTag(context2, 0, parent2);
  const isPreBoundary = context2.inPre && !wasInPre;
  const isVPreBoundary = context2.inVPre && !wasInVPre;
  if (element.isSelfClosing || context2.options.isVoidTag(element.tag)) {
    if (isPreBoundary) {
      context2.inPre = false;
    }
    if (isVPreBoundary) {
      context2.inVPre = false;
    }
    return element;
  }
  ancestors.push(element);
  const mode = context2.options.getTextMode(element, parent2);
  const children = parseChildren(context2, mode, ancestors);
  ancestors.pop();
  {
    const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context2, inlineTemplateProp.loc)) {
      const loc = getSelection(context2, element.loc.end);
      inlineTemplateProp.value = {
        type: 2,
        content: loc.source,
        loc
      };
    }
  }
  element.children = children;
  if (startsWithEndTagOpen(context2.source, element.tag)) {
    parseTag(context2, 1, parent2);
  } else {
    emitError(context2, 24, 0, element.loc.start);
    if (context2.source.length === 0 && element.tag.toLowerCase() === "script") {
      const first = children[0];
      if (first && startsWith(first.loc.source, "<!--")) {
        emitError(context2, 8);
      }
    }
  }
  element.loc = getSelection(context2, element.loc.start);
  if (isPreBoundary) {
    context2.inPre = false;
  }
  if (isVPreBoundary) {
    context2.inVPre = false;
  }
  return element;
}
const isSpecialTemplateDirective = /* @__PURE__ */ makeMap(`if,else,else-if,for,slot`);
function parseTag(context2, type4, parent2) {
  const start = getCursor(context2);
  const match2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context2.source);
  const tag = match2[1];
  const ns = context2.options.getNamespace(tag, parent2);
  advanceBy(context2, match2[0].length);
  advanceSpaces(context2);
  const cursor = getCursor(context2);
  const currentSource = context2.source;
  if (context2.options.isPreTag(tag)) {
    context2.inPre = true;
  }
  let props3 = parseAttributes(context2, type4);
  if (type4 === 0 && !context2.inVPre && props3.some((p2) => p2.type === 7 && p2.name === "pre")) {
    context2.inVPre = true;
    extend$1(context2, cursor);
    context2.source = currentSource;
    props3 = parseAttributes(context2, type4).filter((p2) => p2.name !== "v-pre");
  }
  let isSelfClosing = false;
  if (context2.source.length === 0) {
    emitError(context2, 9);
  } else {
    isSelfClosing = startsWith(context2.source, "/>");
    if (type4 === 1 && isSelfClosing) {
      emitError(context2, 4);
    }
    advanceBy(context2, isSelfClosing ? 2 : 1);
  }
  if (type4 === 1) {
    return;
  }
  let tagType = 0;
  if (!context2.inVPre) {
    if (tag === "slot") {
      tagType = 2;
    } else if (tag === "template") {
      if (props3.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
        tagType = 3;
      }
    } else if (isComponent(tag, props3, context2)) {
      tagType = 1;
    }
  }
  return {
    type: 1,
    ns,
    tag,
    tagType,
    props: props3,
    isSelfClosing,
    children: [],
    loc: getSelection(context2, start),
    codegenNode: void 0
  };
}
function isComponent(tag, props3, context2) {
  const options = context2.options;
  if (options.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
    return true;
  }
  for (let i2 = 0; i2 < props3.length; i2++) {
    const p2 = props3[i2];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
          return true;
        }
      }
    } else {
      if (p2.name === "is") {
        return true;
      } else if (p2.name === "bind" && isStaticArgOf(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
        return true;
      }
    }
  }
}
function parseAttributes(context2, type4) {
  const props3 = [];
  const attributeNames = /* @__PURE__ */ new Set();
  while (context2.source.length > 0 && !startsWith(context2.source, ">") && !startsWith(context2.source, "/>")) {
    if (startsWith(context2.source, "/")) {
      emitError(context2, 22);
      advanceBy(context2, 1);
      advanceSpaces(context2);
      continue;
    }
    if (type4 === 1) {
      emitError(context2, 3);
    }
    const attr = parseAttribute(context2, attributeNames);
    if (attr.type === 6 && attr.value && attr.name === "class") {
      attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
    }
    if (type4 === 0) {
      props3.push(attr);
    }
    if (/^[^\t\r\n\f />]/.test(context2.source)) {
      emitError(context2, 15);
    }
    advanceSpaces(context2);
  }
  return props3;
}
function parseAttribute(context2, nameSet) {
  const start = getCursor(context2);
  const match2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context2.source);
  const name2 = match2[0];
  if (nameSet.has(name2)) {
    emitError(context2, 2);
  }
  nameSet.add(name2);
  if (name2[0] === "=") {
    emitError(context2, 19);
  }
  {
    const pattern4 = /["'<]/g;
    let m2;
    while (m2 = pattern4.exec(name2)) {
      emitError(context2, 17, m2.index);
    }
  }
  advanceBy(context2, name2.length);
  let value = void 0;
  if (/^[\t\r\n\f ]*=/.test(context2.source)) {
    advanceSpaces(context2);
    advanceBy(context2, 1);
    advanceSpaces(context2);
    value = parseAttributeValue(context2);
    if (!value) {
      emitError(context2, 13);
    }
  }
  const loc = getSelection(context2, start);
  if (!context2.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name2)) {
    const match3 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name2);
    let isPropShorthand = startsWith(name2, ".");
    let dirName = match3[1] || (isPropShorthand || startsWith(name2, ":") ? "bind" : startsWith(name2, "@") ? "on" : "slot");
    let arg;
    if (match3[2]) {
      const isSlot = dirName === "slot";
      const startOffset = name2.lastIndexOf(match3[2]);
      const loc2 = getSelection(context2, getNewPosition(context2, start, startOffset), getNewPosition(context2, start, startOffset + match3[2].length + (isSlot && match3[3] || "").length));
      let content = match3[2];
      let isStatic = true;
      if (content.startsWith("[")) {
        isStatic = false;
        if (!content.endsWith("]")) {
          emitError(context2, 27);
          content = content.slice(1);
        } else {
          content = content.slice(1, content.length - 1);
        }
      } else if (isSlot) {
        content += match3[3] || "";
      }
      arg = {
        type: 4,
        content,
        isStatic,
        constType: isStatic ? 3 : 0,
        loc: loc2
      };
    }
    if (value && value.isQuoted) {
      const valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }
    const modifiers = match3[3] ? match3[3].slice(1).split(".") : [];
    if (isPropShorthand)
      modifiers.push("prop");
    if (dirName === "bind" && arg) {
      if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context2, loc, arg.loc.source)) {
        dirName = "model";
        modifiers.splice(modifiers.indexOf("sync"), 1);
      }
    }
    return {
      type: 7,
      name: dirName,
      exp: value && {
        type: 4,
        content: value.content,
        isStatic: false,
        constType: 0,
        loc: value.loc
      },
      arg,
      modifiers,
      loc
    };
  }
  if (!context2.inVPre && startsWith(name2, "v-")) {
    emitError(context2, 26);
  }
  return {
    type: 6,
    name: name2,
    value: value && {
      type: 2,
      content: value.content,
      loc: value.loc
    },
    loc
  };
}
function parseAttributeValue(context2) {
  const start = getCursor(context2);
  let content;
  const quote2 = context2.source[0];
  const isQuoted = quote2 === `"` || quote2 === `'`;
  if (isQuoted) {
    advanceBy(context2, 1);
    const endIndex = context2.source.indexOf(quote2);
    if (endIndex === -1) {
      content = parseTextData(context2, context2.source.length, 4);
    } else {
      content = parseTextData(context2, endIndex, 4);
      advanceBy(context2, 1);
    }
  } else {
    const match2 = /^[^\t\r\n\f >]+/.exec(context2.source);
    if (!match2) {
      return void 0;
    }
    const unexpectedChars = /["'<=`]/g;
    let m2;
    while (m2 = unexpectedChars.exec(match2[0])) {
      emitError(context2, 18, m2.index);
    }
    content = parseTextData(context2, match2[0].length, 4);
  }
  return { content, isQuoted, loc: getSelection(context2, start) };
}
function parseInterpolation(context2, mode) {
  const [open2, close3] = context2.options.delimiters;
  const closeIndex = context2.source.indexOf(close3, open2.length);
  if (closeIndex === -1) {
    emitError(context2, 25);
    return void 0;
  }
  const start = getCursor(context2);
  advanceBy(context2, open2.length);
  const innerStart = getCursor(context2);
  const innerEnd = getCursor(context2);
  const rawContentLength = closeIndex - open2.length;
  const rawContent = context2.source.slice(0, rawContentLength);
  const preTrimContent = parseTextData(context2, rawContentLength, mode);
  const content = preTrimContent.trim();
  const startOffset = preTrimContent.indexOf(content);
  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }
  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context2, close3.length);
  return {
    type: 5,
    content: {
      type: 4,
      isStatic: false,
      constType: 0,
      content,
      loc: getSelection(context2, innerStart, innerEnd)
    },
    loc: getSelection(context2, start)
  };
}
function parseText(context2, mode) {
  const endTokens = mode === 3 ? ["]]>"] : ["<", context2.options.delimiters[0]];
  let endIndex = context2.source.length;
  for (let i2 = 0; i2 < endTokens.length; i2++) {
    const index2 = context2.source.indexOf(endTokens[i2], 1);
    if (index2 !== -1 && endIndex > index2) {
      endIndex = index2;
    }
  }
  const start = getCursor(context2);
  const content = parseTextData(context2, endIndex, mode);
  return {
    type: 2,
    content,
    loc: getSelection(context2, start)
  };
}
function parseTextData(context2, length, mode) {
  const rawText = context2.source.slice(0, length);
  advanceBy(context2, length);
  if (mode === 2 || mode === 3 || !rawText.includes("&")) {
    return rawText;
  } else {
    return context2.options.decodeEntities(rawText, mode === 4);
  }
}
function getCursor(context2) {
  const { column: column2, line: line2, offset: offset3 } = context2;
  return { column: column2, line: line2, offset: offset3 };
}
function getSelection(context2, start, end) {
  end = end || getCursor(context2);
  return {
    start,
    end,
    source: context2.originalSource.slice(start.offset, end.offset)
  };
}
function last$2(xs) {
  return xs[xs.length - 1];
}
function startsWith(source2, searchString) {
  return source2.startsWith(searchString);
}
function advanceBy(context2, numberOfCharacters) {
  const { source: source2 } = context2;
  advancePositionWithMutation(context2, source2, numberOfCharacters);
  context2.source = source2.slice(numberOfCharacters);
}
function advanceSpaces(context2) {
  const match2 = /^[\t\r\n\f ]+/.exec(context2.source);
  if (match2) {
    advanceBy(context2, match2[0].length);
  }
}
function getNewPosition(context2, start, numberOfCharacters) {
  return advancePositionWithClone(start, context2.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context2, code, offset3, loc = getCursor(context2)) {
  if (offset3) {
    loc.offset += offset3;
    loc.column += offset3;
  }
  context2.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ""
  }));
}
function isEnd(context2, mode, ancestors) {
  const s2 = context2.source;
  switch (mode) {
    case 0:
      if (startsWith(s2, "</")) {
        for (let i2 = ancestors.length - 1; i2 >= 0; --i2) {
          if (startsWithEndTagOpen(s2, ancestors[i2].tag)) {
            return true;
          }
        }
      }
      break;
    case 1:
    case 2: {
      const parent2 = last$2(ancestors);
      if (parent2 && startsWithEndTagOpen(s2, parent2.tag)) {
        return true;
      }
      break;
    }
    case 3:
      if (startsWith(s2, "]]>")) {
        return true;
      }
      break;
  }
  return !s2;
}
function startsWithEndTagOpen(source2, tag) {
  return startsWith(source2, "</") && source2.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source2[2 + tag.length] || ">");
}
function hoistStatic(root2, context2) {
  walk(
    root2,
    context2,
    isSingleElementRoot(root2, root2.children[0])
  );
}
function isSingleElementRoot(root2, child) {
  const { children } = root2;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context2, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context2);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + ``;
          child.codegenNode = context2.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context2) >= 2) {
            const props3 = getNodeProps(child);
            if (props3) {
              codegenNode.props = context2.hoist(props3);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context2.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context2.scopes.vSlot++;
      }
      walk(child, context2);
      if (isComponent2) {
        context2.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context2, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i3 = 0; i3 < child.branches.length; i3++) {
        walk(child.branches[i3], context2, child.branches[i3].children.length === 1);
      }
    }
  }
  if (hoistedCount && context2.transformHoist) {
    context2.transformHoist(children, context2, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray$c(node.codegenNode.children)) {
    node.codegenNode.children = context2.hoist(createArrayExpression(node.codegenNode.children));
  }
}
function getConstantType(node, context2) {
  const { constantCache } = context2;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached2 = constantCache.get(node);
      if (cached2 !== void 0) {
        return cached2;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context2);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i2 = 0; i2 < node.children.length; i2++) {
          const childType = getConstantType(node.children[i2], context2);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i2 = 0; i2 < node.props.length; i2++) {
            const p2 = node.props[i2];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context2);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i2 = 0; i2 < node.props.length; i2++) {
            const p2 = node.props[i2];
            if (p2.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context2.removeHelper(OPEN_BLOCK);
          context2.removeHelper(getVNodeBlockHelper(context2.inSSR, codegenNode.isComponent));
          codegenNode.isBlock = false;
          context2.helper(getVNodeHelper(context2.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context2);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        if (isString$4(child) || isSymbol$2(child)) {
          continue;
        }
        const childType = getConstantType(child, context2);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context2) {
  if (value.type === 14 && !isString$4(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context2);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context2);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context2) {
  let returnType = 3;
  const props3 = getNodeProps(node);
  if (props3 && props3.type === 15) {
    const { properties } = props3;
    for (let i2 = 0; i2 < properties.length; i2++) {
      const { key: key2, value } = properties[i2];
      const keyType = getConstantType(key2, context2);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context2);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context2);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root2, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context2 = {
    selfName: nameMatch && capitalize(camelize$2(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    root: root2,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root2,
    childIndex: 0,
    inVOnce: false,
    helper(name2) {
      const count = context2.helpers.get(name2) || 0;
      context2.helpers.set(name2, count + 1);
      return name2;
    },
    removeHelper(name2) {
      const count = context2.helpers.get(name2);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context2.helpers.delete(name2);
        } else {
          context2.helpers.set(name2, currentCount);
        }
      }
    },
    helperString(name2) {
      return `_${helperNameMap[context2.helper(name2)]}`;
    },
    replaceNode(node) {
      context2.parent.children[context2.childIndex] = context2.currentNode = node;
    },
    removeNode(node) {
      const list = context2.parent.children;
      const removalIndex = node ? list.indexOf(node) : context2.currentNode ? context2.childIndex : -1;
      if (!node || node === context2.currentNode) {
        context2.currentNode = null;
        context2.onNodeRemoved();
      } else {
        if (context2.childIndex > removalIndex) {
          context2.childIndex--;
          context2.onNodeRemoved();
        }
      }
      context2.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString$4(exp))
        exp = createSimpleExpression(exp);
      context2.hoists.push(exp);
      const identifier = createSimpleExpression(`_hoisted_${context2.hoists.length}`, false, exp.loc, 2);
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode2 = false) {
      return createCacheExpression(context2.cached++, exp, isVNode2);
    }
  };
  {
    context2.filters = /* @__PURE__ */ new Set();
  }
  return context2;
}
function transform(root2, options) {
  const context2 = createTransformContext(root2, options);
  traverseNode(root2, context2);
  if (options.hoistStatic) {
    hoistStatic(root2, context2);
  }
  if (!options.ssr) {
    createRootCodegen(root2, context2);
  }
  root2.helpers = [...context2.helpers.keys()];
  root2.components = [...context2.components];
  root2.directives = [...context2.directives];
  root2.imports = context2.imports;
  root2.hoists = context2.hoists;
  root2.temps = context2.temps;
  root2.cached = context2.cached;
  {
    root2.filters = [...context2.filters];
  }
}
function createRootCodegen(root2, context2) {
  const { helper } = context2;
  const { children } = root2;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root2, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        makeBlock(codegenNode, context2);
      }
      root2.codegenNode = codegenNode;
    } else {
      root2.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    root2.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, root2.children, patchFlag + ``, void 0, void 0, true, void 0, false);
  } else
    ;
}
function traverseChildren(parent2, context2) {
  let i2 = 0;
  const nodeRemoved = () => {
    i2--;
  };
  for (; i2 < parent2.children.length; i2++) {
    const child = parent2.children[i2];
    if (isString$4(child))
      continue;
    context2.parent = parent2;
    context2.childIndex = i2;
    context2.onNodeRemoved = nodeRemoved;
    traverseNode(child, context2);
  }
}
function traverseNode(node, context2) {
  context2.currentNode = node;
  const { nodeTransforms } = context2;
  const exitFns = [];
  for (let i3 = 0; i3 < nodeTransforms.length; i3++) {
    const onExit = nodeTransforms[i3](node, context2);
    if (onExit) {
      if (isArray$c(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context2.currentNode) {
      return;
    } else {
      node = context2.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context2.ssr) {
        context2.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context2.ssr) {
        context2.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i3 = 0; i3 < node.branches.length; i3++) {
        traverseNode(node.branches[i3], context2);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context2);
      break;
  }
  context2.currentNode = node;
  let i2 = exitFns.length;
  while (i2--) {
    exitFns[i2]();
  }
}
function createStructuralDirectiveTransform(name2, fn) {
  const matches2 = isString$4(name2) ? (n2) => n2 === name2 : (n2) => name2.test(n2);
  return (node, context2) => {
    if (node.type === 1) {
      const { props: props3 } = node;
      if (node.tagType === 3 && props3.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i2 = 0; i2 < props3.length; i2++) {
        const prop = props3[i2];
        if (prop.type === 7 && matches2(prop.name)) {
          props3.splice(i2, 1);
          i2--;
          const onExit = fn(node, prop, context2);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
const PURE_ANNOTATION = `/*#__PURE__*/`;
const aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
  const context2 = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.loc.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key2) {
      return `_${helperNameMap[key2]}`;
    },
    push(code, node) {
      context2.code += code;
    },
    indent() {
      newline(++context2.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context2.indentLevel;
      } else {
        newline(--context2.indentLevel);
      }
    },
    newline() {
      newline(context2.indentLevel);
    }
  };
  function newline(n2) {
    context2.push("\n" + `  `.repeat(n2));
  }
  return context2;
}
function generate$2(ast, options = {}) {
  const context2 = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context2);
  const { mode, push: push2, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context2;
  const hasHelpers = ast.helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context2;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args2 = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args2.join(", ");
  {
    push2(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push2(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push2(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = _Vue`);
      push2(`
`);
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context2);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context2);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context2);
    newline();
  }
  if (ast.temps > 0) {
    push2(`let `);
    for (let i2 = 0; i2 < ast.temps; i2++) {
      push2(`${i2 > 0 ? `, ` : ``}_temp${i2}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push2(`
`);
    newline();
  }
  if (!ssr) {
    push2(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context2);
  } else {
    push2(`null`);
  }
  if (useWithBlock) {
    deindent();
    push2(`}`);
  }
  deindent();
  push2(`}`);
  return {
    ast,
    code: context2.code,
    preamble: ``,
    map: context2.map ? context2.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context2) {
  const { ssr, prefixIdentifiers, push: push2, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context2;
  const VueBinding = runtimeGlobalName;
  if (ast.helpers.length > 0) {
    {
      push2(`const _Vue = ${VueBinding}
`);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
        push2(`const { ${staticHelpers} } = _Vue
`);
      }
    }
  }
  genHoists(ast.hoists, context2);
  newline();
  push2(`return `);
}
function genAssets(assets, type4, { helper, push: push2, newline, isTS }) {
  const resolver = helper(type4 === "filter" ? RESOLVE_FILTER : type4 === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
  for (let i2 = 0; i2 < assets.length; i2++) {
    let id = assets[i2];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push2(`const ${toValidAssetId(id, type4)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
    if (i2 < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context2) {
  if (!hoists.length) {
    return;
  }
  context2.pure = true;
  const { push: push2, newline, helper, scopeId, mode } = context2;
  newline();
  for (let i2 = 0; i2 < hoists.length; i2++) {
    const exp = hoists[i2];
    if (exp) {
      push2(`const _hoisted_${i2 + 1} = ${``}`);
      genNode(exp, context2);
      newline();
    }
  }
  context2.pure = false;
}
function genNodeListAsArray(nodes, context2) {
  const multilines = nodes.length > 3 || false;
  context2.push(`[`);
  multilines && context2.indent();
  genNodeList(nodes, context2, multilines);
  multilines && context2.deindent();
  context2.push(`]`);
}
function genNodeList(nodes, context2, multilines = false, comma = true) {
  const { push: push2, newline } = context2;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (isString$4(node)) {
      push2(node);
    } else if (isArray$c(node)) {
      genNodeListAsArray(node, context2);
    } else {
      genNode(node, context2);
    }
    if (i2 < nodes.length - 1) {
      if (multilines) {
        comma && push2(",");
        newline();
      } else {
        comma && push2(", ");
      }
    }
  }
}
function genNode(node, context2) {
  if (isString$4(node)) {
    context2.push(node);
    return;
  }
  if (isSymbol$2(node)) {
    context2.push(context2.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      genNode(node.codegenNode, context2);
      break;
    case 2:
      genText(node, context2);
      break;
    case 4:
      genExpression(node, context2);
      break;
    case 5:
      genInterpolation(node, context2);
      break;
    case 12:
      genNode(node.codegenNode, context2);
      break;
    case 8:
      genCompoundExpression(node, context2);
      break;
    case 3:
      genComment(node, context2);
      break;
    case 13:
      genVNodeCall(node, context2);
      break;
    case 14:
      genCallExpression(node, context2);
      break;
    case 15:
      genObjectExpression(node, context2);
      break;
    case 17:
      genArrayExpression(node, context2);
      break;
    case 18:
      genFunctionExpression(node, context2);
      break;
    case 19:
      genConditionalExpression(node, context2);
      break;
    case 20:
      genCacheExpression(node, context2);
      break;
    case 21:
      genNodeList(node.body, context2, true, false);
      break;
  }
}
function genText(node, context2) {
  context2.push(JSON.stringify(node.content), node);
}
function genExpression(node, context2) {
  const { content, isStatic } = node;
  context2.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context2) {
  const { push: push2, helper, pure } = context2;
  if (pure)
    push2(PURE_ANNOTATION);
  push2(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context2);
  push2(`)`);
}
function genCompoundExpression(node, context2) {
  for (let i2 = 0; i2 < node.children.length; i2++) {
    const child = node.children[i2];
    if (isString$4(child)) {
      context2.push(child);
    } else {
      genNode(child, context2);
    }
  }
}
function genExpressionAsPropertyKey(node, context2) {
  const { push: push2 } = context2;
  if (node.type === 8) {
    push2(`[`);
    genCompoundExpression(node, context2);
    push2(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push2(text, node);
  } else {
    push2(`[${node.content}]`, node);
  }
}
function genComment(node, context2) {
  const { push: push2, helper, pure } = context2;
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  push2(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
}
function genVNodeCall(node, context2) {
  const { push: push2, helper, pure } = context2;
  const { tag, props: props3, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
  if (directives) {
    push2(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context2.inSSR, isComponent2) : getVNodeHelper(context2.inSSR, isComponent2);
  push2(helper(callHelper) + `(`, node);
  genNodeList(genNullableArgs([tag, props3, children, patchFlag, dynamicProps]), context2);
  push2(`)`);
  if (isBlock) {
    push2(`)`);
  }
  if (directives) {
    push2(`, `);
    genNode(directives, context2);
    push2(`)`);
  }
}
function genNullableArgs(args2) {
  let i2 = args2.length;
  while (i2--) {
    if (args2[i2] != null)
      break;
  }
  return args2.slice(0, i2 + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context2) {
  const { push: push2, helper, pure } = context2;
  const callee = isString$4(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push2(PURE_ANNOTATION);
  }
  push2(callee + `(`, node);
  genNodeList(node.arguments, context2);
  push2(`)`);
}
function genObjectExpression(node, context2) {
  const { push: push2, indent, deindent, newline } = context2;
  const { properties } = node;
  if (!properties.length) {
    push2(`{}`, node);
    return;
  }
  const multilines = properties.length > 1 || false;
  push2(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i2 = 0; i2 < properties.length; i2++) {
    const { key: key2, value } = properties[i2];
    genExpressionAsPropertyKey(key2, context2);
    push2(`: `);
    genNode(value, context2);
    if (i2 < properties.length - 1) {
      push2(`,`);
      newline();
    }
  }
  multilines && deindent();
  push2(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context2) {
  genNodeListAsArray(node.elements, context2);
}
function genFunctionExpression(node, context2) {
  const { push: push2, indent, deindent } = context2;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push2(`_${helperNameMap[WITH_CTX]}(`);
  }
  push2(`(`, node);
  if (isArray$c(params)) {
    genNodeList(params, context2);
  } else if (params) {
    genNode(params, context2);
  }
  push2(`) => `);
  if (newline || body) {
    push2(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push2(`return `);
    }
    if (isArray$c(returns)) {
      genNodeListAsArray(returns, context2);
    } else {
      genNode(returns, context2);
    }
  } else if (body) {
    genNode(body, context2);
  }
  if (newline || body) {
    deindent();
    push2(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push2(`, undefined, true`);
    }
    push2(`)`);
  }
}
function genConditionalExpression(node, context2) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push: push2, indent, deindent, newline } = context2;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push2(`(`);
    genExpression(test, context2);
    needsParens && push2(`)`);
  } else {
    push2(`(`);
    genNode(test, context2);
    push2(`)`);
  }
  needNewline && indent();
  context2.indentLevel++;
  needNewline || push2(` `);
  push2(`? `);
  genNode(consequent, context2);
  context2.indentLevel--;
  needNewline && newline();
  needNewline || push2(` `);
  push2(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context2.indentLevel++;
  }
  genNode(alternate, context2);
  if (!isNested) {
    context2.indentLevel--;
  }
  needNewline && deindent(true);
}
function genCacheExpression(node, context2) {
  const { push: push2, helper, indent, deindent, newline } = context2;
  push2(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push2(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push2(`_cache[${node.index}] = `);
  genNode(node.value, context2);
  if (node.isVNode) {
    push2(`,`);
    newline();
    push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push2(`_cache[${node.index}]`);
    deindent();
  }
  push2(`)`);
}
new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context2) => {
  return processIf(node, dir, context2, (ifNode, branch, isRoot) => {
    const siblings = context2.parent.children;
    let i2 = siblings.indexOf(ifNode);
    let key2 = 0;
    while (i2-- >= 0) {
      const sibling = siblings[i2];
      if (sibling && sibling.type === 9) {
        key2 += sibling.branches.length;
      }
    }
    return () => {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key2, context2);
      } else {
        const parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key2 + ifNode.branches.length - 1, context2);
      }
    };
  });
});
function processIf(node, dir, context2, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context2.onError(createCompilerError(28, dir.loc));
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context2.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context2.parent.children;
    let i2 = siblings.indexOf(node);
    while (i2-- >= -1) {
      const sibling = siblings[i2];
      if (sibling && sibling.type === 3) {
        context2.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context2.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context2.onError(createCompilerError(30, node.loc));
        }
        context2.removeNode();
        const branch = createIfBranch(node, dir);
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context2);
        if (onExit)
          onExit();
        context2.currentNode = null;
      } else {
        context2.onError(createCompilerError(30, node.loc));
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context2) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context2),
      createCallExpression(context2.helper(CREATE_COMMENT), [
        '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context2);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context2) {
  const { helper } = context2;
  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context2);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      return createVNodeCall(context2, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ``, void 0, void 0, true, false, false, branch.loc);
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      makeBlock(vnodeCall, context2);
    }
    injectProp(vnodeCall, keyProperty, context2);
    return ret;
  }
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
const transformFor = createStructuralDirectiveTransform("for", (node, dir, context2) => {
  const { helper, removeHelper } = context2;
  return processFor(node, dir, context2, (forNode) => {
    const renderExp = createCallExpression(helper(RENDER_LIST), [
      forNode.source
    ]);
    const isTemplate = isTemplateNode(node);
    const memo = findDir(node, "memo");
    const keyProp = findProp(node, `key`);
    const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
    const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
    const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
    forNode.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ``, void 0, void 0, true, !isStableFragment, false, node.loc);
    return () => {
      let childBlock;
      const { children } = forNode;
      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
      if (slotOutlet) {
        childBlock = slotOutlet.codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context2);
        }
      } else if (needFragmentWrapper) {
        childBlock = createVNodeCall(context2, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + ``, void 0, void 0, true, void 0, false);
      } else {
        childBlock = children[0].codegenNode;
        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context2);
        }
        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            removeHelper(OPEN_BLOCK);
            removeHelper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
          } else {
            removeHelper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
          }
        }
        childBlock.isBlock = !isStableFragment;
        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
        } else {
          helper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
        }
      }
      if (memo) {
        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
          createSimpleExpression(`_cached`)
        ]));
        loop.body = createBlockStatement([
          createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
          createCompoundExpression([
            `if (_cached`,
            ...keyExp ? [` && _cached.key === `, keyExp] : [],
            ` && ${context2.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
          ]),
          createCompoundExpression([`const _item = `, childBlock]),
          createSimpleExpression(`_item.memo = _memo`),
          createSimpleExpression(`return _item`)
        ]);
        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context2.cached++)));
      } else {
        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
      }
    };
  });
});
function processFor(node, dir, context2, processCodegen) {
  if (!dir.exp) {
    context2.onError(createCompilerError(31, dir.loc));
    return;
  }
  const parseResult = parseForExpression(
    dir.exp
  );
  if (!parseResult) {
    context2.onError(createCompilerError(32, dir.loc));
    return;
  }
  const { addIdentifiers, removeIdentifiers, scopes } = context2;
  const { source: source2, value, key: key2, index: index2 } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source: source2,
    valueAlias: value,
    keyAlias: key2,
    objectIndexAlias: index2,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context2.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context2) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);
  }
  return result;
}
function createAliasExpression(range3, content, offset3) {
  return createSimpleExpression(content, false, getInnerRange(range3, offset3, content.length));
}
function createForLoopParams({ value, key: key2, index: index2 }, memoArgs = []) {
  return createParamsList([value, key2, index2, ...memoArgs]);
}
function createParamsList(args2) {
  let i2 = args2.length;
  while (i2--) {
    if (args2[i2])
      break;
  }
  return args2.slice(0, i2 + 1).map((arg, i3) => arg || createSimpleExpression(`_`.repeat(i3 + 1), false));
}
const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context2) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context2.scopes.vSlot++;
      return () => {
        context2.scopes.vSlot--;
      };
    }
  }
};
const buildClientSlotFn = (props3, children, loc) => createFunctionExpression(props3, children, false, true, children.length ? children[0].loc : loc);
function buildSlots(node, context2, buildSlotFn = buildClientSlotFn) {
  context2.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context2.scopes.vSlot > 0 || context2.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const slotElement = children[i2];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context2.onError(createCompilerError(37, slotDir.loc));
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
    let vIf;
    let vElse;
    let vFor;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
      let j2 = i2;
      let prev2;
      while (j2--) {
        prev2 = children[j2];
        if (prev2.type !== 3) {
          break;
        }
      }
      if (prev2 && isTemplateNode(prev2) && findDir(prev2, "if")) {
        children.splice(i2, 1);
        i2--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context2.onError(createCompilerError(30, vElse.loc));
      }
    } else if (vFor = findDir(slotElement, "for")) {
      hasDynamicSlots = true;
      const parseResult = vFor.parseResult || parseForExpression(vFor.exp);
      if (parseResult) {
        dynamicSlots.push(createCallExpression(context2.helper(RENDER_LIST), [
          parseResult.source,
          createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
        ]));
      } else {
        context2.onError(createCompilerError(32, vFor.loc));
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context2.onError(createCompilerError(38, dirLoc));
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props3, children2) => {
      const fn = buildSlotFn(props3, children2, loc);
      if (context2.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context2.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(
    `_`,
    createSimpleExpression(slotFlag + ``, false)
  )), loc);
  if (dynamicSlots.length) {
    slots = createCallExpression(context2.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name2, fn, index2) {
  const props3 = [
    createObjectProperty(`name`, name2),
    createObjectProperty(`fn`, fn)
  ];
  if (index2 != null) {
    props3.push(createObjectProperty(`key`, createSimpleExpression(String(index2), true)));
  }
  return createObjectExpression(props3);
}
function hasForwardedSlots(children) {
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context2) => {
  return function postTransformElement() {
    node = context2.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props: props3 } = node;
    const isComponent2 = node.tagType === 1;
    let vnodeTag = isComponent2 ? resolveComponentType(node, context2) : `"${tag}"`;
    const isDynamicComponent = isObject$4(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let vnodePatchFlag;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
    if (props3.length > 0) {
      const propsBuildResult = buildProps(node, context2, void 0, isComponent2, isDynamicComponent);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context2))) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
      }
      const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context2);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type4 = child.type;
        const hasDynamicTextChild = type4 === 5 || type4 === 8;
        if (hasDynamicTextChild && getConstantType(child, context2) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type4 === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (patchFlag !== 0) {
      {
        vnodePatchFlag = String(patchFlag);
      }
      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }
    node.codegenNode = createVNodeCall(context2, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
  };
};
function resolveComponentType(node, context2, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2)) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const isDir = !isExplicitDynamic && findDir(node, "is");
  if (isDir && isDir.exp) {
    return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
      isDir.exp
    ]);
  }
  const builtIn = isCoreComponent(tag) || context2.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context2.helper(builtIn);
    return builtIn;
  }
  context2.helper(RESOLVE_COMPONENT);
  context2.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context2, props3 = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key: key2, value }) => {
    if (isStaticExp(key2)) {
      const name2 = key2.content;
      const isEventHandler = isOn$1(name2);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && name2.toLowerCase() !== "onclick" && name2 !== "onUpdate:modelValue" && !isReservedProp(name2)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name2)) {
        hasVnodeHook = true;
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context2) > 0) {
        return;
      }
      if (name2 === "ref") {
        hasRef = true;
      } else if (name2 === "class") {
        hasClassBinding = true;
      } else if (name2 === "style") {
        hasStyleBinding = true;
      } else if (name2 !== "key" && !dynamicPropNames.includes(name2)) {
        dynamicPropNames.push(name2);
      }
      if (isComponent2 && (name2 === "class" || name2 === "style") && !dynamicPropNames.includes(name2)) {
        dynamicPropNames.push(name2);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i2 = 0; i2 < props3.length; i2++) {
    const prop = props3[i2];
    if (prop.type === 6) {
      const { loc, name: name2, value } = prop;
      let isStatic = true;
      if (name2 === "ref") {
        hasRef = true;
        if (context2.scopes.vFor > 0) {
          properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
        }
      }
      if (name2 === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
        continue;
      }
      properties.push(createObjectProperty(createSimpleExpression(name2, true, getInnerRange(loc, 0, name2.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
    } else {
      const { name: name2, arg, exp, loc } = prop;
      const isVBind = name2 === "bind";
      const isVOn = name2 === "on";
      if (name2 === "slot") {
        if (!isComponent2) {
          context2.onError(createCompilerError(40, loc));
        }
        continue;
      }
      if (name2 === "once" || name2 === "memo") {
        continue;
      }
      if (name2 === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context2.scopes.vFor > 0) {
        properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context2.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context2.onError(createCompilerError(isVBind ? 34 : 35, loc));
        }
        continue;
      }
      const directiveTransform = context2.directiveTransforms[name2];
      if (directiveTransform) {
        const { props: props4, needRuntime } = directiveTransform(prop, node, context2);
        !ssr && props4.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props4, elementLoc));
        } else {
          properties.push(...props4);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol$2(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name2)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context2.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context2.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i2 = 0; i2 < propsExpression.properties.length; i2++) {
          const key2 = propsExpression.properties[i2].key;
          if (isStaticExp(key2)) {
            if (key2.content === "class") {
              classKeyIndex = i2;
            } else if (key2.content === "style") {
              styleKeyIndex = i2;
            }
          } else if (!key2.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(context2.helper(NORMALIZE_CLASS), [classProp.value]);
          }
          if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(context2.helper(NORMALIZE_STYLE), [styleProp.value]);
          }
        } else {
          propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [propsExpression]);
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [
          createCallExpression(context2.helper(GUARD_REACTIVE_PROPS), [
            propsExpression
          ])
        ]);
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i2 = 0; i2 < properties.length; i2++) {
    const prop = properties[i2];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name2 = prop.key.content;
    const existing = knownProps.get(name2);
    if (existing) {
      if (name2 === "style" || name2 === "class" || isOn$1(name2)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name2, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}
function buildDirectiveArgs(dir, context2) {
  const dirArgs = [];
  const runtime2 = directiveImportMap.get(dir);
  if (runtime2) {
    dirArgs.push(context2.helperString(runtime2));
  } else {
    {
      context2.helper(RESOLVE_DIRECTIVE);
      context2.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props3) {
  let propsNamesString = `[`;
  for (let i2 = 0, l2 = props3.length; i2 < l2; i2++) {
    propsNamesString += JSON.stringify(props3[i2]);
    if (i2 < l2 - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
const cacheStringFunction$1 = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction$1((str) => {
  return str.replace(camelizeRE$1, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const transformSlotOutlet = (node, context2) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context2);
    const slotArgs = [
      context2.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context2.scopeId && !context2.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(context2.helper(RENDER_SLOT), slotArgs, loc);
  }
};
function processSlotOutlet(node, context2) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i2 = 0; i2 < node.props.length; i2++) {
    const p2 = node.props[i2];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize$1(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp)
          slotName = p2.exp;
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize$1(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props: props3, directives } = buildProps(node, context2, nonNameProps, false, false);
    slotProps = props3;
    if (directives.length) {
      context2.onError(createCompilerError(36, directives[0].loc));
    }
  }
  return {
    slotName,
    slotProps
  };
}
const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const transformOn$1 = (dir, node, context2, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context2.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? toHandlerKey(camelize$2(rawName)) : `on:${rawName}`;
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context2.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context2.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context2.cacheHandlers && !exp && !context2.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp.content);
    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context2.cache(ret.props[0].value);
  }
  ret.props.forEach((p2) => p2.key.isHandlerKey = true);
  return ret;
};
const transformBind = (dir, _node, context2) => {
  const { exp, modifiers, loc } = dir;
  const arg = dir.arg;
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = `${arg.content} || ""`;
  }
  if (modifiers.includes("camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = camelize$2(arg.content);
      } else {
        arg.content = `${context2.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context2.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context2.inSSR) {
    if (modifiers.includes("prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.includes("attr")) {
      injectPrefix(arg, "^");
    }
  }
  if (!exp || exp.type === 4 && !exp.content.trim()) {
    context2.onError(createCompilerError(34, loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
    };
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};
const transformText = (node, context2) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isText(child)) {
          hasText = true;
          for (let j2 = i2 + 1; j2 < children.length; j2++) {
            const next2 = children[j2];
            if (isText(next2)) {
              if (!currentContainer) {
                currentContainer = children[i2] = createCompoundExpression([child], child.loc);
              }
              currentContainer.children.push(` + `, next2);
              children.splice(j2, 1);
              j2--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p2) => p2.type === 7 && !context2.directiveTransforms[p2.name]) && !(node.tag === "template"))) {
        return;
      }
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isText(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context2.ssr && getConstantType(child, context2) === 0) {
            callArgs.push(1 + ``);
          }
          children[i2] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context2.helper(CREATE_TEXT), callArgs)
          };
        }
      }
    };
  }
};
const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context2) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context2.inVOnce) {
      return;
    }
    seen$1.add(node);
    context2.inVOnce = true;
    context2.helper(SET_BLOCK_TRACKING);
    return () => {
      context2.inVOnce = false;
      const cur = context2.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context2.cache(cur.codegenNode, true);
      }
    };
  }
};
const transformModel$1 = (dir, node, context2) => {
  const { exp, arg } = dir;
  if (!exp) {
    context2.onError(createCompilerError(41, dir.loc));
    return createTransformProps();
  }
  const rawExp = exp.loc.source;
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context2.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context2.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  const maybeRef = false;
  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
    context2.onError(createCompilerError(42, exp.loc));
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context2.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props3 = [
    createObjectProperty(propName, dir.exp),
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m2) => (isSimpleIdentifier(m2) ? m2 : JSON.stringify(m2)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props3.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
  }
  return createTransformProps(props3);
};
function createTransformProps(props3 = []) {
  return { props: props3 };
}
const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context2) => {
  if (!isCompatEnabled("COMPILER_FILTER", context2)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context2);
  }
  if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context2);
      }
    });
  }
};
function rewriteFilter(node, context2) {
  if (node.type === 4) {
    parseFilter(node, context2);
  } else {
    for (let i2 = 0; i2 < node.children.length; i2++) {
      const child = node.children[i2];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context2);
      } else if (child.type === 8) {
        rewriteFilter(node, context2);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context2);
      }
    }
  }
}
function parseFilter(node, context2) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c2, prev2, i2, expression, filters = [];
  for (i2 = 0; i2 < exp.length; i2++) {
    prev2 = c2;
    c2 = exp.charCodeAt(i2);
    if (inSingle) {
      if (c2 === 39 && prev2 !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c2 === 34 && prev2 !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c2 === 96 && prev2 !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c2 === 47 && prev2 !== 92)
        inRegex = false;
    } else if (c2 === 124 && exp.charCodeAt(i2 + 1) !== 124 && exp.charCodeAt(i2 - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i2 + 1;
        expression = exp.slice(0, i2).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c2) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c2 === 47) {
        let j2 = i2 - 1;
        let p2;
        for (; j2 >= 0; j2--) {
          p2 = exp.charAt(j2);
          if (p2 !== " ")
            break;
        }
        if (!p2 || !validDivisionCharRE.test(p2)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i2).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i2).trim());
    lastFilterIndex = i2 + 1;
  }
  if (filters.length) {
    for (i2 = 0; i2 < filters.length; i2++) {
      expression = wrapFilter(expression, filters[i2], context2);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context2) {
  context2.helper(RESOLVE_FILTER);
  const i2 = filter.indexOf("(");
  if (i2 < 0) {
    context2.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name2 = filter.slice(0, i2);
    const args2 = filter.slice(i2 + 1);
    context2.filters.add(name2);
    return `${toValidAssetId(name2, "filter")}(${exp}${args2 !== ")" ? "," + args2 : args2}`;
  }
}
const seen$1$1 = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context2) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen$1$1.has(node)) {
      return;
    }
    seen$1$1.add(node);
    return () => {
      const codegenNode = node.codegenNode || context2.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          makeBlock(codegenNode, context2);
        }
        node.codegenNode = createCallExpression(context2.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context2.cached++)
        ]);
      }
    };
  }
};
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...[],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn$1,
      bind: transformBind,
      model: transformModel$1
    }
  ];
}
function baseCompile(template, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const ast = isString$4(template) ? baseParse(template, options) : template;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(ast, extend$1({}, options, {
    prefixIdentifiers,
    nodeTransforms: [
      ...nodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend$1(
      {},
      directiveTransforms,
      options.directiveTransforms || {}
    )
  }));
  return generate$2(ast, extend$1({}, options, {
    prefixIdentifiers
  }));
}
const noopDirectiveTransform = () => ({ props: [] });
const V_MODEL_RADIO = Symbol(``);
const V_MODEL_CHECKBOX = Symbol(``);
const V_MODEL_TEXT = Symbol(``);
const V_MODEL_SELECT = Symbol(``);
const V_MODEL_DYNAMIC = Symbol(``);
const V_ON_WITH_MODIFIERS = Symbol(``);
const V_ON_WITH_KEYS = Symbol(``);
const V_SHOW = Symbol(``);
const TRANSITION = Symbol(``);
const TRANSITION_GROUP = Symbol(``);
registerRuntimeHelpers({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});
let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
const isRawTextContainer = /* @__PURE__ */ makeMap("style,iframe,script,noscript", true);
const parserOptions = {
  isVoidTag,
  isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
  isPreTag: (tag) => tag === "pre",
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: (tag) => {
    if (isBuiltInType(tag, `Transition`)) {
      return TRANSITION;
    } else if (isBuiltInType(tag, `TransitionGroup`)) {
      return TRANSITION_GROUP;
    }
  },
  getNamespace(tag, parent2) {
    let ns = parent2 ? parent2.ns : 0;
    if (parent2 && ns === 2) {
      if (parent2.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent2.props.some((a2) => a2.type === 6 && a2.name === "encoding" && a2.value != null && (a2.value.content === "text/html" || a2.value.content === "application/xhtml+xml"))) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent2.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent2 && ns === 1) {
      if (parent2.tag === "foreignObject" || parent2.tag === "desc" || parent2.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  },
  getTextMode({ tag, ns }) {
    if (ns === 0) {
      if (tag === "textarea" || tag === "title") {
        return 1;
      }
      if (isRawTextContainer(tag)) {
        return 2;
      }
    }
    return 0;
  }
};
const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p2, i2) => {
      if (p2.type === 6 && p2.name === "style" && p2.value) {
        node.props[i2] = {
          type: 7,
          name: `bind`,
          arg: createSimpleExpression(`style`, true, p2.loc),
          exp: parseInlineCSS(p2.value.content, p2.loc),
          modifiers: [],
          loc: p2.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = parseStringStyle(cssText);
  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
};
function createDOMCompilerError(code, loc) {
  return createCompilerError(code, loc);
}
const transformVHtml = (dir, node, context2) => {
  const { exp, loc } = dir;
  if (!exp) {
    context2.onError(createDOMCompilerError(51, loc));
  }
  if (node.children.length) {
    context2.onError(createDOMCompilerError(52, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
    ]
  };
};
const transformVText = (dir, node, context2) => {
  const { exp, loc } = dir;
  if (!exp) {
    context2.onError(createDOMCompilerError(53, loc));
  }
  if (node.children.length) {
    context2.onError(createDOMCompilerError(54, loc));
    node.children.length = 0;
  }
  return {
    props: [
      createObjectProperty(createSimpleExpression(`textContent`, true), exp ? getConstantType(exp, context2) > 0 ? exp : createCallExpression(context2.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
    ]
  };
};
const transformModel = (dir, node, context2) => {
  const baseResult = transformModel$1(dir, node, context2);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context2.onError(createDOMCompilerError(56, dir.arg.loc));
  }
  const { tag } = node;
  const isCustomElement = context2.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type4 = findProp(node, `type`);
      if (type4) {
        if (type4.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type4.value) {
          switch (type4.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context2.onError(createDOMCompilerError(57, dir.loc));
              break;
          }
        }
      } else if (hasDynamicKeyVBind(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else
        ;
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else
      ;
    if (!isInvalidType) {
      baseResult.needRuntime = context2.helper(directiveToUse);
    }
  } else {
    context2.onError(createDOMCompilerError(55, dir.loc));
  }
  baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
  return baseResult;
};
const isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ makeMap(
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
const isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`, true);
const resolveModifiers = (key2, modifiers, context2, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i2 = 0; i2 < modifiers.length; i2++) {
    const modifier = modifiers[i2];
    if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context2)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if (isStaticExp(key2)) {
          if (isKeyboardEvent(key2.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key2, event2) => {
  const isStaticClick = isStaticExp(key2) && key2.content.toLowerCase() === "onclick";
  return isStaticClick ? createSimpleExpression(event2, true) : key2.type !== 4 ? createCompoundExpression([
    `(`,
    key2,
    `) === "onClick" ? "${event2}" : (`,
    key2,
    `)`
  ]) : key2;
};
const transformOn = (dir, node, context2) => {
  return transformOn$1(dir, node, context2, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length)
      return baseResult;
    let { key: key2, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key2, modifiers, context2, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key2 = transformClick(key2, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key2 = transformClick(key2, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = createCallExpression(context2.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && (!isStaticExp(key2) || isKeyboardEvent(key2.content))) {
      handlerExp = createCallExpression(context2.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
      key2 = isStaticExp(key2) ? createSimpleExpression(`${key2.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key2, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [createObjectProperty(key2, handlerExp)]
    };
  });
};
const transformShow = (dir, node, context2) => {
  const { exp, loc } = dir;
  if (!exp) {
    context2.onError(createDOMCompilerError(59, loc));
  }
  return {
    props: [],
    needRuntime: context2.helper(V_SHOW)
  };
};
const ignoreSideEffectTags = (node, context2) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
    context2.onError(createDOMCompilerError(61, node.loc));
    context2.removeNode();
  }
};
const DOMNodeTransforms = [
  transformStyle,
  ...[]
];
const DOMDirectiveTransforms = {
  cloak: noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};
function compile(template, options = {}) {
  return baseCompile(template, extend$1({}, parserOptions, options, {
    nodeTransforms: [
      ignoreSideEffectTags,
      ...DOMNodeTransforms,
      ...options.nodeTransforms || []
    ],
    directiveTransforms: extend$1({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!isString$4(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
      return NOOP;
    }
  }
  const key2 = template;
  const cached2 = compileCache[key2];
  if (cached2) {
    return cached2;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    template = el ? el.innerHTML : ``;
  }
  const opts = extend$1({
    hoistStatic: true,
    onError: void 0,
    onWarn: NOOP
  }, options);
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code } = compile(template, opts);
  const render14 = new Function("Vue", code)(runtimeDom);
  render14._rc = true;
  return compileCache[key2] = render14;
}
registerRuntimeCompiler(compileToFunction);
const style = "";
const index$n = "";
const ui = "";
const antd = "";
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof$3(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$3(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key2 = _toPrimitive(arg, "string");
  return _typeof$3(key2) === "symbol" ? key2 : String(key2);
}
function _defineProperty$U(obj, key2, value) {
  key2 = _toPropertyKey(key2);
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function ownKeys$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source2), true).forEach(function(key2) {
      _defineProperty$U(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys$1(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key2 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key2)) {
          target[key2] = source2[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var isFunction$2 = function isFunction(val) {
  return typeof val === "function";
};
var isArray$b = Array.isArray;
var isString$3 = function isString(val) {
  return typeof val === "string";
};
var isObject$3 = function isObject(val) {
  return val !== null && _typeof$3(val) === "object";
};
var onRE$1 = /^on[^a-z]/;
var isOn = function isOn2(key2) {
  return onRE$1.test(key2);
};
var cacheStringFunction = function cacheStringFunction2(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction(function(str) {
  return str.replace(camelizeRE, function(_2, c2) {
    return c2 ? c2.toUpperCase() : "";
  });
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
var hasOwnProperty$d = Object.prototype.hasOwnProperty;
var hasOwn$2 = function hasOwn(val, key2) {
  return hasOwnProperty$d.call(val, key2);
};
function resolvePropValue(options, props3, key2, value) {
  var opt = options[key2];
  if (opt != null) {
    var hasDefault = hasOwn$2(opt, "default");
    if (hasDefault && value === void 0) {
      var defaultValue = opt.default;
      value = opt.type !== Function && isFunction$2(defaultValue) ? defaultValue() : defaultValue;
    }
    if (opt.type === Boolean) {
      if (!hasOwn$2(props3, key2) && !hasDefault) {
        value = false;
      } else if (value === "") {
        value = true;
      }
    }
  }
  return value;
}
function getDataAndAriaProps(props3) {
  return Object.keys(props3).reduce(function(memo, key2) {
    if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-") {
      memo[key2] = props3[key2];
    }
    return memo;
  }, {});
}
function toPx(val) {
  if (typeof val === "number")
    return "".concat(val, "px");
  return val;
}
function renderHelper(v2) {
  var props3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaultV = arguments.length > 2 ? arguments[2] : void 0;
  if (typeof v2 === "function") {
    return v2(props3);
  }
  return v2 !== null && v2 !== void 0 ? v2 : defaultV;
}
function classNames() {
  var classes = [];
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (!value)
      continue;
    if (isString$3(value)) {
      classes.push(value);
    } else if (isArray$b(value)) {
      for (var _i = 0; _i < value.length; _i++) {
        var inner = classNames(value[_i]);
        if (inner) {
          classes.push(inner);
        }
      }
    } else if (isObject$3(value)) {
      for (var name2 in value) {
        if (value[name2]) {
          classes.push(name2);
        }
      }
    }
  }
  return classes.join(" ");
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key2, value]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
        var entry = _a2[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
    var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props3) {
  for (var _i = 0, _a2 = Object.keys(props3); _i < _a2.length; _i++) {
    var key2 = _a2[_i];
    Object.defineProperty(target, key2, {
      value: props3[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size2, position) {
    var value = styles["border-" + position + "-width"];
    return size2 + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$2.prototype[method4] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
  };
});
var index$m = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit$2(arr, i2) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i2) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true) {
          ;
        }
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$2(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread();
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf || Function("return this")();
const root$2 = root$1;
var Symbol$1 = root$2.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var objectTag$4 = "[object Object]";
var funcProto$2 = Function.prototype, objectProto$d = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$4) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$b.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
var isValid$1 = function isValid(value) {
  return value !== void 0 && value !== null && value !== "";
};
const isValid$2 = isValid$1;
var initDefaultProps = function initDefaultProps2(types2, defaultProps2) {
  var propTypes2 = _objectSpread2$1({}, types2);
  Object.keys(defaultProps2).forEach(function(k2) {
    var prop = propTypes2[k2];
    if (prop) {
      if (prop.type || prop.default) {
        prop.default = defaultProps2[k2];
      } else if (prop.def) {
        prop.def(defaultProps2[k2]);
      } else {
        propTypes2[k2] = {
          type: prop,
          default: defaultProps2[k2]
        };
      }
    } else {
      throw new Error("not have ".concat(k2, " prop"));
    }
  });
  return propTypes2;
};
const initDefaultProps$1 = initDefaultProps;
var splitAttrs = function splitAttrs2(attrs) {
  var allAttrs = Object.keys(attrs);
  var eventAttrs = {};
  var onEvents = {};
  var extraAttrs = {};
  for (var i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
    var key2 = allAttrs[i2];
    if (isOn(key2)) {
      eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2];
      onEvents[key2] = attrs[key2];
    } else {
      extraAttrs[key2] = attrs[key2];
    }
  }
  return {
    onEvents,
    events: eventAttrs,
    extraAttrs
  };
};
var parseStyleText = function parseStyleText2() {
  var cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var camel = arguments.length > 1 ? arguments[1] : void 0;
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  if (_typeof$3(cssText) === "object")
    return cssText;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      if (tmp.length > 1) {
        var k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
        res[k2] = tmp[1].trim();
      }
    }
  });
  return res;
};
var hasProp = function hasProp2(instance, prop) {
  return instance[prop] !== void 0;
};
var flattenChildren = function flattenChildren2() {
  var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var temp = Array.isArray(children) ? children : [children];
  var res = [];
  temp.forEach(function(child) {
    if (Array.isArray(child)) {
      res.push.apply(res, _toConsumableArray(flattenChildren2(child, filterEmpty2)));
    } else if (child && child.type === Fragment) {
      res.push.apply(res, _toConsumableArray(flattenChildren2(child.children, filterEmpty2)));
    } else if (child && isVNode(child)) {
      if (filterEmpty2 && !isEmptyElement(child)) {
        res.push(child);
      } else if (!filterEmpty2) {
        res.push(child);
      }
    } else if (isValid$2(child)) {
      res.push(child);
    }
  });
  return res;
};
var getSlot = function getSlot2(self2) {
  var name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (isVNode(self2)) {
    if (self2.type === Fragment) {
      return name2 === "default" ? flattenChildren(self2.children) : [];
    } else if (self2.children && self2.children[name2]) {
      return flattenChildren(self2.children[name2](options));
    } else {
      return [];
    }
  } else {
    var res = self2.$slots[name2] && self2.$slots[name2](options);
    return flattenChildren(res);
  }
};
var findDOMNode = function findDOMNode2(instance) {
  var _instance$vnode;
  var node = (instance === null || instance === void 0 ? void 0 : (_instance$vnode = instance.vnode) === null || _instance$vnode === void 0 ? void 0 : _instance$vnode.el) || instance && (instance.$el || instance);
  while (node && !node.tagName) {
    node = node.nextSibling;
  }
  return node;
};
var getOptionProps = function getOptionProps2(instance) {
  var res = {};
  if (instance.$ && instance.$.vnode) {
    var props3 = instance.$.vnode.props || {};
    Object.keys(instance.$props).forEach(function(k2) {
      var v2 = instance.$props[k2];
      var hyphenateKey = hyphenate(k2);
      if (v2 !== void 0 || hyphenateKey in props3) {
        res[k2] = v2;
      }
    });
  } else if (isVNode(instance) && _typeof$3(instance.type) === "object") {
    var originProps = instance.props || {};
    var _props = {};
    Object.keys(originProps).forEach(function(key2) {
      _props[camelize(key2)] = originProps[key2];
    });
    var options = instance.type.props || {};
    Object.keys(options).forEach(function(k2) {
      var v2 = resolvePropValue(options, _props, k2, _props[k2]);
      if (v2 !== void 0 || k2 in _props) {
        res[k2] = v2;
      }
    });
  }
  return res;
};
var getComponent = function getComponent2(instance) {
  var prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
  var execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var com = void 0;
  if (instance.$) {
    var temp = instance[prop];
    if (temp !== void 0) {
      return typeof temp === "function" && execute ? temp(options) : temp;
    } else {
      com = instance.$slots[prop];
      com = execute && com ? com(options) : com;
    }
  } else if (isVNode(instance)) {
    var _temp = instance.props && instance.props[prop];
    if (_temp !== void 0 && instance.props !== null) {
      return typeof _temp === "function" && execute ? _temp(options) : _temp;
    } else if (instance.type === Fragment) {
      com = instance.children;
    } else if (instance.children && instance.children[prop]) {
      com = instance.children[prop];
      com = execute && com ? com(options) : com;
    }
  }
  if (Array.isArray(com)) {
    com = flattenChildren(com);
    com = com.length === 1 ? com[0] : com;
    com = com.length === 0 ? void 0 : com;
  }
  return com;
};
function getEvents() {
  var ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var on = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var props3 = {};
  if (ele.$) {
    props3 = _objectSpread2$1(_objectSpread2$1({}, props3), ele.$attrs);
  } else {
    props3 = _objectSpread2$1(_objectSpread2$1({}, props3), ele.props);
  }
  return splitAttrs(props3)[on ? "onEvents" : "events"];
}
function getClass(ele) {
  var props3 = (isVNode(ele) ? ele.props : ele.$attrs) || {};
  var tempCls = props3.class || {};
  var cls = {};
  if (typeof tempCls === "string") {
    tempCls.split(" ").forEach(function(c2) {
      cls[c2.trim()] = true;
    });
  } else if (Array.isArray(tempCls)) {
    classNames(tempCls).split(" ").forEach(function(c2) {
      cls[c2.trim()] = true;
    });
  } else {
    cls = _objectSpread2$1(_objectSpread2$1({}, cls), tempCls);
  }
  return cls;
}
function getStyle(ele, camel) {
  var props3 = (isVNode(ele) ? ele.props : ele.$attrs) || {};
  var style2 = props3.style || {};
  if (typeof style2 === "string") {
    style2 = parseStyleText(style2, camel);
  } else if (camel && style2) {
    var res = {};
    Object.keys(style2).forEach(function(k2) {
      return res[camelize(k2)] = style2[k2];
    });
    return res;
  }
  return style2;
}
function isEmptyContent(c2) {
  return c2 === void 0 || c2 === null || c2 === "" || Array.isArray(c2) && c2.length === 0;
}
function isEmptyElement(c2) {
  return c2 && (c2.type === Comment$1 || c2.type === Fragment && c2.children.length === 0 || c2.type === Text$2 && c2.children.trim() === "");
}
function isStringElement(c2) {
  return c2 && c2.type === Text$2;
}
function filterEmpty() {
  var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var res = [];
  children.forEach(function(child) {
    if (Array.isArray(child)) {
      res.push.apply(res, _toConsumableArray(child));
    } else if ((child === null || child === void 0 ? void 0 : child.type) === Fragment) {
      res.push.apply(res, _toConsumableArray(filterEmpty(child.children)));
    } else {
      res.push(child);
    }
  });
  return res.filter(function(c2) {
    return !isEmptyElement(c2);
  });
}
function filterEmptyWithUndefined(children) {
  if (children) {
    var coms = filterEmpty(children);
    return coms.length ? coms : void 0;
  } else {
    return children;
  }
}
function isValidElement(element) {
  if (Array.isArray(element) && element.length === 1) {
    element = element[0];
  }
  return element && element.__v_isVNode && _typeof$3(element.type) !== "symbol";
}
function getPropsSlot(slots, props3) {
  var _props$prop, _slots$prop;
  var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  return (_props$prop = props3[prop]) !== null && _props$prop !== void 0 ? _props$prop : (_slots$prop = slots[prop]) === null || _slots$prop === void 0 ? void 0 : _slots$prop.call(slots);
}
const ResizeObserver$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup: function setup(props3, _ref) {
    var slots = _ref.slots;
    var state = reactive({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    var currentElement = null;
    var resizeObserver = null;
    var destroyObserver = function destroyObserver2() {
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
    };
    var onResize = function onResize2(entries) {
      var onResize3 = props3.onResize;
      var target = entries[0].target;
      var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
      var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);
      if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
        var size2 = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        _extends$1(state, size2);
        if (onResize3) {
          Promise.resolve().then(function() {
            onResize3(_objectSpread2$1(_objectSpread2$1({}, size2), {}, {
              offsetWidth,
              offsetHeight
            }), target);
          });
        }
      }
    };
    var instance = getCurrentInstance();
    var registerObserver = function registerObserver2() {
      var disabled = props3.disabled;
      if (disabled) {
        destroyObserver();
        return;
      }
      var element = findDOMNode(instance);
      var elementChanged = element !== currentElement;
      if (elementChanged) {
        destroyObserver();
        currentElement = element;
      }
      if (!resizeObserver && element) {
        resizeObserver = new index$m(onResize);
        resizeObserver.observe(element);
      }
    };
    onMounted(function() {
      registerObserver();
    });
    onUpdated(function() {
      registerObserver();
    });
    onUnmounted(function() {
      destroyObserver();
    });
    watch(function() {
      return props3.disabled;
    }, function() {
      registerObserver();
    }, {
      flush: "post"
    });
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)[0];
    };
  }
});
var raf$1 = function raf(callback) {
  return setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf$1 = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds.delete(id);
}
function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      var realId = raf$1(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = function(id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};
function throttleByAnimationFrame(fn) {
  var requestId;
  var later = function later2(args2) {
    return function() {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args2));
    };
  };
  var throttled = function throttled2() {
    if (requestId == null) {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      requestId = wrapperRaf(later(args2));
    }
  };
  throttled.cancel = function() {
    return wrapperRaf.cancel(requestId);
  };
  return throttled;
}
var tuple$1 = function tuple() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
    args2[_key] = arguments[_key];
  }
  return args2;
};
var tupleNum = function tupleNum2() {
  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args2[_key2] = arguments[_key2];
  }
  return args2;
};
var withInstall = function withInstall2(comp) {
  var c2 = comp;
  c2.install = function(app) {
    app.component(c2.displayName || c2.name, comp);
  };
  return comp;
};
var supportsPassive = false;
try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get4() {
      supportsPassive = true;
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e2) {
}
const supportsPassive$1 = supportsPassive;
function addEventListenerWrap(target, eventType, cb, option) {
  if (target && target.addEventListener) {
    var opt = option;
    if (opt === void 0 && supportsPassive$1 && (eventType === "touchstart" || eventType === "touchmove" || eventType === "wheel")) {
      opt = {
        passive: false
      };
    }
    target.addEventListener(eventType, cb, opt);
  }
  return {
    remove: function remove2() {
      if (target && target.removeEventListener) {
        target.removeEventListener(eventType, cb);
      }
    }
  };
}
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderReact, targetRect, offsetTop) {
  if (offsetTop !== void 0 && targetRect.top > placeholderReact.top - offsetTop) {
    return "".concat(offsetTop + targetRect.top, "px");
  }
  return void 0;
}
function getFixedBottom(placeholderReact, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && targetRect.bottom < placeholderReact.bottom + offsetBottom) {
    var targetBottomOffset = window.innerHeight - targetRect.bottom;
    return "".concat(offsetBottom + targetBottomOffset, "px");
  }
  return void 0;
}
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
var observerEntities = [];
function addObserveTarget(target, affix) {
  if (!target)
    return;
  var entity = observerEntities.find(function(item) {
    return item.target === target;
  });
  if (entity) {
    entity.affixList.push(affix);
  } else {
    entity = {
      target,
      affixList: [affix],
      eventHandlers: {}
    };
    observerEntities.push(entity);
    TRIGGER_EVENTS.forEach(function(eventName) {
      entity.eventHandlers[eventName] = addEventListenerWrap(target, eventName, function() {
        entity.affixList.forEach(function(targetAffix) {
          var lazyUpdatePosition = targetAffix.exposed.lazyUpdatePosition;
          lazyUpdatePosition();
        }, (eventName === "touchstart" || eventName === "touchmove") && supportsPassive$1 ? {
          passive: true
        } : false);
      });
    });
  }
}
function removeObserveTarget(affix) {
  var observerEntity = observerEntities.find(function(oriObserverEntity) {
    var hasAffix = oriObserverEntity.affixList.some(function(item) {
      return item === affix;
    });
    if (hasAffix) {
      oriObserverEntity.affixList = oriObserverEntity.affixList.filter(function(item) {
        return item !== affix;
      });
    }
    return hasAffix;
  });
  if (observerEntity && observerEntity.affixList.length === 0) {
    observerEntities = observerEntities.filter(function(item) {
      return item !== observerEntity;
    });
    TRIGGER_EVENTS.forEach(function(eventName) {
      var handler5 = observerEntity.eventHandlers[eventName];
      if (handler5 && handler5.remove) {
        handler5.remove();
      }
    });
  }
}
function _objectWithoutPropertiesLoose$2(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source2[key2];
  }
  return target;
}
function _objectWithoutProperties$2(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source2, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key2))
        continue;
      target[key2] = source2[key2];
    }
  }
  return target;
}
const enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
};
var locale$5 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const CalendarLocale$1 = locale$5;
var locale$4 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
const TimePicker$4 = locale$4;
var locale$3 = {
  lang: _objectSpread2$1({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, CalendarLocale$1),
  timePickerLocale: _objectSpread2$1({}, TimePicker$4)
};
const enUS = locale$3;
var typeTemplate$2 = "${label} is not a valid ${type}";
var localeValues$1 = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker: TimePicker$4,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No Data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$2,
        method: typeTemplate$2,
        array: typeTemplate$2,
        object: typeTemplate$2,
        number: typeTemplate$2,
        date: typeTemplate$2,
        boolean: typeTemplate$2,
        integer: typeTemplate$2,
        float: typeTemplate$2,
        regexp: typeTemplate$2,
        email: typeTemplate$2,
        url: typeTemplate$2,
        hex: typeTemplate$2
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  }
};
const defaultLocale = localeValues$1;
const LocaleReceiver = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup: function setup2(props3, _ref) {
    var slots = _ref.slots;
    var localeData2 = inject("localeData", {});
    var locale2 = computed(function() {
      var _props$componentName = props3.componentName, componentName = _props$componentName === void 0 ? "global" : _props$componentName, defaultLocale$1 = props3.defaultLocale;
      var locale3 = defaultLocale$1 || defaultLocale[componentName || "global"];
      var antLocale = localeData2.antLocale;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _objectSpread2$1(_objectSpread2$1({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
    });
    var localeCode = computed(function() {
      var antLocale = localeData2.antLocale;
      var localeCode2 = antLocale && antLocale.locale;
      if (antLocale && antLocale.exist && !localeCode2) {
        return defaultLocale.locale;
      }
      return localeCode2;
    });
    return function() {
      var children = props3.children || slots.default;
      var antLocale = localeData2.antLocale;
      return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
    };
  }
});
function useLocaleReceiver(componentName, defaultLocale$1, propsLocale) {
  var localeData2 = inject("localeData", {});
  var componentLocale = computed(function() {
    var antLocale = localeData2.antLocale;
    var locale2 = unref(defaultLocale$1) || defaultLocale[componentName || "global"];
    var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
    return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {}), unref(propsLocale) || {});
  });
  return [componentLocale];
}
var Empty$2 = function Empty() {
  var _useConfigInject = useConfigInject("empty", {}), getPrefixCls2 = _useConfigInject.getPrefixCls;
  var prefixCls = getPrefixCls2("empty-img-default");
  return createVNode("svg", {
    "class": prefixCls,
    "width": "184",
    "height": "152",
    "viewBox": "0 0 184 152"
  }, [createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(24 31.67)"
  }, [createVNode("ellipse", {
    "class": "".concat(prefixCls, "-ellipse"),
    "cx": "67.797",
    "cy": "106.89",
    "rx": "67.797",
    "ry": "12.668"
  }, null), createVNode("path", {
    "class": "".concat(prefixCls, "-path-1"),
    "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }, null), createVNode("path", {
    "class": "".concat(prefixCls, "-path-2"),
    "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    "transform": "translate(13.56)"
  }, null), createVNode("path", {
    "class": "".concat(prefixCls, "-path-3"),
    "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }, null), createVNode("path", {
    "class": "".concat(prefixCls, "-path-4"),
    "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  }, null)]), createVNode("path", {
    "class": "".concat(prefixCls, "-path-5"),
    "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }, null), createVNode("g", {
    "class": "".concat(prefixCls, "-g"),
    "transform": "translate(149.65 15.383)"
  }, [createVNode("ellipse", {
    "cx": "20.654",
    "cy": "3.167",
    "rx": "2.849",
    "ry": "2.815"
  }, null), createVNode("path", {
    "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }, null)])])]);
};
Empty$2.PRESENTED_IMAGE_DEFAULT = true;
const DefaultEmptyImg = Empty$2;
var Simple = function Simple2() {
  var _useConfigInject = useConfigInject("empty", {}), getPrefixCls2 = _useConfigInject.getPrefixCls;
  var prefixCls = getPrefixCls2("empty-img-simple");
  return createVNode("svg", {
    "class": prefixCls,
    "width": "64",
    "height": "41",
    "viewBox": "0 0 64 41"
  }, [createVNode("g", {
    "transform": "translate(0 1)",
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("ellipse", {
    "class": "".concat(prefixCls, "-ellipse"),
    "fill": "#F5F5F5",
    "cx": "32",
    "cy": "33",
    "rx": "32",
    "ry": "7"
  }, null), createVNode("g", {
    "class": "".concat(prefixCls, "-g"),
    "fill-rule": "nonzero",
    "stroke": "#D9D9D9"
  }, [createVNode("path", {
    "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }, null), createVNode("path", {
    "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    "fill": "#FAFAFA",
    "class": "".concat(prefixCls, "-path")
  }, null)])])]);
};
Simple.PRESENTED_IMAGE_SIMPLE = true;
const SimpleEmptyImg = Simple;
function e$1(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
  }
}
function t$1(t2, n2, r2) {
  return n2 && e$1(t2.prototype, n2), r2 && e$1(t2, r2), t2;
}
function n$1() {
  return (n$1 = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
function r$1(e2, t2) {
  e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
}
function i$1(e2, t2) {
  if (null == e2)
    return {};
  var n2, r2, i2 = {}, o2 = Object.keys(e2);
  for (r2 = 0; r2 < o2.length; r2++)
    t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
  return i2;
}
function o(e2) {
  return 1 == (null != (t2 = e2) && "object" == typeof t2 && false === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
  var t2;
}
var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c$1 = /^\s*function (\w+)/;
function l(e2) {
  var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
  if (n2) {
    var r2 = n2.toString().match(c$1);
    return r2 ? r2[1] : "";
  }
  return "";
}
var s = function(e2) {
  var t2, n2;
  return false !== o(e2) && "function" == typeof (t2 = e2.constructor) && false !== o(n2 = t2.prototype) && false !== n2.hasOwnProperty("isPrototypeOf");
}, v = function(e2) {
  return e2;
}, y = v;
var d = function(e2, t2) {
  return f.call(e2, t2);
}, h = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
}, b = Array.isArray || function(e2) {
  return "[object Array]" === a.call(e2);
}, O = function(e2) {
  return "[object Function]" === a.call(e2);
}, g = function(e2) {
  return s(e2) && d(e2, "_vueTypes_name");
}, m = function(e2) {
  return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
    return d(e2, t2);
  }));
};
function j(e2, t2) {
  return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
}
function _$1(e2, t2, n2) {
  var r2;
  void 0 === n2 && (n2 = false);
  var i2 = true, o2 = "";
  r2 = s(e2) ? e2 : { type: e2 };
  var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
  if (m(r2) && null !== r2.type) {
    if (void 0 === r2.type || true === r2.type)
      return i2;
    if (!r2.required && void 0 === t2)
      return i2;
    b(r2.type) ? (i2 = r2.type.some(function(e3) {
      return true === _$1(e3, t2, true);
    }), o2 = r2.type.map(function(e3) {
      return l(e3);
    }).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
      if (null == e3)
        return "";
      var t3 = e3.constructor.toString().match(c$1);
      return t3 ? t3[1] : "";
    }(t2) === o2 : t2 instanceof r2.type;
  }
  if (!i2) {
    var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
    return false === n2 ? (y(a2), false) : a2;
  }
  if (d(r2, "validator") && O(r2.validator)) {
    var f2 = y, v2 = [];
    if (y = function(e3) {
      v2.push(e3);
    }, i2 = r2.validator(t2), y = f2, !i2) {
      var p2 = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
      return v2.length = 0, false === n2 ? (y(p2), i2) : p2;
    }
  }
  return i2;
}
function T(e2, t2) {
  var n2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get: function() {
    return this.required = true, this;
  } }, def: { value: function(e3) {
    return void 0 !== e3 || this.default ? O(e3) || true === _$1(this, e3, true) ? (this.default = b(e3) ? function() {
      return [].concat(e3);
    } : s(e3) ? function() {
      return Object.assign({}, e3);
    } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
  } } }), r2 = n2.validator;
  return O(r2) && (n2.validator = j(r2, n2)), n2;
}
function w(e2, t2) {
  var n2 = T(e2, t2);
  return Object.defineProperty(n2, "validate", { value: function(e3) {
    return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
  } });
}
function k(e2, t2, n2) {
  var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
    o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
  }), Object.defineProperties({}, o2));
  if (u2._vueTypes_name = e2, !s(n2))
    return u2;
  var a2, f2, c2 = n2.validator, l2 = i$1(n2, ["validator"]);
  if (O(c2)) {
    var v2 = u2.validator;
    v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
      return v2.call(this, e3) && c2.call(this, e3);
    } : c2, u2);
  }
  return Object.assign(u2, l2);
}
function P(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
var x = function() {
  return w("any", {});
}, A = function() {
  return w("function", { type: Function });
}, E = function() {
  return w("boolean", { type: Boolean });
}, N = function() {
  return w("string", { type: String });
}, q = function() {
  return w("number", { type: Number });
}, S = function() {
  return w("array", { type: Array });
}, V = function() {
  return w("object", { type: Object });
}, F = function() {
  return T("integer", { type: Number, validator: function(e2) {
    return h(e2);
  } });
}, D = function() {
  return T("symbol", { validator: function(e2) {
    return "symbol" == typeof e2;
  } });
};
function L(e2, t2) {
  if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2)
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return T(e2.name || "<<anonymous function>>", { validator: function(n2) {
    var r2 = e2(n2);
    return r2 || y(this._vueTypes_name + " - " + t2), r2;
  } });
}
function Y(e2) {
  if (!b(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
    if (null != t3) {
      var n3 = t3.constructor;
      -1 === e3.indexOf(n3) && e3.push(n3);
    }
    return e3;
  }, []);
  return T("oneOf", { type: n2.length > 0 ? n2 : void 0, validator: function(n3) {
    var r2 = -1 !== e2.indexOf(n3);
    return r2 || y(t2), r2;
  } });
}
function B(e2) {
  if (!b(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
    var i2 = e2[r2];
    if (m(i2)) {
      if (g(i2) && "oneOf" === i2._vueTypes_name) {
        n2 = n2.concat(i2.type);
        continue;
      }
      if (O(i2.validator) && (t2 = true), true !== i2.type && i2.type) {
        n2 = n2.concat(i2.type);
        continue;
      }
    }
    n2.push(i2);
  }
  return n2 = n2.filter(function(e3, t3) {
    return n2.indexOf(e3) === t3;
  }), T("oneOfType", t2 ? { type: n2, validator: function(t3) {
    var n3 = [], r3 = e2.some(function(e3) {
      var r4 = _$1(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
      return "string" == typeof r4 && n3.push(r4), true === r4;
    });
    return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
  } } : { type: n2 });
}
function I(e2) {
  return T("arrayOf", { type: Array, validator: function(t2) {
    var n2, r2 = t2.every(function(t3) {
      return true === (n2 = _$1(e2, t3, true));
    });
    return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
  } });
}
function J(e2) {
  return T("instanceOf", { type: e2 });
}
function M(e2) {
  return T("objectOf", { type: Object, validator: function(t2) {
    var n2, r2 = Object.keys(t2).every(function(r3) {
      return true === (n2 = _$1(e2, t2[r3], true));
    });
    return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
  } });
}
function R(e2) {
  var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
    var n3;
    return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
  }), r2 = T("shape", { type: Object, validator: function(r3) {
    var i2 = this;
    if (!s(r3))
      return false;
    var o2 = Object.keys(r3);
    if (n2.length > 0 && n2.some(function(e3) {
      return -1 === o2.indexOf(e3);
    })) {
      var u2 = n2.filter(function(e3) {
        return -1 === o2.indexOf(e3);
      });
      return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
    }
    return o2.every(function(n3) {
      if (-1 === t2.indexOf(n3))
        return true === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
      var o3 = _$1(e2[n3], r3[n3], true);
      return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), true === o3;
    });
  } });
  return Object.defineProperty(r2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(r2, "loose", { get: function() {
    return this._vueTypes_isLoose = true, this;
  } }), r2;
}
var $$2 = function() {
  function e2() {
  }
  return e2.extend = function(e3) {
    var t2 = this;
    if (b(e3))
      return e3.forEach(function(e4) {
        return t2.extend(e4);
      }), this;
    var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i$1(e3, ["name", "validate", "getter"]);
    if (d(this, n2))
      throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
    var c2, l2 = f2.type;
    return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? { get: function() {
      return k(n2, l2, f2);
    } } : { value: function() {
      var e4, t3 = k(n2, l2, f2);
      return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
    } })) : (c2 = a2 ? { get: function() {
      var e4 = Object.assign({}, f2);
      return o2 ? w(n2, e4) : T(n2, e4);
    }, enumerable: true } : { value: function() {
      var e4, t3, r3 = Object.assign({}, f2);
      return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
    }, enumerable: true }, Object.defineProperty(this, n2, c2));
  }, t$1(e2, null, [{ key: "any", get: function() {
    return x();
  } }, { key: "func", get: function() {
    return A().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return E().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return N().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return q().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return S().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return V().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return F().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return D();
  } }]), e2;
}();
function z(e2) {
  var i2;
  return void 0 === e2 && (e2 = { func: function() {
  }, bool: true, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (i2 = function(i3) {
    function o2() {
      return i3.apply(this, arguments) || this;
    }
    return r$1(o2, i3), t$1(o2, null, [{ key: "sensibleDefaults", get: function() {
      return n$1({}, this.defaults);
    }, set: function(t2) {
      this.defaults = false !== t2 ? n$1({}, true !== t2 ? t2 : e2) : {};
    } }]), o2;
  }($$2)).defaults = n$1({}, e2), i2;
}
$$2.defaults = {}, $$2.custom = L, $$2.oneOf = Y, $$2.instanceOf = J, $$2.oneOfType = B, $$2.arrayOf = I, $$2.objectOf = M, $$2.shape = R, $$2.utils = { validate: function(e2, t2) {
  return true === _$1(t2, e2, true);
}, toType: function(e2, t2, n2) {
  return void 0 === n2 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
} };
(function(e2) {
  function t2() {
    return e2.apply(this, arguments) || this;
  }
  return r$1(t2, e2), t2;
})(z());
var PropTypes = z({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
PropTypes.extend([{
  name: "looseBool",
  getter: true,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: true,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: true,
  type: null
}]);
function withUndefined(type4) {
  type4.default = void 0;
  return type4;
}
const PropTypes$1 = PropTypes;
var _excluded$12 = ["image", "description", "imageStyle", "class"];
var defaultEmptyImg = createVNode(DefaultEmptyImg, null, null);
var simpleEmptyImg = createVNode(SimpleEmptyImg, null, null);
var Empty2 = function Empty3(props3, _ref) {
  var _slots$description;
  var _ref$slots = _ref.slots, slots = _ref$slots === void 0 ? {} : _ref$slots, attrs = _ref.attrs;
  var _useConfigInject = useConfigInject("empty", props3), direction = _useConfigInject.direction, prefixClsRef = _useConfigInject.prefixCls;
  var prefixCls = prefixClsRef.value;
  var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), _props$attrs$image = _props$attrs.image, image = _props$attrs$image === void 0 ? defaultEmptyImg : _props$attrs$image, _props$attrs$descript = _props$attrs.description, description = _props$attrs$descript === void 0 ? ((_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.call(slots)) || void 0 : _props$attrs$descript, imageStyle = _props$attrs.imageStyle, _props$attrs$class = _props$attrs.class, className = _props$attrs$class === void 0 ? "" : _props$attrs$class, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$12);
  return createVNode(LocaleReceiver, {
    "componentName": "Empty",
    "children": function children(locale2) {
      var _classNames;
      var des = typeof description !== "undefined" ? description : locale2.description;
      var alt = typeof des === "string" ? des : "empty";
      var imageNode = null;
      if (typeof image === "string") {
        imageNode = createVNode("img", {
          "alt": alt,
          "src": image
        }, null);
      } else {
        imageNode = image;
      }
      return createVNode("div", _objectSpread2$1({
        "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-normal"), image === simpleEmptyImg), _defineProperty$U(_classNames, "".concat(prefixCls, "-rtl"), direction.value === "rtl"), _classNames))
      }, restProps), [createVNode("div", {
        "class": "".concat(prefixCls, "-image"),
        "style": imageStyle
      }, [imageNode]), des && createVNode("p", {
        "class": "".concat(prefixCls, "-description")
      }, [des]), slots.default && createVNode("div", {
        "class": "".concat(prefixCls, "-footer")
      }, [filterEmpty(slots.default())])]);
    }
  }, null);
};
Empty2.displayName = "AEmpty";
Empty2.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty2.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
Empty2.inheritAttrs = false;
Empty2.props = {
  prefixCls: String,
  image: PropTypes$1.any,
  description: PropTypes$1.any,
  imageStyle: {
    type: Object,
    default: void 0
  }
};
const Empty$1 = withInstall(Empty2);
var RenderEmpty = function RenderEmpty2(props3) {
  var _useConfigInject = useConfigInject("empty", props3), prefixCls = _useConfigInject.prefixCls;
  var renderHtml = function renderHtml2(componentName) {
    switch (componentName) {
      case "Table":
      case "List":
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "class": "".concat(prefixCls.value, "-small")
        }, null);
      default:
        return createVNode(Empty$1, null, null);
    }
  };
  return renderHtml(props3.componentName);
};
function renderEmpty(componentName) {
  return createVNode(RenderEmpty, {
    "componentName": componentName
  }, null);
}
var warned = {};
function warning$3(valid, message2) {
}
function note(valid, message2) {
}
function call(method4, valid, message2) {
  if (!valid && !warned[message2]) {
    method4(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid, message2) {
  call(warning$3, valid, message2);
}
function noteOnce(valid, message2) {
  call(note, valid, message2);
}
const warning$2 = function(valid, component) {
  var message2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  warningOnce(valid, "[antdv: ".concat(component, "] ").concat(message2));
};
var ANT_MARK = "internalMark";
var LocaleProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup: function setup3(props3, _ref) {
    var slots = _ref.slots;
    warning$2(props3.ANT_MARK__ === ANT_MARK, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    var state = reactive({
      antLocale: _objectSpread2$1(_objectSpread2$1({}, props3.locale), {}, {
        exist: true
      }),
      ANT_MARK__: ANT_MARK
    });
    provide("localeData", state);
    watch(function() {
      return props3.locale;
    }, function() {
      state.antLocale = _objectSpread2$1(_objectSpread2$1({}, props3.locale), {}, {
        exist: true
      });
    }, {
      immediate: true
    });
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
LocaleProvider.install = function(app) {
  app.component(LocaleProvider.name, LocaleProvider);
  return app;
};
const LocaleProvider$1 = withInstall(LocaleProvider);
tuple$1("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionDirection = function getTransitionDirection2(placement) {
  if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
    return "slide-down";
  }
  return "slide-up";
};
var getTransitionProps = function getTransitionProps2(transitionName2) {
  var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var transitionProps = transitionName2 ? _objectSpread2$1({
    name: transitionName2,
    appear: true,
    enterFromClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-prepare"),
    enterActiveClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-prepare"),
    enterToClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-enter-active"),
    leaveFromClass: " ".concat(transitionName2, "-leave"),
    leaveActiveClass: "".concat(transitionName2, "-leave ").concat(transitionName2, "-leave-active"),
    leaveToClass: "".concat(transitionName2, "-leave ").concat(transitionName2, "-leave-active")
  }, opt) : _objectSpread2$1({
    css: false
  }, opt);
  return transitionProps;
};
var getTransitionGroupProps = function getTransitionGroupProps2(transitionName2) {
  var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var transitionProps = transitionName2 ? _objectSpread2$1({
    name: transitionName2,
    appear: true,
    appearActiveClass: "".concat(transitionName2),
    appearToClass: "".concat(transitionName2, "-appear ").concat(transitionName2, "-appear-active"),
    enterFromClass: "".concat(transitionName2, "-appear ").concat(transitionName2, "-enter ").concat(transitionName2, "-appear-prepare ").concat(transitionName2, "-enter-prepare"),
    enterActiveClass: "".concat(transitionName2),
    enterToClass: "".concat(transitionName2, "-enter ").concat(transitionName2, "-appear ").concat(transitionName2, "-appear-active ").concat(transitionName2, "-enter-active"),
    leaveActiveClass: "".concat(transitionName2, " ").concat(transitionName2, "-leave"),
    leaveToClass: "".concat(transitionName2, "-leave-active")
  }, opt) : _objectSpread2$1({
    css: false
  }, opt);
  return transitionProps;
};
var getTransitionName$2 = function getTransitionName(rootPrefixCls, motion, transitionName2) {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
const Transition = Transition$1;
const Notice = defineComponent({
  name: "Notice",
  inheritAttrs: false,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup: function setup4(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var closeTimer;
    var duration = computed(function() {
      return props3.duration === void 0 ? 1.5 : props3.duration;
    });
    var startCloseTimer = function startCloseTimer2() {
      if (duration.value) {
        closeTimer = setTimeout(function() {
          close3();
        }, duration.value * 1e3);
      }
    };
    var clearCloseTimer = function clearCloseTimer2() {
      if (closeTimer) {
        clearTimeout(closeTimer);
        closeTimer = null;
      }
    };
    var close3 = function close4(e2) {
      if (e2) {
        e2.stopPropagation();
      }
      clearCloseTimer();
      var onClose = props3.onClose, noticeKey = props3.noticeKey;
      if (onClose) {
        onClose(noticeKey);
      }
    };
    var restartCloseTimer = function restartCloseTimer2() {
      clearCloseTimer();
      startCloseTimer();
    };
    onMounted(function() {
      startCloseTimer();
    });
    onUnmounted(function() {
      clearCloseTimer();
    });
    watch([duration, function() {
      return props3.updateMark;
    }, function() {
      return props3.visible;
    }], function(_ref2, _ref3) {
      var _ref4 = _slicedToArray$2(_ref2, 3), preDuration = _ref4[0], preUpdateMark = _ref4[1], preVisible = _ref4[2];
      var _ref5 = _slicedToArray$2(_ref3, 3), newDuration = _ref5[0], newUpdateMark = _ref5[1], newVisible = _ref5[2];
      if (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) {
        restartCloseTimer();
      }
    }, {
      flush: "post"
    });
    return function() {
      var _slots$closeIcon, _slots$default;
      var prefixCls = props3.prefixCls, closable = props3.closable, _props$closeIcon = props3.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : _props$closeIcon, onClick2 = props3.onClick, holder = props3.holder;
      var className = attrs.class, style2 = attrs.style;
      var componentClass = "".concat(prefixCls, "-notice");
      var dataOrAriaAttributeProps = Object.keys(attrs).reduce(function(acc, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          acc[key2] = attrs[key2];
        }
        return acc;
      }, {});
      var node = createVNode("div", _objectSpread2$1({
        "class": classNames(componentClass, className, _defineProperty$U({}, "".concat(componentClass, "-closable"), closable)),
        "style": style2,
        "onMouseenter": clearCloseTimer,
        "onMouseleave": startCloseTimer,
        "onClick": onClick2
      }, dataOrAriaAttributeProps), [createVNode("div", {
        "class": "".concat(componentClass, "-content")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), closable ? createVNode("a", {
        "tabindex": 0,
        "onClick": close3,
        "class": "".concat(componentClass, "-close")
      }, [closeIcon || createVNode("span", {
        "class": "".concat(componentClass, "-close-x")
      }, null)]) : null]);
      if (holder) {
        return createVNode(Teleport, {
          "to": holder
        }, {
          default: function _default9() {
            return node;
          }
        });
      }
      return node;
    };
  }
});
var _excluded$11 = ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName"];
var seed = 0;
var now$3 = Date.now();
function getUuid() {
  var id = seed;
  seed += 1;
  return "rcNotification_".concat(now$3, "_").concat(id);
}
var Notification = defineComponent({
  name: "Notification",
  inheritAttrs: false,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon"],
  setup: function setup5(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var hookRefs = /* @__PURE__ */ new Map();
    var notices = ref([]);
    var transitionProps = computed(function() {
      var prefixCls = props3.prefixCls, _props$animation = props3.animation, animation = _props$animation === void 0 ? "fade" : _props$animation;
      var name2 = props3.transitionName;
      if (!name2 && animation) {
        name2 = "".concat(prefixCls, "-").concat(animation);
      }
      return getTransitionGroupProps(name2);
    });
    var add2 = function add3(originNotice, holderCallback) {
      var key2 = originNotice.key || getUuid();
      var notice2 = _objectSpread2$1(_objectSpread2$1({}, originNotice), {}, {
        key: key2
      });
      var maxCount2 = props3.maxCount;
      var noticeIndex = notices.value.map(function(v2) {
        return v2.notice.key;
      }).indexOf(key2);
      var updatedNotices = notices.value.concat();
      if (noticeIndex !== -1) {
        updatedNotices.splice(noticeIndex, 1, {
          notice: notice2,
          holderCallback
        });
      } else {
        if (maxCount2 && notices.value.length >= maxCount2) {
          notice2.key = updatedNotices[0].notice.key;
          notice2.updateMark = getUuid();
          notice2.userPassKey = key2;
          updatedNotices.shift();
        }
        updatedNotices.push({
          notice: notice2,
          holderCallback
        });
      }
      notices.value = updatedNotices;
    };
    var remove2 = function remove3(removeKey) {
      notices.value = notices.value.filter(function(_ref2) {
        var _ref2$notice = _ref2.notice, key2 = _ref2$notice.key, userPassKey = _ref2$notice.userPassKey;
        var mergedKey = userPassKey || key2;
        return mergedKey !== removeKey;
      });
    };
    expose({
      add: add2,
      remove: remove2,
      notices
    });
    return function() {
      var _slots$closeIcon, _className;
      var prefixCls = props3.prefixCls, _props$closeIcon = props3.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots, {
        prefixCls
      }) : _props$closeIcon;
      var noticeNodes = notices.value.map(function(_ref3, index2) {
        var notice2 = _ref3.notice, holderCallback = _ref3.holderCallback;
        var updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
        var key2 = notice2.key, userPassKey = notice2.userPassKey;
        var content = notice2.content;
        var noticeProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          prefixCls,
          closeIcon: typeof closeIcon === "function" ? closeIcon({
            prefixCls
          }) : closeIcon
        }, notice2), notice2.props), {}, {
          key: key2,
          noticeKey: userPassKey || key2,
          updateMark,
          onClose: function onClose(noticeKey) {
            var _notice$onClose;
            remove2(noticeKey);
            (_notice$onClose = notice2.onClose) === null || _notice$onClose === void 0 ? void 0 : _notice$onClose.call(notice2);
          },
          onClick: notice2.onClick
        });
        if (holderCallback) {
          return createVNode("div", {
            "key": key2,
            "class": "".concat(prefixCls, "-hook-holder"),
            "ref": function ref2(div) {
              if (typeof key2 === "undefined") {
                return;
              }
              if (div) {
                hookRefs.set(key2, div);
                holderCallback(div, noticeProps);
              } else {
                hookRefs.delete(key2);
              }
            }
          }, null);
        }
        return createVNode(Notice, noticeProps, {
          default: function _default9() {
            return [typeof content === "function" ? content({
              prefixCls
            }) : content];
          }
        });
      });
      var className = (_className = {}, _defineProperty$U(_className, prefixCls, 1), _defineProperty$U(_className, attrs.class, !!attrs.class), _className);
      return createVNode("div", {
        "class": className,
        "style": attrs.style || {
          top: "65px",
          left: "50%"
        }
      }, [createVNode(TransitionGroup, _objectSpread2$1({
        "tag": "div"
      }, transitionProps.value), {
        default: function _default9() {
          return [noticeNodes];
        }
      })]);
    };
  }
});
Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _ref4 = properties || {}, _ref4$name = _ref4.name, name2 = _ref4$name === void 0 ? "notification" : _ref4$name, getContainer4 = _ref4.getContainer, appContext = _ref4.appContext, customizePrefixCls = _ref4.prefixCls, customRootPrefixCls = _ref4.rootPrefixCls, customTransitionName = _ref4.transitionName, hasTransitionName2 = _ref4.hasTransitionName, props3 = _objectWithoutProperties$2(_ref4, _excluded$11);
  var div = document.createElement("div");
  if (getContainer4) {
    var root2 = getContainer4();
    root2.appendChild(div);
  } else {
    document.body.appendChild(div);
  }
  var Wrapper = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup: function setup219(_props, _ref5) {
      var attrs = _ref5.attrs;
      var notiRef = ref();
      onMounted(function() {
        callback({
          notice: function notice2(noticeProps) {
            var _notiRef$value;
            (_notiRef$value = notiRef.value) === null || _notiRef$value === void 0 ? void 0 : _notiRef$value.add(noticeProps);
          },
          removeNotice: function removeNotice(key2) {
            var _notiRef$value2;
            (_notiRef$value2 = notiRef.value) === null || _notiRef$value2 === void 0 ? void 0 : _notiRef$value2.remove(key2);
          },
          destroy: function destroy3() {
            render$a(null, div);
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          },
          component: notiRef
        });
      });
      return function() {
        var global2 = globalConfigForApi;
        var prefixCls = global2.getPrefixCls(name2, customizePrefixCls);
        var rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls);
        var transitionName2 = hasTransitionName2 ? customTransitionName : "".concat(rootPrefixCls, "-").concat(customTransitionName);
        return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
          "notUpdateGlobalConfig": true,
          "prefixCls": rootPrefixCls
        }), {
          default: function _default9() {
            return [createVNode(Notification, _objectSpread2$1(_objectSpread2$1({
              "ref": notiRef
            }, attrs), {}, {
              "prefixCls": prefixCls,
              "transitionName": transitionName2
            }), null)];
          }
        });
      };
    }
  });
  var vm = createVNode(Wrapper, props3);
  vm.appContext = appContext || vm.appContext;
  render$a(vm, div);
};
const Notification$1 = Notification;
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
function bound01(n2, max3) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max3 === 360 ? n2 : Math.min(max3, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max3), 10) / 100;
  }
  if (Math.abs(n2 - max3) < 1e-6) {
    return 1;
  }
  if (max3 === 360) {
    n2 = (n2 < 0 ? n2 % max3 + max3 : n2 % max3) / parseFloat(String(max3));
  } else {
    n2 = n2 % max3 / parseFloat(String(max3));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r2, g2, b2);
  var min3 = Math.min(r2, g2, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max3 + min3) / 2;
  if (max3 === min3) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max3 - min3;
    s2 = l2 > 0.5 ? d2 / (2 - max3 - min3) : d2 / (max3 + min3);
    switch (max3) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r2, g2, b2);
  var min3 = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max3;
  var d2 = max3 - min3;
  var s2 = max3 === 0 ? 0 : d2 / max3;
  if (max3 === min3) {
    h2 = 0;
  } else {
    switch (max3) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b2, a2, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a2))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format5 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format5 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok = true;
      format5 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok = true;
      format5 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color.format || format5,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
  function TinyColor2(color, opts) {
    if (color === void 0) {
      color = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.isMonochrome = function() {
    var s2 = this.toHsl().s;
    return s2 === 0;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s2 = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
      var _b = _a2[_i], key2 = _b[0], value = _b[1];
      if (hex2 === value) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format5) {
    var formatSet = Boolean(format5);
    format5 = format5 !== null && format5 !== void 0 ? format5 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format5.startsWith("hex") || format5 === "name");
    if (needsAlphaFormat) {
      if (format5 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format5 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format5 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format5 === "hex" || format5 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format5 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format5 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format5 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format5 === "name") {
      formattedString = this.toName();
    }
    if (format5 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format5 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment = 360 / n2;
    for (var i2 = 1; i2 < n2; i2++) {
      result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix$1(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$4(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$1(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue$4(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue$4(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key2) {
  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
  presetPalettes[key2].primary = presetPalettes[key2][5];
  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
});
var containers = [];
var styleElements = [];
var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
function createStyleElement() {
  var styleElement = document.createElement("style");
  styleElement.setAttribute("type", "text/css");
  return styleElement;
}
function insertCss(css2, options) {
  options = options || {};
  if (css2 === void 0) {
    throw new Error(usage);
  }
  var position = options.prepend === true ? "prepend" : "append";
  var container = options.container !== void 0 ? options.container : document.querySelector("head");
  var containerId = containers.indexOf(container);
  if (containerId === -1) {
    containerId = containers.push(container) - 1;
    styleElements[containerId] = {};
  }
  var styleElement;
  if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) {
    styleElement = styleElements[containerId][position];
  } else {
    styleElement = styleElements[containerId][position] = createStyleElement();
    if (position === "prepend") {
      container.insertBefore(styleElement, container.childNodes[0]);
    } else {
      container.appendChild(styleElement);
    }
  }
  if (css2.charCodeAt(0) === 65279) {
    css2 = css2.substr(1, css2.length);
  }
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText += css2;
  } else {
    styleElement.textContent += css2;
  }
  return styleElement;
}
function _objectSpread$S(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$T(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$T(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function warning$1(valid, message2) {
}
function isIconDefinition(target) {
  return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function generate(node, key2, rootProps) {
  if (!rootProps) {
    return h$1(node.tag, _objectSpread$S({
      key: key2
    }, node.attrs), (node.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
    }));
  }
  return h$1(node.tag, _objectSpread$S({
    key: key2
  }, rootProps, node.attrs), (node.children || []).map(function(child, index2) {
    return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var cssInjectedFlag = false;
var useInsertStyles = function useInsertStyles2() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  nextTick(function() {
    if (!cssInjectedFlag) {
      if (typeof window !== "undefined" && window.document && window.document.documentElement) {
        insertCss(styleStr, {
          prepend: true
        });
      }
      cssInjectedFlag = true;
    }
  });
};
var _excluded$10 = ["icon", "primaryColor", "secondaryColor"];
function _objectWithoutProperties$1(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source2, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key2))
        continue;
      target[key2] = source2[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source2[key2];
  }
  return target;
}
function _objectSpread$R(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$S(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$S(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread$R({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props3, context2) {
  var _props$context$attrs = _objectSpread$R({}, props3, context2.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$10);
  var colors2 = twoToneColorPalette;
  if (primaryColor) {
    colors2 = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning$1(isIconDefinition(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread$R({}, target, {
      icon: target.icon(colors2.primaryColor, colors2.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread$R({}, restProps, {
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
IconBase.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
IconBase.inheritAttrs = false;
IconBase.displayName = "IconBase";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const VueIcon = IconBase;
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return VueIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors2 = VueIcon.getTwoToneColors();
  if (!colors2.calculated) {
    return colors2.primaryColor;
  }
  return [colors2.primaryColor, colors2.secondaryColor];
}
var _excluded$$ = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectSpread$Q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$R(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$R(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key2))
        continue;
      target[key2] = source2[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source2[key2];
  }
  return target;
}
setTwoToneColor("#1890ff");
var Icon = function Icon2(props3, context2) {
  var _classObj;
  var _props$context$attrs = _objectSpread$Q({}, props3, context2.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick2 = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded$$);
  var classObj = (_classObj = {
    anticon: true
  }, _defineProperty$R(_classObj, "anticon-".concat(icon.name), Boolean(icon.name)), _defineProperty$R(_classObj, cls, cls), _classObj);
  var svgClassString = spin === "" || !!spin || icon.name === "loading" ? "anticon-spin" : "";
  var iconTabIndex = tabindex;
  if (iconTabIndex === void 0 && onClick2) {
    iconTabIndex = -1;
    restProps.tabindex = iconTabIndex;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return createVNode("span", _objectSpread$Q({
    "role": "img",
    "aria-label": icon.name
  }, restProps, {
    "onClick": onClick2,
    "class": classObj
  }), [createVNode(VueIcon, {
    "class": svgClassString,
    "icon": icon,
    "primaryColor": primaryColor,
    "secondaryColor": secondaryColor,
    "style": svgStyle
  }, null)]);
};
Icon.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: String
};
Icon.displayName = "AntdIcon";
Icon.inheritAttrs = false;
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon;
function _objectSpread$P(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$Q(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$Q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LoadingOutlined = function LoadingOutlined2(props3, context2) {
  var p2 = _objectSpread$P({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$P({}, p2, {
    "icon": LoadingOutlinedSvg
  }), null);
};
LoadingOutlined.displayName = "LoadingOutlined";
LoadingOutlined.inheritAttrs = false;
const LoadingOutlined$1 = LoadingOutlined;
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
function _objectSpread$O(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$P(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$P(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleFilled = function ExclamationCircleFilled2(props3, context2) {
  var p2 = _objectSpread$O({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$O({}, p2, {
    "icon": ExclamationCircleFilledSvg
  }), null);
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
ExclamationCircleFilled.inheritAttrs = false;
const ExclamationCircleFilled$1 = ExclamationCircleFilled;
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
const CloseCircleFilledSvg = CloseCircleFilled$2;
function _objectSpread$N(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$O(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$O(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleFilled = function CloseCircleFilled2(props3, context2) {
  var p2 = _objectSpread$N({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$N({}, p2, {
    "icon": CloseCircleFilledSvg
  }), null);
};
CloseCircleFilled.displayName = "CloseCircleFilled";
CloseCircleFilled.inheritAttrs = false;
const CloseCircleFilled$1 = CloseCircleFilled;
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
const CheckCircleFilledSvg = CheckCircleFilled$2;
function _objectSpread$M(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$N(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$N(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleFilled = function CheckCircleFilled2(props3, context2) {
  var p2 = _objectSpread$M({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$M({}, p2, {
    "icon": CheckCircleFilledSvg
  }), null);
};
CheckCircleFilled.displayName = "CheckCircleFilled";
CheckCircleFilled.inheritAttrs = false;
const CheckCircleFilled$1 = CheckCircleFilled;
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
const InfoCircleFilledSvg = InfoCircleFilled$2;
function _objectSpread$L(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$M(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$M(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleFilled = function InfoCircleFilled2(props3, context2) {
  var p2 = _objectSpread$L({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$L({}, p2, {
    "icon": InfoCircleFilledSvg
  }), null);
};
InfoCircleFilled.displayName = "InfoCircleFilled";
InfoCircleFilled.inheritAttrs = false;
const InfoCircleFilled$1 = InfoCircleFilled;
var defaultDuration$1 = 3;
var defaultTop$1;
var messageInstance;
var key$2 = 1;
var localPrefixCls = "";
var transitionName = "move-up";
var hasTransitionName = false;
var getContainer$1 = function getContainer() {
  return document.body;
};
var maxCount$1;
var rtl$1 = false;
function getKeyThenIncreaseKey() {
  return key$2++;
}
function setMessageConfig(options) {
  if (options.top !== void 0) {
    defaultTop$1 = options.top;
    messageInstance = null;
  }
  if (options.duration !== void 0) {
    defaultDuration$1 = options.duration;
  }
  if (options.prefixCls !== void 0) {
    localPrefixCls = options.prefixCls;
  }
  if (options.getContainer !== void 0) {
    getContainer$1 = options.getContainer;
    messageInstance = null;
  }
  if (options.transitionName !== void 0) {
    transitionName = options.transitionName;
    messageInstance = null;
    hasTransitionName = true;
  }
  if (options.maxCount !== void 0) {
    maxCount$1 = options.maxCount;
    messageInstance = null;
  }
  if (options.rtl !== void 0) {
    rtl$1 = options.rtl;
  }
}
function getMessageInstance(args2, callback) {
  if (messageInstance) {
    callback(messageInstance);
    return;
  }
  Notification$1.newInstance({
    appContext: args2.appContext,
    prefixCls: args2.prefixCls || localPrefixCls,
    rootPrefixCls: args2.rootPrefixCls,
    transitionName,
    hasTransitionName,
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer$1 || args2.getPopupContainer,
    maxCount: maxCount$1,
    name: "message"
  }, function(instance) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }
    messageInstance = instance;
    callback(instance);
  });
}
var typeToIcon$1 = {
  info: InfoCircleFilled$1,
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  loading: LoadingOutlined$1
};
function notice$1(args2) {
  var duration = args2.duration !== void 0 ? args2.duration : defaultDuration$1;
  var target = args2.key || getKeyThenIncreaseKey();
  var closePromise = new Promise(function(resolve2) {
    var callback = function callback2() {
      if (typeof args2.onClose === "function") {
        args2.onClose();
      }
      return resolve2(true);
    };
    getMessageInstance(args2, function(instance) {
      instance.notice({
        key: target,
        duration,
        style: args2.style || {},
        class: args2.class,
        content: function content(_ref) {
          var _classNames;
          var prefixCls = _ref.prefixCls;
          var Icon3 = typeToIcon$1[args2.type];
          var iconNode = Icon3 ? createVNode(Icon3, null, null) : "";
          var messageClass = classNames("".concat(prefixCls, "-custom-content"), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-").concat(args2.type), args2.type), _defineProperty$U(_classNames, "".concat(prefixCls, "-rtl"), rtl$1 === true), _classNames));
          return createVNode("div", {
            "class": messageClass
          }, [typeof args2.icon === "function" ? args2.icon() : args2.icon || iconNode, createVNode("span", null, [typeof args2.content === "function" ? args2.content() : args2.content])]);
        },
        onClose: callback,
        onClick: args2.onClick
      });
    });
  });
  var result = function result2() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };
  result.then = function(filled, rejected) {
    return closePromise.then(filled, rejected);
  };
  result.promise = closePromise;
  return result;
}
function isArgsProps(content) {
  return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
}
var api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy: function destroy(messageKey) {
    if (messageInstance) {
      if (messageKey) {
        var _messageInstance = messageInstance, removeNotice = _messageInstance.removeNotice;
        removeNotice(messageKey);
      } else {
        var _messageInstance2 = messageInstance, destroy3 = _messageInstance2.destroy;
        destroy3();
        messageInstance = null;
      }
    }
  }
};
function attachTypeApi(originalApi, type4) {
  originalApi[type4] = function(content, duration, onClose) {
    if (isArgsProps(content)) {
      return originalApi.open(_objectSpread2$1(_objectSpread2$1({}, content), {}, {
        type: type4
      }));
    }
    if (typeof duration === "function") {
      onClose = duration;
      duration = void 0;
    }
    return originalApi.open({
      content,
      duration,
      type: type4,
      onClose
    });
  };
}
["success", "info", "warning", "error", "loading"].forEach(function(type4) {
  return attachTypeApi(api$1, type4);
});
api$1.warn = api$1.warning;
const message = api$1;
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key2, arg) {
  try {
    var info = gen[key2](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args2 = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self2, args2);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function() {
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var regeneratorRuntime$1 = { exports: {} };
var _typeof$2 = { exports: {} };
(function(module2) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(obj);
  }
  module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(_typeof$2);
(function(module2) {
  var _typeof2 = _typeof$2.exports["default"];
  function _regeneratorRuntime() {
    module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    var exports2 = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key2, desc) {
      obj[key2] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key2, value) {
      return Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key2];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key2, value) {
        return obj[key2] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator2 = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
      return defineProperty2(generator2, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context2)
      }), generator2;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports2.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto2 = Object.getPrototypeOf, NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method4) {
        define(prototype, method4, function(arg) {
          return this._invoke(method4, arg);
        });
      });
    }
    function AsyncIterator(generator2, PromiseImpl) {
      function invoke(method4, arg, resolve2, reject) {
        var record = tryCatch(generator2[method4], generator2, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == _typeof2(value) && hasOwn3.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve2, reject);
          }, function(err) {
            invoke("throw", err, resolve2, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve2(result);
          }, function(error) {
            return invoke("throw", error, resolve2, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty2(this, "_invoke", {
        value: function value(method4, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve2, reject) {
              invoke(method4, arg, resolve2, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context2.method = method4, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context2.method)
            context2.sent = context2._sent = context2.arg;
          else if ("throw" === context2.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            "return" === context2.method && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context2);
          if ("normal" === record.type) {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context2.done
            };
          }
          "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var methodName = context2.method, method4 = delegate.iterator[methodName];
      if (void 0 === method4)
        return context2.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method4, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i2 = -1, next2 = function next3() {
            for (; ++i2 < iterable.length; ) {
              if (hasOwn3.call(iterable, i2))
                return next3.value = iterable[i2], next3.done = false, next3;
            }
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports2.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports2.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports2.keys = function(val) {
      var object4 = Object(val), keys2 = [];
      for (var key2 in object4) {
        keys2.push(key2);
      }
      return keys2.reverse(), function next2() {
        for (; keys2.length; ) {
          var key3 = keys2.pop();
          if (key3 in object4)
            return next2.value = key3, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports2.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name2 in this) {
            "t" === name2.charAt(0) && hasOwn3.call(this, name2) && !isNaN(+name2.slice(1)) && (this[name2] = void 0);
          }
      },
      stop: function stop2() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context2 = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type4, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports2;
  }
  module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(regeneratorRuntime$1);
var runtime = regeneratorRuntime$1.exports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
var CheckCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
const CheckCircleOutlinedSvg = CheckCircleOutlined$2;
function _objectSpread$K(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$L(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$L(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckCircleOutlined = function CheckCircleOutlined2(props3, context2) {
  var p2 = _objectSpread$K({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$K({}, p2, {
    "icon": CheckCircleOutlinedSvg
  }), null);
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
CheckCircleOutlined.inheritAttrs = false;
const CheckCircleOutlined$1 = CheckCircleOutlined;
var InfoCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
const InfoCircleOutlinedSvg = InfoCircleOutlined$2;
function _objectSpread$J(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$K(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$K(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var InfoCircleOutlined = function InfoCircleOutlined2(props3, context2) {
  var p2 = _objectSpread$J({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$J({}, p2, {
    "icon": InfoCircleOutlinedSvg
  }), null);
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
InfoCircleOutlined.inheritAttrs = false;
const InfoCircleOutlined$1 = InfoCircleOutlined;
var CloseCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z" } }, { "tag": "path", "attrs": { "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "close-circle", "theme": "outlined" };
const CloseCircleOutlinedSvg = CloseCircleOutlined$2;
function _objectSpread$I(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$J(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$J(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseCircleOutlined = function CloseCircleOutlined2(props3, context2) {
  var p2 = _objectSpread$I({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$I({}, p2, {
    "icon": CloseCircleOutlinedSvg
  }), null);
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
CloseCircleOutlined.inheritAttrs = false;
const CloseCircleOutlined$1 = CloseCircleOutlined;
var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
function _objectSpread$H(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$I(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$I(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props3, context2) {
  var p2 = _objectSpread$H({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$H({}, p2, {
    "icon": ExclamationCircleOutlinedSvg
  }), null);
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
ExclamationCircleOutlined.inheritAttrs = false;
const ExclamationCircleOutlined$1 = ExclamationCircleOutlined;
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
const CloseOutlinedSvg = CloseOutlined$2;
function _objectSpread$G(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$H(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$H(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CloseOutlined = function CloseOutlined2(props3, context2) {
  var p2 = _objectSpread$G({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$G({}, p2, {
    "icon": CloseOutlinedSvg
  }), null);
};
CloseOutlined.displayName = "CloseOutlined";
CloseOutlined.inheritAttrs = false;
const CloseOutlined$1 = CloseOutlined;
var notificationInstance = {};
var defaultDuration = 4.5;
var defaultTop = "24px";
var defaultBottom = "24px";
var defaultPrefixCls$1 = "";
var defaultPlacement = "topRight";
var defaultGetContainer = function defaultGetContainer2() {
  return document.body;
};
var defaultCloseIcon = null;
var rtl = false;
var maxCount;
function setNotificationConfig(options) {
  var duration = options.duration, placement = options.placement, bottom = options.bottom, top = options.top, getContainer4 = options.getContainer, closeIcon = options.closeIcon, prefixCls = options.prefixCls;
  if (prefixCls !== void 0) {
    defaultPrefixCls$1 = prefixCls;
  }
  if (duration !== void 0) {
    defaultDuration = duration;
  }
  if (placement !== void 0) {
    defaultPlacement = placement;
  }
  if (bottom !== void 0) {
    defaultBottom = typeof bottom === "number" ? "".concat(bottom, "px") : bottom;
  }
  if (top !== void 0) {
    defaultTop = typeof top === "number" ? "".concat(top, "px") : top;
  }
  if (getContainer4 !== void 0) {
    defaultGetContainer = getContainer4;
  }
  if (closeIcon !== void 0) {
    defaultCloseIcon = closeIcon;
  }
  if (options.rtl !== void 0) {
    rtl = options.rtl;
  }
  if (options.maxCount !== void 0) {
    maxCount = options.maxCount;
  }
}
function getPlacementStyle(placement) {
  var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop;
  var bottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom;
  var style2;
  switch (placement) {
    case "topLeft":
      style2 = {
        left: "0px",
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: "0px",
        top,
        bottom: "auto"
      };
      break;
    case "bottomLeft":
      style2 = {
        left: "0px",
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: "0px",
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
function getNotificationInstance(_ref, callback) {
  var customizePrefixCls = _ref.prefixCls, _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? defaultPlacement : _ref$placement, _ref$getContainer = _ref.getContainer, getContainer4 = _ref$getContainer === void 0 ? defaultGetContainer : _ref$getContainer, top = _ref.top, bottom = _ref.bottom, _ref$closeIcon = _ref.closeIcon, _closeIcon = _ref$closeIcon === void 0 ? defaultCloseIcon : _ref$closeIcon, appContext = _ref.appContext;
  var _globalConfig = globalConfig(), getPrefixCls2 = _globalConfig.getPrefixCls;
  var prefixCls = getPrefixCls2("notification", customizePrefixCls || defaultPrefixCls$1);
  var cacheKey = "".concat(prefixCls, "-").concat(placement, "-").concat(rtl);
  var cacheInstance = notificationInstance[cacheKey];
  if (cacheInstance) {
    Promise.resolve(cacheInstance).then(function(instance) {
      callback(instance);
    });
    return;
  }
  var notificationClass = classNames("".concat(prefixCls, "-").concat(placement), _defineProperty$U({}, "".concat(prefixCls, "-rtl"), rtl === true));
  Notification$1.newInstance({
    name: "notification",
    prefixCls: customizePrefixCls || defaultPrefixCls$1,
    class: notificationClass,
    style: getPlacementStyle(placement, top, bottom),
    appContext,
    getContainer: getContainer4,
    closeIcon: function closeIcon(_ref2) {
      var prefixCls2 = _ref2.prefixCls;
      var closeIconToRender = createVNode("span", {
        "class": "".concat(prefixCls2, "-close-x")
      }, [renderHelper(_closeIcon, {}, createVNode(CloseOutlined$1, {
        "class": "".concat(prefixCls2, "-close-icon")
      }, null))]);
      return closeIconToRender;
    },
    maxCount,
    hasTransitionName: true
  }, function(notification2) {
    notificationInstance[cacheKey] = notification2;
    callback(notification2);
  });
}
var typeToIcon = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
function notice(args2) {
  var icon = args2.icon, type4 = args2.type, description = args2.description, message2 = args2.message, btn = args2.btn;
  var duration = args2.duration === void 0 ? defaultDuration : args2.duration;
  getNotificationInstance(args2, function(notification2) {
    notification2.notice({
      content: function content(_ref3) {
        var outerPrefixCls = _ref3.prefixCls;
        var prefixCls = "".concat(outerPrefixCls, "-notice");
        var iconNode = null;
        if (icon) {
          iconNode = function iconNode2() {
            return createVNode("span", {
              "class": "".concat(prefixCls, "-icon")
            }, [renderHelper(icon)]);
          };
        } else if (type4) {
          var Icon3 = typeToIcon[type4];
          iconNode = function iconNode2() {
            return createVNode(Icon3, {
              "class": "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(type4)
            }, null);
          };
        }
        return createVNode("div", {
          "class": iconNode ? "".concat(prefixCls, "-with-icon") : ""
        }, [iconNode && iconNode(), createVNode("div", {
          "class": "".concat(prefixCls, "-message")
        }, [!description && iconNode ? createVNode("span", {
          "class": "".concat(prefixCls, "-message-single-line-auto-margin")
        }, null) : null, renderHelper(message2)]), createVNode("div", {
          "class": "".concat(prefixCls, "-description")
        }, [renderHelper(description)]), btn ? createVNode("span", {
          "class": "".concat(prefixCls, "-btn")
        }, [renderHelper(btn)]) : null]);
      },
      duration,
      closable: true,
      onClose: args2.onClose,
      onClick: args2.onClick,
      key: args2.key,
      style: args2.style || {},
      class: args2.class
    });
  });
}
var api = {
  open: notice,
  close: function close(key2) {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      return Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.removeNotice(key2);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function destroy2() {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.destroy();
      });
      delete notificationInstance[cacheKey];
    });
  }
};
var iconTypes = ["success", "info", "warning", "error"];
iconTypes.forEach(function(type4) {
  api[type4] = function(args2) {
    return api.open(_objectSpread2$1(_objectSpread2$1({}, args2), {}, {
      type: type4
    }));
  };
});
api.warn = api.warning;
const notification = api;
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var MARK_KEY = "vc-util-key";
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer2(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function injectCSS(css2) {
  var _option$csp;
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var styleNode = document.createElement("style");
  if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce) {
    var _option$csp2;
    styleNode.nonce = (_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer2(option);
  var firstChild = container.firstChild;
  if (option.prepend && container.prepend) {
    container.prepend(styleNode);
  } else if (option.prepend && firstChild) {
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
var containerCache = /* @__PURE__ */ new Map();
function findExistNode(key2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer2(option);
  return Array.from(containerCache.get(container).children).find(function(node) {
    return node.tagName === "STYLE" && node.getAttribute(getMark(option)) === key2;
  });
}
function updateCSS(css2, key2) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer2(option);
  if (!containerCache.has(container)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
  var existNode = findExistNode(key2, option);
  if (existNode) {
    var _option$csp3, _option$csp4;
    if ((_option$csp3 = option.csp) !== null && _option$csp3 !== void 0 && _option$csp3.nonce && existNode.nonce !== ((_option$csp4 = option.csp) === null || _option$csp4 === void 0 ? void 0 : _option$csp4.nonce)) {
      var _option$csp5;
      existNode.nonce = (_option$csp5 = option.csp) === null || _option$csp5 === void 0 ? void 0 : _option$csp5.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key2);
  return newNode;
}
const devWarning = function(valid, component, message2) {
  warningOnce(valid, "[ant-design-vue: ".concat(component, "] ").concat(message2));
};
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());
function registerTheme(globalPrefixCls, theme2) {
  var variables = {};
  var formatColor = function formatColor2(color, updater) {
    var clone3 = color.clone();
    clone3 = (updater === null || updater === void 0 ? void 0 : updater(clone3)) || clone3;
    return clone3.toRgbString();
  };
  var fillColor = function fillColor2(colorVal, type4) {
    var baseColor = new TinyColor(colorVal);
    var colorPalettes = generate$1(baseColor.toRgbString());
    variables["".concat(type4, "-color")] = formatColor(baseColor);
    variables["".concat(type4, "-color-disabled")] = colorPalettes[1];
    variables["".concat(type4, "-color-hover")] = colorPalettes[4];
    variables["".concat(type4, "-color-active")] = colorPalettes[6];
    variables["".concat(type4, "-color-outline")] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables["".concat(type4, "-color-deprecated-bg")] = colorPalettes[1];
    variables["".concat(type4, "-color-deprecated-border")] = colorPalettes[3];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    var primaryColor = new TinyColor(theme2.primaryColor);
    var primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach(function(color, index2) {
      variables["primary-".concat(index2 + 1)] = color;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(35);
    });
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(20);
    });
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, function(c2) {
      return c2.tint(20);
    });
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, function(c2) {
      return c2.tint(50);
    });
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.12);
    });
    var primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.3);
    });
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, function(c2) {
      return c2.darken(2);
    });
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  var cssList = Object.keys(variables).map(function(key2) {
    return "--".concat(globalPrefixCls, "-").concat(key2, ": ").concat(variables[key2], ";");
  });
  if (canUseDom()) {
    updateCSS("\n  :root {\n    ".concat(cssList.join("\n"), "\n  }\n  "), "".concat(dynamicStyleMark, "-dynamic-theme"));
  } else {
    devWarning(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
  }
}
var GlobalFormContextKey = Symbol("GlobalFormContextKey");
var useProvideGlobalForm = function useProvideGlobalForm2(state) {
  provide(GlobalFormContextKey, state);
};
var useInjectGlobalForm = function useInjectGlobalForm2() {
  return inject(GlobalFormContextKey, {
    validateMessages: computed(function() {
      return void 0;
    })
  });
};
var configProviderProps = function configProviderProps2() {
  return {
    getTargetContainer: {
      type: Function
    },
    getPopupContainer: {
      type: Function
    },
    prefixCls: String,
    getPrefixCls: {
      type: Function
    },
    renderEmpty: {
      type: Function
    },
    transformCellText: {
      type: Function
    },
    csp: {
      type: Object,
      default: void 0
    },
    input: {
      type: Object
    },
    autoInsertSpaceInButton: {
      type: Boolean,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    pageHeader: {
      type: Object
    },
    componentSize: {
      type: String
    },
    direction: {
      type: String
    },
    space: {
      type: Object
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: true
    },
    form: {
      type: Object,
      default: void 0
    },
    notUpdateGlobalConfig: Boolean
  };
};
var defaultPrefixCls = "ant";
function getGlobalPrefixCls() {
  return globalConfigForApi.prefixCls || defaultPrefixCls;
}
var globalConfigByCom = reactive({});
var globalConfigBySet = reactive({});
var globalConfigForApi = reactive({});
watchEffect(function() {
  _extends$1(globalConfigForApi, globalConfigByCom, globalConfigBySet);
  globalConfigForApi.prefixCls = getGlobalPrefixCls();
  globalConfigForApi.getPrefixCls = function(suffixCls, customizePrefixCls) {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? "".concat(globalConfigForApi.prefixCls, "-").concat(suffixCls) : globalConfigForApi.prefixCls;
  };
  globalConfigForApi.getRootPrefixCls = function(rootPrefixCls, customizePrefixCls) {
    if (rootPrefixCls) {
      return rootPrefixCls;
    }
    if (globalConfigForApi.prefixCls) {
      return globalConfigForApi.prefixCls;
    }
    if (customizePrefixCls && customizePrefixCls.includes("-")) {
      return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
    }
    return getGlobalPrefixCls();
  };
});
var stopWatchEffect;
var setGlobalConfig = function setGlobalConfig2(params) {
  if (stopWatchEffect) {
    stopWatchEffect();
  }
  stopWatchEffect = watchEffect(function() {
    _extends$1(globalConfigBySet, reactive(params));
    _extends$1(globalConfigForApi, reactive(params));
  });
  if (params.theme) {
    registerTheme(getGlobalPrefixCls(), params.theme);
  }
};
var globalConfig = function globalConfig2() {
  return {
    getPrefixCls: function getPrefixCls2(suffixCls, customizePrefixCls) {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(getGlobalPrefixCls(), "-").concat(suffixCls) : getGlobalPrefixCls();
    },
    getRootPrefixCls: function getRootPrefixCls(rootPrefixCls, customizePrefixCls) {
      if (rootPrefixCls) {
        return rootPrefixCls;
      }
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      if (customizePrefixCls && customizePrefixCls.includes("-")) {
        return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
      }
      return getGlobalPrefixCls();
    }
  };
};
var ConfigProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: false,
  props: configProviderProps(),
  setup: function setup6(props3, _ref) {
    var slots = _ref.slots;
    var getPrefixCls2 = function getPrefixCls3(suffixCls, customizePrefixCls) {
      var _props$prefixCls = props3.prefixCls, prefixCls = _props$prefixCls === void 0 ? "ant" : _props$prefixCls;
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(prefixCls, "-").concat(suffixCls) : prefixCls;
    };
    var renderEmptyComponent = function renderEmptyComponent2(name2) {
      var renderEmpty$1 = props3.renderEmpty || slots.renderEmpty || renderEmpty;
      return renderEmpty$1(name2);
    };
    var getPrefixClsWrapper = function getPrefixClsWrapper2(suffixCls, customizePrefixCls) {
      var prefixCls = props3.prefixCls;
      if (customizePrefixCls)
        return customizePrefixCls;
      var mergedPrefixCls = prefixCls || getPrefixCls2("");
      return suffixCls ? "".concat(mergedPrefixCls, "-").concat(suffixCls) : mergedPrefixCls;
    };
    var configProvider = reactive(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
      getPrefixCls: getPrefixClsWrapper,
      renderEmpty: renderEmptyComponent
    }));
    Object.keys(props3).forEach(function(key2) {
      watch(function() {
        return props3[key2];
      }, function() {
        configProvider[key2] = props3[key2];
      });
    });
    if (!props3.notUpdateGlobalConfig) {
      _extends$1(globalConfigByCom, configProvider);
      watch(configProvider, function() {
        _extends$1(globalConfigByCom, configProvider);
      });
    }
    var validateMessagesRef = computed(function() {
      var validateMessages = {};
      if (props3.locale) {
        var _props$locale$Form, _defaultLocale$Form;
        validateMessages = ((_props$locale$Form = props3.locale.Form) === null || _props$locale$Form === void 0 ? void 0 : _props$locale$Form.defaultValidateMessages) || ((_defaultLocale$Form = defaultLocale.Form) === null || _defaultLocale$Form === void 0 ? void 0 : _defaultLocale$Form.defaultValidateMessages) || {};
      }
      if (props3.form && props3.form.validateMessages) {
        validateMessages = _objectSpread2$1(_objectSpread2$1({}, validateMessages), props3.form.validateMessages);
      }
      return validateMessages;
    });
    useProvideGlobalForm({
      validateMessages: validateMessagesRef
    });
    provide("configProvider", configProvider);
    var renderProvider = function renderProvider2(legacyLocale) {
      var _slots$default;
      return createVNode(LocaleProvider$1, {
        "locale": props3.locale || legacyLocale,
        "ANT_MARK__": ANT_MARK
      }, {
        default: function _default9() {
          return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
        }
      });
    };
    watchEffect(function() {
      if (props3.direction) {
        message.config({
          rtl: props3.direction === "rtl"
        });
        notification.config({
          rtl: props3.direction === "rtl"
        });
      }
    });
    return function() {
      return createVNode(LocaleReceiver, {
        "children": function children(_2, __, legacyLocale) {
          return renderProvider(legacyLocale);
        }
      }, null);
    };
  }
});
var defaultConfigProvider = reactive({
  getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? "ant-".concat(suffixCls) : "ant";
  },
  renderEmpty,
  direction: "ltr"
});
ConfigProvider.config = setGlobalConfig;
ConfigProvider.install = function(app) {
  app.component(ConfigProvider.name, ConfigProvider);
};
const useConfigInject = function(name2, props3) {
  var configProvider = inject("configProvider", defaultConfigProvider);
  var prefixCls = computed(function() {
    return configProvider.getPrefixCls(name2, props3.prefixCls);
  });
  var direction = computed(function() {
    var _props$direction;
    return (_props$direction = props3.direction) !== null && _props$direction !== void 0 ? _props$direction : configProvider.direction;
  });
  var rootPrefixCls = computed(function() {
    return configProvider.getPrefixCls();
  });
  var autoInsertSpaceInButton = computed(function() {
    return configProvider.autoInsertSpaceInButton;
  });
  var renderEmpty2 = computed(function() {
    return configProvider.renderEmpty;
  });
  var space = computed(function() {
    return configProvider.space;
  });
  var pageHeader = computed(function() {
    return configProvider.pageHeader;
  });
  var form = computed(function() {
    return configProvider.form;
  });
  var getTargetContainer = computed(function() {
    return props3.getTargetContainer || configProvider.getTargetContainer;
  });
  var getPopupContainer = computed(function() {
    return props3.getPopupContainer || configProvider.getPopupContainer;
  });
  var dropdownMatchSelectWidth = computed(function() {
    var _props$dropdownMatchS;
    return (_props$dropdownMatchS = props3.dropdownMatchSelectWidth) !== null && _props$dropdownMatchS !== void 0 ? _props$dropdownMatchS : configProvider.dropdownMatchSelectWidth;
  });
  var virtual = computed(function() {
    return (props3.virtual === void 0 ? configProvider.virtual !== false : props3.virtual !== false) && dropdownMatchSelectWidth.value !== false;
  });
  var size2 = computed(function() {
    return props3.size || configProvider.componentSize;
  });
  var autocomplete = computed(function() {
    var _configProvider$input;
    return props3.autocomplete || ((_configProvider$input = configProvider.input) === null || _configProvider$input === void 0 ? void 0 : _configProvider$input.autocomplete);
  });
  var csp = computed(function() {
    return configProvider.csp;
  });
  return {
    configProvider,
    prefixCls,
    direction,
    size: size2,
    getTargetContainer,
    getPopupContainer,
    space,
    pageHeader,
    form,
    autoInsertSpaceInButton,
    renderEmpty: renderEmpty2,
    virtual,
    dropdownMatchSelectWidth,
    rootPrefixCls,
    getPrefixCls: configProvider.getPrefixCls,
    autocomplete,
    csp
  };
};
function omit$2(obj, fields) {
  var shallowCopy = _extends$1({}, obj);
  for (var i2 = 0; i2 < fields.length; i2 += 1) {
    var key2 = fields[i2];
    delete shallowCopy[key2];
  }
  return shallowCopy;
}
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
var AffixStatus;
(function(AffixStatus2) {
  AffixStatus2[AffixStatus2["None"] = 0] = "None";
  AffixStatus2[AffixStatus2["Prepare"] = 1] = "Prepare";
})(AffixStatus || (AffixStatus = {}));
var affixProps = function affixProps2() {
  return {
    offsetTop: Number,
    offsetBottom: Number,
    target: {
      type: Function,
      default: getDefaultTarget
    },
    prefixCls: String,
    onChange: Function,
    onTestUpdatePosition: Function
  };
};
var Affix = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAffix",
  props: affixProps(),
  setup: function setup7(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var placeholderNode = ref();
    var fixedNode = ref();
    var state = reactive({
      affixStyle: void 0,
      placeholderStyle: void 0,
      status: AffixStatus.None,
      lastAffix: false,
      prevTarget: null,
      timeout: null
    });
    var currentInstance2 = getCurrentInstance();
    var offsetTop = computed(function() {
      return props3.offsetBottom === void 0 && props3.offsetTop === void 0 ? 0 : props3.offsetTop;
    });
    var offsetBottom = computed(function() {
      return props3.offsetBottom;
    });
    var measure2 = function measure3() {
      var status = state.status, lastAffix = state.lastAffix;
      var target = props3.target;
      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {
        return;
      }
      var targetNode = target();
      if (!targetNode) {
        return;
      }
      var newState = {
        status: AffixStatus.None
      };
      var targetRect = getTargetRect(targetNode);
      var placeholderReact = getTargetRect(placeholderNode.value);
      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);
      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);
      if (fixedTop !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width: placeholderReact.width + "px",
          height: placeholderReact.height + "px"
        };
        newState.placeholderStyle = {
          width: placeholderReact.width + "px",
          height: placeholderReact.height + "px"
        };
      } else if (fixedBottom !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width: placeholderReact.width + "px",
          height: placeholderReact.height + "px"
        };
        newState.placeholderStyle = {
          width: placeholderReact.width + "px",
          height: placeholderReact.height + "px"
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (lastAffix !== newState.lastAffix) {
        emit("change", newState.lastAffix);
      }
      _extends$1(state, newState);
    };
    var prepareMeasure = function prepareMeasure2() {
      _extends$1(state, {
        status: AffixStatus.Prepare,
        affixStyle: void 0,
        placeholderStyle: void 0
      });
      currentInstance2.update();
    };
    var updatePosition = throttleByAnimationFrame(function() {
      prepareMeasure();
    });
    var lazyUpdatePosition = throttleByAnimationFrame(function() {
      var target = props3.target;
      var affixStyle = state.affixStyle;
      if (target && affixStyle) {
        var targetNode = target();
        if (targetNode && placeholderNode.value) {
          var targetRect = getTargetRect(targetNode);
          var placeholderReact = getTargetRect(placeholderNode.value);
          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);
          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);
          if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
            return;
          }
        }
      }
      prepareMeasure();
    });
    expose({
      updatePosition,
      lazyUpdatePosition
    });
    watch(function() {
      return props3.target;
    }, function(val) {
      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;
      if (state.prevTarget !== newTarget) {
        removeObserveTarget(currentInstance2);
        if (newTarget) {
          addObserveTarget(newTarget, currentInstance2);
          updatePosition();
        }
        state.prevTarget = newTarget;
      }
    });
    watch(function() {
      return [props3.offsetTop, props3.offsetBottom];
    }, updatePosition);
    onMounted(function() {
      var target = props3.target;
      if (target) {
        state.timeout = setTimeout(function() {
          addObserveTarget(target(), currentInstance2);
          updatePosition();
        });
      }
    });
    onUpdated(function() {
      measure2();
    });
    onUnmounted(function() {
      clearTimeout(state.timeout);
      removeObserveTarget(currentInstance2);
      updatePosition.cancel();
      lazyUpdatePosition.cancel();
    });
    var _useConfigInject = useConfigInject("affix", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _slots$default;
      var affixStyle = state.affixStyle, placeholderStyle = state.placeholderStyle;
      var className = classNames(_defineProperty$U({}, prefixCls.value, affixStyle));
      var restProps = omit$2(props3, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange", "onTestUpdatePosition"]);
      return createVNode(ResizeObserver$1, {
        "onResize": updatePosition
      }, {
        default: function _default9() {
          return [createVNode("div", _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
            "style": placeholderStyle,
            "ref": placeholderNode
          }), [createVNode("div", {
            "class": className,
            "ref": fixedNode,
            "style": affixStyle
          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])])];
        }
      });
    };
  }
});
const Affix$1 = withInstall(Affix);
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$3(target, top) {
  if (typeof window === "undefined") {
    return 0;
  }
  var method4 = top ? "scrollTop" : "scrollLeft";
  var result = 0;
  if (isWindow$1(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow$1(target) && typeof result !== "number") {
    var _documentElement;
    result = (_documentElement = (target.ownerDocument || target).documentElement) === null || _documentElement === void 0 ? void 0 : _documentElement[method4];
  }
  return result;
}
function easeInOutCubic(t2, b2, c2, d2) {
  var cc = c2 - b2;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc / 2 * t2 * t2 * t2 + b2;
  }
  return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
}
function scrollTo$1(y2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$getContainer = options.getContainer, getContainer4 = _options$getContainer === void 0 ? function() {
    return window;
  } : _options$getContainer, callback = options.callback, _options$duration = options.duration, duration = _options$duration === void 0 ? 450 : _options$duration;
  var container = getContainer4();
  var scrollTop = getScroll$3(container, true);
  var startTime = Date.now();
  var frameFunc = function frameFunc2() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow$1(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof HTMLDocument || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf(frameFunc2);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf(frameFunc);
}
function noop$c() {
}
var AnchorContextKey = Symbol("anchorContextKey");
var useProvideAnchor = function useProvideAnchor2(state) {
  provide(AnchorContextKey, state);
};
var useInjectAnchor = function useInjectAnchor2() {
  return inject(AnchorContextKey, {
    registerLink: noop$c,
    unregisterLink: noop$c,
    scrollTo: noop$c,
    activeLink: computed(function() {
      return "";
    }),
    handleClick: noop$c
  });
};
const useProvideAnchor$1 = useProvideAnchor;
function getDefaultContainer() {
  return window;
}
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  var rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      container = element.ownerDocument.documentElement;
      return rect.top - container.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
var sharpMatcherRegx = /#([\S ]+)$/;
var anchorProps = function anchorProps2() {
  return {
    prefixCls: String,
    offsetTop: Number,
    bounds: Number,
    affix: {
      type: Boolean,
      default: true
    },
    showInkInFixed: {
      type: Boolean,
      default: false
    },
    getContainer: Function,
    wrapperClass: String,
    wrapperStyle: {
      type: Object,
      default: void 0
    },
    getCurrentAnchor: Function,
    targetOffset: Number,
    onChange: Function,
    onClick: Function
  };
};
const Anchor = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchor",
  inheritAttrs: false,
  props: anchorProps(),
  setup: function setup8(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var _useConfigInject = useConfigInject("anchor", props3), prefixCls = _useConfigInject.prefixCls, getTargetContainer = _useConfigInject.getTargetContainer, direction = _useConfigInject.direction;
    var inkNodeRef = ref();
    var anchorRef = ref();
    var state = reactive({
      links: [],
      scrollContainer: null,
      scrollEvent: null,
      animating: false
    });
    var activeLink = ref(null);
    var getContainer4 = computed(function() {
      var getContainer5 = props3.getContainer;
      return getContainer5 || getTargetContainer.value || getDefaultContainer;
    });
    var getCurrentAnchor = function getCurrentAnchor2() {
      var offsetTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var bounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
      var linkSections = [];
      var container = getContainer4.value();
      state.links.forEach(function(link2) {
        var sharpLinkMatch = sharpMatcherRegx.exec(link2.toString());
        if (!sharpLinkMatch) {
          return;
        }
        var target = document.getElementById(sharpLinkMatch[1]);
        if (target) {
          var top = getOffsetTop(target, container);
          if (top < offsetTop + bounds) {
            linkSections.push({
              link: link2,
              top
            });
          }
        }
      });
      if (linkSections.length) {
        var maxSection = linkSections.reduce(function(prev2, curr) {
          return curr.top > prev2.top ? curr : prev2;
        });
        return maxSection.link;
      }
      return "";
    };
    var setCurrentActiveLink = function setCurrentActiveLink2(link2) {
      var getCurrentAnchor2 = props3.getCurrentAnchor;
      if (activeLink.value === link2) {
        return;
      }
      activeLink.value = typeof getCurrentAnchor2 === "function" ? getCurrentAnchor2() : link2;
      emit("change", link2);
    };
    var handleScrollTo = function handleScrollTo2(link2) {
      var offsetTop = props3.offsetTop, targetOffset2 = props3.targetOffset;
      setCurrentActiveLink(link2);
      var container = getContainer4.value();
      var scrollTop = getScroll$3(container, true);
      var sharpLinkMatch = sharpMatcherRegx.exec(link2);
      if (!sharpLinkMatch) {
        return;
      }
      var targetElement = document.getElementById(sharpLinkMatch[1]);
      if (!targetElement) {
        return;
      }
      var eleOffsetTop = getOffsetTop(targetElement, container);
      var y2 = scrollTop + eleOffsetTop;
      y2 -= targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0;
      state.animating = true;
      scrollTo$1(y2, {
        callback: function callback() {
          state.animating = false;
        },
        getContainer: getContainer4.value
      });
    };
    expose({
      scrollTo: handleScrollTo
    });
    var handleScroll = function handleScroll2() {
      if (state.animating) {
        return;
      }
      var offsetTop = props3.offsetTop, bounds = props3.bounds, targetOffset2 = props3.targetOffset;
      var currentActiveLink = getCurrentAnchor(targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0, bounds);
      setCurrentActiveLink(currentActiveLink);
    };
    var updateInk = function updateInk2() {
      var linkNode = anchorRef.value.getElementsByClassName("".concat(prefixCls.value, "-link-title-active"))[0];
      if (linkNode) {
        inkNodeRef.value.style.top = "".concat(linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5, "px");
      }
    };
    useProvideAnchor$1({
      registerLink: function registerLink(link2) {
        if (!state.links.includes(link2)) {
          state.links.push(link2);
        }
      },
      unregisterLink: function unregisterLink(link2) {
        var index2 = state.links.indexOf(link2);
        if (index2 !== -1) {
          state.links.splice(index2, 1);
        }
      },
      activeLink,
      scrollTo: handleScrollTo,
      handleClick: function handleClick2(e2, info) {
        emit("click", e2, info);
      }
    });
    onMounted(function() {
      nextTick(function() {
        var container = getContainer4.value();
        state.scrollContainer = container;
        state.scrollEvent = addEventListenerWrap(state.scrollContainer, "scroll", handleScroll);
        handleScroll();
      });
    });
    onBeforeUnmount(function() {
      if (state.scrollEvent) {
        state.scrollEvent.remove();
      }
    });
    onUpdated(function() {
      if (state.scrollEvent) {
        var currentContainer = getContainer4.value();
        if (state.scrollContainer !== currentContainer) {
          state.scrollContainer = currentContainer;
          state.scrollEvent.remove();
          state.scrollEvent = addEventListenerWrap(state.scrollContainer, "scroll", handleScroll);
          handleScroll();
        }
      }
      updateInk();
    });
    return function() {
      var _slots$default;
      var offsetTop = props3.offsetTop, affix = props3.affix, showInkInFixed = props3.showInkInFixed;
      var pre = prefixCls.value;
      var inkClass = classNames("".concat(pre, "-ink-ball"), {
        visible: activeLink.value
      });
      var wrapperClass = classNames(props3.wrapperClass, "".concat(pre, "-wrapper"), _defineProperty$U({}, "".concat(pre, "-rtl"), direction.value === "rtl"));
      var anchorClass = classNames(pre, _defineProperty$U({}, "".concat(pre, "-fixed"), !affix && !showInkInFixed));
      var wrapperStyle2 = _objectSpread2$1({
        maxHeight: offsetTop ? "calc(100vh - ".concat(offsetTop, "px)") : "100vh"
      }, props3.wrapperStyle);
      var anchorContent = createVNode("div", {
        "class": wrapperClass,
        "style": wrapperStyle2,
        "ref": anchorRef
      }, [createVNode("div", {
        "class": anchorClass
      }, [createVNode("div", {
        "class": "".concat(pre, "-ink")
      }, [createVNode("span", {
        "class": inkClass,
        "ref": inkNodeRef
      }, null)]), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
      return !affix ? anchorContent : createVNode(Affix$1, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "offsetTop": offsetTop,
        "target": getContainer4.value
      }), {
        default: function _default9() {
          return [anchorContent];
        }
      });
    };
  }
});
var anchorLinkProps = function anchorLinkProps2() {
  return {
    prefixCls: String,
    href: String,
    title: PropTypes$1.any,
    target: String
  };
};
const AnchorLink = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchorLink",
  props: initDefaultProps$1(anchorLinkProps(), {
    href: "#"
  }),
  slots: ["title"],
  setup: function setup9(props3, _ref) {
    var slots = _ref.slots;
    var mergedTitle = null;
    var _useInjectAnchor = useInjectAnchor(), contextHandleClick = _useInjectAnchor.handleClick, scrollTo2 = _useInjectAnchor.scrollTo, unregisterLink = _useInjectAnchor.unregisterLink, registerLink = _useInjectAnchor.registerLink, activeLink = _useInjectAnchor.activeLink;
    var _useConfigInject = useConfigInject("anchor", props3), prefixCls = _useConfigInject.prefixCls;
    var handleClick2 = function handleClick3(e2) {
      var href = props3.href;
      contextHandleClick(e2, {
        title: mergedTitle,
        href
      });
      scrollTo2(href);
    };
    watch(function() {
      return props3.href;
    }, function(val, oldVal) {
      nextTick(function() {
        unregisterLink(oldVal);
        registerLink(val);
      });
    });
    onMounted(function() {
      registerLink(props3.href);
    });
    onBeforeUnmount(function() {
      unregisterLink(props3.href);
    });
    return function() {
      var _slots$default;
      var href = props3.href, target = props3.target;
      var pre = prefixCls.value;
      var title = getPropsSlot(slots, props3, "title");
      mergedTitle = title;
      var active = activeLink.value === href;
      var wrapperClassName = classNames("".concat(pre, "-link"), _defineProperty$U({}, "".concat(pre, "-link-active"), active));
      var titleClassName = classNames("".concat(pre, "-link-title"), _defineProperty$U({}, "".concat(pre, "-link-title-active"), active));
      return createVNode("div", {
        "class": wrapperClassName
      }, [createVNode("a", {
        "class": titleClassName,
        "href": href,
        "title": typeof title === "string" ? title : "",
        "target": target,
        "onClick": handleClick2
      }, [title]), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
Anchor.Link = AnchorLink;
Anchor.install = function(app) {
  app.component(Anchor.name, Anchor);
  app.component(Anchor.Link.name, Anchor.Link);
  return app;
};
function _toArray(arr) {
  return _arrayWithHoles$2(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableRest$2();
}
function getKey$2(data9, index2) {
  var key2 = data9.key;
  var value;
  if ("value" in data9) {
    value = data9.value;
  }
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  if (value !== void 0) {
    return value;
  }
  return "rc-index-key-".concat(index2);
}
function fillFieldNames$3(fieldNames, childrenAsData) {
  var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options;
  return {
    label: label || (childrenAsData ? "children" : "label"),
    value: value || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
  var flattenList = [];
  var _fillFieldNames = fillFieldNames$3(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
  function dig(list, isGroupOption) {
    list.forEach(function(data9) {
      var label = data9[fieldLabel];
      if (isGroupOption || !(fieldOptions in data9)) {
        var value = data9[fieldValue];
        flattenList.push({
          key: getKey$2(data9, flattenList.length),
          groupOption: isGroupOption,
          data: data9,
          label,
          value
        });
      } else {
        var grpLabel = label;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data9.label;
        }
        flattenList.push({
          key: getKey$2(data9, flattenList.length),
          group: true,
          data: data9,
          label: grpLabel
        });
        dig(data9[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  var newOption = _objectSpread2$1({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get: function get4() {
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  var match2 = false;
  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
    if (!token2) {
      return [str];
    }
    var list2 = str.split(token2);
    match2 = match2 || list2.length > 1;
    return list2.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function(unit) {
      return unit;
    });
  }
  var list = separate(text, tokens);
  return match2 ? list : null;
}
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  return root2.contains(n2);
}
var availablePrefixs = ["moz", "ms", "webkit"];
function requestAnimationFramePolyfill() {
  var lastTime = 0;
  return function(callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
function getRequestAnimationFrame() {
  if (typeof window === "undefined") {
    return function() {
    };
  }
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame.bind(window);
  }
  var prefix = availablePrefixs.filter(function(key2) {
    return "".concat(key2, "RequestAnimationFrame") in window;
  })[0];
  return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
  if (typeof window === "undefined") {
    return null;
  }
  if (window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(id);
  }
  var prefix = availablePrefixs.filter(function(key2) {
    return "".concat(key2, "CancelAnimationFrame") in window || "".concat(key2, "CancelRequestAnimationFrame") in window;
  })[0];
  return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(this, id) : clearTimeout(id);
}
var raf2 = getRequestAnimationFrame();
var cancelAnimationTimeout = function cancelAnimationTimeout2(frame) {
  return cancelRequestAnimationFrame(frame.id);
};
var requestAnimationTimeout = function requestAnimationTimeout2(callback) {
  var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var start = Date.now();
  function timeout() {
    if (Date.now() - start >= delay) {
      callback.call();
    } else {
      frame.id = raf2(timeout);
    }
  }
  var frame = {
    id: raf2(timeout)
  };
  return frame;
};
var innerProps = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  animation: [String, Object],
  transitionName: String,
  stretch: {
    type: String
  },
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
};
var mobileProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
  mobile: {
    type: Object
  }
});
var popupProps = _objectSpread2$1(_objectSpread2$1({}, innerProps), {}, {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function getMotion(_ref) {
  var prefixCls = _ref.prefixCls, animation = _ref.animation, transitionName2 = _ref.transitionName;
  if (animation) {
    return {
      name: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName2) {
    return {
      name: transitionName2
    };
  }
  return {};
}
function Mask$1(props3) {
  var prefixCls = props3.prefixCls, visible = props3.visible, zIndex = props3.zIndex, mask = props3.mask, maskAnimation = props3.maskAnimation, maskTransitionName = props3.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion = {};
  if (maskTransitionName || maskAnimation) {
    motion = getMotion({
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    });
  }
  return createVNode(Transition$1, _objectSpread2$1({
    "appear": true
  }, motion), {
    default: function _default9() {
      return [withDirectives(createVNode("div", {
        "style": {
          zIndex
        },
        "class": "".concat(prefixCls, "-mask")
      }, null), [[resolveDirective("if"), visible]])];
    }
  });
}
Mask$1.displayName = "Mask";
const MobilePopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: false,
  props: mobileProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function setup10(props3, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var elementRef = ref();
    expose({
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.value;
      }
    });
    return function() {
      var _slots$default;
      var zIndex = props3.zIndex, visible = props3.visible, prefixCls = props3.prefixCls, _props$mobile = props3.mobile;
      _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
      var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender;
      var mergedStyle = _objectSpread2$1({
        zIndex
      }, popupStyle);
      var childNode = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      if (childNode.length > 1) {
        childNode = createVNode("div", {
          "class": "".concat(prefixCls, "-content")
        }, [childNode]);
      }
      if (popupRender) {
        childNode = popupRender(childNode);
      }
      var mergedClassName = classNames(prefixCls, popupClassName);
      return createVNode(Transition$1, _objectSpread2$1({
        "ref": elementRef
      }, popupMotion), {
        default: function _default9() {
          return [visible ? createVNode("div", {
            "class": mergedClassName,
            "style": mergedStyle
          }, [childNode]) : null];
        }
      });
    };
  }
});
var StatusQueue = ["measure", "align", null, "motion"];
const useVisibleStatus = function(visible, doMeasure) {
  var status = ref(null);
  var rafRef = ref();
  var destroyRef = ref(false);
  function setStatus(nextStatus) {
    if (!destroyRef.value) {
      status.value = nextStatus;
    }
  }
  function cancelRaf() {
    wrapperRaf.cancel(rafRef.value);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.value = wrapperRaf(function() {
      var newStatus = status.value;
      switch (status.value) {
        case "align":
          newStatus = "motion";
          break;
        case "motion":
          newStatus = "stable";
          break;
      }
      setStatus(newStatus);
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  watch(visible, function() {
    setStatus("measure");
  }, {
    immediate: true,
    flush: "post"
  });
  onMounted(function() {
    watch(status, function() {
      switch (status.value) {
        case "measure":
          doMeasure();
          break;
      }
      if (status.value) {
        rafRef.value = wrapperRaf(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee() {
          var index2, nextStatus;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  index2 = StatusQueue.indexOf(status.value);
                  nextStatus = StatusQueue[index2 + 1];
                  if (nextStatus && index2 !== -1) {
                    setStatus(nextStatus);
                  }
                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })));
      }
    }, {
      immediate: true,
      flush: "post"
    });
  });
  onBeforeUnmount(function() {
    destroyRef.value = true;
    cancelRaf();
  });
  return [status, goNextStatus];
};
const useStretchStyle = function(stretch) {
  var targetSize = ref({
    width: 0,
    height: 0
  });
  function measureStretch(element) {
    targetSize.value = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  var style2 = computed(function() {
    var sizeStyle = {};
    if (stretch.value) {
      var _targetSize$value = targetSize.value, width = _targetSize$value.width, height = _targetSize$value.height;
      if (stretch.value.indexOf("height") !== -1 && height) {
        sizeStyle.height = "".concat(height, "px");
      } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = "".concat(height, "px");
      }
      if (stretch.value.indexOf("width") !== -1 && width) {
        sizeStyle.width = "".concat(width, "px");
      } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = "".concat(width, "px");
      }
    }
    return sizeStyle;
  });
  return [style2, measureStretch];
};
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source2), true).forEach(function(key2) {
      _defineProperty$G(target, key2, source2[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
    });
  }
  return target;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _defineProperty$G(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style2 = document.createElement("p").style;
  var testProp = "Transform";
  for (var key2 in jsCssMap) {
    if (key2 + testProp in style2) {
      vendorPrefix = key2;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node, value) {
  var name2 = getTransitionName$1();
  if (name2) {
    node.style[name2] = value;
    if (name2 !== "transitionProperty") {
      node.style.transitionProperty = value;
    }
  }
}
function setTransform(node, value) {
  var name2 = getTransformName();
  if (name2) {
    node.style[name2] = value;
    if (name2 !== "transform") {
      node.style.transform = value;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName$1()];
}
function getTransformXY(node) {
  var style2 = window.getComputedStyle(node, null);
  var transform2 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform2 && transform2 !== "none") {
    var matrix = transform2.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style2 = window.getComputedStyle(node, null);
  var transform2 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform2 && transform2 !== "none") {
    var arr;
    var match2d = transform2.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform2.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el, name2, v2) {
  var value = v2;
  if (_typeof$1(name2) === "object") {
    for (var i2 in name2) {
      if (name2.hasOwnProperty(i2)) {
        css(el, i2, name2[i2]);
      }
    }
    return void 0;
  }
  if (typeof value !== "undefined") {
    if (typeof value === "number") {
      value = "".concat(value, "px");
    }
    el.style[name2] = value;
    return void 0;
  }
  return getComputedStyleX(el, name2);
}
function getClientPosition$1(elem) {
  var box;
  var x2;
  var y2;
  var doc2 = elem.ownerDocument;
  var body = doc2.body;
  var docElem = doc2 && doc2.documentElement;
  box = elem.getBoundingClientRect();
  x2 = Math.floor(box.left);
  y2 = Math.floor(box.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll$2(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll$2(w2);
}
function getScrollTop(w2) {
  return getScroll$2(w2, true);
}
function getOffset$2(el) {
  var pos2 = getClientPosition$1(el);
  var doc2 = el.ownerDocument;
  var w2 = doc2.defaultView || doc2.parentWindow;
  pos2.left += getScrollLeft(w2);
  pos2.top += getScrollTop(w2);
  return pos2;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name2, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name2) || computedStyle[name2];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT = "left";
var PX = "px";
function _getComputedStyleIE(elem, name2) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name2];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name2)) {
    var style2 = elem.style;
    var left = style2[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
    style2[LEFT] = name2 === "fontSize" ? "1em" : ret || 0;
    ret = style2.pixelLeft + PX;
    style2[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$2(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$2(elem);
  var originalStyle = {};
  for (var key2 in offset3) {
    if (offset3.hasOwnProperty(key2)) {
      var dir = getOffsetDirection(key2, option);
      var preset = key2 === "left" ? presetH : presetV;
      var off = originalOffset[key2] - old[key2];
      if (dir === key2) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset3) {
  var originalOffset = getOffset$2(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$2(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each(arr, fn) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    fn(arr[i2]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style2 = elem.style;
  var name2;
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      old[name2] = style2[name2];
      style2[name2] = options[name2];
    }
  }
  callback.call(elem);
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      style2[name2] = old[name2];
    }
  }
}
function getPBMWidth(elem, props3, which) {
  var value = 0;
  var prop;
  var j2;
  var i2;
  for (j2 = 0; j2 < props3.length; j2++) {
    prop = props3[j2];
    if (prop) {
      for (i2 = 0; i2 < which.length; i2++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i2], "Width");
        } else {
          cssProp = prop + which[i2];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent2 = element;
    do {
      if (parent2.nodeType === 11 && parent2.host) {
        parent2 = parent2.host;
      } else {
        parent2 = parent2.parentNode;
      }
    } while (parent2 && parent2.nodeType !== 1 && parent2.nodeType !== 9);
    return parent2;
  }
};
each(["Width", "Height"], function(name2) {
  domUtils["doc".concat(name2)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(
      d2.documentElement["scroll".concat(name2)],
      d2.body["scroll".concat(name2)],
      domUtils["viewport".concat(name2)](d2)
    );
  };
  domUtils["viewport".concat(name2)] = function(win) {
    var prop = "client".concat(name2);
    var doc2 = win.document;
    var body = doc2.body;
    var documentElement = doc2.documentElement;
    var documentElementProp = documentElement[prop];
    return doc2.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name2, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name2 === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name2 === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name2 === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name2);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name2] || 0;
    }
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args2 = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args2[_key2] = arguments[_key2];
  }
  var val;
  var elem = args2[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args2);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args2);
    });
  }
  return val;
}
each(["width", "height"], function(name2) {
  var first = name2.charAt(0).toUpperCase() + name2.slice(1);
  domUtils["outer".concat(first)] = function(el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name2, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name2] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name2, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name2, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i2 in from) {
    if (from.hasOwnProperty(i2)) {
      to[i2] = from[i2];
    }
  }
  return to;
}
var utils$d = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc2 = node.ownerDocument || node;
    return doc2.defaultView || doc2.parentWindow;
  },
  getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== "undefined") {
      setOffset(el, value, option || {});
    } else {
      return getOffset$2(el);
    }
  },
  isWindow,
  each,
  css,
  clone: function clone(obj) {
    var i2;
    var ret = {};
    for (i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        ret[i2] = obj[i2];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret.overflow[i2] = obj.overflow[i2];
        }
      }
    }
    return ret;
  },
  mix,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge() {
    var ret = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      utils$d.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils$d, domUtils);
var getParent$1 = utils$d.getParent;
function getOffsetParent(element) {
  if (utils$d.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc2 = utils$d.getDocument(element);
  var body = doc2.body;
  var parent2;
  var positionStyle = utils$d.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
  }
  for (parent2 = getParent$1(element); parent2 && parent2 !== body && parent2.nodeType !== 9; parent2 = getParent$1(parent2)) {
    positionStyle = utils$d.css(parent2, "position");
    if (positionStyle !== "static") {
      return parent2;
    }
  }
  return null;
}
var getParent$1$1 = utils$d.getParent;
function isAncestorFixed(element) {
  if (utils$d.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc2 = utils$d.getDocument(element);
  var body = doc2.body;
  var parent2 = null;
  for (parent2 = getParent$1$1(element); parent2 && parent2 !== body && parent2 !== doc2; parent2 = getParent$1$1(parent2)) {
    var positionStyle = utils$d.css(parent2, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc2 = utils$d.getDocument(element);
  var win = doc2.defaultView || doc2.parentWindow;
  var body = doc2.body;
  var documentElement = doc2.documentElement;
  while (el) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils$d.css(el, "overflow") !== "visible") {
      var pos2 = utils$d.offset(el);
      pos2.left += el.clientLeft;
      pos2.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos2.top);
      visibleRect.right = Math.min(
        visibleRect.right,
        pos2.left + el.clientWidth
      );
      visibleRect.bottom = Math.min(visibleRect.bottom, pos2.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos2.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }
  var originalPosition = null;
  if (!utils$d.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils$d.css(element, "position");
    if (position === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils$d.getWindowScrollLeft(win);
  var scrollY = utils$d.getWindowScrollTop(win);
  var viewportWidth = utils$d.viewportWidth(win);
  var viewportHeight = utils$d.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos2 = utils$d.clone(elFuturePos);
  var size2 = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos2.left < visibleRect.left) {
    pos2.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos2.left >= visibleRect.left && pos2.left + size2.width > visibleRect.right) {
    size2.width -= pos2.left + size2.width - visibleRect.right;
  }
  if (overflow.adjustX && pos2.left + size2.width > visibleRect.right) {
    pos2.left = Math.max(visibleRect.right - size2.width, visibleRect.left);
  }
  if (overflow.adjustY && pos2.top < visibleRect.top) {
    pos2.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos2.top >= visibleRect.top && pos2.top + size2.height > visibleRect.bottom) {
    size2.height -= pos2.top + size2.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos2.top + size2.height > visibleRect.bottom) {
    pos2.top = Math.max(visibleRect.bottom - size2.height, visibleRect.top);
  }
  return utils$d.mix(pos2, size2);
}
function getRegion(node) {
  var offset3;
  var w2;
  var h2;
  if (!utils$d.isWindow(node) && node.nodeType !== 9) {
    offset3 = utils$d.offset(node);
    w2 = utils$d.outerWidth(node);
    h2 = utils$d.outerHeight(node);
  } else {
    var win = utils$d.getWindow(node);
    offset3 = {
      left: utils$d.getWindowScrollLeft(win),
      top: utils$d.getWindowScrollTop(win)
    };
    w2 = utils$d.viewportWidth(win);
    h2 = utils$d.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H === "c") {
    x2 += w2 / 2;
  } else if (H === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff2 = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff2[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff2[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils$d.each(points, function(p2) {
    ret.push(p2.replace(reg, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el) {
  offset3[0] = convertOffset(offset3[0], el.width);
  offset3[1] = convertOffset(offset3[1], el.height);
}
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source2 = align.source || el;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source2, alwaysByViewport);
  var elRegion = getRegion(source2);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
  var newElRegion = utils$d.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
      utils$d.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils$d.css(source2, "width", utils$d.width(source2) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils$d.css(source2, "height", utils$d.height(source2) + newElRegion.height - elRegion.height);
  }
  utils$d.offset(source2, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc2 = utils$d.getDocument(el);
  var win = doc2.defaultView || doc2.parentWindow;
  var scrollX = utils$d.getWindowScrollLeft(win);
  var scrollY = utils$d.getWindowScrollTop(win);
  var viewportWidth = utils$d.viewportWidth(win);
  var viewportHeight = utils$d.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points
  }), pointInView);
}
function cloneElement(vnode) {
  var nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var ele = vnode;
  if (Array.isArray(vnode)) {
    ele = filterEmpty(vnode)[0];
  }
  if (!ele) {
    return null;
  }
  var node = cloneVNode(ele, nodeProps, mergeRef);
  node.props = override ? _objectSpread2$1(_objectSpread2$1({}, node.props), nodeProps) : node.props;
  warning$2(_typeof$3(node.props.class) !== "object", "class must be string");
  return node;
}
function cloneVNodes(vnodes) {
  var nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  return vnodes.map(function(vnode) {
    return cloneElement(vnode, nodeProps, override);
  });
}
const isVisible = function(element) {
  if (!element) {
    return false;
  }
  if (element.offsetParent) {
    return true;
  }
  if (element.getBBox) {
    var box = element.getBBox();
    if (box.width || box.height) {
      return true;
    }
  }
  if (element.getBoundingClientRect) {
    var _box = element.getBoundingClientRect();
    if (_box.width || _box.height) {
      return true;
    }
  }
  return false;
};
function isSamePoint(prev2, next2) {
  if (prev2 === next2)
    return true;
  if (!prev2 || !next2)
    return false;
  if ("pageX" in next2 && "pageY" in next2) {
    return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
  }
  if ("clientX" in next2 && "clientY" in next2) {
    return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize(_ref) {
    var _ref2 = _slicedToArray$2(_ref, 1), target = _ref2[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver = new index$m(onResize);
  if (element) {
    resizeObserver.observe(element);
  }
  return function() {
    resizeObserver.disconnect();
  };
}
const useBuffer = function(callback, buffer2) {
  var called = false;
  var timeout = null;
  function cancelTrigger() {
    clearTimeout(timeout);
  }
  function trigger2(force) {
    if (!called || force === true) {
      if (callback() === false) {
        return;
      }
      called = true;
      cancelTrigger();
      timeout = setTimeout(function() {
        called = false;
      }, buffer2.value);
    } else {
      cancelTrigger();
      timeout = setTimeout(function() {
        called = false;
        trigger2();
      }, buffer2.value);
    }
  }
  return [trigger2, function() {
    called = false;
    cancelTrigger();
  }];
};
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array4, key2) {
  var length = array4.length;
  while (length--) {
    if (eq(array4[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data9.length - 1;
  if (index2 == lastIndex) {
    data9.pop();
  } else {
    splice.call(data9, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key2);
  return index2 < 0 ? void 0 : data9[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key2);
  if (index2 < 0) {
    ++this.size;
    data9.push([key2, value]);
  } else {
    data9[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data9 = this.__data__, result = data9["delete"](key2);
  this.size = data9.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
function isObject$2(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$2["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource(value));
}
function getValue$3(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
function getNative(object4, key2) {
  var value = getValue$3(object4, key2);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$2, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key2) {
  var data9 = this.__data__;
  if (nativeCreate$1) {
    var result = data9[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data9, key2) ? data9[key2] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key2) {
  var data9 = this.__data__;
  return nativeCreate$1 ? data9[key2] !== void 0 : hasOwnProperty$8.call(data9, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data9 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data9[key2] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key2) {
  var data9 = map.__data__;
  return isKeyable(key2) ? data9[typeof key2 == "string" ? "string" : "hash"] : data9.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data9 = getMapData(this, key2), size2 = data9.size;
  data9.set(key2, value);
  this.size += data9.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key2, value) {
  var data9 = this.__data__;
  if (data9 instanceof ListCache) {
    var pairs = data9.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data9.size;
      return this;
    }
    data9 = this.__data__ = new MapCache(pairs);
  }
  data9.set(key2, value);
  this.size = data9.size;
  return this;
}
function Stack(entries) {
  var data9 = this.__data__ = new ListCache(entries);
  this.size = data9.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key2) {
  return cache.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array4);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array4, other);
  stack2.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack2) : customizer(arrValue, othValue, index2, array4, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen2) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen2.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array4);
  stack2["delete"](other);
  return result;
}
var Uint8Array$1 = root$2.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag$4:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$3:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object4), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$3:
    case numberTag$4:
      return eq(+object4, +other);
    case errorTag$2:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$3:
    case stringTag$3:
      return object4 == other + "";
    case mapTag$5:
      var convert2 = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object4, other);
      var result = equalArrays(convert2(object4), convert2(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object4);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object4) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
function arrayPush(array4, values) {
  var index2 = -1, length = values.length, offset3 = array4.length;
  while (++index2 < length) {
    array4[offset3 + index2] = values[index2];
  }
  return array4;
}
var isArray$9 = Array.isArray;
const isArray$a = isArray$9;
function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$a(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
function arrayFilter(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
const getSymbols$1 = getSymbols;
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
const isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$2 = nativeIsBuffer || stubFalse;
const isBuffer$3 = isBuffer$2;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type4 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$a(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$6.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys$1(object4);
  }
  var result = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$5.call(object4, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function keys(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
function getAllKeys$1(object4) {
  return baseGetAllKeys(object4, keys, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function equalObjects(object4, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object4), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$4.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack2.get(object4);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack2.set(object4, other);
  stack2.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack2) : customizer(objValue, othValue, key2, object4, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object4);
  stack2["delete"](other);
  return result;
}
var DataView$1 = getNative(root$2, "DataView");
const DataView$2 = DataView$1;
var Promise$1 = getNative(root$2, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$2, "Set");
const Set$2 = Set$1;
var WeakMap$1 = getNative(root$2, "WeakMap");
const WeakMap$2 = WeakMap$1;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
const getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$a(object4), othIsArr = isArray$a(other), objTag = objIsArr ? arrayTag$1 : getTag$1(object4), othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object4)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
function isEqual$1(value, other) {
  return baseIsEqual(value, other);
}
var alignProps = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint(point) {
  if (_typeof$3(point) !== "object" || !point)
    return null;
  return point;
}
const Align = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: alignProps,
  emits: ["align"],
  setup: function setup11(props3, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var cacheRef = ref({});
    var nodeRef = ref();
    var _useBuffer = useBuffer(function() {
      var latestDisabled = props3.disabled, latestTarget = props3.target, latestAlign = props3.align, latestOnAlign = props3.onAlign;
      if (!latestDisabled && latestTarget && nodeRef.value) {
        var source2 = nodeRef.value;
        var result;
        var element = getElement(latestTarget);
        var point = getPoint(latestTarget);
        cacheRef.value.element = element;
        cacheRef.value.point = point;
        cacheRef.value.align = latestAlign;
        var _document = document, activeElement = _document.activeElement;
        if (element && isVisible(element)) {
          result = alignElement(source2, element, latestAlign);
        } else if (point) {
          result = alignPoint(source2, point, latestAlign);
        }
        restoreFocus(activeElement, source2);
        if (latestOnAlign && result) {
          latestOnAlign(source2, result);
        }
        return true;
      }
      return false;
    }, computed(function() {
      return props3.monitorBufferTime;
    })), _useBuffer2 = _slicedToArray$2(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
    var resizeMonitor = ref({
      cancel: function cancel() {
      }
    });
    var sourceResizeMonitor = ref({
      cancel: function cancel() {
      }
    });
    var goAlign = function goAlign2() {
      var target = props3.target;
      var element = getElement(target);
      var point = getPoint(target);
      if (nodeRef.value !== sourceResizeMonitor.value.element) {
        sourceResizeMonitor.value.cancel();
        sourceResizeMonitor.value.element = nodeRef.value;
        sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, _forceAlign);
      }
      if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual$1(cacheRef.value.align, props3.align)) {
        _forceAlign();
        if (resizeMonitor.value.element !== element) {
          resizeMonitor.value.cancel();
          resizeMonitor.value.element = element;
          resizeMonitor.value.cancel = monitorResize(element, _forceAlign);
        }
      }
    };
    onMounted(function() {
      nextTick(function() {
        goAlign();
      });
    });
    onUpdated(function() {
      nextTick(function() {
        goAlign();
      });
    });
    watch(function() {
      return props3.disabled;
    }, function(disabled) {
      if (!disabled) {
        _forceAlign();
      } else {
        cancelForceAlign();
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var winResizeRef = ref(null);
    watch(function() {
      return props3.monitorWindowResize;
    }, function(monitorWindowResize) {
      if (monitorWindowResize) {
        if (!winResizeRef.value) {
          winResizeRef.value = addEventListenerWrap(window, "resize", _forceAlign);
        }
      } else if (winResizeRef.value) {
        winResizeRef.value.remove();
        winResizeRef.value = null;
      }
    }, {
      flush: "post"
    });
    onUnmounted(function() {
      resizeMonitor.value.cancel();
      sourceResizeMonitor.value.cancel();
      if (winResizeRef.value)
        winResizeRef.value.remove();
      cancelForceAlign();
    });
    expose({
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    });
    return function() {
      var child = slots === null || slots === void 0 ? void 0 : slots.default();
      if (child) {
        return cloneElement(child[0], {
          ref: nodeRef
        }, true, true);
      }
      return null;
    };
  }
});
const PopupInner = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: false,
  props: innerProps,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup: function setup12(props3, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var alignRef = ref();
    var elementRef = ref();
    var alignedClassName = ref();
    var _useStretchStyle = useStretchStyle(toRef(props3, "stretch")), _useStretchStyle2 = _slicedToArray$2(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
    var doMeasure = function doMeasure2() {
      if (props3.stretch) {
        measureStretchStyle(props3.getRootDomNode());
      }
    };
    var visible = ref(false);
    var timeoutId;
    watch(function() {
      return props3.visible;
    }, function(val) {
      clearTimeout(timeoutId);
      if (val) {
        timeoutId = setTimeout(function() {
          visible.value = props3.visible;
        });
      } else {
        visible.value = false;
      }
    }, {
      immediate: true
    });
    var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray$2(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
    var prepareResolveRef = ref();
    var getAlignTarget = function getAlignTarget2() {
      if (props3.point) {
        return props3.point;
      }
      return props3.getRootDomNode;
    };
    var forceAlign = function forceAlign2() {
      var _alignRef$value;
      (_alignRef$value = alignRef.value) === null || _alignRef$value === void 0 ? void 0 : _alignRef$value.forceAlign();
    };
    var onInternalAlign = function onInternalAlign2(popupDomNode, matchAlign) {
      var nextAlignedClassName = props3.getClassNameFromAlign(matchAlign);
      var preAlignedClassName = alignedClassName.value;
      if (alignedClassName.value !== nextAlignedClassName) {
        alignedClassName.value = nextAlignedClassName;
      }
      if (status.value === "align") {
        var _props$onAlign;
        if (preAlignedClassName !== nextAlignedClassName) {
          Promise.resolve().then(function() {
            forceAlign();
          });
        } else {
          goNextStatus(function() {
            var _prepareResolveRef$va;
            (_prepareResolveRef$va = prepareResolveRef.value) === null || _prepareResolveRef$va === void 0 ? void 0 : _prepareResolveRef$va.call(prepareResolveRef);
          });
        }
        (_props$onAlign = props3.onAlign) === null || _props$onAlign === void 0 ? void 0 : _props$onAlign.call(props3, popupDomNode, matchAlign);
      }
    };
    var motion = computed(function() {
      var m2 = _typeof$3(props3.animation) === "object" ? props3.animation : getMotion(props3);
      ["onAfterEnter", "onAfterLeave"].forEach(function(eventName) {
        var originFn = m2[eventName];
        m2[eventName] = function(node) {
          goNextStatus();
          status.value = "stable";
          originFn === null || originFn === void 0 ? void 0 : originFn(node);
        };
      });
      return m2;
    });
    var onShowPrepare = function onShowPrepare2() {
      return new Promise(function(resolve2) {
        prepareResolveRef.value = resolve2;
      });
    };
    watch([motion, status], function() {
      if (!motion.value && status.value === "motion") {
        goNextStatus();
      }
    }, {
      immediate: true
    });
    expose({
      forceAlign,
      getElement: function getElement2() {
        return elementRef.value.$el || elementRef.value;
      }
    });
    var alignDisabled = computed(function() {
      var _props$align;
      if ((_props$align = props3.align) !== null && _props$align !== void 0 && _props$align.points && (status.value === "align" || status.value === "stable")) {
        return false;
      }
      return true;
    });
    return function() {
      var _slots$default;
      var zIndex = props3.zIndex, align = props3.align, prefixCls = props3.prefixCls, destroyPopupOnHide = props3.destroyPopupOnHide, onMouseenter2 = props3.onMouseenter, onMouseleave2 = props3.onMouseleave, _props$onTouchstart = props3.onTouchstart, onTouchstart2 = _props$onTouchstart === void 0 ? function() {
      } : _props$onTouchstart, onMousedown2 = props3.onMousedown;
      var statusValue = status.value;
      var mergedStyle = [_objectSpread2$1(_objectSpread2$1({}, stretchStyle.value), {}, {
        zIndex,
        opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
        pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
      }), attrs.style];
      var childNode = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, {
        visible: props3.visible
      }));
      if (childNode.length > 1) {
        childNode = createVNode("div", {
          "class": "".concat(prefixCls, "-content")
        }, [childNode]);
      }
      var mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value);
      var hasAnimate = visible.value || !props3.visible;
      var transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
      return createVNode(Transition$1, _objectSpread2$1(_objectSpread2$1({
        "ref": elementRef
      }, transitionProps), {}, {
        "onBeforeEnter": onShowPrepare
      }), {
        default: function _default9() {
          return !destroyPopupOnHide || props3.visible ? withDirectives(createVNode(Align, {
            "target": getAlignTarget(),
            "key": "popup",
            "ref": alignRef,
            "monitorWindowResize": true,
            "disabled": alignDisabled.value,
            "align": align,
            "onAlign": onInternalAlign
          }, {
            default: function _default10() {
              return createVNode("div", _objectSpread2$1(_objectSpread2$1({
                "class": mergedClassName,
                "onMouseenter": onMouseenter2,
                "onMouseleave": onMouseleave2,
                "onMousedown": withModifiers(onMousedown2, ["capture"])
              }, _defineProperty$U({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", withModifiers(onTouchstart2, ["capture"]))), {}, {
                "style": mergedStyle
              }), [childNode]);
            }
          }), [[vShow, visible.value]]) : null;
        }
      });
    };
  }
});
const Popup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: false,
  props: popupProps,
  setup: function setup13(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var innerVisible = ref(false);
    var inMobile = ref(false);
    var popupRef = ref();
    watch([function() {
      return props3.visible;
    }, function() {
      return props3.mobile;
    }], function() {
      innerVisible.value = props3.visible;
      if (props3.visible && props3.mobile) {
        inMobile.value = true;
      }
    }, {
      immediate: true,
      flush: "post"
    });
    expose({
      forceAlign: function forceAlign() {
        var _popupRef$value;
        (_popupRef$value = popupRef.value) === null || _popupRef$value === void 0 ? void 0 : _popupRef$value.forceAlign();
      },
      getElement: function getElement2() {
        var _popupRef$value2;
        return (_popupRef$value2 = popupRef.value) === null || _popupRef$value2 === void 0 ? void 0 : _popupRef$value2.getElement();
      }
    });
    return function() {
      var cloneProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        visible: innerVisible.value
      });
      var popupNode = inMobile.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "mobile": props3.mobile,
        "ref": popupRef
      }), {
        default: slots.default
      }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
        "ref": popupRef
      }), {
        default: slots.default
      });
      return createVNode("div", null, [createVNode(Mask$1, cloneProps, null), popupNode]);
    };
  }
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i2 = 0; i2 < placements2.length; i2 += 1) {
    var placement = placements2[i2];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
const BaseMixin = {
  methods: {
    setState: function setState() {
      var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      var newState = typeof state === "function" ? state(this.$data, this.$props) : state;
      if (this.getDerivedStateFromProps) {
        var s2 = this.getDerivedStateFromProps(getOptionProps(this), _objectSpread2$1(_objectSpread2$1({}, this.$data), newState));
        if (s2 === null) {
          return;
        } else {
          newState = _objectSpread2$1(_objectSpread2$1({}, newState), s2 || {});
        }
      }
      _extends$1(this.$data, newState);
      if (this._.isMounted) {
        this.$forceUpdate();
      }
      nextTick(function() {
        callback && callback();
      });
    },
    __emit: function __emit() {
      var args2 = [].slice.call(arguments, 0);
      var eventName = args2[0];
      eventName = "on".concat(eventName[0].toUpperCase()).concat(eventName.substring(1));
      var event2 = this.$props[eventName] || this.$attrs[eventName];
      if (args2.length && event2) {
        if (Array.isArray(event2)) {
          for (var i2 = 0, l2 = event2.length; i2 < l2; i2++) {
            event2[i2].apply(event2, _toConsumableArray(args2.slice(1)));
          }
        } else {
          event2.apply(void 0, _toConsumableArray(args2.slice(1)));
        }
      }
    }
  }
};
var TriggerContextKey = Symbol("TriggerContextKey");
var useProviderTrigger = function useProviderTrigger2() {
  var portal = null;
  provide(TriggerContextKey, {
    setPortal: function setPortal(val) {
      portal = val;
    },
    popPortal: true
  });
  return function() {
    return portal;
  };
};
var useInjectTrigger = function useInjectTrigger2(tryPopPortal) {
  return tryPopPortal ? inject(TriggerContextKey, {
    setPortal: function setPortal() {
    },
    popPortal: false
  }) : {
    setPortal: function setPortal() {
    },
    popPortal: false
  };
};
var PortalContextKey = Symbol("PortalContextKey");
var useProvidePortal = function useProvidePortal2(instance) {
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: true
  };
  provide(PortalContextKey, {
    inTriggerContext: config.inTriggerContext,
    shouldRender: computed(function() {
      var _ref = instance || {}, sPopupVisible = _ref.sPopupVisible, popupRef = _ref.popupRef, forceRender = _ref.forceRender, autoDestroy = _ref.autoDestroy;
      var shouldRender = false;
      if (sPopupVisible || popupRef || forceRender) {
        shouldRender = true;
      }
      if (!sPopupVisible && autoDestroy) {
        shouldRender = false;
      }
      return shouldRender;
    })
  });
};
var useInjectPortal = function useInjectPortal2() {
  useProvidePortal({}, {
    inTriggerContext: false
  });
  var portalContext = inject(PortalContextKey, {
    shouldRender: computed(function() {
      return false;
    }),
    inTriggerContext: false
  });
  return {
    shouldRender: computed(function() {
      return portalContext.shouldRender.value || portalContext.inTriggerContext === false;
    })
  };
};
const Portal$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: false,
  props: {
    getContainer: PropTypes$1.func.isRequired,
    didUpdate: Function
  },
  setup: function setup14(props3, _ref) {
    var slots = _ref.slots;
    var isSSR = true;
    var container;
    var _useInjectPortal = useInjectPortal(), shouldRender = _useInjectPortal.shouldRender;
    onBeforeMount(function() {
      isSSR = false;
      if (shouldRender.value) {
        container = props3.getContainer();
      }
    });
    var stopWatch = watch(shouldRender, function() {
      if (shouldRender.value && !container) {
        container = props3.getContainer();
      }
      if (container) {
        stopWatch();
      }
    });
    onUpdated(function() {
      nextTick(function() {
        if (shouldRender.value) {
          var _props$didUpdate;
          (_props$didUpdate = props3.didUpdate) === null || _props$didUpdate === void 0 ? void 0 : _props$didUpdate.call(props3, props3);
        }
      });
    });
    onBeforeUnmount(function() {
      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }
    });
    return function() {
      if (!shouldRender.value)
        return null;
      if (isSSR) {
        var _slots$default;
        return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }
      return container ? createVNode(Teleport, {
        "to": container
      }, slots) : null;
    };
  }
});
function noop$b() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
const Trigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    action: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def([]),
    showAction: PropTypes$1.any.def([]),
    hideAction: PropTypes$1.any.def([]),
    getPopupClassNameFromAlign: PropTypes$1.any.def(returnEmptyString),
    onPopupVisibleChange: Function,
    afterPopupVisibleChange: PropTypes$1.func.def(noop$b),
    popup: PropTypes$1.any,
    popupStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-trigger-popup"),
    popupClassName: PropTypes$1.string.def(""),
    popupPlacement: String,
    builtinPlacements: PropTypes$1.object,
    popupTransitionName: String,
    popupAnimation: PropTypes$1.any,
    mouseEnterDelay: PropTypes$1.number.def(0),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    zIndex: Number,
    focusDelay: PropTypes$1.number.def(0),
    blurDelay: PropTypes$1.number.def(0.15),
    getPopupContainer: Function,
    getDocument: PropTypes$1.func.def(returnDocument),
    forceRender: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: false
    },
    mask: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    popupAlign: PropTypes$1.object.def(function() {
      return {};
    }),
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    maskTransitionName: String,
    maskAnimation: String,
    stretch: String,
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    autoDestroy: {
      type: Boolean,
      default: false
    },
    mobile: Object,
    getTriggerDOMNode: Function,
    tryPopPortal: Boolean
  },
  setup: function setup15(props3) {
    var align = computed(function() {
      var popupPlacement = props3.popupPlacement, popupAlign = props3.popupAlign, builtinPlacements = props3.builtinPlacements;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    });
    var _useInjectTrigger = useInjectTrigger(props3.tryPopPortal), setPortal = _useInjectTrigger.setPortal, popPortal = _useInjectTrigger.popPortal;
    var popupRef = ref(null);
    var setPopupRef = function setPopupRef2(val) {
      popupRef.value = val;
    };
    return {
      popPortal,
      setPortal,
      vcTriggerContext: inject("vcTriggerContext", {}),
      popupRef,
      setPopupRef,
      triggerRef: ref(null),
      align,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: false,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data: function data() {
    var _this = this, _this$setPortal;
    var props3 = this.$props;
    var popupVisible2;
    if (this.popupVisible !== void 0) {
      popupVisible2 = !!props3.popupVisible;
    } else {
      popupVisible2 = !!props3.defaultPopupVisible;
    }
    ALL_HANDLERS.forEach(function(h2) {
      _this["fire".concat(h2)] = function(e2) {
        _this.fireEvents(h2, e2);
      };
    });
    (_this$setPortal = this.setPortal) === null || _this$setPortal === void 0 ? void 0 : _this$setPortal.call(this, createVNode(Portal$1, {
      "key": "portal",
      "getContainer": this.getContainer,
      "didUpdate": this.handlePortalUpdate
    }, {
      default: this.getComponent
    }));
    return {
      prevPopupVisible: popupVisible2,
      sPopupVisible: popupVisible2,
      point: null
    };
  },
  watch: {
    popupVisible: function popupVisible(val) {
      if (val !== void 0) {
        this.prevPopupVisible = this.sPopupVisible;
        this.sPopupVisible = val;
      }
    }
  },
  created: function created() {
    provide("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown
    });
    useProvidePortal(this);
  },
  deactivated: function deactivated() {
    this.setPopupVisible(false);
  },
  mounted: function mounted() {
    var _this2 = this;
    this.$nextTick(function() {
      _this2.updatedCal();
    });
  },
  updated: function updated() {
    var _this3 = this;
    this.$nextTick(function() {
      _this3.updatedCal();
    });
  },
  beforeUnmount: function beforeUnmount() {
    this.clearDelayTimer();
    this.clearOutsideHandler();
    clearTimeout(this.mouseDownTimeout);
    wrapperRaf.cancel(this.attachId);
  },
  methods: {
    updatedCal: function updatedCal() {
      var props3 = this.$props;
      var state = this.$data;
      if (state.sPopupVisible) {
        var currentDocument;
        if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
          currentDocument = props3.getDocument(this.getRootDomNode());
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
        }
        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || props3.getDocument(this.getRootDomNode());
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
            passive: false
          } : false);
        }
        if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
          currentDocument = currentDocument || props3.getDocument(this.getRootDomNode());
          this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
        }
        if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
          this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
        }
      } else {
        this.clearOutsideHandler();
      }
    },
    onMouseenter: function onMouseenter(e2) {
      var mouseEnterDelay = this.$props.mouseEnterDelay;
      this.fireEvents("onMouseenter", e2);
      this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
    },
    onMouseMove: function onMouseMove(e2) {
      this.fireEvents("onMousemove", e2);
      this.setPoint(e2);
    },
    onMouseleave: function onMouseleave(e2) {
      this.fireEvents("onMouseleave", e2);
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter: function onPopupMouseenter() {
      this.clearDelayTimer();
    },
    onPopupMouseleave: function onPopupMouseleave(e2) {
      var _this$popupRef;
      if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_this$popupRef = this.popupRef) === null || _this$popupRef === void 0 ? void 0 : _this$popupRef.getElement(), e2.relatedTarget)) {
        return;
      }
      this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
    },
    onFocus: function onFocus(e2) {
      this.fireEvents("onFocus", e2);
      this.clearDelayTimer();
      if (this.isFocusToShow()) {
        this.focusTime = Date.now();
        this.delaySetPopupVisible(true, this.$props.focusDelay);
      }
    },
    onMousedown: function onMousedown(e2) {
      this.fireEvents("onMousedown", e2);
      this.preClickTime = Date.now();
    },
    onTouchstart: function onTouchstart(e2) {
      this.fireEvents("onTouchstart", e2);
      this.preTouchTime = Date.now();
    },
    onBlur: function onBlur(e2) {
      if (!contains(e2.target, e2.relatedTarget || document.activeElement)) {
        this.fireEvents("onBlur", e2);
        this.clearDelayTimer();
        if (this.isBlurToHide()) {
          this.delaySetPopupVisible(false, this.$props.blurDelay);
        }
      }
    },
    onContextmenu: function onContextmenu(e2) {
      e2.preventDefault();
      this.fireEvents("onContextmenu", e2);
      this.setPopupVisible(true, e2);
    },
    onContextmenuClose: function onContextmenuClose() {
      if (this.isContextmenuToShow()) {
        this.close();
      }
    },
    onClick: function onClick(event2) {
      this.fireEvents("onClick", event2);
      if (this.focusTime) {
        var preTime;
        if (this.preClickTime && this.preTouchTime) {
          preTime = Math.min(this.preClickTime, this.preTouchTime);
        } else if (this.preClickTime) {
          preTime = this.preClickTime;
        } else if (this.preTouchTime) {
          preTime = this.preTouchTime;
        }
        if (Math.abs(preTime - this.focusTime) < 20) {
          return;
        }
        this.focusTime = 0;
      }
      this.preClickTime = 0;
      this.preTouchTime = 0;
      if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event2 && event2.preventDefault) {
        event2.preventDefault();
      }
      if (event2 && event2.domEvent) {
        event2.domEvent.preventDefault();
      }
      var nextVisible = !this.$data.sPopupVisible;
      if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
        this.setPopupVisible(!this.$data.sPopupVisible, event2);
      }
    },
    onPopupMouseDown: function onPopupMouseDown() {
      var _this4 = this;
      var _this$vcTriggerContex = this.vcTriggerContext, vcTriggerContext = _this$vcTriggerContex === void 0 ? {} : _this$vcTriggerContex;
      this.hasPopupMouseDown = true;
      clearTimeout(this.mouseDownTimeout);
      this.mouseDownTimeout = setTimeout(function() {
        _this4.hasPopupMouseDown = false;
      }, 0);
      if (vcTriggerContext.onPopupMouseDown) {
        vcTriggerContext.onPopupMouseDown.apply(vcTriggerContext, arguments);
      }
    },
    onDocumentClick: function onDocumentClick(event2) {
      if (this.$props.mask && !this.$props.maskClosable) {
        return;
      }
      var target = event2.target;
      var root2 = this.getRootDomNode();
      var popupNode = this.getPopupDomNode();
      if ((!contains(root2, target) || this.isContextMenuOnly()) && !contains(popupNode, target) && !this.hasPopupMouseDown) {
        this.delaySetPopupVisible(false, 0.1);
      }
    },
    getPopupDomNode: function getPopupDomNode() {
      var _this$popupRef2;
      return ((_this$popupRef2 = this.popupRef) === null || _this$popupRef2 === void 0 ? void 0 : _this$popupRef2.getElement()) || null;
    },
    getRootDomNode: function getRootDomNode() {
      var getTriggerDOMNode = this.$props.getTriggerDOMNode;
      if (getTriggerDOMNode) {
        var domNode = findDOMNode(this.triggerRef);
        return findDOMNode(getTriggerDOMNode(domNode));
      }
      try {
        var _domNode = findDOMNode(this.triggerRef);
        if (_domNode) {
          return _domNode;
        }
      } catch (err) {
      }
      return findDOMNode(this);
    },
    handleGetPopupClassFromAlign: function handleGetPopupClassFromAlign(align) {
      var className = [];
      var props3 = this.$props;
      var popupPlacement = props3.popupPlacement, builtinPlacements = props3.builtinPlacements, prefixCls = props3.prefixCls, alignPoint2 = props3.alignPoint, getPopupClassNameFromAlign = props3.getPopupClassNameFromAlign;
      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
      }
      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }
      return className.join(" ");
    },
    getPopupAlign: function getPopupAlign() {
      var props3 = this.$props;
      var popupPlacement = props3.popupPlacement, popupAlign = props3.popupAlign, builtinPlacements = props3.builtinPlacements;
      if (popupPlacement && builtinPlacements) {
        return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }
      return popupAlign;
    },
    getComponent: function getComponent$1() {
      var _this5 = this;
      var mouseProps = {};
      if (this.isMouseEnterToShow()) {
        mouseProps.onMouseenter = this.onPopupMouseenter;
      }
      if (this.isMouseLeaveToHide()) {
        mouseProps.onMouseleave = this.onPopupMouseleave;
      }
      mouseProps.onMousedown = this.onPopupMouseDown;
      mouseProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      var handleGetPopupClassFromAlign2 = this.handleGetPopupClassFromAlign, getRootDomNode2 = this.getRootDomNode, getContainer4 = this.getContainer, $attrs = this.$attrs;
      var _this$$props = this.$props, prefixCls = _this$$props.prefixCls, destroyPopupOnHide = _this$$props.destroyPopupOnHide, popupClassName = _this$$props.popupClassName, popupAnimation = _this$$props.popupAnimation, popupTransitionName = _this$$props.popupTransitionName, popupStyle = _this$$props.popupStyle, mask = _this$$props.mask, maskAnimation = _this$$props.maskAnimation, maskTransitionName = _this$$props.maskTransitionName, zIndex = _this$$props.zIndex, stretch = _this$$props.stretch, alignPoint2 = _this$$props.alignPoint, mobile = _this$$props.mobile, forceRender = _this$$props.forceRender;
      var _this$$data = this.$data, sPopupVisible = _this$$data.sPopupVisible, point = _this$$data.point;
      var popupProps2 = _objectSpread2$1(_objectSpread2$1({
        prefixCls,
        destroyPopupOnHide,
        visible: sPopupVisible,
        point: alignPoint2 ? point : null,
        align: this.align,
        animation: popupAnimation,
        getClassNameFromAlign: handleGetPopupClassFromAlign2,
        stretch,
        getRootDomNode: getRootDomNode2,
        mask,
        zIndex,
        transitionName: popupTransitionName,
        maskAnimation,
        maskTransitionName,
        getContainer: getContainer4,
        class: popupClassName,
        style: popupStyle,
        onAlign: $attrs.onPopupAlign || noop$b
      }, mouseProps), {}, {
        ref: this.setPopupRef,
        mobile,
        forceRender
      });
      return createVNode(Popup, popupProps2, {
        default: this.$slots.popup || function() {
          return getComponent(_this5, "popup");
        }
      });
    },
    attachParent: function attachParent(popupContainer) {
      var _this6 = this;
      wrapperRaf.cancel(this.attachId);
      var _this$$props2 = this.$props, getPopupContainer = _this$$props2.getPopupContainer, getDocument2 = _this$$props2.getDocument;
      var domNode = this.getRootDomNode();
      var mountNode;
      if (!getPopupContainer) {
        mountNode = getDocument2(this.getRootDomNode()).body;
      } else if (domNode || getPopupContainer.length === 0) {
        mountNode = getPopupContainer(domNode);
      }
      if (mountNode) {
        mountNode.appendChild(popupContainer);
      } else {
        this.attachId = wrapperRaf(function() {
          _this6.attachParent(popupContainer);
        });
      }
    },
    getContainer: function getContainer3() {
      var props3 = this.$props;
      var getDocument2 = props3.getDocument;
      var popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
      popupContainer.style.position = "absolute";
      popupContainer.style.top = "0";
      popupContainer.style.left = "0";
      popupContainer.style.width = "100%";
      this.attachParent(popupContainer);
      return popupContainer;
    },
    setPopupVisible: function setPopupVisible(sPopupVisible, event2) {
      var alignPoint2 = this.alignPoint, prevPopupVisible = this.sPopupVisible, onPopupVisibleChange = this.onPopupVisibleChange;
      this.clearDelayTimer();
      if (prevPopupVisible !== sPopupVisible) {
        if (!hasProp(this, "popupVisible")) {
          this.setState({
            sPopupVisible,
            prevPopupVisible
          });
        }
        onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
      }
      if (alignPoint2 && event2 && sPopupVisible) {
        this.setPoint(event2);
      }
    },
    setPoint: function setPoint(point) {
      var alignPoint2 = this.$props.alignPoint;
      if (!alignPoint2 || !point)
        return;
      this.setState({
        point: {
          pageX: point.pageX,
          pageY: point.pageY
        }
      });
    },
    handlePortalUpdate: function handlePortalUpdate() {
      if (this.prevPopupVisible !== this.sPopupVisible) {
        this.afterPopupVisibleChange(this.sPopupVisible);
      }
    },
    delaySetPopupVisible: function delaySetPopupVisible(visible, delayS, event2) {
      var _this7 = this;
      var delay = delayS * 1e3;
      this.clearDelayTimer();
      if (delay) {
        var point = event2 ? {
          pageX: event2.pageX,
          pageY: event2.pageY
        } : null;
        this.delayTimer = requestAnimationTimeout(function() {
          _this7.setPopupVisible(visible, point);
          _this7.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible, event2);
      }
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        cancelAnimationTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    },
    clearOutsideHandler: function clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }
      if (this.contextmenuOutsideHandler1) {
        this.contextmenuOutsideHandler1.remove();
        this.contextmenuOutsideHandler1 = null;
      }
      if (this.contextmenuOutsideHandler2) {
        this.contextmenuOutsideHandler2.remove();
        this.contextmenuOutsideHandler2 = null;
      }
      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    },
    createTwoChains: function createTwoChains(event2) {
      var fn = function fn2() {
      };
      var events2 = getEvents(this);
      if (this.childOriginEvents[event2] && events2[event2]) {
        return this["fire".concat(event2)];
      }
      fn = this.childOriginEvents[event2] || events2[event2] || fn;
      return fn;
    },
    isClickToShow: function isClickToShow() {
      var _this$$props3 = this.$props, action = _this$$props3.action, showAction = _this$$props3.showAction;
      return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
    },
    isContextMenuOnly: function isContextMenuOnly() {
      var action = this.$props.action;
      return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
    },
    isContextmenuToShow: function isContextmenuToShow() {
      var _this$$props4 = this.$props, action = _this$$props4.action, showAction = _this$$props4.showAction;
      return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
    },
    isClickToHide: function isClickToHide() {
      var _this$$props5 = this.$props, action = _this$$props5.action, hideAction = _this$$props5.hideAction;
      return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
    },
    isMouseEnterToShow: function isMouseEnterToShow() {
      var _this$$props6 = this.$props, action = _this$$props6.action, showAction = _this$$props6.showAction;
      return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide: function isMouseLeaveToHide() {
      var _this$$props7 = this.$props, action = _this$$props7.action, hideAction = _this$$props7.hideAction;
      return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
    },
    isFocusToShow: function isFocusToShow() {
      var _this$$props8 = this.$props, action = _this$$props8.action, showAction = _this$$props8.showAction;
      return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
    },
    isBlurToHide: function isBlurToHide() {
      var _this$$props9 = this.$props, action = _this$$props9.action, hideAction = _this$$props9.hideAction;
      return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
    },
    forcePopupAlign: function forcePopupAlign() {
      if (this.$data.sPopupVisible) {
        var _this$popupRef3;
        (_this$popupRef3 = this.popupRef) === null || _this$popupRef3 === void 0 ? void 0 : _this$popupRef3.forceAlign();
      }
    },
    fireEvents: function fireEvents(type4, e2) {
      if (this.childOriginEvents[type4]) {
        this.childOriginEvents[type4](e2);
      }
      var event2 = this.$props[type4] || this.$attrs[type4];
      if (event2) {
        event2(e2);
      }
    },
    close: function close2() {
      this.setPopupVisible(false);
    }
  },
  render: function render() {
    var _this8 = this;
    var $attrs = this.$attrs;
    var children = filterEmpty(getSlot(this));
    var alignPoint2 = this.$props.alignPoint;
    var child = children[0];
    this.childOriginEvents = getEvents(child);
    var newChildProps = {
      key: "trigger"
    };
    if (this.isContextmenuToShow()) {
      newChildProps.onContextmenu = this.onContextmenu;
    } else {
      newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
    }
    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMousedown = this.onMousedown;
      newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
    } else {
      newChildProps.onClick = this.createTwoChains("onClick");
      newChildProps.onMousedown = this.createTwoChains("onMousedown");
      newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseenter = this.onMouseenter;
      if (alignPoint2) {
        newChildProps.onMousemove = this.onMouseMove;
      }
    } else {
      newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseleave = this.onMouseleave;
    } else {
      newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains("onFocus");
      newChildProps.onBlur = function(e2) {
        if (e2 && (!e2.relatedTarget || !contains(e2.target, e2.relatedTarget))) {
          _this8.createTwoChains("onBlur")(e2);
        }
      };
    }
    var childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
    if (childrenClassName) {
      newChildProps.class = childrenClassName;
    }
    var trigger2 = cloneElement(child, _objectSpread2$1(_objectSpread2$1({}, newChildProps), {}, {
      ref: "triggerRef"
    }), true, true);
    if (this.popPortal) {
      return trigger2;
    } else {
      var portal = createVNode(Portal$1, {
        "key": "portal",
        "getContainer": this.getContainer,
        "didUpdate": this.handlePortalUpdate
      }, {
        default: this.getComponent
      });
      return createVNode(Fragment, null, [portal, trigger2]);
    }
  }
});
var _excluded$_ = ["empty"];
var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    }
  };
};
var SelectTrigger = defineComponent({
  name: "SelectTrigger",
  inheritAttrs: false,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: PropTypes$1.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: PropTypes$1.oneOfType([Number, Boolean]).def(true),
    popupElement: PropTypes$1.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function
  },
  setup: function setup16(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var builtInPlacements = computed(function() {
      var dropdownMatchSelectWidth = props3.dropdownMatchSelectWidth;
      return getBuiltInPlacements(dropdownMatchSelectWidth);
    });
    var popupRef = ref();
    expose({
      getPopupElement: function getPopupElement() {
        return popupRef.value;
      }
    });
    return function() {
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), _props$attrs$empty = _props$attrs.empty, empty2 = _props$attrs$empty === void 0 ? false : _props$attrs$empty, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$_);
      var visible = restProps.visible, dropdownAlign = restProps.dropdownAlign, prefixCls = restProps.prefixCls, popupElement = restProps.popupElement, dropdownClassName = restProps.dropdownClassName, dropdownStyle = restProps.dropdownStyle, _restProps$direction = restProps.direction, direction = _restProps$direction === void 0 ? "ltr" : _restProps$direction, placement = restProps.placement, dropdownMatchSelectWidth = restProps.dropdownMatchSelectWidth, containerWidth = restProps.containerWidth, dropdownRender = restProps.dropdownRender, animation = restProps.animation, transitionName2 = restProps.transitionName, getPopupContainer = restProps.getPopupContainer, getTriggerDOMNode = restProps.getTriggerDOMNode, onPopupVisibleChange = restProps.onPopupVisibleChange, onPopupMouseEnter = restProps.onPopupMouseEnter;
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender({
          menuNode: popupElement,
          props: props3
        });
      }
      var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName2;
      var popupStyle = _objectSpread2$1({
        minWidth: "".concat(containerWidth, "px")
      }, dropdownStyle);
      if (typeof dropdownMatchSelectWidth === "number") {
        popupStyle.width = "".concat(dropdownMatchSelectWidth, "px");
      } else if (dropdownMatchSelectWidth) {
        popupStyle.width = "".concat(containerWidth, "px");
      }
      return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        "showAction": onPopupVisibleChange ? ["click"] : [],
        "hideAction": onPopupVisibleChange ? ["click"] : [],
        "popupPlacement": placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        "builtinPlacements": builtInPlacements.value,
        "prefixCls": dropdownPrefixCls,
        "popupTransitionName": mergedTransitionName,
        "popupAlign": dropdownAlign,
        "popupVisible": visible,
        "getPopupContainer": getPopupContainer,
        "popupClassName": classNames(dropdownClassName, _defineProperty$U({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
        "popupStyle": popupStyle,
        "getTriggerDOMNode": getTriggerDOMNode,
        "onPopupVisibleChange": onPopupVisibleChange
      }), {
        default: slots.default,
        popup: function popup() {
          return createVNode("div", {
            "ref": popupRef,
            "onMouseenter": onPopupMouseEnter
          }, [popupNode]);
        }
      });
    };
  }
});
const SelectTrigger$1 = SelectTrigger;
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
const KeyCode$1 = KeyCode;
var TransBtn = function TransBtn2(props3, _ref) {
  var _slots$default;
  var slots = _ref.slots;
  var className = props3.class, customizeIcon = props3.customizeIcon, customizeIconProps = props3.customizeIconProps, _onMousedown = props3.onMousedown, onClick2 = props3.onClick;
  var icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return createVNode("span", {
    "class": className,
    "onMousedown": function onMousedown2(event2) {
      event2.preventDefault();
      if (_onMousedown) {
        _onMousedown(event2);
      }
    },
    "style": {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    "unselectable": "on",
    "onClick": onClick2,
    "aria-hidden": true
  }, [icon !== void 0 ? icon : createVNode("span", {
    "class": className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    })
  }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
};
TransBtn.inheritAttrs = false;
TransBtn.displayName = "TransBtn";
TransBtn.props = {
  class: String,
  customizeIcon: PropTypes$1.any,
  customizeIconProps: PropTypes$1.any,
  onMousedown: Function,
  onClick: Function
};
const TransBtn$1 = TransBtn;
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  if (!e2.target.composing)
    return;
  e2.target.composing = false;
  trigger(e2.target, "input");
}
function trigger(el, type4) {
  var e2 = document.createEvent("HTMLEvents");
  e2.initEvent(type4, true, true);
  el.dispatchEvent(e2);
}
function addEventListener$2(el, event2, handler5, options) {
  el.addEventListener(event2, handler5, options);
}
var antInput = {
  created: function created2(el, binding) {
    if (!binding.modifiers || !binding.modifiers.lazy) {
      addEventListener$2(el, "compositionstart", onCompositionStart);
      addEventListener$2(el, "compositionend", onCompositionEnd);
      addEventListener$2(el, "change", onCompositionEnd);
    }
  }
};
const antInputDirective = antInput;
var inputProps$2 = {
  inputRef: PropTypes$1.any,
  prefixCls: String,
  id: String,
  inputElement: PropTypes$1.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  attrs: PropTypes$1.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
};
var Input$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Input",
  inheritAttrs: false,
  props: inputProps$2,
  setup: function setup17(props3) {
    var blurTimeout = null;
    var VCSelectContainerEvent = inject("VCSelectContainerEvent");
    return function() {
      var _inputNode, _inputNode$props;
      var prefixCls = props3.prefixCls, id = props3.id, inputElement = props3.inputElement, disabled = props3.disabled, tabindex = props3.tabindex, autofocus = props3.autofocus, autocomplete = props3.autocomplete, editable = props3.editable, activeDescendantId = props3.activeDescendantId, value = props3.value, _onKeydown = props3.onKeydown, _onMousedown = props3.onMousedown, onChange3 = props3.onChange, onPaste = props3.onPaste, _onCompositionstart = props3.onCompositionstart, _onCompositionend = props3.onCompositionend, _onFocus = props3.onFocus, _onBlur = props3.onBlur, open2 = props3.open, inputRef = props3.inputRef, attrs = props3.attrs;
      var inputNode = inputElement || withDirectives(createVNode("input", null, null), [[antInputDirective]]);
      var inputProps3 = inputNode.props || {};
      var onOriginKeyDown = inputProps3.onKeydown, onOriginInput = inputProps3.onInput, onOriginFocus = inputProps3.onFocus, onOriginBlur = inputProps3.onBlur, onOriginMouseDown = inputProps3.onMousedown, onOriginCompositionStart = inputProps3.onCompositionstart, onOriginCompositionEnd = inputProps3.onCompositionend, style2 = inputProps3.style;
      inputNode = cloneElement(inputNode, _extends$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        type: "search"
      }, inputProps3), {}, {
        id,
        ref: inputRef,
        disabled,
        tabindex,
        autocomplete: autocomplete || "off",
        autofocus,
        class: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode = inputNode) === null || _inputNode === void 0 ? void 0 : (_inputNode$props = _inputNode.props) === null || _inputNode$props === void 0 ? void 0 : _inputNode$props.class),
        role: "combobox",
        "aria-expanded": open2,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(id, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(id, "_list"),
        "aria-activedescendant": activeDescendantId
      }, attrs), {}, {
        value: editable ? value : "",
        readonly: !editable,
        unselectable: !editable ? "on" : null,
        style: _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
          opacity: editable ? null : 0
        }),
        onKeydown: function onKeydown(event2) {
          _onKeydown(event2);
          if (onOriginKeyDown) {
            onOriginKeyDown(event2);
          }
        },
        onMousedown: function onMousedown2(event2) {
          _onMousedown(event2);
          if (onOriginMouseDown) {
            onOriginMouseDown(event2);
          }
        },
        onInput: function onInput(event2) {
          onChange3(event2);
          if (onOriginInput) {
            onOriginInput(event2);
          }
        },
        onCompositionstart: function onCompositionstart(event2) {
          _onCompositionstart(event2);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event2);
          }
        },
        onCompositionend: function onCompositionend(event2) {
          _onCompositionend(event2);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event2);
          }
        },
        onPaste,
        onFocus: function onFocus2() {
          clearTimeout(blurTimeout);
          onOriginFocus && onOriginFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          _onFocus && _onFocus(arguments.length <= 0 ? void 0 : arguments[0]);
          VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function onBlur2() {
          for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
            args2[_key] = arguments[_key];
          }
          blurTimeout = setTimeout(function() {
            onOriginBlur && onOriginBlur(args2[0]);
            _onBlur && _onBlur(args2[0]);
            VCSelectContainerEvent === null || VCSelectContainerEvent === void 0 ? void 0 : VCSelectContainerEvent.blur(args2[0]);
          }, 100);
        }
      }), inputNode.type === "textarea" ? {} : {
        type: "search"
      }), true, true);
      return inputNode;
    };
  }
});
const Input$3 = Input$2;
var attributes = "accept acceptcharset accesskey action allowfullscreen allowtransparency\nalt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge\ncharset checked classid classname colspan cols content contenteditable contextmenu\ncontrols coords crossorigin data datetime default defer dir disabled download draggable\nenctype form formaction formenctype formmethod formnovalidate formtarget frameborder\nheaders height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity\nis keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media\nmediagroup method min minlength multiple muted name novalidate nonce open\noptimum pattern placeholder poster preload radiogroup readonly rel required\nreversed role rowspan rows sandbox scope scoped scrolling seamless selected\nshape size sizes span spellcheck src srcdoc srclang srcset start step style\nsummary tabindex target title type usemap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown\n    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick\n    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown\n    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel\n    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough\n    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata\n    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match$1(key2, prefix) {
  return key2.indexOf(prefix) === 0;
}
function pickAttrs(props3) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$1({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props3).forEach(function(key2) {
    if (mergedConfig.aria && (key2 === "role" || match$1(key2, ariaPrefix)) || mergedConfig.data && match$1(key2, dataPrefix) || mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))) {
      attrs[key2] = props3[key2];
    }
  });
  return attrs;
}
var OverflowContextProviderKey = Symbol("OverflowContextProviderKey");
var OverflowContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object
    }
  },
  setup: function setup18(props3, _ref) {
    var slots = _ref.slots;
    provide(OverflowContextProviderKey, computed(function() {
      return props3.value;
    }));
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var useInjectOverflowContext = function useInjectOverflowContext2() {
  return inject(OverflowContextProviderKey, computed(function() {
    return null;
  }));
};
var _excluded$Z = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"];
var UNDEFINED = void 0;
const Item$3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: PropTypes$1.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: PropTypes$1.any,
    invalidate: Boolean
  },
  setup: function setup19(props3, _ref) {
    var slots = _ref.slots, expose = _ref.expose;
    var mergedHidden = computed(function() {
      return props3.responsive && !props3.display;
    });
    var itemNodeRef = ref();
    expose({
      itemNodeRef
    });
    function internalRegisterSize(width) {
      props3.registerSize(props3.itemKey, width);
    }
    onUnmounted(function() {
      internalRegisterSize(null);
    });
    return function() {
      var _slots$default;
      var prefixCls = props3.prefixCls, invalidate = props3.invalidate, item = props3.item, renderItem = props3.renderItem, responsive = props3.responsive;
      props3.registerSize;
      props3.itemKey;
      props3.display;
      var order = props3.order, _props$component = props3.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$2(props3, _excluded$Z);
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
      var overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden.value ? 0 : 1,
          height: mergedHidden.value ? 0 : UNDEFINED,
          overflowY: mergedHidden.value ? "hidden" : UNDEFINED,
          order: responsive ? order : UNDEFINED,
          pointerEvents: mergedHidden.value ? "none" : UNDEFINED,
          position: mergedHidden.value ? "absolute" : UNDEFINED
        };
      }
      var overflowProps3 = {};
      if (mergedHidden.value) {
        overflowProps3["aria-hidden"] = true;
      }
      return createVNode(ResizeObserver$1, {
        "disabled": !responsive,
        "onResize": function onResize(_ref2) {
          var offsetWidth = _ref2.offsetWidth;
          internalRegisterSize(offsetWidth);
        }
      }, {
        default: function _default9() {
          return createVNode(Component, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(!invalidate && prefixCls),
            "style": overflowStyle
          }, overflowProps3), restProps), {}, {
            "ref": itemNodeRef
          }), {
            default: function _default10() {
              return [childNode];
            }
          });
        }
      });
    };
  }
});
var _excluded$Y = ["component"], _excluded2$6 = ["className"], _excluded3 = ["class"];
const RawItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: false,
  props: {
    component: PropTypes$1.any,
    title: PropTypes$1.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    }
  },
  setup: function setup20(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var context2 = useInjectOverflowContext();
    return function() {
      if (!context2.value) {
        var _slots$default;
        var _props$component = props3.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$2(props3, _excluded$Y);
        return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, _restProps), attrs), {
          default: function _default9() {
            return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
          }
        });
      }
      var _context$value = context2.value, contextClassName = _context$value.className, restContext = _objectWithoutProperties$2(_context$value, _excluded2$6);
      var className = attrs.class, restProps = _objectWithoutProperties$2(attrs, _excluded3);
      return createVNode(OverflowContextProvider, {
        "value": null
      }, {
        default: function _default9() {
          return [createVNode(Item$3, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "class": classNames(contextClassName, className)
          }, restContext), restProps), props3), slots)];
        }
      });
    };
  }
});
var _excluded$X = ["class", "style"];
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
var overflowProps = function overflowProps2() {
  return {
    id: String,
    prefixCls: String,
    data: Array,
    itemKey: [String, Number, Function],
    itemWidth: {
      type: Number,
      default: 10
    },
    renderItem: Function,
    renderRawItem: Function,
    maxCount: [Number, String],
    renderRest: Function,
    renderRawRest: Function,
    suffix: PropTypes$1.any,
    component: String,
    itemComponent: PropTypes$1.any,
    onVisibleChange: Function,
    ssr: String,
    onMousedown: Function
  };
};
var Overflow = defineComponent({
  name: "Overflow",
  inheritAttrs: false,
  props: overflowProps(),
  emits: ["visibleChange"],
  setup: function setup21(props3, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, slots = _ref.slots;
    var fullySSR = computed(function() {
      return props3.ssr === "full";
    });
    var containerWidth = ref(null);
    var mergedContainerWidth = computed(function() {
      return containerWidth.value || 0;
    });
    var itemWidths = ref(/* @__PURE__ */ new Map());
    var prevRestWidth = ref(0);
    var restWidth = ref(0);
    var suffixWidth = ref(0);
    var suffixFixedStart = ref(null);
    var displayCount = ref(null);
    var mergedDisplayCount = computed(function() {
      if (displayCount.value === null && fullySSR.value) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount.value || 0;
    });
    var restReady = ref(false);
    var itemPrefixCls = computed(function() {
      return "".concat(props3.prefixCls, "-item");
    });
    var mergedRestWidth = computed(function() {
      return Math.max(prevRestWidth.value, restWidth.value);
    });
    var isResponsive = computed(function() {
      return !!(props3.data.length && props3.maxCount === RESPONSIVE);
    });
    var invalidate = computed(function() {
      return props3.maxCount === INVALIDATE;
    });
    var showRest = computed(function() {
      return isResponsive.value || typeof props3.maxCount === "number" && props3.data.length > props3.maxCount;
    });
    var mergedData = computed(function() {
      var items = props3.data;
      if (isResponsive.value) {
        if (containerWidth.value === null && fullySSR.value) {
          items = props3.data;
        } else {
          items = props3.data.slice(0, Math.min(props3.data.length, mergedContainerWidth.value / props3.itemWidth));
        }
      } else if (typeof props3.maxCount === "number") {
        items = props3.data.slice(0, props3.maxCount);
      }
      return items;
    });
    var omittedItems = computed(function() {
      if (isResponsive.value) {
        return props3.data.slice(mergedDisplayCount.value + 1);
      }
      return props3.data.slice(mergedData.value.length);
    });
    var getKey3 = function getKey4(item, index2) {
      var _ref2;
      if (typeof props3.itemKey === "function") {
        return props3.itemKey(item);
      }
      return (_ref2 = props3.itemKey && (item === null || item === void 0 ? void 0 : item[props3.itemKey])) !== null && _ref2 !== void 0 ? _ref2 : index2;
    };
    var mergedRenderItem = computed(function() {
      return props3.renderItem || function(item) {
        return item;
      };
    });
    var updateDisplayCount = function updateDisplayCount2(count, notReady) {
      displayCount.value = count;
      if (!notReady) {
        restReady.value = count < props3.data.length - 1;
        emit("visibleChange", count);
      }
    };
    var onOverflowResize = function onOverflowResize2(_2, element) {
      containerWidth.value = element.clientWidth;
    };
    var registerSize = function registerSize2(key2, width) {
      var clone3 = new Map(itemWidths.value);
      if (width === null) {
        clone3.delete(key2);
      } else {
        clone3.set(key2, width);
      }
      itemWidths.value = clone3;
    };
    var registerOverflowSize = function registerOverflowSize2(_2, width) {
      prevRestWidth.value = restWidth.value;
      restWidth.value = width;
    };
    var registerSuffixSize = function registerSuffixSize2(_2, width) {
      suffixWidth.value = width;
    };
    var getItemWidth = function getItemWidth2(index2) {
      return itemWidths.value.get(getKey3(mergedData.value[index2], index2));
    };
    watch([mergedContainerWidth, itemWidths, restWidth, suffixWidth, function() {
      return props3.itemKey;
    }, mergedData], function() {
      if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
        var totalWidth = suffixWidth.value;
        var len = mergedData.value.length;
        var lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0);
          suffixFixedStart.value = null;
          return;
        }
        for (var i2 = 0; i2 < len; i2 += 1) {
          var currentItemWidth = getItemWidth(i2);
          if (currentItemWidth === void 0) {
            updateDisplayCount(i2 - 1, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (lastIndex === 0 && totalWidth <= mergedContainerWidth.value || i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {
            updateDisplayCount(lastIndex);
            suffixFixedStart.value = null;
            break;
          } else if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
            updateDisplayCount(i2 - 1);
            suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
            break;
          }
        }
        if (props3.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value) {
          suffixFixedStart.value = null;
        }
      }
    });
    return function() {
      var displayRest = restReady.value && !!omittedItems.value.length;
      var itemComponent = props3.itemComponent, renderRawItem = props3.renderRawItem, renderRawRest = props3.renderRawRest, renderRest = props3.renderRest, _props$prefixCls = props3.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, suffix = props3.suffix, _props$component = props3.component, Component = _props$component === void 0 ? "div" : _props$component, id = props3.id, onMousedown2 = props3.onMousedown;
      var className = attrs.class, style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded$X);
      var suffixStyle = {};
      if (suffixFixedStart.value !== null && isResponsive.value) {
        suffixStyle = {
          position: "absolute",
          left: "".concat(suffixFixedStart.value, "px"),
          top: 0
        };
      }
      var itemSharedProps = {
        prefixCls: itemPrefixCls.value,
        responsive: isResponsive.value,
        component: itemComponent,
        invalidate: invalidate.value
      };
      var internalRenderItemNode = renderRawItem ? function(item, index2) {
        var key2 = getKey3(item, index2);
        return createVNode(OverflowContextProvider, {
          "key": key2,
          "value": _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
            order: index2,
            item,
            itemKey: key2,
            registerSize,
            display: index2 <= mergedDisplayCount.value
          })
        }, {
          default: function _default9() {
            return [renderRawItem(item, index2)];
          }
        });
      } : function(item, index2) {
        var key2 = getKey3(item, index2);
        return createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
          "order": index2,
          "key": key2,
          "item": item,
          "renderItem": mergedRenderItem.value,
          "itemKey": key2,
          "registerSize": registerSize,
          "display": index2 <= mergedDisplayCount.value
        }), null);
      };
      var restNode = function restNode2() {
        return null;
      };
      var restContextProps = {
        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
        className: "".concat(itemPrefixCls.value, " ").concat(itemPrefixCls.value, "-rest"),
        registerSize: registerOverflowSize,
        display: displayRest
      };
      if (!renderRawRest) {
        var mergedRenderRest = renderRest || defaultRenderRest;
        restNode = function restNode2() {
          return createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps), {
            default: function _default9() {
              return typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems.value) : mergedRenderRest;
            }
          });
        };
      } else if (renderRawRest) {
        restNode = function restNode2() {
          return createVNode(OverflowContextProvider, {
            "value": _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps)
          }, {
            default: function _default9() {
              return [renderRawRest(omittedItems.value)];
            }
          });
        };
      }
      var overflowNode = function overflowNode2() {
        var _slots$default;
        return createVNode(Component, _objectSpread2$1({
          "id": id,
          "class": classNames(!invalidate.value && prefixCls, className),
          "style": style2,
          "onMousedown": onMousedown2
        }, restAttrs), {
          default: function _default9() {
            return [mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && createVNode(Item$3, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
              "order": mergedDisplayCount.value,
              "class": "".concat(itemPrefixCls.value, "-suffix"),
              "registerSize": registerSuffixSize,
              "display": true,
              "style": suffixStyle
            }), {
              default: function _default10() {
                return suffix;
              }
            }), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
          }
        });
      };
      return createVNode(ResizeObserver$1, {
        "disabled": !isResponsive.value,
        "onResize": onOverflowResize
      }, {
        default: overflowNode
      });
    };
  }
});
Overflow.Item = RawItem;
Overflow.RESPONSIVE = RESPONSIVE;
Overflow.INVALIDATE = INVALIDATE;
const Overflow$1 = Overflow;
var TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
function useProvideLegacySelectContext(props3) {
  return provide(TreeSelectLegacyContextPropsKey, props3);
}
function useInjectLegacySelectContext() {
  return inject(TreeSelectLegacyContextPropsKey, {});
}
var props$2 = {
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  removeIcon: PropTypes$1.any,
  choiceTransitionName: String,
  maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: PropTypes$1.any.def(function() {
    return function(omittedValues) {
      return "+ ".concat(omittedValues.length, " ...");
    };
  }),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
var onPreventMouseDown = function onPreventMouseDown2(event2) {
  event2.preventDefault();
  event2.stopPropagation();
};
var SelectSelector = defineComponent({
  name: "MultipleSelectSelector",
  inheritAttrs: false,
  props: props$2,
  setup: function setup22(props3) {
    var measureRef = ref();
    var inputWidth = ref(0);
    var focused = ref(false);
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    var selectionPrefixCls = computed(function() {
      return "".concat(props3.prefixCls, "-selection");
    });
    var inputValue = computed(function() {
      return props3.open || props3.mode === "tags" ? props3.searchValue : "";
    });
    var inputEditable = computed(function() {
      return props3.mode === "tags" || props3.showSearch && (props3.open || focused.value);
    });
    onMounted(function() {
      watch(inputValue, function() {
        inputWidth.value = measureRef.value.scrollWidth;
      }, {
        flush: "post",
        immediate: true
      });
    });
    function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
      return createVNode("span", {
        "class": classNames("".concat(selectionPrefixCls.value, "-item"), _defineProperty$U({}, "".concat(selectionPrefixCls.value, "-item-disabled"), itemDisabled)),
        "title": typeof title === "string" || typeof title === "number" ? title.toString() : void 0
      }, [createVNode("span", {
        "class": "".concat(selectionPrefixCls.value, "-item-content")
      }, [content]), closable && createVNode(TransBtn$1, {
        "class": "".concat(selectionPrefixCls.value, "-item-remove"),
        "onMousedown": onPreventMouseDown,
        "onClick": onClose,
        "customizeIcon": props3.removeIcon
      }, {
        default: function _default9() {
          return [createTextVNode("\xD7")];
        }
      })]);
    }
    function customizeRenderSelector(value, content, itemDisabled, closable, onClose, option) {
      var onMouseDown2 = function onMouseDown3(e2) {
        onPreventMouseDown(e2);
        props3.onToggleOpen(!open);
      };
      var originData = option;
      if (legacyTreeSelectContext.keyEntities) {
        var _legacyTreeSelectCont;
        originData = ((_legacyTreeSelectCont = legacyTreeSelectContext.keyEntities[value]) === null || _legacyTreeSelectCont === void 0 ? void 0 : _legacyTreeSelectCont.node) || {};
      }
      return createVNode("span", {
        "key": value,
        "onMousedown": onMouseDown2
      }, [props3.tagRender({
        label: content,
        value,
        disabled: itemDisabled,
        closable,
        onClose,
        option: originData
      })]);
    }
    function renderItem(valueItem) {
      var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value, option = valueItem.option;
      var closable = !props3.disabled && !itemDisabled;
      var displayLabel = label;
      if (typeof props3.maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          var strLabel = String(displayLabel);
          if (strLabel.length > props3.maxTagTextLength) {
            displayLabel = "".concat(strLabel.slice(0, props3.maxTagTextLength), "...");
          }
        }
      }
      var onClose = function onClose2(event2) {
        var _props$onRemove;
        if (event2)
          event2.stopPropagation();
        (_props$onRemove = props3.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props3, valueItem);
      };
      return typeof props3.tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, option) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
    }
    function renderRest(omittedValues) {
      var _props$maxTagPlacehol = props3.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues2) {
        return "+ ".concat(omittedValues2.length, " ...");
      } : _props$maxTagPlacehol;
      var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return defaultRenderSelector(content, content, false);
    }
    return function() {
      var id = props3.id, prefixCls = props3.prefixCls, values = props3.values, open2 = props3.open, inputRef = props3.inputRef, placeholder = props3.placeholder, disabled = props3.disabled, autofocus = props3.autofocus, autocomplete = props3.autocomplete, activeDescendantId = props3.activeDescendantId, tabindex = props3.tabindex, onInputChange = props3.onInputChange, onInputPaste = props3.onInputPaste, onInputKeyDown = props3.onInputKeyDown, onInputMouseDown = props3.onInputMouseDown, onInputCompositionStart = props3.onInputCompositionStart, onInputCompositionEnd = props3.onInputCompositionEnd;
      var inputNode = createVNode("div", {
        "class": "".concat(selectionPrefixCls.value, "-search"),
        "style": {
          width: inputWidth.value + "px"
        },
        "key": "input"
      }, [createVNode(Input$3, {
        "inputRef": inputRef,
        "open": open2,
        "prefixCls": prefixCls,
        "id": id,
        "inputElement": null,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": inputValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": onInputChange,
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props3, true),
        "onFocus": function onFocus2() {
          return focused.value = true;
        },
        "onBlur": function onBlur2() {
          return focused.value = false;
        }
      }, null), createVNode("span", {
        "ref": measureRef,
        "class": "".concat(selectionPrefixCls.value, "-search-mirror"),
        "aria-hidden": true
      }, [inputValue.value, createTextVNode("\xA0")])]);
      var selectionNode = createVNode(Overflow$1, {
        "prefixCls": "".concat(selectionPrefixCls.value, "-overflow"),
        "data": values,
        "renderItem": renderItem,
        "renderRest": renderRest,
        "suffix": inputNode,
        "itemKey": "key",
        "maxCount": props3.maxTagCount,
        "key": "overflow"
      }, null);
      return createVNode(Fragment, null, [selectionNode, !values.length && !inputValue.value && createVNode("span", {
        "class": "".concat(selectionPrefixCls.value, "-placeholder")
      }, [placeholder])]);
    };
  }
});
const MultipleSelector = SelectSelector;
var props$1 = {
  inputElement: PropTypes$1.any,
  id: String,
  prefixCls: String,
  values: PropTypes$1.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: PropTypes$1.any,
  placeholder: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
};
var SingleSelector = defineComponent({
  name: "SingleSelector",
  setup: function setup23(props3) {
    var inputChanged = ref(false);
    var combobox = computed(function() {
      return props3.mode === "combobox";
    });
    var inputEditable = computed(function() {
      return combobox.value || props3.showSearch;
    });
    var inputValue = computed(function() {
      var inputValue2 = props3.searchValue || "";
      if (combobox.value && props3.activeValue && !inputChanged.value) {
        inputValue2 = props3.activeValue;
      }
      return inputValue2;
    });
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    watch([combobox, function() {
      return props3.activeValue;
    }], function() {
      if (combobox.value) {
        inputChanged.value = false;
      }
    }, {
      immediate: true
    });
    var hasTextInput = computed(function() {
      return props3.mode !== "combobox" && !props3.open && !props3.showSearch ? false : !!inputValue.value;
    });
    var title = computed(function() {
      var item = props3.values[0];
      return item && (typeof item.label === "string" || typeof item.label === "number") ? item.label.toString() : void 0;
    });
    var renderPlaceholder = function renderPlaceholder2() {
      if (props3.values[0]) {
        return null;
      }
      var hiddenStyle = hasTextInput.value ? {
        visibility: "hidden"
      } : void 0;
      return createVNode("span", {
        "class": "".concat(props3.prefixCls, "-selection-placeholder"),
        "style": hiddenStyle
      }, [props3.placeholder]);
    };
    return function() {
      var _item$key2;
      var inputElement = props3.inputElement, prefixCls = props3.prefixCls, id = props3.id, values = props3.values, inputRef = props3.inputRef, disabled = props3.disabled, autofocus = props3.autofocus, autocomplete = props3.autocomplete, activeDescendantId = props3.activeDescendantId, open2 = props3.open, tabindex = props3.tabindex, optionLabelRender = props3.optionLabelRender, onInputKeyDown = props3.onInputKeyDown, onInputMouseDown = props3.onInputMouseDown, onInputChange = props3.onInputChange, onInputPaste = props3.onInputPaste, onInputCompositionStart = props3.onInputCompositionStart, onInputCompositionEnd = props3.onInputCompositionEnd;
      var item = values[0];
      var titleNode = null;
      if (item && legacyTreeSelectContext.customSlots) {
        var _item$key, _legacyTreeSelectCont, _originData$slots;
        var key2 = (_item$key = item.key) !== null && _item$key !== void 0 ? _item$key : item.value;
        var originData = ((_legacyTreeSelectCont = legacyTreeSelectContext.keyEntities[key2]) === null || _legacyTreeSelectCont === void 0 ? void 0 : _legacyTreeSelectCont.node) || {};
        titleNode = legacyTreeSelectContext.customSlots[(_originData$slots = originData.slots) === null || _originData$slots === void 0 ? void 0 : _originData$slots.title] || legacyTreeSelectContext.customSlots.title || item.label;
        if (typeof titleNode === "function") {
          titleNode = titleNode(originData);
        }
      } else {
        titleNode = optionLabelRender && item ? optionLabelRender(item.option) : item === null || item === void 0 ? void 0 : item.label;
      }
      return createVNode(Fragment, null, [createVNode("span", {
        "class": "".concat(prefixCls, "-selection-search")
      }, [createVNode(Input$3, {
        "inputRef": inputRef,
        "prefixCls": prefixCls,
        "id": id,
        "open": open2,
        "inputElement": inputElement,
        "disabled": disabled,
        "autofocus": autofocus,
        "autocomplete": autocomplete,
        "editable": inputEditable.value,
        "activeDescendantId": activeDescendantId,
        "value": inputValue.value,
        "onKeydown": onInputKeyDown,
        "onMousedown": onInputMouseDown,
        "onChange": function onChange3(e2) {
          inputChanged.value = true;
          onInputChange(e2);
        },
        "onPaste": onInputPaste,
        "onCompositionstart": onInputCompositionStart,
        "onCompositionend": onInputCompositionEnd,
        "tabindex": tabindex,
        "attrs": pickAttrs(props3, true)
      }, null)]), !combobox.value && item && !hasTextInput.value && createVNode("span", {
        "class": "".concat(prefixCls, "-selection-item"),
        "title": title.value
      }, [createVNode(Fragment, {
        "key": (_item$key2 = item.key) !== null && _item$key2 !== void 0 ? _item$key2 : item.value
      }, [titleNode])]), renderPlaceholder()]);
    };
  }
});
SingleSelector.props = props$1;
SingleSelector.inheritAttrs = false;
const SingleSelector$1 = SingleSelector;
function isValidateOpenKey(currentKeyCode) {
  return ![
    KeyCode$1.ESC,
    KeyCode$1.SHIFT,
    KeyCode$1.BACKSPACE,
    KeyCode$1.TAB,
    KeyCode$1.WIN_KEY,
    KeyCode$1.ALT,
    KeyCode$1.META,
    KeyCode$1.WIN_KEY_RIGHT,
    KeyCode$1.CTRL,
    KeyCode$1.SEMICOLON,
    KeyCode$1.EQUALS,
    KeyCode$1.CAPS_LOCK,
    KeyCode$1.CONTEXT_MENU,
    KeyCode$1.F1,
    KeyCode$1.F2,
    KeyCode$1.F3,
    KeyCode$1.F4,
    KeyCode$1.F5,
    KeyCode$1.F6,
    KeyCode$1.F7,
    KeyCode$1.F8,
    KeyCode$1.F9,
    KeyCode$1.F10,
    KeyCode$1.F11,
    KeyCode$1.F12
  ].includes(currentKeyCode);
}
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  var lock = null;
  var timeout;
  onBeforeUnmount(function() {
    clearTimeout(timeout);
  });
  function doLock(locked) {
    if (locked || lock === null) {
      lock = locked;
    }
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      lock = null;
    }, duration);
  }
  return [function() {
    return lock;
  }, doLock];
}
function createRef() {
  var func = function func2(node) {
    func2.current = node;
  };
  return func;
}
var Selector = defineComponent({
  name: "Selector",
  inheritAttrs: false,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    values: PropTypes$1.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: PropTypes$1.any,
    removeIcon: PropTypes$1.any,
    maxTagCount: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: PropTypes$1.any,
    tagRender: Function,
    optionLabelRender: Function,
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    domRef: Function
  },
  setup: function setup24(props3, _ref) {
    var expose = _ref.expose;
    var inputRef = createRef();
    var compositionStatus = false;
    var _useLock = useLock(0), _useLock2 = _slicedToArray$2(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
    var onInternalInputKeyDown = function onInternalInputKeyDown2(event2) {
      var which = event2.which;
      if (which === KeyCode$1.UP || which === KeyCode$1.DOWN) {
        event2.preventDefault();
      }
      if (props3.onInputKeyDown) {
        props3.onInputKeyDown(event2);
      }
      if (which === KeyCode$1.ENTER && props3.mode === "tags" && !compositionStatus && !props3.open) {
        props3.onSearchSubmit(event2.target.value);
      }
      if (isValidateOpenKey(which)) {
        props3.onToggleOpen(true);
      }
    };
    var onInternalInputMouseDown = function onInternalInputMouseDown2() {
      setInputMouseDown(true);
    };
    var pastedText = null;
    var triggerOnSearch = function triggerOnSearch2(value) {
      if (props3.onSearch(value, true, compositionStatus) !== false) {
        props3.onToggleOpen(true);
      }
    };
    var onInputCompositionStart = function onInputCompositionStart2() {
      compositionStatus = true;
    };
    var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
      compositionStatus = false;
      if (props3.mode !== "combobox") {
        triggerOnSearch(e2.target.value);
      }
    };
    var onInputChange = function onInputChange2(event2) {
      var value = event2.target.value;
      if (props3.tokenWithEnter && pastedText && /[\r\n]/.test(pastedText)) {
        var replacedText = pastedText.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        value = value.replace(replacedText, pastedText);
      }
      pastedText = null;
      triggerOnSearch(value);
    };
    var onInputPaste = function onInputPaste2(e2) {
      var clipboardData = e2.clipboardData;
      var value = clipboardData.getData("text");
      pastedText = value;
    };
    var onClick2 = function onClick3(_ref2) {
      var target = _ref2.target;
      if (target !== inputRef.current) {
        var isIE = document.body.style.msTouchAction !== void 0;
        if (isIE) {
          setTimeout(function() {
            inputRef.current.focus();
          });
        } else {
          inputRef.current.focus();
        }
      }
    };
    var onMousedown2 = function onMousedown3(event2) {
      var inputMouseDown = getInputMouseDown();
      if (event2.target !== inputRef.current && !inputMouseDown) {
        event2.preventDefault();
      }
      if (props3.mode !== "combobox" && (!props3.showSearch || !inputMouseDown) || !props3.open) {
        if (props3.open) {
          props3.onSearch("", true, false);
        }
        props3.onToggleOpen();
      }
    };
    expose({
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    });
    return function() {
      var prefixCls = props3.prefixCls, domRef = props3.domRef, mode = props3.mode;
      var sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd
      };
      var selectNode = mode === "multiple" || mode === "tags" ? createVNode(MultipleSelector, _objectSpread2$1(_objectSpread2$1({}, props3), sharedProps), null) : createVNode(SingleSelector$1, _objectSpread2$1(_objectSpread2$1({}, props3), sharedProps), null);
      return createVNode("div", {
        "ref": domRef,
        "class": "".concat(prefixCls, "-selector"),
        "onClick": onClick2,
        "onMousedown": onMousedown2
      }, [selectNode]);
    };
  }
});
const Selector$1 = Selector;
function useSelectTriggerControl(refs, open2, triggerOpen) {
  function onGlobalMouseDown(event2) {
    var _refs$, _refs$2, _refs$2$value;
    var target = event2.target;
    if (target.shadowRoot && event2.composed) {
      target = event2.composedPath()[0] || target;
    }
    var elements = [(_refs$ = refs[0]) === null || _refs$ === void 0 ? void 0 : _refs$.value, (_refs$2 = refs[1]) === null || _refs$2 === void 0 ? void 0 : (_refs$2$value = _refs$2.value) === null || _refs$2$value === void 0 ? void 0 : _refs$2$value.getPopupElement()];
    if (open2.value && elements.every(function(element) {
      return element && !element.contains(target) && element !== target;
    })) {
      triggerOpen(false);
    }
  }
  onMounted(function() {
    window.addEventListener("mousedown", onGlobalMouseDown);
  });
  onBeforeUnmount(function() {
    window.removeEventListener("mousedown", onGlobalMouseDown);
  });
}
function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  var bool = ref(false);
  var delay;
  var cancelLatest = function cancelLatest2() {
    clearTimeout(delay);
  };
  onMounted(function() {
    cancelLatest();
  });
  var delaySetBool = function delaySetBool2(value, callback) {
    cancelLatest();
    delay = setTimeout(function() {
      bool.value = value;
      if (callback) {
        callback();
      }
    }, timeout);
  };
  return [bool, delaySetBool, cancelLatest];
}
var BaseSelectContextKey = Symbol("BaseSelectContextKey");
function useProvideBaseSelectProps(props3) {
  return provide(BaseSelectContextKey, props3);
}
function useBaseProps() {
  return inject(BaseSelectContextKey, {});
}
const isMobile$2 = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4))) {
    return true;
  }
  return false;
};
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  var proxy = new Proxy({}, {
    get: function get4(_2, p2, receiver) {
      return Reflect.get(objectRef.value, p2, receiver);
    },
    set: function set2(_2, p2, value) {
      objectRef.value[p2] = value;
      return true;
    },
    deleteProperty: function deleteProperty2(_2, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has: function has2(_2, p2) {
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys: function ownKeys2() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
var _excluded$W = ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"];
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"];
var baseSelectPrivateProps = function baseSelectPrivateProps2() {
  return {
    prefixCls: String,
    id: String,
    omitDomProps: Array,
    displayValues: Array,
    onDisplayValuesChange: Function,
    activeValue: String,
    activeDescendantId: String,
    onActiveValueChange: Function,
    searchValue: String,
    onSearch: Function,
    onSearchSplit: Function,
    maxLength: Number,
    OptionList: PropTypes$1.any,
    emptyOptions: Boolean
  };
};
var baseSelectPropsWithoutPrivate = function baseSelectPropsWithoutPrivate2() {
  return {
    showSearch: {
      type: Boolean,
      default: void 0
    },
    tagRender: {
      type: Function
    },
    optionLabelRender: {
      type: Function
    },
    direction: {
      type: String
    },
    tabindex: Number,
    autofocus: Boolean,
    notFoundContent: PropTypes$1.any,
    placeholder: PropTypes$1.any,
    onClear: Function,
    choiceTransitionName: String,
    mode: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    onDropdownVisibleChange: {
      type: Function
    },
    getInputElement: {
      type: Function
    },
    getRawInputElement: {
      type: Function
    },
    maxTagTextLength: Number,
    maxTagCount: {
      type: [String, Number]
    },
    maxTagPlaceholder: PropTypes$1.any,
    tokenSeparators: {
      type: Array
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    inputIcon: PropTypes$1.any,
    clearIcon: PropTypes$1.any,
    removeIcon: PropTypes$1.any,
    animation: String,
    transitionName: String,
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: String,
    dropdownMatchSelectWidth: {
      type: [Boolean, Number],
      default: void 0
    },
    dropdownRender: {
      type: Function
    },
    dropdownAlign: Object,
    placement: {
      type: String
    },
    getPopupContainer: {
      type: Function
    },
    showAction: {
      type: Array
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onKeyup: Function,
    onKeydown: Function,
    onMousedown: Function,
    onPopupScroll: Function,
    onInputKeyDown: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
var baseSelectProps = function baseSelectProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate());
};
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
const BaseSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: false,
  props: initDefaultProps$1(baseSelectProps(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup: function setup25(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var multiple = computed(function() {
      return isMultiple(props3.mode);
    });
    var mergedShowSearch = computed(function() {
      return props3.showSearch !== void 0 ? props3.showSearch : multiple.value || props3.mode === "combobox";
    });
    var mobile = ref(false);
    onMounted(function() {
      mobile.value = isMobile$2();
    });
    var legacyTreeSelectContext = useInjectLegacySelectContext();
    var containerRef = ref(null);
    var selectorDomRef = createRef();
    var triggerRef2 = ref(null);
    var selectorRef = ref(null);
    var listRef = ref(null);
    var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray$2(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
    var focus = function focus2() {
      var _selectorRef$value;
      (_selectorRef$value = selectorRef.value) === null || _selectorRef$value === void 0 ? void 0 : _selectorRef$value.focus();
    };
    var blur = function blur2() {
      var _selectorRef$value2;
      (_selectorRef$value2 = selectorRef.value) === null || _selectorRef$value2 === void 0 ? void 0 : _selectorRef$value2.blur();
    };
    expose({
      focus,
      blur,
      scrollTo: function scrollTo2(arg) {
        var _listRef$value;
        return (_listRef$value = listRef.value) === null || _listRef$value === void 0 ? void 0 : _listRef$value.scrollTo(arg);
      }
    });
    var mergedSearchValue = computed(function() {
      var _props$displayValues$;
      if (props3.mode !== "combobox") {
        return props3.searchValue;
      }
      var val = (_props$displayValues$ = props3.displayValues[0]) === null || _props$displayValues$ === void 0 ? void 0 : _props$displayValues$.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    });
    var initOpen = props3.open !== void 0 ? props3.open : props3.defaultOpen;
    var innerOpen = ref(initOpen);
    var mergedOpen = ref(initOpen);
    var setInnerOpen = function setInnerOpen2(val) {
      innerOpen.value = props3.open !== void 0 ? props3.open : val;
      mergedOpen.value = innerOpen.value;
    };
    watch(function() {
      return props3.open;
    }, function() {
      setInnerOpen(props3.open);
    });
    var emptyListContent = computed(function() {
      return !props3.notFoundContent && props3.emptyOptions;
    });
    watchEffect(function() {
      mergedOpen.value = innerOpen.value;
      if (props3.disabled || emptyListContent.value && mergedOpen.value && props3.mode === "combobox") {
        mergedOpen.value = false;
      }
    });
    var triggerOpen = computed(function() {
      return emptyListContent.value ? false : mergedOpen.value;
    });
    var onToggleOpen = function onToggleOpen2(newOpen) {
      var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen.value;
      if (innerOpen.value !== nextOpen && !props3.disabled) {
        setInnerOpen(nextOpen);
        if (props3.onDropdownVisibleChange) {
          props3.onDropdownVisibleChange(nextOpen);
        }
      }
    };
    var tokenWithEnter = computed(function() {
      return (props3.tokenSeparators || []).some(function(tokenSeparator) {
        return ["\n", "\r\n"].includes(tokenSeparator);
      });
    });
    var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
      var _props$onActiveValueC;
      var ret = true;
      var newSearchText = searchText;
      (_props$onActiveValueC = props3.onActiveValueChange) === null || _props$onActiveValueC === void 0 ? void 0 : _props$onActiveValueC.call(props3, null);
      var patchLabels = isCompositing ? null : getSeparatedContent(searchText, props3.tokenSeparators);
      if (props3.mode !== "combobox" && patchLabels) {
        var _props$onSearchSplit;
        newSearchText = "";
        (_props$onSearchSplit = props3.onSearchSplit) === null || _props$onSearchSplit === void 0 ? void 0 : _props$onSearchSplit.call(props3, patchLabels);
        onToggleOpen(false);
        ret = false;
      }
      if (props3.onSearch && mergedSearchValue.value !== newSearchText) {
        props3.onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      return ret;
    };
    var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
      var _props$onSearch;
      if (!searchText || !searchText.trim()) {
        return;
      }
      (_props$onSearch = props3.onSearch) === null || _props$onSearch === void 0 ? void 0 : _props$onSearch.call(props3, searchText, {
        source: "submit"
      });
    };
    watch(mergedOpen, function() {
      if (!mergedOpen.value && !multiple.value && props3.mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, {
      immediate: true,
      flush: "post"
    });
    watch(function() {
      return props3.disabled;
    }, function() {
      if (innerOpen.value && !!props3.disabled) {
        setInnerOpen(false);
      }
    }, {
      immediate: true
    });
    var _useLock = useLock(), _useLock2 = _slicedToArray$2(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
    var onInternalKeyDown = function onInternalKeyDown2(event2) {
      var _props$onKeydown;
      var clearLock = getClearLock();
      var which = event2.which;
      if (which === KeyCode$1.ENTER) {
        if (props3.mode !== "combobox") {
          event2.preventDefault();
        }
        if (!mergedOpen.value) {
          onToggleOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue.value);
      if (which === KeyCode$1.BACKSPACE && !clearLock && multiple.value && !mergedSearchValue.value && props3.displayValues.length) {
        var cloneDisplayValues = _toConsumableArray(props3.displayValues);
        var removedDisplayValue = null;
        for (var i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
          var current2 = cloneDisplayValues[i2];
          if (!current2.disabled) {
            cloneDisplayValues.splice(i2, 1);
            removedDisplayValue = current2;
            break;
          }
        }
        if (removedDisplayValue) {
          props3.onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }
      if (mergedOpen.value && listRef.value) {
        var _listRef$value2;
        (_listRef$value2 = listRef.value).onKeydown.apply(_listRef$value2, [event2].concat(rest));
      }
      (_props$onKeydown = props3.onKeydown) === null || _props$onKeydown === void 0 ? void 0 : _props$onKeydown.call.apply(_props$onKeydown, [props3, event2].concat(rest));
    };
    var onInternalKeyUp = function onInternalKeyUp2(event2) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        rest[_key2 - 1] = arguments[_key2];
      }
      if (mergedOpen.value && listRef.value) {
        var _listRef$value3;
        (_listRef$value3 = listRef.value).onKeyup.apply(_listRef$value3, [event2].concat(rest));
      }
      if (props3.onKeyup) {
        props3.onKeyup.apply(props3, [event2].concat(rest));
      }
    };
    var onSelectorRemove = function onSelectorRemove2(val) {
      var newValues = props3.displayValues.filter(function(i2) {
        return i2 !== val;
      });
      props3.onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    };
    var focusRef = ref(false);
    var onContainerFocus = function onContainerFocus2() {
      setMockFocused(true);
      if (!props3.disabled) {
        if (props3.onFocus && !focusRef.value) {
          props3.onFocus.apply(props3, arguments);
        }
        if (props3.showAction && props3.showAction.includes("focus")) {
          onToggleOpen(true);
        }
      }
      focusRef.value = true;
    };
    var onContainerBlur = function onContainerBlur2() {
      setMockFocused(false, function() {
        focusRef.value = false;
        onToggleOpen(false);
      });
      if (props3.disabled) {
        return;
      }
      var searchVal = mergedSearchValue.value;
      if (searchVal) {
        if (props3.mode === "tags") {
          props3.onSearch(searchVal, {
            source: "submit"
          });
        } else if (props3.mode === "multiple") {
          props3.onSearch("", {
            source: "blur"
          });
        }
      }
      if (props3.onBlur) {
        props3.onBlur.apply(props3, arguments);
      }
    };
    provide("VCSelectContainerEvent", {
      focus: onContainerFocus,
      blur: onContainerBlur
    });
    var activeTimeoutIds = [];
    onMounted(function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    onBeforeUnmount(function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    });
    var onInternalMouseDown = function onInternalMouseDown2(event2) {
      var _triggerRef$value, _props$onMousedown;
      var target = event2.target;
      var popupElement = (_triggerRef$value = triggerRef2.value) === null || _triggerRef$value === void 0 ? void 0 : _triggerRef$value.getPopupElement();
      if (popupElement && popupElement.contains(target)) {
        var timeoutId = setTimeout(function() {
          var index2 = activeTimeoutIds.indexOf(timeoutId);
          if (index2 !== -1) {
            activeTimeoutIds.splice(index2, 1);
          }
          cancelSetMockFocused();
          if (!mobile.value && !popupElement.contains(document.activeElement)) {
            var _selectorRef$value3;
            (_selectorRef$value3 = selectorRef.value) === null || _selectorRef$value3 === void 0 ? void 0 : _selectorRef$value3.focus();
          }
        });
        activeTimeoutIds.push(timeoutId);
      }
      for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        restArgs[_key3 - 1] = arguments[_key3];
      }
      (_props$onMousedown = props3.onMousedown) === null || _props$onMousedown === void 0 ? void 0 : _props$onMousedown.call.apply(_props$onMousedown, [props3, event2].concat(restArgs));
    };
    var containerWidth = ref(null);
    var instance = getCurrentInstance();
    var onPopupMouseEnter = function onPopupMouseEnter2() {
      instance.update();
    };
    onMounted(function() {
      watch(triggerOpen, function() {
        if (triggerOpen.value) {
          var _containerRef$value;
          var newWidth = Math.ceil((_containerRef$value = containerRef.value) === null || _containerRef$value === void 0 ? void 0 : _containerRef$value.offsetWidth);
          if (containerWidth.value !== newWidth && !Number.isNaN(newWidth)) {
            containerWidth.value = newWidth;
          }
        }
      }, {
        immediate: true,
        flush: "post"
      });
    });
    useSelectTriggerControl([containerRef, triggerRef2], triggerOpen, onToggleOpen);
    useProvideBaseSelectProps(toReactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(props3)), {}, {
      open: mergedOpen,
      triggerOpen,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    })));
    return function() {
      var _classNames2;
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), prefixCls = _props$attrs.prefixCls, id = _props$attrs.id;
      _props$attrs.open;
      _props$attrs.defaultOpen;
      var mode = _props$attrs.mode;
      _props$attrs.showSearch;
      _props$attrs.searchValue;
      _props$attrs.onSearch;
      var allowClear = _props$attrs.allowClear, clearIcon = _props$attrs.clearIcon, showArrow = _props$attrs.showArrow, inputIcon = _props$attrs.inputIcon, disabled = _props$attrs.disabled, loading = _props$attrs.loading, getInputElement = _props$attrs.getInputElement, getPopupContainer = _props$attrs.getPopupContainer, placement = _props$attrs.placement, animation = _props$attrs.animation, transitionName2 = _props$attrs.transitionName, dropdownStyle = _props$attrs.dropdownStyle, dropdownClassName = _props$attrs.dropdownClassName, dropdownMatchSelectWidth = _props$attrs.dropdownMatchSelectWidth, dropdownRender = _props$attrs.dropdownRender, dropdownAlign = _props$attrs.dropdownAlign;
      _props$attrs.showAction;
      var direction = _props$attrs.direction;
      _props$attrs.tokenSeparators;
      var tagRender = _props$attrs.tagRender, optionLabelRender = _props$attrs.optionLabelRender;
      _props$attrs.onPopupScroll;
      _props$attrs.onDropdownVisibleChange;
      _props$attrs.onFocus;
      _props$attrs.onBlur;
      _props$attrs.onKeyup;
      _props$attrs.onKeydown;
      _props$attrs.onMousedown;
      var onClear = _props$attrs.onClear, omitDomProps = _props$attrs.omitDomProps, getRawInputElement = _props$attrs.getRawInputElement, displayValues = _props$attrs.displayValues, onDisplayValuesChange = _props$attrs.onDisplayValuesChange, emptyOptions = _props$attrs.emptyOptions, activeDescendantId = _props$attrs.activeDescendantId, activeValue = _props$attrs.activeValue, OptionList2 = _props$attrs.OptionList, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$W);
      var customizeInputElement = mode === "combobox" && getInputElement && getInputElement() || null;
      var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      var domProps = _objectSpread2$1({}, restProps);
      var onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
          onToggleOpen(newOpen);
        };
      }
      DEFAULT_OMIT_PROPS.forEach(function(propName) {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
        delete domProps[propName];
      });
      var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple.value && mode !== "combobox";
      var arrowNode;
      if (mergedShowArrow) {
        arrowNode = createVNode(TransBtn$1, {
          "class": classNames("".concat(prefixCls, "-arrow"), _defineProperty$U({}, "".concat(prefixCls, "-arrow-loading"), loading)),
          "customizeIcon": inputIcon,
          "customizeIconProps": {
            loading,
            searchValue: mergedSearchValue.value,
            open: mergedOpen.value,
            focused: mockFocused.value,
            showSearch: mergedShowSearch.value
          }
        }, null);
      }
      var clearNode;
      var onClearMouseDown = function onClearMouseDown2() {
        onClear === null || onClear === void 0 ? void 0 : onClear();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      if (!disabled && allowClear && (displayValues.length || mergedSearchValue.value)) {
        clearNode = createVNode(TransBtn$1, {
          "class": "".concat(prefixCls, "-clear"),
          "onMousedown": onClearMouseDown,
          "customizeIcon": clearIcon
        }, {
          default: function _default9() {
            return [createTextVNode("\xD7")];
          }
        });
      }
      var optionList = createVNode(OptionList2, {
        "ref": listRef
      }, _objectSpread2$1(_objectSpread2$1({}, legacyTreeSelectContext.customSlots), {}, {
        option: slots.option
      }));
      var mergedClassName = classNames(prefixCls, attrs.class, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-focused"), mockFocused.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-multiple"), multiple.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-single"), !multiple.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$U(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$U(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$U(_classNames2, "".concat(prefixCls, "-open"), mergedOpen.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$U(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch.value), _classNames2));
      var selectorNode = createVNode(SelectTrigger$1, {
        "ref": triggerRef2,
        "disabled": disabled,
        "prefixCls": prefixCls,
        "visible": triggerOpen.value,
        "popupElement": optionList,
        "containerWidth": containerWidth.value,
        "animation": animation,
        "transitionName": transitionName2,
        "dropdownStyle": dropdownStyle,
        "dropdownClassName": dropdownClassName,
        "direction": direction,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownRender": dropdownRender,
        "dropdownAlign": dropdownAlign,
        "placement": placement,
        "getPopupContainer": getPopupContainer,
        "empty": emptyOptions,
        "getTriggerDOMNode": function getTriggerDOMNode() {
          return selectorDomRef.current;
        },
        "onPopupVisibleChange": onTriggerVisibleChange,
        "onPopupMouseEnter": onPopupMouseEnter
      }, {
        default: function _default9() {
          return customizeRawInputElement ? isValidElement(customizeRawInputElement) && cloneElement(customizeRawInputElement, {
            ref: selectorDomRef
          }, false, true) : createVNode(Selector$1, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
            "domRef": selectorDomRef,
            "prefixCls": prefixCls,
            "inputElement": customizeInputElement,
            "ref": selectorRef,
            "id": id,
            "showSearch": mergedShowSearch.value,
            "mode": mode,
            "activeDescendantId": activeDescendantId,
            "tagRender": tagRender,
            "optionLabelRender": optionLabelRender,
            "values": displayValues,
            "open": mergedOpen.value,
            "onToggleOpen": onToggleOpen,
            "activeValue": activeValue,
            "searchValue": mergedSearchValue.value,
            "onSearch": onInternalSearch,
            "onSearchSubmit": onInternalSearchSubmit,
            "onRemove": onSelectorRemove,
            "tokenWithEnter": tokenWithEnter.value
          }), null);
        }
      });
      var renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, domProps), {}, {
          "class": mergedClassName,
          "ref": containerRef,
          "onMousedown": onInternalMouseDown,
          "onKeydown": onInternalKeyDown,
          "onKeyup": onInternalKeyUp
        }), [mockFocused.value && !mergedOpen.value && createVNode("span", {
          "style": {
            width: 0,
            height: 0,
            display: "flex",
            overflow: "hidden",
            opacity: 0
          },
          "aria-live": "polite"
        }, ["".concat(displayValues.map(function(_ref2) {
          var label = _ref2.label, value = _ref2.value;
          return ["number", "string"].includes(_typeof$3(label)) ? label : value;
        }).join(", "))]), selectorNode, arrowNode, clearNode]);
      }
      return renderNode;
    };
  }
});
var Filter = function Filter2(_ref, _ref2) {
  var _slots$default;
  var height = _ref.height, offset3 = _ref.offset, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize;
  var slots = _ref2.slots;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height: "".concat(height, "px"),
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread2$1(_objectSpread2$1({}, innerStyle), {}, {
      transform: "translateY(".concat(offset3, "px)"),
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return createVNode("div", {
    "style": outerStyle
  }, [createVNode(ResizeObserver$1, {
    "onResize": function onResize(_ref3) {
      var offsetHeight = _ref3.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, {
    default: function _default9() {
      return [createVNode("div", {
        "style": innerStyle,
        "class": classNames(_defineProperty$U({}, "".concat(prefixCls, "-holder-inner"), prefixCls))
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])];
    }
  })]);
};
Filter.displayName = "Filter";
Filter.inheritAttrs = false;
Filter.props = {
  prefixCls: String,
  height: Number,
  offset: Number,
  onInnerResize: Function
};
const Filler = Filter;
var Item$1 = function Item(_ref, _ref2) {
  var _slots$default;
  var setRef2 = _ref.setRef;
  var slots = _ref2.slots;
  var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
  return children && children.length ? cloneVNode(children[0], {
    ref: setRef2
  }) : children;
};
Item$1.props = {
  setRef: {
    type: Function,
    default: function _default() {
    }
  }
};
const Item$2 = Item$1;
var MIN_SIZE = 20;
function getPageY(e2) {
  return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
}
const ScrollBar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup: function setup26() {
    return {
      moveRaf: null,
      scrollbarRef: createRef(),
      thumbRef: createRef(),
      visibleTimeout: null,
      state: reactive({
        dragging: false,
        pageY: null,
        startTop: null,
        visible: false
      })
    };
  },
  watch: {
    scrollTop: {
      handler: function handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted: function mounted2() {
    var _this$scrollbarRef$cu, _this$thumbRef$curren;
    (_this$scrollbarRef$cu = this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.addEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
      passive: false
    } : false);
    (_this$thumbRef$curren = this.thumbRef.current) === null || _this$thumbRef$curren === void 0 ? void 0 : _this$thumbRef$curren.addEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
      passive: false
    } : false);
  },
  beforeUnmount: function beforeUnmount2() {
    this.removeEvents();
    clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden: function delayHidden() {
      var _this = this;
      clearTimeout(this.visibleTimeout);
      this.state.visible = true;
      this.visibleTimeout = setTimeout(function() {
        _this.state.visible = false;
      }, 2e3);
    },
    onScrollbarTouchStart: function onScrollbarTouchStart(e2) {
      e2.preventDefault();
    },
    onContainerMouseDown: function onContainerMouseDown(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    },
    patchEvents: function patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove);
      window.addEventListener("mouseup", this.onMouseUp);
      this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents: function removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("mouseup", this.onMouseUp);
      this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, supportsPassive$1 ? {
        passive: false
      } : false);
      this.thumbRef.current.removeEventListener("touchend", this.onMouseUp);
      wrapperRaf.cancel(this.moveRaf);
    },
    onMouseDown: function onMouseDown(e2) {
      var onStartMove = this.$props.onStartMove;
      _extends$1(this.state, {
        dragging: true,
        pageY: getPageY(e2),
        startTop: this.getTop()
      });
      onStartMove();
      this.patchEvents();
      e2.stopPropagation();
      e2.preventDefault();
    },
    onMouseMove: function onMouseMove2(e2) {
      var _this$state = this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
      var onScroll = this.$props.onScroll;
      wrapperRaf.cancel(this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e2) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = this.getEnableScrollRange();
        var enableHeightRange = this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        this.moveRaf = wrapperRaf(function() {
          onScroll(newScrollTop);
        });
      }
    },
    onMouseUp: function onMouseUp() {
      var onStopMove = this.$props.onStopMove;
      this.state.dragging = false;
      onStopMove();
      this.removeEvents();
    },
    getSpinHeight: function getSpinHeight() {
      var _this$$props = this.$props, height = _this$$props.height, count = _this$$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    },
    getEnableScrollRange: function getEnableScrollRange() {
      var _this$$props2 = this.$props, scrollHeight = _this$$props2.scrollHeight, height = _this$$props2.height;
      return scrollHeight - height || 0;
    },
    getEnableHeightRange: function getEnableHeightRange() {
      var height = this.$props.height;
      var spinHeight = this.getSpinHeight();
      return height - spinHeight || 0;
    },
    getTop: function getTop() {
      var scrollTop = this.$props.scrollTop;
      var enableScrollRange = this.getEnableScrollRange();
      var enableHeightRange = this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    },
    showScroll: function showScroll() {
      var _this$$props3 = this.$props, height = _this$$props3.height, scrollHeight = _this$$props3.scrollHeight;
      return scrollHeight > height;
    }
  },
  render: function render2() {
    var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
    var prefixCls = this.$props.prefixCls;
    var spinHeight = this.getSpinHeight() + "px";
    var top = this.getTop() + "px";
    var canScroll = this.showScroll();
    var mergedVisible = canScroll && visible;
    return createVNode("div", {
      "ref": this.scrollbarRef,
      "class": classNames("".concat(prefixCls, "-scrollbar"), _defineProperty$U({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
      "style": {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: mergedVisible ? void 0 : "none"
      },
      "onMousedown": this.onContainerMouseDown,
      "onMousemove": this.delayHidden
    }, [createVNode("div", {
      "ref": this.thumbRef,
      "class": classNames("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$U({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
      "style": {
        width: "100%",
        height: spinHeight,
        top,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      "onMousedown": this.onMouseDown
    }, null)]);
  }
});
function useHeights(mergedData, getKey3, onItemAdd, onItemRemove) {
  var instance = /* @__PURE__ */ new Map();
  var heights = /* @__PURE__ */ new Map();
  var updatedMark = ref(Symbol("update"));
  watch(mergedData, function() {
    updatedMark.value = Symbol("update");
  });
  var heightUpdateId = 0;
  function collectHeight() {
    heightUpdateId += 1;
    var currentId = heightUpdateId;
    Promise.resolve().then(function() {
      if (currentId !== heightUpdateId)
        return;
      instance.forEach(function(element, key2) {
        if (element && element.offsetParent) {
          var offsetHeight = element.offsetHeight;
          if (heights.get(key2) !== offsetHeight) {
            updatedMark.value = Symbol("update");
            heights.set(key2, element.offsetHeight);
          }
        }
      });
    });
  }
  function setInstance(item, ins) {
    var key2 = getKey3(item);
    var origin = instance.get(key2);
    if (ins) {
      instance.set(key2, ins.$el || ins);
      collectHeight();
    } else {
      instance.delete(key2);
    }
    if (!origin !== !ins) {
      if (ins) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  return [setInstance, collectHeight, heights, updatedMark];
}
function useScrollTo(containerRef, mergedData, heights, props3, getKey3, collectHeight, syncScrollTop, triggerFlash) {
  var scroll;
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf.cancel(scroll);
    var data9 = mergedData.value;
    var itemHeight2 = props3.itemHeight;
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$3(arg) === "object") {
      var index2;
      var align = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data9.findIndex(function(item) {
          return getKey3(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      var syncScroll = function syncScroll2(times, targetAlign) {
        if (times < 0 || !containerRef.value)
          return;
        var height = containerRef.value.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        if (height) {
          var mergedAlign = targetAlign || align;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data9.length, index2);
          for (var i2 = 0; i2 <= maxLen; i2 += 1) {
            var key2 = getKey3(data9[i2]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key2);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight2 : cacheHeight);
            stackTop = itemBottom;
            if (i2 === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          var scrollTop = containerRef.value.scrollTop;
          var targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scroll = wrapperRaf(function() {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll2(times - 1, newTargetAlign);
        });
      };
      syncScroll(5);
    }
  };
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$3(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const isFF$1 = isFF;
const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lock = false;
  var lockTimeout = null;
  function lockScroll() {
    clearTimeout(lockTimeout);
    lock = true;
    lockTimeout = setTimeout(function() {
      lock = false;
    }, 50);
  }
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = deltaY < 0 && isScrollAtTop.value || deltaY > 0 && isScrollAtBottom.value;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeout);
      lock = false;
    } else if (!originScroll || lock) {
      lockScroll();
    }
    return !lock && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = 0;
  var nextFrame2 = null;
  var wheelValue = null;
  var isMouseScroll = false;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event2) {
    if (!inVirtual.value)
      return;
    wrapperRaf.cancel(nextFrame2);
    var deltaY = event2.deltaY;
    offsetRef += deltaY;
    wheelValue = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF$1) {
      event2.preventDefault();
    }
    nextFrame2 = wrapperRaf(function() {
      var patchMultiple = isMouseScroll ? 10 : 1;
      onWheelDelta(offsetRef * patchMultiple);
      offsetRef = 0;
    });
  }
  function onFireFoxScroll(event2) {
    if (!inVirtual.value)
      return;
    isMouseScroll = event2.detail === wheelValue;
  }
  return [onWheel, onFireFoxScroll];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touched = false;
  var touchY = 0;
  var element = null;
  var interval = null;
  var cleanUpEvents = function cleanUpEvents2() {
    if (element) {
      element.removeEventListener("touchmove", onTouchMove);
      element.removeEventListener("touchend", onTouchEnd);
    }
  };
  var onTouchMove = function onTouchMove2(e2) {
    if (touched) {
      var currentY = Math.ceil(e2.touches[0].pageY);
      var offsetY = touchY - currentY;
      touchY = currentY;
      if (callback(offsetY)) {
        e2.preventDefault();
      }
      clearInterval(interval);
      interval = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(interval);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touched = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e2) {
    cleanUpEvents();
    if (e2.touches.length === 1 && !touched) {
      touched = true;
      touchY = Math.ceil(e2.touches[0].pageY);
      element = e2.target;
      element.addEventListener("touchmove", onTouchMove, {
        passive: false
      });
      element.addEventListener("touchend", onTouchEnd);
    }
  };
  var noop3 = function noop4() {
  };
  onMounted(function() {
    document.addEventListener("touchmove", noop3, {
      passive: false
    });
    watch(inVirtual, function(val) {
      listRef.value.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(interval);
      if (val) {
        listRef.value.addEventListener("touchstart", onTouchStart, {
          passive: false
        });
      }
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(function() {
    document.removeEventListener("touchmove", noop3);
  });
}
var _excluded$V = ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"];
var EMPTY_DATA$1 = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function renderChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey3 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node = renderFunc(item, eleIndex, {});
    var key2 = getKey3(item);
    return createVNode(Item$2, {
      "key": key2,
      "setRef": function setRef2(ele) {
        return setNodeRef(item, ele);
      }
    }, {
      default: function _default9() {
        return [node];
      }
    });
  });
}
var List$3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    data: PropTypes$1.array,
    height: Number,
    itemHeight: Number,
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: true
    },
    component: {
      type: [String, Object]
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup: function setup27(props3, _ref2) {
    var expose = _ref2.expose;
    var useVirtual = computed(function() {
      var height = props3.height, itemHeight2 = props3.itemHeight, virtual = props3.virtual;
      return !!(virtual !== false && height && itemHeight2);
    });
    var inVirtual = computed(function() {
      var height = props3.height, itemHeight2 = props3.itemHeight, data10 = props3.data;
      return useVirtual.value && data10 && itemHeight2 * data10.length > height;
    });
    var state = reactive({
      scrollTop: 0,
      scrollMoving: false
    });
    var data9 = computed(function() {
      return props3.data || EMPTY_DATA$1;
    });
    var mergedData = shallowRef([]);
    watch(data9, function() {
      mergedData.value = toRaw(data9.value).slice();
    }, {
      immediate: true
    });
    var itemKey2 = shallowRef(function(_item) {
      return void 0;
    });
    watch(function() {
      return props3.itemKey;
    }, function(val) {
      if (typeof val === "function") {
        itemKey2.value = val;
      } else {
        itemKey2.value = function(item) {
          return item === null || item === void 0 ? void 0 : item[val];
        };
      }
    }, {
      immediate: true
    });
    var componentRef = ref();
    var fillerInnerRef = ref();
    var scrollBarRef = ref();
    var getKey3 = function getKey4(item) {
      return itemKey2.value(item);
    };
    var sharedConfig = {
      getKey: getKey3
    };
    function syncScrollTop(newTop) {
      var value;
      if (typeof newTop === "function") {
        value = newTop(state.scrollTop);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      if (componentRef.value) {
        componentRef.value.scrollTop = alignedTop;
      }
      state.scrollTop = alignedTop;
    }
    var _useHeights = useHeights(mergedData, getKey3, null, null), _useHeights2 = _slicedToArray$2(_useHeights, 4), setInstance = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], updatedMark = _useHeights2[3];
    var calRes = reactive({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    });
    var offsetHeight = ref(0);
    onMounted(function() {
      nextTick(function() {
        var _fillerInnerRef$value;
        offsetHeight.value = ((_fillerInnerRef$value = fillerInnerRef.value) === null || _fillerInnerRef$value === void 0 ? void 0 : _fillerInnerRef$value.offsetHeight) || 0;
      });
    });
    onUpdated(function() {
      nextTick(function() {
        var _fillerInnerRef$value2;
        offsetHeight.value = ((_fillerInnerRef$value2 = fillerInnerRef.value) === null || _fillerInnerRef$value2 === void 0 ? void 0 : _fillerInnerRef$value2.offsetHeight) || 0;
      });
    });
    watch([useVirtual, mergedData], function() {
      if (!useVirtual.value) {
        _extends$1(calRes, {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    watch([useVirtual, mergedData, offsetHeight, inVirtual], function() {
      if (useVirtual.value && !inVirtual.value) {
        _extends$1(calRes, {
          scrollHeight: offsetHeight.value,
          start: 0,
          end: mergedData.value.length - 1,
          offset: void 0
        });
      }
    }, {
      immediate: true
    });
    watch([inVirtual, useVirtual, function() {
      return state.scrollTop;
    }, mergedData, updatedMark, function() {
      return props3.height;
    }, offsetHeight], function() {
      if (!useVirtual.value || !inVirtual.value) {
        return;
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.value.length;
      var data10 = mergedData.value;
      var scrollTop = state.scrollTop;
      var itemHeight2 = props3.itemHeight, height = props3.height;
      var scrollTopHeight = scrollTop + height;
      for (var i2 = 0; i2 < dataLen; i2 += 1) {
        var item = data10[i2];
        var key2 = getKey3(item);
        var cacheHeight = heights.get(key2);
        if (cacheHeight === void 0) {
          cacheHeight = itemHeight2;
        }
        var currentItemBottom = itemTop + cacheHeight;
        if (startIndex === void 0 && currentItemBottom >= scrollTop) {
          startIndex = i2;
          startOffset = itemTop;
        }
        if (endIndex === void 0 && currentItemBottom > scrollTopHeight) {
          endIndex = i2;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
      }
      if (endIndex === void 0) {
        endIndex = dataLen - 1;
      }
      endIndex = Math.min(endIndex + 1, dataLen);
      _extends$1(calRes, {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      });
    }, {
      immediate: true
    });
    var maxScrollHeight = computed(function() {
      return calRes.scrollHeight - props3.height;
    });
    function keepInRange(newScrollTop) {
      var newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeight.value)) {
        newTop = Math.min(newTop, maxScrollHeight.value);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    var isScrollAtTop = computed(function() {
      return state.scrollTop <= 0;
    });
    var isScrollAtBottom = computed(function() {
      return state.scrollTop >= maxScrollHeight.value;
    });
    var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
    function onScrollBar(newScrollTop) {
      var newTop = newScrollTop;
      syncScrollTop(newTop);
    }
    function onFallbackScroll(e2) {
      var _props$onScroll;
      var newScrollTop = e2.currentTarget.scrollTop;
      if (Math.abs(newScrollTop - state.scrollTop) >= 1) {
        syncScrollTop(newScrollTop);
      }
      (_props$onScroll = props3.onScroll) === null || _props$onScroll === void 0 ? void 0 : _props$onScroll.call(props3, e2);
    }
    var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
      syncScrollTop(function(top) {
        var newTop = top + offsetY;
        return newTop;
      });
    }), _useFrameWheel2 = _slicedToArray$2(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
    useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
      if (originScroll(deltaY, smoothOffset)) {
        return false;
      }
      onRawWheel({
        preventDefault: function preventDefault() {
        },
        deltaY
      });
      return true;
    });
    function onMozMousePixelScroll(e2) {
      if (useVirtual.value) {
        e2.preventDefault();
      }
    }
    var removeEventListener2 = function removeEventListener3() {
      if (componentRef.value) {
        componentRef.value.removeEventListener("wheel", onRawWheel, supportsPassive$1 ? {
          passive: false
        } : false);
        componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
    watchEffect(function() {
      nextTick(function() {
        if (componentRef.value) {
          removeEventListener2();
          componentRef.value.addEventListener("wheel", onRawWheel, supportsPassive$1 ? {
            passive: false
          } : false);
          componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll);
          componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        }
      });
    });
    onBeforeUnmount(function() {
      removeEventListener2();
    });
    var scrollTo2 = useScrollTo(componentRef, mergedData, heights, props3, getKey3, collectHeight, syncScrollTop, function() {
      var _scrollBarRef$value;
      (_scrollBarRef$value = scrollBarRef.value) === null || _scrollBarRef$value === void 0 ? void 0 : _scrollBarRef$value.delayHidden();
    });
    expose({
      scrollTo: scrollTo2
    });
    var componentStyle = computed(function() {
      var cs = null;
      if (props3.height) {
        cs = _objectSpread2$1(_defineProperty$U({}, props3.fullHeight ? "height" : "maxHeight", props3.height + "px"), ScrollStyle);
        if (useVirtual.value) {
          cs.overflowY = "hidden";
          if (state.scrollMoving) {
            cs.pointerEvents = "none";
          }
        }
      }
      return cs;
    });
    watch([function() {
      return calRes.start;
    }, function() {
      return calRes.end;
    }, mergedData], function() {
      if (props3.onVisibleChange) {
        var renderList2 = mergedData.value.slice(calRes.start, calRes.end + 1);
        props3.onVisibleChange(renderList2, mergedData.value);
      }
    }, {
      flush: "post"
    });
    return {
      state,
      mergedData,
      componentStyle,
      onFallbackScroll,
      onScrollBar,
      componentRef,
      useVirtual,
      calRes,
      collectHeight,
      setInstance,
      sharedConfig,
      scrollBarRef,
      fillerInnerRef
    };
  },
  render: function render3() {
    var _this = this;
    var _this$$props$this$$at = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$attrs), _this$$props$this$$at2 = _this$$props$this$$at.prefixCls, prefixCls = _this$$props$this$$at2 === void 0 ? "rc-virtual-list" : _this$$props$this$$at2, height = _this$$props$this$$at.height;
    _this$$props$this$$at.itemHeight;
    _this$$props$this$$at.fullHeight;
    _this$$props$this$$at.data;
    _this$$props$this$$at.itemKey;
    _this$$props$this$$at.virtual;
    var _this$$props$this$$at3 = _this$$props$this$$at.component, Component = _this$$props$this$$at3 === void 0 ? "div" : _this$$props$this$$at3;
    _this$$props$this$$at.onScroll;
    var _this$$props$this$$at4 = _this$$props$this$$at.children, children = _this$$props$this$$at4 === void 0 ? this.$slots.default : _this$$props$this$$at4, style2 = _this$$props$this$$at.style, className = _this$$props$this$$at.class, restProps = _objectWithoutProperties$2(_this$$props$this$$at, _excluded$V);
    var mergedClassName = classNames(prefixCls, className);
    var scrollTop = this.state.scrollTop;
    var _this$calRes = this.calRes, scrollHeight = _this$calRes.scrollHeight, offset3 = _this$calRes.offset, start = _this$calRes.start, end = _this$calRes.end;
    var componentStyle = this.componentStyle, onFallbackScroll = this.onFallbackScroll, onScrollBar = this.onScrollBar, useVirtual = this.useVirtual, collectHeight = this.collectHeight, sharedConfig = this.sharedConfig, setInstance = this.setInstance, mergedData = this.mergedData;
    return createVNode("div", _objectSpread2$1({
      "style": _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
        position: "relative"
      }),
      "class": mergedClassName
    }, restProps), [createVNode(Component, {
      "class": "".concat(prefixCls, "-holder"),
      "style": componentStyle,
      "ref": "componentRef",
      "onScroll": onFallbackScroll
    }, {
      default: function _default9() {
        return [createVNode(Filler, {
          "prefixCls": prefixCls,
          "height": scrollHeight,
          "offset": offset3,
          "onInnerResize": collectHeight,
          "ref": "fillerInnerRef"
        }, {
          default: function _default10() {
            return renderChildren(mergedData, start, end, setInstance, children, sharedConfig);
          }
        })];
      }
    }), useVirtual && createVNode(ScrollBar, {
      "ref": "scrollBarRef",
      "prefixCls": prefixCls,
      "scrollTop": scrollTop,
      "height": height,
      "scrollHeight": scrollHeight,
      "count": mergedData.length,
      "onScroll": onScrollBar,
      "onStartMove": function onStartMove() {
        _this.state.scrollMoving = true;
      },
      "onStopMove": function onStopMove() {
        _this.state.scrollMoving = false;
      }
    }, null)]);
  }
});
const List$4 = List$3;
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = ref(getValue2());
  watch(condition, function(next2, pre) {
    if (shouldUpdate) {
      if (shouldUpdate(next2, pre)) {
        cacheRef.value = getValue2();
      }
    } else {
      cacheRef.value = getValue2();
    }
  });
  return cacheRef;
}
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var SelectContextKey = Symbol("SelectContextKey");
function useProvideSelectProps(props3) {
  return provide(SelectContextKey, props3);
}
function useSelectProps() {
  return inject(SelectContextKey, {});
}
var _excluded$U = ["disabled", "title", "children", "style", "class", "className"];
function isTitleType(content) {
  return typeof content === "string" || typeof content === "number";
}
var OptionList$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  slots: ["option"],
  setup: function setup28(_2, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var baseProps3 = useBaseProps();
    var props3 = useSelectProps();
    var itemPrefixCls = computed(function() {
      return "".concat(baseProps3.prefixCls, "-item");
    });
    var memoFlattenOptions = useMemo(function() {
      return props3.flattenOptions;
    }, [function() {
      return baseProps3.open;
    }, function() {
      return props3.flattenOptions;
    }], function(next2) {
      return next2[0];
    });
    var listRef = createRef();
    var onListMouseDown = function onListMouseDown2(event2) {
      event2.preventDefault();
    };
    var scrollIntoView2 = function scrollIntoView3(args2) {
      if (listRef.current) {
        listRef.current.scrollTo(typeof args2 === "number" ? {
          index: args2
        } : args2);
      }
    };
    var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
      var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var len = memoFlattenOptions.value.length;
      for (var i2 = 0; i2 < len; i2 += 1) {
        var current2 = (index2 + i2 * offset3 + len) % len;
        var _memoFlattenOptions$v = memoFlattenOptions.value[current2], group2 = _memoFlattenOptions$v.group, data9 = _memoFlattenOptions$v.data;
        if (!group2 && !data9.disabled) {
          return current2;
        }
      }
      return -1;
    };
    var state = reactive({
      activeIndex: getEnabledActiveIndex(0)
    });
    var setActive = function setActive2(index2) {
      var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      state.activeIndex = index2;
      var info = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      var flattenItem = memoFlattenOptions.value[index2];
      if (!flattenItem) {
        props3.onActiveValue(null, -1, info);
        return;
      }
      props3.onActiveValue(flattenItem.value, index2, info);
    };
    watch([function() {
      return memoFlattenOptions.value.length;
    }, function() {
      return baseProps3.searchValue;
    }], function() {
      setActive(props3.defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, {
      immediate: true
    });
    var isSelected = function isSelected2(value) {
      return props3.rawValues.has(value) && baseProps3.mode !== "combobox";
    };
    watch([function() {
      return baseProps3.open;
    }, function() {
      return baseProps3.searchValue;
    }], function() {
      if (!baseProps3.multiple && baseProps3.open && props3.rawValues.size === 1) {
        var value = Array.from(props3.rawValues)[0];
        var index2 = toRaw(memoFlattenOptions.value).findIndex(function(_ref2) {
          var data9 = _ref2.data;
          return data9[props3.fieldNames.value] === value;
        });
        if (index2 !== -1) {
          setActive(index2);
          nextTick(function() {
            scrollIntoView2(index2);
          });
        }
      }
      if (baseProps3.open) {
        nextTick(function() {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var onSelectValue = function onSelectValue2(value) {
      if (value !== void 0) {
        props3.onSelect(value, {
          selected: !props3.rawValues.has(value)
        });
      }
      if (!baseProps3.multiple) {
        baseProps3.toggleOpen(false);
      }
    };
    var getLabel = function getLabel2(item) {
      return typeof item.label === "function" ? item.label() : item.label;
    };
    function renderItem(index2) {
      var item = memoFlattenOptions.value[index2];
      if (!item)
        return null;
      var itemData = item.data || {};
      var value = itemData.value;
      var group2 = item.group;
      var attrs = pickAttrs(itemData, true);
      var mergedLabel = getLabel(item);
      return item ? createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "aria-label": typeof mergedLabel === "string" && !group2 ? mergedLabel : null
      }, attrs), {}, {
        "key": index2,
        "role": group2 ? "presentation" : "option",
        "id": "".concat(baseProps3.id, "_list_").concat(index2),
        "aria-selected": isSelected(value)
      }), [value]) : null;
    }
    var onKeydown = function onKeydown2(event2) {
      var which = event2.which, ctrlKey = event2.ctrlKey;
      switch (which) {
        case KeyCode$1.N:
        case KeyCode$1.P:
        case KeyCode$1.UP:
        case KeyCode$1.DOWN: {
          var offset3 = 0;
          if (which === KeyCode$1.UP) {
            offset3 = -1;
          } else if (which === KeyCode$1.DOWN) {
            offset3 = 1;
          } else if (isPlatformMac() && ctrlKey) {
            if (which === KeyCode$1.N) {
              offset3 = 1;
            } else if (which === KeyCode$1.P) {
              offset3 = -1;
            }
          }
          if (offset3 !== 0) {
            var nextActiveIndex = getEnabledActiveIndex(state.activeIndex + offset3, offset3);
            scrollIntoView2(nextActiveIndex);
            setActive(nextActiveIndex, true);
          }
          break;
        }
        case KeyCode$1.ENTER: {
          var item = memoFlattenOptions.value[state.activeIndex];
          if (item && !item.data.disabled) {
            onSelectValue(item.value);
          } else {
            onSelectValue(void 0);
          }
          if (baseProps3.open) {
            event2.preventDefault();
          }
          break;
        }
        case KeyCode$1.ESC: {
          baseProps3.toggleOpen(false);
          if (baseProps3.open) {
            event2.stopPropagation();
          }
        }
      }
    };
    var onKeyup = function onKeyup2() {
    };
    var scrollTo2 = function scrollTo3(index2) {
      scrollIntoView2(index2);
    };
    expose({
      onKeydown,
      onKeyup,
      scrollTo: scrollTo2
    });
    return function() {
      var id = baseProps3.id, notFoundContent = baseProps3.notFoundContent, onPopupScroll = baseProps3.onPopupScroll;
      var menuItemSelectedIcon = props3.menuItemSelectedIcon, fieldNames = props3.fieldNames, virtual = props3.virtual, listHeight = props3.listHeight, listItemHeight = props3.listItemHeight;
      var renderOption = slots.option;
      var activeIndex = state.activeIndex;
      var omitFieldNameList = Object.keys(fieldNames).map(function(key2) {
        return fieldNames[key2];
      });
      if (memoFlattenOptions.value.length === 0) {
        return createVNode("div", {
          "role": "listbox",
          "id": "".concat(id, "_list"),
          "class": "".concat(itemPrefixCls.value, "-empty"),
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }
      return createVNode(Fragment, null, [createVNode("div", {
        "role": "listbox",
        "id": "".concat(id, "_list"),
        "style": {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)]), createVNode(List$4, {
        "itemKey": "key",
        "ref": listRef,
        "data": memoFlattenOptions.value,
        "height": listHeight,
        "itemHeight": listItemHeight,
        "fullHeight": false,
        "onMousedown": onListMouseDown,
        "onScroll": onPopupScroll,
        "virtual": virtual
      }, {
        default: function _default9(item, itemIndex) {
          var _classNames;
          var group2 = item.group, groupOption = item.groupOption, data9 = item.data, value = item.value;
          var key2 = data9.key;
          var label = typeof item.label === "function" ? item.label() : item.label;
          if (group2) {
            var _data$title;
            var groupTitle = (_data$title = data9.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) && label;
            return createVNode("div", {
              "class": classNames(itemPrefixCls.value, "".concat(itemPrefixCls.value, "-group")),
              "title": groupTitle
            }, [renderOption ? renderOption(data9) : label !== void 0 ? label : key2]);
          }
          var disabled = data9.disabled, title = data9.title;
          data9.children;
          var style2 = data9.style, cls = data9.class, className = data9.className, otherProps = _objectWithoutProperties$2(data9, _excluded$U);
          var passedProps = omit$2(otherProps, omitFieldNameList);
          var selected = isSelected(value);
          var optionPrefixCls = "".concat(itemPrefixCls.value, "-option");
          var optionClassName = classNames(itemPrefixCls.value, optionPrefixCls, cls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$U(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$U(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
          var mergedLabel = getLabel(item);
          var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
          var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
          var optionTitle = isTitleType(content) ? content.toString() : void 0;
          if (title !== void 0) {
            optionTitle = title;
          }
          return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, passedProps), {}, {
            "aria-selected": selected,
            "class": optionClassName,
            "title": optionTitle,
            "onMousemove": function onMousemove(e2) {
              if (otherProps.onMousemove) {
                otherProps.onMousemove(e2);
              }
              if (activeIndex === itemIndex || disabled) {
                return;
              }
              setActive(itemIndex);
            },
            "onClick": function onClick2(e2) {
              if (!disabled) {
                onSelectValue(value);
              }
              if (otherProps.onClick) {
                otherProps.onClick(e2);
              }
            },
            "style": style2
          }), [createVNode("div", {
            "class": "".concat(optionPrefixCls, "-content")
          }, [renderOption ? renderOption(data9) : content]), isValidElement(menuItemSelectedIcon) || selected, iconVisible && createVNode(TransBtn$1, {
            "class": "".concat(itemPrefixCls.value, "-option-state"),
            "customizeIcon": menuItemSelectedIcon,
            "customizeIconProps": {
              isSelected: selected
            }
          }, {
            default: function _default10() {
              return [selected ? "\u2713" : null];
            }
          })]);
        }
      })]);
    };
  }
});
const OptionList$3 = OptionList$2;
var _excluded$T = ["value", "disabled"];
function convertNodeToOption(node) {
  var key2 = node.key, children = node.children, _node$props = node.props, value = _node$props.value, disabled = _node$props.disabled, restProps = _objectWithoutProperties$2(_node$props, _excluded$T);
  var child = children === null || children === void 0 ? void 0 : children.default;
  return _objectSpread2$1({
    key: key2,
    value: value !== void 0 ? value : key2,
    children: child,
    disabled: disabled || disabled === ""
  }, restProps);
}
function convertChildrenToData$1(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dd = flattenChildren(nodes).map(function(node, index2) {
    var _children$label;
    if (!isValidElement(node) || !node.type) {
      return null;
    }
    var isSelectOptGroup = node.type.isSelectOptGroup, key2 = node.key, children = node.children, props3 = node.props;
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }
    var child = children && children.default ? children.default() : void 0;
    var label = (props3 === null || props3 === void 0 ? void 0 : props3.label) || ((_children$label = children.label) === null || _children$label === void 0 ? void 0 : _children$label.call(children)) || key2;
    return _objectSpread2$1(_objectSpread2$1({
      key: "__RC_SELECT_GRP__".concat(key2 === null ? index2 : String(key2), "__")
    }, props3), {}, {
      label,
      options: convertChildrenToData$1(child || [])
    });
  }).filter(function(data9) {
    return data9;
  });
  return dd;
}
function useOptions(options, children, fieldNames) {
  var mergedOptions = shallowRef();
  var valueOptions = shallowRef();
  var labelOptions = shallowRef();
  var tempMergedOptions = shallowRef([]);
  watch([options, children], function() {
    if (options.value) {
      tempMergedOptions.value = toRaw(options.value).slice();
    } else {
      tempMergedOptions.value = convertChildrenToData$1(children.value);
    }
  }, {
    immediate: true,
    deep: true
  });
  watchEffect(function() {
    var newOptions = tempMergedOptions.value;
    var newValueOptions = /* @__PURE__ */ new Map();
    var newLabelOptions = /* @__PURE__ */ new Map();
    var fieldNamesValue = fieldNames.value;
    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (var i2 = 0; i2 < optionList.length; i2 += 1) {
        var option = optionList[i2];
        if (!option[fieldNamesValue.options] || isChildren) {
          newValueOptions.set(option[fieldNamesValue.value], option);
          newLabelOptions.set(option[fieldNamesValue.label], option);
        } else {
          dig(option[fieldNamesValue.options], true);
        }
      }
    }
    dig(newOptions);
    mergedOptions.value = newOptions;
    valueOptions.value = newValueOptions;
    labelOptions.value = newLabelOptions;
  });
  return {
    options: mergedOptions,
    valueOptions,
    labelOptions
  };
}
var uuid$4 = 0;
var isBrowserClient = canUseDom();
function getUUID$1() {
  var retId;
  if (isBrowserClient) {
    retId = uuid$4;
    uuid$4 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId() {
  var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ref("");
  var innerId = "rc_select_".concat(getUUID$1());
  return id.value || innerId;
}
function toArray$7(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function includes(test, search) {
  return toArray$7(test).join("").toUpperCase().includes(search);
}
const useFilterOptions = function(options, fieldNames, searchValue, filterOption2, optionFilterProp) {
  return computed(function() {
    var searchValueVal = searchValue.value;
    var optionFilterPropValue = optionFilterProp === null || optionFilterProp === void 0 ? void 0 : optionFilterProp.value;
    var filterOptionValue = filterOption2 === null || filterOption2 === void 0 ? void 0 : filterOption2.value;
    if (!searchValueVal || filterOptionValue === false) {
      return options.value;
    }
    var _fieldNames$value = fieldNames.value, fieldOptions = _fieldNames$value.options, fieldLabel = _fieldNames$value.label, fieldValue = _fieldNames$value.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOptionValue === "function";
    var upperSearch = searchValueVal.toUpperCase();
    var filterFunc = customizeFilter ? filterOptionValue : function(_2, option) {
      if (optionFilterPropValue) {
        return includes(option[optionFilterPropValue], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    options.value.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValueVal, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValueVal, wrapOption(subItem));
          });
          if (subOptions.length) {
            filteredOptions.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, _defineProperty$U({}, fieldOptions, subOptions)));
          }
        }
        return;
      }
      if (filterFunc(searchValueVal, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  });
};
const useCache$1 = function(labeledValues, valueOptions) {
  var cacheRef = shallowRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  var filledLabeledValues = computed(function() {
    var _cacheRef$value = cacheRef.value, prevValueCache = _cacheRef$value.values, prevOptionCache = _cacheRef$value.options;
    var patchedValues = labeledValues.value.map(function(item) {
      if (item.label === void 0) {
        var _prevValueCache$get;
        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }
      return item;
    });
    var valueCache = /* @__PURE__ */ new Map();
    var optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach(function(item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.value.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.value.values = valueCache;
    cacheRef.value.options = optionCache;
    return patchedValues;
  });
  var getOption = function getOption2(val) {
    return valueOptions.value.get(val) || cacheRef.value.options.get(val);
  };
  return [filledLabeledValues, getOption];
};
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, _ref$value = _ref.value, value = _ref$value === void 0 ? ref() : _ref$value;
  var initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  if (value.value !== void 0) {
    initValue = unref(value);
  }
  if (defaultValue !== void 0) {
    initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
  }
  var innerValue = ref(initValue);
  var mergedValue = ref(initValue);
  watchEffect(function() {
    var val = value.value !== void 0 ? value.value : innerValue.value;
    if (option.postState) {
      val = option.postState(val);
    }
    mergedValue.value = val;
  });
  function triggerChange(newValue) {
    var preVal = mergedValue.value;
    innerValue.value = newValue;
    if (toRaw(mergedValue.value) !== newValue && option.onChange) {
      option.onChange(newValue, preVal);
    }
  }
  watch(value, function() {
    innerValue.value = value.value;
  });
  return [mergedValue, triggerChange];
}
function useState(defaultStateValue) {
  var initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
  var innerValue = ref(initValue);
  function triggerChange(newValue) {
    innerValue.value = newValue;
  }
  return [innerValue, triggerChange];
}
var OMIT_DOM_PROPS = ["inputValue"];
function selectProps$1() {
  return _objectSpread2$1(_objectSpread2$1({}, baseSelectPropsWithoutPrivate()), {}, {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    fieldNames: Object,
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    onSelect: Function,
    onDeselect: Function,
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    menuItemSelectedIcon: PropTypes$1.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    onChange: Function,
    children: Array
  });
}
function isRawValue$1(value) {
  return !value || _typeof$3(value) !== "object";
}
const Select$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Select",
  inheritAttrs: false,
  props: initDefaultProps$1(selectProps$1(), {
    prefixCls: "vc-select",
    autoClearSearchValue: true,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: true
  }),
  setup: function setup29(props3, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var mergedId = useId(toRef(props3, "id"));
    var multiple = computed(function() {
      return isMultiple(props3.mode);
    });
    var childrenAsData = computed(function() {
      return !!(!props3.options && props3.children);
    });
    var mergedFilterOption = computed(function() {
      if (props3.filterOption === void 0 && props3.mode === "combobox") {
        return false;
      }
      return props3.filterOption;
    });
    var mergedFieldNames = computed(function() {
      return fillFieldNames$3(props3.fieldNames, childrenAsData.value);
    });
    var _useMergedState = useMergedState("", {
      value: computed(function() {
        return props3.searchValue !== void 0 ? props3.searchValue : props3.inputValue;
      }),
      postState: function postState(search) {
        return search || "";
      }
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
    var parsedOptions = useOptions(toRef(props3, "options"), toRef(props3, "children"), mergedFieldNames);
    var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
    var convert2LabelValues = function convert2LabelValues2(draftValues) {
      var valueList = toArray$7(draftValues);
      return valueList.map(function(val) {
        var rawValue;
        var rawLabel;
        var rawKey;
        var rawDisabled;
        if (isRawValue$1(val)) {
          rawValue = val;
        } else {
          var _val$value;
          rawKey = val.key;
          rawLabel = val.label;
          rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
        }
        var option = valueOptions.value.get(rawValue);
        if (option) {
          var _option$key;
          if (rawLabel === void 0)
            rawLabel = option === null || option === void 0 ? void 0 : option[props3.optionLabelProp || mergedFieldNames.value.label];
          if (rawKey === void 0)
            rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
          rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawKey,
          disabled: rawDisabled,
          option
        };
      });
    };
    var _useMergedState3 = useMergedState(props3.defaultValue, {
      value: toRef(props3, "value")
    }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
    var rawLabeledValues = computed(function() {
      var _values$;
      var values = convert2LabelValues(internalValue.value);
      if (props3.mode === "combobox" && !((_values$ = values[0]) !== null && _values$ !== void 0 && _values$.value)) {
        return [];
      }
      return values;
    });
    var _useCache = useCache$1(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray$2(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
    var displayValues = computed(function() {
      if (!props3.mode && mergedValues.value.length === 1) {
        var firstValue = mergedValues.value[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.value.map(function(item) {
        var _ref2;
        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_ref2 = typeof item.label === "function" ? item.label() : item.label) !== null && _ref2 !== void 0 ? _ref2 : item.value
        });
      });
    });
    var rawValues = computed(function() {
      return new Set(mergedValues.value.map(function(val) {
        return val.value;
      }));
    });
    watchEffect(function() {
      if (props3.mode === "combobox") {
        var _mergedValues$value$;
        var strValue = (_mergedValues$value$ = mergedValues.value[0]) === null || _mergedValues$value$ === void 0 ? void 0 : _mergedValues$value$.value;
        if (strValue !== void 0 && strValue !== null) {
          setSearchValue(String(strValue));
        }
      }
    }, {
      flush: "post"
    });
    var createTagOption = function createTagOption2(val, label) {
      var _ref3;
      var mergedLabel = label !== null && label !== void 0 ? label : val;
      return _ref3 = {}, _defineProperty$U(_ref3, mergedFieldNames.value.value, val), _defineProperty$U(_ref3, mergedFieldNames.value.label, mergedLabel), _ref3;
    };
    var filledTagOptions = shallowRef();
    watchEffect(function() {
      if (props3.mode !== "tags") {
        filledTagOptions.value = mergedOptions.value;
        return;
      }
      var cloneOptions = mergedOptions.value.slice();
      var existOptions = function existOptions2(val) {
        return valueOptions.value.has(val);
      };
      _toConsumableArray(mergedValues.value).sort(function(a2, b2) {
        return a2.value < b2.value ? -1 : 1;
      }).forEach(function(item) {
        var val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      filledTagOptions.value = cloneOptions;
    });
    var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, toRef(props3, "optionFilterProp"));
    var filledSearchOptions = computed(function() {
      if (props3.mode !== "tags" || !mergedSearchValue.value || filteredOptions.value.some(function(item) {
        return item[props3.optionFilterProp || "value"] === mergedSearchValue.value;
      })) {
        return filteredOptions.value;
      }
      return [createTagOption(mergedSearchValue.value)].concat(_toConsumableArray(filteredOptions.value));
    });
    var orderedFilteredOptions = computed(function() {
      if (!props3.filterSort) {
        return filledSearchOptions.value;
      }
      return _toConsumableArray(filledSearchOptions.value).sort(function(a2, b2) {
        return props3.filterSort(a2, b2);
      });
    });
    var displayOptions = computed(function() {
      return flattenOptions(orderedFilteredOptions.value, {
        fieldNames: mergedFieldNames.value,
        childrenAsData: childrenAsData.value
      });
    });
    var triggerChange = function triggerChange2(values) {
      var labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (props3.onChange && (labeledValues.length !== mergedValues.value.length || labeledValues.some(function(newVal, index2) {
        var _mergedValues$value$i;
        return ((_mergedValues$value$i = mergedValues.value[index2]) === null || _mergedValues$value$i === void 0 ? void 0 : _mergedValues$value$i.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
      }))) {
        var returnValues = props3.labelInValue ? labeledValues.map(function(v2) {
          return _objectSpread2$1(_objectSpread2$1({}, v2), {}, {
            originLabel: v2.label,
            label: typeof v2.label === "function" ? v2.label() : v2.label
          });
        }) : labeledValues.map(function(v2) {
          return v2.value;
        });
        var returnOptions = labeledValues.map(function(v2) {
          return injectPropsWithOption(getMixedOption(v2.value));
        });
        props3.onChange(
          multiple.value ? returnValues : returnValues[0],
          multiple.value ? returnOptions : returnOptions[0]
        );
      }
    };
    var _useState = useState(null), _useState2 = _slicedToArray$2(_useState, 2), activeValue = _useState2[0], setActiveValue = _useState2[1];
    var _useState3 = useState(0), _useState4 = _slicedToArray$2(_useState3, 2), accessibilityIndex = _useState4[0], setAccessibilityIndex = _useState4[1];
    var mergedDefaultActiveFirstOption = computed(function() {
      return props3.defaultActiveFirstOption !== void 0 ? props3.defaultActiveFirstOption : props3.mode !== "combobox";
    });
    var onActiveValue = function onActiveValue2(active, index2) {
      var _ref4 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref4$source = _ref4.source, source2 = _ref4$source === void 0 ? "keyboard" : _ref4$source;
      setAccessibilityIndex(index2);
      if (props3.backfill && props3.mode === "combobox" && active !== null && source2 === "keyboard") {
        setActiveValue(String(active));
      }
    };
    var triggerSelect = function triggerSelect2(val, selected) {
      var getSelectEnt = function getSelectEnt2() {
        var _option$key2;
        var option2 = getMixedOption(val);
        var originLabel = option2 === null || option2 === void 0 ? void 0 : option2[mergedFieldNames.value.label];
        return [props3.labelInValue ? {
          label: typeof originLabel === "function" ? originLabel() : originLabel,
          originLabel,
          value: val,
          key: (_option$key2 = option2 === null || option2 === void 0 ? void 0 : option2.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
        } : val, injectPropsWithOption(option2)];
      };
      if (selected && props3.onSelect) {
        var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray$2(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], option = _getSelectEnt2[1];
        props3.onSelect(wrappedValue, option);
      } else if (!selected && props3.onDeselect) {
        var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray$2(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option = _getSelectEnt4[1];
        props3.onDeselect(_wrappedValue, _option);
      }
    };
    var onInternalSelect = function onInternalSelect2(val, info) {
      var cloneValues;
      var mergedSelect = multiple.value ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple.value ? [].concat(_toConsumableArray(mergedValues.value), [val]) : [val];
      } else {
        cloneValues = mergedValues.value.filter(function(v2) {
          return v2.value !== val;
        });
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (props3.mode === "combobox") {
        setActiveValue("");
      } else if (!multiple.value || props3.autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    };
    var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
      triggerChange(nextValues);
      if (info.type === "remove" || info.type === "clear") {
        info.values.forEach(function(item) {
          triggerSelect(item.value, false);
        });
      }
    };
    var onInternalSearch = function onInternalSearch2(searchText, info) {
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        var formatted = (searchText || "").trim();
        if (formatted) {
          var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues.value), [formatted])));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        var _props$onSearch;
        if (props3.mode === "combobox") {
          triggerChange(searchText);
        }
        (_props$onSearch = props3.onSearch) === null || _props$onSearch === void 0 ? void 0 : _props$onSearch.call(props3, searchText);
      }
    };
    var onInternalSearchSplit = function onInternalSearchSplit2(words) {
      var patchValues = words;
      if (props3.mode !== "tags") {
        patchValues = words.map(function(word) {
          var opt = labelOptions.value.get(word);
          return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter(function(val) {
          return val !== void 0;
        });
      }
      var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues.value), _toConsumableArray(patchValues))));
      triggerChange(newRawValues);
      newRawValues.forEach(function(newRawValue) {
        triggerSelect(newRawValue, true);
      });
    };
    var realVirtual = computed(function() {
      return props3.virtual !== false && props3.dropdownMatchSelectWidth !== false;
    });
    useProvideSelectProps(toReactive(_objectSpread2$1(_objectSpread2$1({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon: toRef(props3, "menuItemSelectedIcon"),
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight: toRef(props3, "listHeight"),
      listItemHeight: toRef(props3, "listItemHeight"),
      childrenAsData
    })));
    var selectRef = ref();
    expose({
      focus: function focus() {
        var _selectRef$value;
        (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
      },
      blur: function blur() {
        var _selectRef$value2;
        (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
      },
      scrollTo: function scrollTo2(arg) {
        var _selectRef$value3;
        (_selectRef$value3 = selectRef.value) === null || _selectRef$value3 === void 0 ? void 0 : _selectRef$value3.scrollTo(arg);
      }
    });
    var pickProps = computed(function() {
      return omit$2(props3, [
        "id",
        "mode",
        "prefixCls",
        "backfill",
        "fieldNames",
        "inputValue",
        "searchValue",
        "onSearch",
        "autoClearSearchValue",
        "onSelect",
        "onDeselect",
        "dropdownMatchSelectWidth",
        "filterOption",
        "filterSort",
        "optionFilterProp",
        "optionLabelProp",
        "options",
        "children",
        "defaultActiveFirstOption",
        "menuItemSelectedIcon",
        "virtual",
        "listHeight",
        "listItemHeight",
        "value",
        "defaultValue",
        "labelInValue",
        "onChange"
      ]);
    });
    return function() {
      return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
        "id": mergedId,
        "prefixCls": props3.prefixCls,
        "ref": selectRef,
        "omitDomProps": OMIT_DOM_PROPS,
        "mode": props3.mode,
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "onSearchSplit": onInternalSearchSplit,
        "dropdownMatchSelectWidth": props3.dropdownMatchSelectWidth,
        "OptionList": OptionList$3,
        "emptyOptions": !displayOptions.value.length,
        "activeValue": activeValue.value,
        "activeDescendantId": "".concat(mergedId, "_list_").concat(accessibilityIndex.value)
      }), slots);
    };
  }
});
var Option$4 = function Option() {
  return null;
};
Option$4.isSelectOption = true;
Option$4.displayName = "ASelectOption";
const Option$5 = Option$4;
var OptGroup$2 = function OptGroup() {
  return null;
};
OptGroup$2.isSelectOptGroup = true;
OptGroup$2.displayName = "ASelectOptGroup";
const OptGroup$3 = OptGroup$2;
var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
const DownOutlinedSvg = DownOutlined$2;
function _objectSpread$F(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$F(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$F(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownOutlined = function DownOutlined2(props3, context2) {
  var p2 = _objectSpread$F({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$F({}, p2, {
    "icon": DownOutlinedSvg
  }), null);
};
DownOutlined.displayName = "DownOutlined";
DownOutlined.inheritAttrs = false;
const DownOutlined$1 = DownOutlined;
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
const CheckOutlinedSvg = CheckOutlined$2;
function _objectSpread$E(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$E(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$E(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CheckOutlined = function CheckOutlined2(props3, context2) {
  var p2 = _objectSpread$E({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$E({}, p2, {
    "icon": CheckOutlinedSvg
  }), null);
};
CheckOutlined.displayName = "CheckOutlined";
CheckOutlined.inheritAttrs = false;
const CheckOutlined$1 = CheckOutlined;
var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
const SearchOutlinedSvg = SearchOutlined$2;
function _objectSpread$D(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$D(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$D(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SearchOutlined = function SearchOutlined2(props3, context2) {
  var p2 = _objectSpread$D({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$D({}, p2, {
    "icon": SearchOutlinedSvg
  }), null);
};
SearchOutlined.displayName = "SearchOutlined";
SearchOutlined.inheritAttrs = false;
const SearchOutlined$1 = SearchOutlined;
function getIcons(props3) {
  var slots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var loading = props3.loading, multiple = props3.multiple, prefixCls = props3.prefixCls;
  var suffixIcon = props3.suffixIcon || slots.suffixIcon && slots.suffixIcon();
  var clearIcon = props3.clearIcon || slots.clearIcon && slots.clearIcon();
  var menuItemSelectedIcon = props3.menuItemSelectedIcon || slots.menuItemSelectedIcon && slots.menuItemSelectedIcon();
  var removeIcon = props3.removeIcon || slots.removeIcon && slots.removeIcon();
  var mergedClearIcon = clearIcon;
  if (!clearIcon) {
    mergedClearIcon = createVNode(CloseCircleFilled$1, null, null);
  }
  var mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = suffixIcon;
  } else if (loading) {
    mergedSuffixIcon = createVNode(LoadingOutlined$1, {
      "spin": true
    }, null);
  } else {
    var iconCls = "".concat(prefixCls, "-suffix");
    mergedSuffixIcon = function mergedSuffixIcon2(_ref) {
      var open2 = _ref.open, showSearch = _ref.showSearch;
      if (open2 && showSearch) {
        return createVNode(SearchOutlined$1, {
          "class": iconCls
        }, null);
      }
      return createVNode(DownOutlined$1, {
        "class": iconCls
      }, null);
    };
  }
  var mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = createVNode(CheckOutlined$1, null, null);
  } else {
    mergedItemIcon = null;
  }
  var mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = createVNode(CloseOutlined$1, null, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
var ContextKey$1 = Symbol("ContextProps");
var InternalContextKey = Symbol("InternalContextProps");
var useProvideFormItemContext = function useProvideFormItemContext2(props3) {
  var useValidation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : computed(function() {
    return true;
  });
  var formItemFields = ref(/* @__PURE__ */ new Map());
  var addFormItemField2 = function addFormItemField3(key2, type4) {
    formItemFields.value.set(key2, type4);
    formItemFields.value = new Map(formItemFields.value);
  };
  var removeFormItemField2 = function removeFormItemField3(key2) {
    formItemFields.value.delete(key2);
    formItemFields.value = new Map(formItemFields.value);
  };
  watch([useValidation, formItemFields], function() {
  });
  provide(ContextKey$1, props3);
  provide(InternalContextKey, {
    addFormItemField: addFormItemField2,
    removeFormItemField: removeFormItemField2
  });
};
var defaultContext = {
  id: computed(function() {
    return void 0;
  }),
  onFieldBlur: function onFieldBlur() {
  },
  onFieldChange: function onFieldChange() {
  },
  clearValidate: function clearValidate() {
  }
};
var defaultInternalContext = {
  addFormItemField: function addFormItemField() {
  },
  removeFormItemField: function removeFormItemField() {
  }
};
var useInjectFormItemContext = function useInjectFormItemContext2() {
  var internalContext = inject(InternalContextKey, defaultInternalContext);
  var formItemFieldKey = Symbol("FormItemFieldKey");
  var instance = getCurrentInstance();
  internalContext.addFormItemField(formItemFieldKey, instance.type);
  onBeforeUnmount(function() {
    internalContext.removeFormItemField(formItemFieldKey);
  });
  provide(InternalContextKey, defaultInternalContext);
  provide(ContextKey$1, defaultContext);
  return inject(ContextKey$1, defaultContext);
};
const FormItemRest = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup: function setup30(_2, _ref) {
    var slots = _ref.slots;
    provide(InternalContextKey, defaultInternalContext);
    provide(ContextKey$1, defaultContext);
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var selectProps = function selectProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(selectProps$1(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {}, {
    value: {
      type: [Array, Object, String, Number]
    },
    defaultValue: {
      type: [Array, Object, String, Number]
    },
    notFoundContent: PropTypes$1.any,
    suffixIcon: PropTypes$1.any,
    itemIcon: PropTypes$1.any,
    size: String,
    mode: String,
    bordered: {
      type: Boolean,
      default: true
    },
    transitionName: String,
    choiceTransitionName: {
      type: String,
      default: ""
    },
    "onUpdate:value": Function
  });
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var Select$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: Option$5,
  OptGroup: OptGroup$3,
  inheritAttrs: false,
  props: initDefaultProps$1(selectProps(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE,
  slots: [
    "notFoundContent",
    "suffixIcon",
    "itemIcon",
    "removeIcon",
    "clearIcon",
    "dropdownRender",
    "option",
    "placeholder",
    "tagRender",
    "maxTagPlaceholder",
    "optionLabel"
  ],
  setup: function setup31(props3, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, slots = _ref.slots, expose = _ref.expose;
    var selectRef = ref();
    var formItemContext = useInjectFormItemContext();
    var focus = function focus2() {
      var _selectRef$value;
      (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
    };
    var blur = function blur2() {
      var _selectRef$value2;
      (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
    };
    var scrollTo2 = function scrollTo3(arg) {
      var _selectRef$value3;
      (_selectRef$value3 = selectRef.value) === null || _selectRef$value3 === void 0 ? void 0 : _selectRef$value3.scrollTo(arg);
    };
    var mode = computed(function() {
      var mode2 = props3.mode;
      if (mode2 === "combobox") {
        return void 0;
      }
      if (mode2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return mode2;
    });
    var _useConfigInject = useConfigInject("select", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, configProvider = _useConfigInject.configProvider, size2 = _useConfigInject.size, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var rootPrefixCls = computed(function() {
      return getPrefixCls2();
    });
    var transitionName2 = computed(function() {
      return getTransitionName$2(rootPrefixCls.value, "slide-up", props3.transitionName);
    });
    var mergedClassName = computed(function() {
      var _classNames;
      return classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-lg"), size2.value === "large"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-sm"), size2.value === "small"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-borderless"), !props3.bordered), _classNames));
    });
    var triggerChange = function triggerChange2() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      emit("update:value", args2[0]);
      emit.apply(void 0, ["change"].concat(args2));
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    expose({
      blur,
      focus,
      scrollTo: scrollTo2
    });
    var isMultiple2 = computed(function() {
      return mode.value === "multiple" || mode.value === "tags";
    });
    return function() {
      var _slots$placeholder, _slots$default;
      var notFoundContent = props3.notFoundContent, _props$listHeight = props3.listHeight, listHeight = _props$listHeight === void 0 ? 256 : _props$listHeight, _props$listItemHeight = props3.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 24 : _props$listItemHeight, getPopupContainer = props3.getPopupContainer, dropdownClassName = props3.dropdownClassName, virtual = props3.virtual, dropdownMatchSelectWidth = props3.dropdownMatchSelectWidth, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, _props$placeholder = props3.placeholder, placeholder = _props$placeholder === void 0 ? (_slots$placeholder = slots.placeholder) === null || _slots$placeholder === void 0 ? void 0 : _slots$placeholder.call(slots) : _props$placeholder;
      var renderEmpty2 = configProvider.renderEmpty, getContextPopupContainer = configProvider.getPopupContainer;
      var mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (slots.notFoundContent) {
        mergedNotFound = slots.notFoundContent();
      } else if (mode.value === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = renderEmpty2("Select");
      }
      var _getIcons = getIcons(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        multiple: isMultiple2.value,
        prefixCls: prefixCls.value
      }), slots), suffixIcon = _getIcons.suffixIcon, itemIcon = _getIcons.itemIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
      var selectProps3 = omit$2(props3, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered"]);
      var rcSelectRtlDropDownClassName = classNames(dropdownClassName, _defineProperty$U({}, "".concat(prefixCls.value, "-dropdown-").concat(direction.value), direction.value === "rtl"));
      return createVNode(Select$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": selectRef,
        "virtual": virtual,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth
      }, selectProps3), attrs), {}, {
        "placeholder": placeholder,
        "listHeight": listHeight,
        "listItemHeight": listItemHeight,
        "mode": mode.value,
        "prefixCls": prefixCls.value,
        "direction": direction.value,
        "inputIcon": suffixIcon,
        "menuItemSelectedIcon": itemIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "notFoundContent": mergedNotFound,
        "class": [mergedClassName.value, attrs.class],
        "getPopupContainer": getPopupContainer || getContextPopupContainer,
        "dropdownClassName": rcSelectRtlDropDownClassName,
        "onChange": triggerChange,
        "onBlur": handleBlur,
        "id": id,
        "dropdownRender": selectProps3.dropdownRender || slots.dropdownRender,
        "transitionName": transitionName2.value,
        "children": (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots),
        "tagRender": props3.tagRender || slots.tagRender,
        "optionLabelRender": slots.optionLabel,
        "maxTagPlaceholder": props3.maxTagPlaceholder || slots.maxTagPlaceholder
      }), {
        option: slots.option
      });
    };
  }
});
Select$1.install = function(app) {
  app.component(Select$1.name, Select$1);
  app.component(Select$1.Option.displayName, Select$1.Option);
  app.component(Select$1.OptGroup.displayName, Select$1.OptGroup);
  return app;
};
var SelectOption = Select$1.Option;
var SelectOptGroup = Select$1.OptGroup;
const VcSelect = Select$1;
var Option$2 = function Option2() {
  return null;
};
Option$2.isSelectOption = true;
Option$2.displayName = "AAutoCompleteOption";
const Option$3 = Option$2;
var OptGroup2 = function OptGroup3() {
  return null;
};
OptGroup2.isSelectOptGroup = true;
OptGroup2.displayName = "AAutoCompleteOptGroup";
const OptGroup$1 = OptGroup2;
function isSelectOptionOrSelectOptGroup(child) {
  var _child$type, _child$type2;
  return (child === null || child === void 0 ? void 0 : (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.isSelectOption) || (child === null || child === void 0 ? void 0 : (_child$type2 = child.type) === null || _child$type2 === void 0 ? void 0 : _child$type2.isSelectOptGroup);
}
var autoCompleteProps = function autoCompleteProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(selectProps(), ["loading", "mode", "optionLabelProp", "labelInValue"])), {}, {
    dataSource: Array,
    dropdownMenuStyle: {
      type: Object,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: true
    },
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    choiceTransitionName: {
      type: String,
      default: "zoom"
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    backfill: {
      type: Boolean,
      default: void 0
    },
    filterOption: {
      type: [Boolean, Function],
      default: false
    },
    defaultActiveFirstOption: {
      type: Boolean,
      default: true
    }
  });
};
var AutoCompleteOption = Option$3;
var AutoCompleteOptGroup = OptGroup$1;
var AutoComplete = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAutoComplete",
  inheritAttrs: false,
  props: autoCompleteProps(),
  slots: ["option"],
  setup: function setup32(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    warning$2(!("dataSource" in slots), "AutoComplete", "`dataSource` slot is deprecated, please use props `options` instead.");
    warning$2(!("options" in slots), "AutoComplete", "`options` slot is deprecated, please use props `options` instead.");
    var selectRef = ref();
    var getInputElement = function getInputElement2() {
      var _slots$default;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var element = children.length ? children[0] : void 0;
      return element;
    };
    var focus = function focus2() {
      var _selectRef$value;
      (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
    };
    var blur = function blur2() {
      var _selectRef$value2;
      (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
    };
    expose({
      focus,
      blur
    });
    var _useConfigInject = useConfigInject("select", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _slots$notFoundConten, _cls;
      var size2 = props3.size, dataSource = props3.dataSource, _props$notFoundConten = props3.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? (_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots) : _props$notFoundConten;
      var optionChildren;
      var className = attrs.class;
      var cls = (_cls = {}, _defineProperty$U(_cls, className, !!className), _defineProperty$U(_cls, "".concat(prefixCls.value, "-lg"), size2 === "large"), _defineProperty$U(_cls, "".concat(prefixCls.value, "-sm"), size2 === "small"), _defineProperty$U(_cls, "".concat(prefixCls.value, "-show-search"), true), _defineProperty$U(_cls, "".concat(prefixCls.value, "-auto-complete"), true), _cls);
      if (props3.options === void 0) {
        var _slots$dataSource, _slots$options;
        var childArray = ((_slots$dataSource = slots.dataSource) === null || _slots$dataSource === void 0 ? void 0 : _slots$dataSource.call(slots)) || ((_slots$options = slots.options) === null || _slots$options === void 0 ? void 0 : _slots$options.call(slots)) || [];
        if (childArray.length && isSelectOptionOrSelectOptGroup(childArray[0])) {
          optionChildren = childArray;
        } else {
          optionChildren = dataSource ? dataSource.map(function(item) {
            if (isValidElement(item)) {
              return item;
            }
            switch (_typeof$3(item)) {
              case "string":
                return createVNode(Option$3, {
                  "key": item,
                  "value": item
                }, {
                  default: function _default9() {
                    return [item];
                  }
                });
              case "object":
                return createVNode(Option$3, {
                  "key": item.value,
                  "value": item.value
                }, {
                  default: function _default9() {
                    return [item.text];
                  }
                });
              default:
                throw new Error("AutoComplete[dataSource] only supports type `string[] | Object[]`.");
            }
          }) : [];
        }
      }
      var selectProps3 = omit$2(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        mode: VcSelect.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        getInputElement,
        notFoundContent,
        class: cls,
        ref: selectRef
      }), ["dataSource", "loading"]);
      return createVNode(VcSelect, selectProps3, _objectSpread2$1({
        default: function _default9() {
          return [optionChildren];
        }
      }, omit$2(slots, ["default", "dataSource", "options"])));
    };
  }
});
const AutoComplete$1 = _extends$1(AutoComplete, {
  Option: Option$3,
  OptGroup: OptGroup$1,
  install: function install(app) {
    app.component(AutoComplete.name, AutoComplete);
    app.component(Option$3.displayName, Option$3);
    app.component(OptGroup$1.displayName, OptGroup$1);
    return app;
  }
});
var iconMapFilled = {
  success: CheckCircleFilled$1,
  info: InfoCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1
};
var iconMapOutlined = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
var AlertTypes = tuple$1("success", "info", "warning", "error");
var alertProps = function alertProps2() {
  return {
    type: PropTypes$1.oneOf(AlertTypes),
    closable: {
      type: Boolean,
      default: void 0
    },
    closeText: PropTypes$1.any,
    message: PropTypes$1.any,
    description: PropTypes$1.any,
    afterClose: Function,
    showIcon: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    banner: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    closeIcon: PropTypes$1.any,
    onClose: Function
  };
};
var Alert = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAlert",
  inheritAttrs: false,
  props: alertProps(),
  setup: function setup33(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var _useConfigInject = useConfigInject("alert", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var closing = ref(false);
    var closed = ref(false);
    var alertNode = ref();
    var handleClose = function handleClose2(e2) {
      e2.preventDefault();
      var dom = alertNode.value;
      dom.style.height = "".concat(dom.offsetHeight, "px");
      dom.style.height = "".concat(dom.offsetHeight, "px");
      closing.value = true;
      emit("close", e2);
    };
    var animationEnd = function animationEnd2() {
      var _props$afterClose;
      closing.value = false;
      closed.value = true;
      (_props$afterClose = props3.afterClose) === null || _props$afterClose === void 0 ? void 0 : _props$afterClose.call(props3);
    };
    expose({
      animationEnd
    });
    var motionStyle = ref({});
    return function() {
      var _slots$closeIcon, _classNames;
      var banner = props3.banner, _props$closeIcon = props3.closeIcon, customCloseIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : _props$closeIcon;
      var closable = props3.closable, type4 = props3.type, showIcon = props3.showIcon;
      var closeText = getPropsSlot(slots, props3, "closeText");
      var description = getPropsSlot(slots, props3, "description");
      var message2 = getPropsSlot(slots, props3, "message");
      var icon = getPropsSlot(slots, props3, "icon");
      showIcon = banner && showIcon === void 0 ? true : showIcon;
      type4 = banner && type4 === void 0 ? "warning" : type4 || "info";
      var IconType = (description ? iconMapOutlined : iconMapFilled)[type4] || null;
      if (closeText) {
        closable = true;
      }
      var prefixClsValue = prefixCls.value;
      var alertCls = classNames(prefixClsValue, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixClsValue, "-").concat(type4), true), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-closing"), closing.value), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-with-description"), !!description), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-no-icon"), !showIcon), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-banner"), !!banner), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-closable"), closable), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-rtl"), direction.value === "rtl"), _classNames));
      var closeIcon = closable ? createVNode("button", {
        "type": "button",
        "onClick": handleClose,
        "class": "".concat(prefixClsValue, "-close-icon"),
        "tabindex": 0
      }, [closeText ? createVNode("span", {
        "class": "".concat(prefixClsValue, "-close-text")
      }, [closeText]) : customCloseIcon === void 0 ? createVNode(CloseOutlined$1, null, null) : customCloseIcon]) : null;
      var iconNode = icon && (isValidElement(icon) ? cloneElement(icon, {
        class: "".concat(prefixClsValue, "-icon")
      }) : createVNode("span", {
        "class": "".concat(prefixClsValue, "-icon")
      }, [icon])) || createVNode(IconType, {
        "class": "".concat(prefixClsValue, "-icon")
      }, null);
      var transitionProps = getTransitionProps("".concat(prefixClsValue, "-motion"), {
        appear: false,
        css: true,
        onAfterLeave: animationEnd,
        onBeforeLeave: function onBeforeLeave(node) {
          node.style.maxHeight = "".concat(node.offsetHeight, "px");
        },
        onLeave: function onLeave(node) {
          node.style.maxHeight = "0px";
        }
      });
      return closed.value ? null : createVNode(Transition$1, transitionProps, {
        default: function _default9() {
          return [withDirectives(createVNode("div", _objectSpread2$1(_objectSpread2$1({
            "role": "alert"
          }, attrs), {}, {
            "style": [attrs.style, motionStyle.value],
            "class": [attrs.class, alertCls],
            "data-show": !closing.value,
            "ref": alertNode
          }), [showIcon ? iconNode : null, createVNode("div", {
            "class": "".concat(prefixClsValue, "-content")
          }, [message2 ? createVNode("div", {
            "class": "".concat(prefixClsValue, "-message")
          }, [message2]) : null, description ? createVNode("div", {
            "class": "".concat(prefixClsValue, "-description")
          }, [description]) : null]), closeIcon]), [[vShow, !closing.value]])];
        }
      });
    };
  }
});
const Alert$1 = withInstall(Alert);
var responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)",
  xxxl: "(min-width: 2000px)"
};
var subscribers = /* @__PURE__ */ new Map();
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch: function dispatch(pointMap) {
    screens = pointMap;
    subscribers.forEach(function(func) {
      return func(screens);
    });
    return subscribers.size >= 1;
  },
  subscribe: function subscribe(func) {
    if (!subscribers.size)
      this.register();
    subUid += 1;
    subscribers.set(subUid, func);
    func(screens);
    return subUid;
  },
  unsubscribe: function unsubscribe(token2) {
    subscribers.delete(token2);
    if (!subscribers.size)
      this.unregister();
  },
  unregister: function unregister() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var handler5 = _this.matchHandlers[matchMediaQuery];
      handler5 === null || handler5 === void 0 ? void 0 : handler5.mql.removeListener(handler5 === null || handler5 === void 0 ? void 0 : handler5.listener);
    });
    subscribers.clear();
  },
  register: function register() {
    var _this2 = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var listener = function listener2(_ref) {
        var matches2 = _ref.matches;
        _this2.dispatch(_objectSpread2$1(_objectSpread2$1({}, screens), {}, _defineProperty$U({}, screen, matches2)));
      };
      var mql = window.matchMedia(matchMediaQuery);
      mql.addListener(listener);
      _this2.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};
const ResponsiveObserve = responsiveObserve;
function useBreakpoint() {
  var screens2 = ref({});
  var token2 = null;
  onMounted(function() {
    token2 = ResponsiveObserve.subscribe(function(supportScreens) {
      screens2.value = supportScreens;
    });
  });
  onUnmounted(function() {
    ResponsiveObserve.unsubscribe(token2);
  });
  return screens2;
}
var sizeProvider = Symbol("SizeProvider");
var useProvideSize = function useProvideSize2(props3) {
  var configProvider = inject("configProvider", defaultConfigProvider);
  var size2 = computed(function() {
    return props3.size || configProvider.componentSize;
  });
  provide(sizeProvider, size2);
  return size2;
};
var useInjectSize = function useInjectSize2(props3) {
  var size2 = props3 ? computed(function() {
    return props3.size;
  }) : inject(sizeProvider, computed(function() {
    return "default";
  }));
  return size2;
};
const useProvideSize$1 = useProvideSize;
function eagerComputed(fn) {
  var result = shallowRef();
  watchEffect(function() {
    result.value = fn();
  }, {
    flush: "sync"
  });
  return result;
}
var avatarProps$1 = function avatarProps() {
  return {
    prefixCls: String,
    shape: {
      type: String,
      default: "circle"
    },
    size: {
      type: [Number, String, Object],
      default: function _default9() {
        return "default";
      }
    },
    src: String,
    srcset: String,
    icon: PropTypes$1.any,
    alt: String,
    gap: Number,
    draggable: {
      type: Boolean,
      default: void 0
    },
    crossOrigin: String,
    loadError: {
      type: Function
    }
  };
};
var Avatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: false,
  props: avatarProps$1(),
  slots: ["icon"],
  setup: function setup34(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var isImgExist = ref(true);
    var isMounted = ref(false);
    var scale = ref(1);
    var avatarChildrenRef = ref(null);
    var avatarNodeRef = ref(null);
    var _useConfigInject = useConfigInject("avatar", props3), prefixCls = _useConfigInject.prefixCls;
    var groupSize = useInjectSize();
    var size2 = computed(function() {
      return props3.size === "default" ? groupSize.value : props3.size;
    });
    var screens2 = useBreakpoint();
    var responsiveSize = eagerComputed(function() {
      if (_typeof$3(props3.size) !== "object") {
        return void 0;
      }
      var currentBreakpoint = responsiveArray.find(function(screen) {
        return screens2.value[screen];
      });
      var currentSize = props3.size[currentBreakpoint];
      return currentSize;
    });
    var responsiveSizeStyle = function responsiveSizeStyle2(hasIcon) {
      if (responsiveSize.value) {
        return {
          width: "".concat(responsiveSize.value, "px"),
          height: "".concat(responsiveSize.value, "px"),
          lineHeight: "".concat(responsiveSize.value, "px"),
          fontSize: "".concat(hasIcon ? responsiveSize.value / 2 : 18, "px")
        };
      }
      return {};
    };
    var setScaleParam = function setScaleParam2() {
      if (!avatarChildrenRef.value || !avatarNodeRef.value) {
        return;
      }
      var childrenWidth = avatarChildrenRef.value.offsetWidth;
      var nodeWidth = avatarNodeRef.value.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        var _props$gap = props3.gap, gap = _props$gap === void 0 ? 4 : _props$gap;
        if (gap * 2 < nodeWidth) {
          scale.value = nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1;
        }
      }
    };
    var handleImgLoadError = function handleImgLoadError2() {
      var loadError = props3.loadError;
      var errorFlag = loadError === null || loadError === void 0 ? void 0 : loadError();
      if (errorFlag !== false) {
        isImgExist.value = false;
      }
    };
    watch(function() {
      return props3.src;
    }, function() {
      nextTick(function() {
        isImgExist.value = true;
        scale.value = 1;
      });
    });
    watch(function() {
      return props3.gap;
    }, function() {
      nextTick(function() {
        setScaleParam();
      });
    });
    onMounted(function() {
      nextTick(function() {
        setScaleParam();
        isMounted.value = true;
      });
    });
    return function() {
      var _classString, _slots$default;
      var shape = props3.shape, src2 = props3.src, alt = props3.alt, srcset = props3.srcset, draggable = props3.draggable, crossOrigin = props3.crossOrigin;
      var icon = getPropsSlot(slots, props3, "icon");
      var pre = prefixCls.value;
      var classString = (_classString = {}, _defineProperty$U(_classString, "".concat(attrs.class), !!attrs.class), _defineProperty$U(_classString, pre, true), _defineProperty$U(_classString, "".concat(pre, "-lg"), size2.value === "large"), _defineProperty$U(_classString, "".concat(pre, "-sm"), size2.value === "small"), _defineProperty$U(_classString, "".concat(pre, "-").concat(shape), shape), _defineProperty$U(_classString, "".concat(pre, "-image"), src2 && isImgExist.value), _defineProperty$U(_classString, "".concat(pre, "-icon"), icon), _classString);
      var sizeStyle = typeof size2.value === "number" ? {
        width: "".concat(size2.value, "px"),
        height: "".concat(size2.value, "px"),
        lineHeight: "".concat(size2.value, "px"),
        fontSize: icon ? "".concat(size2.value / 2, "px") : "18px"
      } : {};
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var childrenToRender;
      if (src2 && isImgExist.value) {
        childrenToRender = createVNode("img", {
          "draggable": draggable,
          "src": src2,
          "srcset": srcset,
          "onError": handleImgLoadError,
          "alt": alt,
          "crossorigin": crossOrigin
        }, null);
      } else if (icon) {
        childrenToRender = icon;
      } else if (isMounted.value || scale.value !== 1) {
        var transformString = "scale(".concat(scale.value, ") translateX(-50%)");
        var childrenStyle = {
          msTransform: transformString,
          WebkitTransform: transformString,
          transform: transformString
        };
        var sizeChildrenStyle = typeof size2.value === "number" ? {
          lineHeight: "".concat(size2.value, "px")
        } : {};
        childrenToRender = createVNode(ResizeObserver$1, {
          "onResize": setScaleParam
        }, {
          default: function _default9() {
            return [createVNode("span", {
              "class": "".concat(pre, "-string"),
              "ref": avatarChildrenRef,
              "style": _objectSpread2$1(_objectSpread2$1({}, sizeChildrenStyle), childrenStyle)
            }, [children])];
          }
        });
      } else {
        childrenToRender = createVNode("span", {
          "class": "".concat(pre, "-string"),
          "ref": avatarChildrenRef,
          "style": {
            opacity: 0
          }
        }, [children]);
      }
      return createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "ref": avatarNodeRef,
        "class": classString,
        "style": [sizeStyle, responsiveSizeStyle(!!icon), attrs.style]
      }), [childrenToRender]);
    };
  }
});
const Avatar$1 = Avatar;
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$3 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
var tooltipContentProps = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: PropTypes$1.any
};
const Content$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Content",
  props: tooltipContentProps,
  slots: ["overlay"],
  setup: function setup35(props3, _ref) {
    var slots = _ref.slots;
    return function() {
      var _slots$overlay;
      return createVNode("div", {
        "class": "".concat(props3.prefixCls, "-inner"),
        "id": props3.id,
        "role": "tooltip",
        "style": props3.overlayInnerStyle
      }, [(_slots$overlay = slots.overlay) === null || _slots$overlay === void 0 ? void 0 : _slots$overlay.call(slots)]);
    };
  }
});
var _excluded$S = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"];
function noop$a() {
}
const Tooltip$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: false,
  props: {
    trigger: PropTypes$1.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: PropTypes$1.string.def("right"),
    transitionName: String,
    animation: PropTypes$1.any,
    afterVisibleChange: PropTypes$1.func.def(function() {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: PropTypes$1.string.def("rc-tooltip"),
    mouseEnterDelay: PropTypes$1.number.def(0.1),
    mouseLeaveDelay: PropTypes$1.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: false
    },
    align: PropTypes$1.object.def(function() {
      return {};
    }),
    arrowContent: PropTypes$1.any.def(null),
    tipId: String,
    builtinPlacements: PropTypes$1.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function
  },
  slots: ["arrowContent", "overlay"],
  setup: function setup36(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var triggerDOM = ref();
    var getPopupElement = function getPopupElement2() {
      var prefixCls = props3.prefixCls, tipId = props3.tipId, overlayInnerStyle = props3.overlayInnerStyle;
      return [createVNode("div", {
        "class": "".concat(prefixCls, "-arrow"),
        "key": "arrow"
      }, [getPropsSlot(slots, props3, "arrowContent")]), createVNode(Content$2, {
        "key": "content",
        "prefixCls": prefixCls,
        "id": tipId,
        "overlayInnerStyle": overlayInnerStyle
      }, {
        overlay: slots.overlay
      })];
    };
    var getPopupDomNode2 = function getPopupDomNode3() {
      return triggerDOM.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode: getPopupDomNode2,
      triggerDOM,
      forcePopupAlign: function forcePopupAlign2() {
        var _triggerDOM$value;
        return (_triggerDOM$value = triggerDOM.value) === null || _triggerDOM$value === void 0 ? void 0 : _triggerDOM$value.forcePopupAlign();
      }
    });
    var destroyTooltip = ref(false);
    var autoDestroy = ref(false);
    watchEffect(function() {
      var destroyTooltipOnHide = props3.destroyTooltipOnHide;
      if (typeof destroyTooltipOnHide === "boolean") {
        destroyTooltip.value = destroyTooltipOnHide;
      } else if (destroyTooltipOnHide && _typeof$3(destroyTooltipOnHide) === "object") {
        var keepParent = destroyTooltipOnHide.keepParent;
        destroyTooltip.value = keepParent === true;
        autoDestroy.value = keepParent === false;
      }
    });
    return function() {
      var overlayClassName = props3.overlayClassName, trigger2 = props3.trigger, mouseEnterDelay = props3.mouseEnterDelay, mouseLeaveDelay = props3.mouseLeaveDelay, overlayStyle = props3.overlayStyle, prefixCls = props3.prefixCls, afterVisibleChange2 = props3.afterVisibleChange, transitionName2 = props3.transitionName, animation = props3.animation, placement = props3.placement, align = props3.align;
      props3.destroyTooltipOnHide;
      var defaultVisible = props3.defaultVisible, restProps = _objectWithoutProperties$2(props3, _excluded$S);
      var extraProps = _objectSpread2$1({}, restProps);
      if (props3.visible !== void 0) {
        extraProps.popupVisible = props3.visible;
      }
      var triggerProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        popupClassName: overlayClassName,
        prefixCls,
        action: trigger2,
        builtinPlacements: placements$3,
        popupPlacement: placement,
        popupAlign: align,
        afterPopupVisibleChange: afterVisibleChange2,
        popupTransitionName: transitionName2,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltip.value,
        autoDestroy: autoDestroy.value,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay
      }, extraProps), attrs), {}, {
        onPopupVisibleChange: props3.onVisibleChange || noop$a,
        onPopupAlign: props3.onPopupAlign || noop$a,
        ref: triggerDOM,
        popup: getPopupElement()
      });
      return createVNode(Trigger, triggerProps, {
        default: slots.default
      });
    };
  }
});
var PresetStatusColorTypes = tuple$1("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple$1("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");
const abstractTooltipProps = function() {
  return {
    trigger: [String, Array],
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    placement: String,
    color: String,
    transitionName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    openClassName: String,
    prefixCls: String,
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    getPopupContainer: Function,
    arrowPointAtCenter: {
      type: Boolean,
      default: void 0
    },
    autoAdjustOverflow: {
      type: [Boolean, Object],
      default: void 0
    },
    destroyTooltipOnHide: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object,
      default: void 0
    },
    builtinPlacements: {
      type: Object,
      default: void 0
    },
    children: Array,
    onVisibleChange: Function,
    "onUpdate:visible": Function
  };
};
var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _objectSpread2$1(_objectSpread2$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow2 = config.autoAdjustOverflow, arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function(key2) {
    placementMap[key2] = arrowPointAtCenter ? _objectSpread2$1(_objectSpread2$1({}, placementMap[key2]), {}, {
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : _objectSpread2$1(_objectSpread2$1({}, placements$3[key2]), {}, {
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key2].ignoreShake = true;
  });
  return placementMap;
}
function firstNotUndefined() {
  var arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    if (arr[i2] !== void 0) {
      return arr[i2];
    }
  }
  return void 0;
}
var splitObject = function splitObject2(obj, keys2) {
  var picked = {};
  var omitted = _objectSpread2$1({}, obj);
  keys2.forEach(function(key2) {
    if (obj && key2 in obj) {
      picked[key2] = obj[key2];
      delete omitted[key2];
    }
  });
  return {
    picked,
    omitted
  };
};
var PresetColorRegex$1 = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
var tooltipProps = function tooltipProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
    title: PropTypes$1.any
  });
};
var tooltipDefaultProps = function tooltipDefaultProps2() {
  return {
    trigger: "hover",
    transitionName: "zoom-big-fast",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  };
};
const ToolTip = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: false,
  props: initDefaultProps$1(tooltipProps(), {
    trigger: "hover",
    transitionName: "zoom-big-fast",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  }),
  slots: ["title"],
  setup: function setup37(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var _useConfigInject = useConfigInject("tooltip", props3), prefixCls = _useConfigInject.prefixCls, getPopupContainer = _useConfigInject.getPopupContainer;
    var visible = ref(firstNotUndefined([props3.visible, props3.defaultVisible]));
    var tooltip = ref();
    onMounted(function() {
      warning$2(props3.defaultVisible === void 0, "Tooltip", "'defaultVisible' is deprecated, please use 'v-model:visible'");
    });
    var rafId;
    watch(function() {
      return props3.visible;
    }, function(val) {
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(function() {
        visible.value = !!val;
      });
    });
    var isNoTitle = function isNoTitle2() {
      var _props$title;
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : slots.title;
      return !title && title !== 0;
    };
    var handleVisibleChange = function handleVisibleChange2(val) {
      var noTitle = isNoTitle();
      if (props3.visible === void 0) {
        visible.value = noTitle ? false : val;
      }
      if (!noTitle) {
        emit("update:visible", val);
        emit("visibleChange", val);
      }
    };
    var getPopupDomNode2 = function getPopupDomNode3() {
      return tooltip.value.getPopupDomNode();
    };
    expose({
      getPopupDomNode: getPopupDomNode2,
      visible,
      forcePopupAlign: function forcePopupAlign2() {
        var _tooltip$value;
        return (_tooltip$value = tooltip.value) === null || _tooltip$value === void 0 ? void 0 : _tooltip$value.forcePopupAlign();
      }
    });
    var tooltipPlacements = computed(function() {
      var builtinPlacements = props3.builtinPlacements, arrowPointAtCenter = props3.arrowPointAtCenter, autoAdjustOverflow2 = props3.autoAdjustOverflow;
      return builtinPlacements || getPlacements({
        arrowPointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2
      });
    });
    var isTrueProps = function isTrueProps2(val) {
      return val || val === "";
    };
    var getDisabledCompatibleChildren = function getDisabledCompatibleChildren2(ele) {
      var elementType = ele.type;
      if (_typeof$3(elementType) === "object" && ele.props) {
        if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading))) {
          var _splitObject = splitObject(getStyle(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), picked = _splitObject.picked, omitted = _splitObject.omitted;
          var spanStyle = _objectSpread2$1(_objectSpread2$1({
            display: "inline-block"
          }, picked), {}, {
            cursor: "not-allowed",
            lineHeight: 1,
            width: ele.props && ele.props.block ? "100%" : null
          });
          var buttonStyle = _objectSpread2$1(_objectSpread2$1({}, omitted), {}, {
            pointerEvents: "none"
          });
          var child = cloneElement(ele, {
            style: buttonStyle
          }, true);
          return createVNode("span", {
            "style": spanStyle,
            "class": "".concat(prefixCls.value, "-disabled-compatible-wrapper")
          }, [child]);
        }
      }
      return ele;
    };
    var getOverlay = function getOverlay2() {
      var _props$title2, _slots$title;
      return (_props$title2 = props3.title) !== null && _props$title2 !== void 0 ? _props$title2 : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
    };
    var onPopupAlign = function onPopupAlign2(domNode, align) {
      var placements2 = tooltipPlacements.value;
      var placement = Object.keys(placements2).filter(function(key2) {
        return placements2[key2].points[0] === align.points[0] && placements2[key2].points[1] === align.points[1];
      })[0];
      if (!placement) {
        return;
      }
      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: "50%",
        left: "50%"
      };
      if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
        transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
      } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
        transformOrigin.top = "".concat(-align.offset[1], "px");
      }
      if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
        transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
      } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
        transformOrigin.left = "".concat(-align.offset[0], "px");
      }
      domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
    };
    return function() {
      var _filterEmpty, _slots$default, _classNames;
      var openClassName = props3.openClassName, color = props3.color, overlayClassName = props3.overlayClassName;
      var children = (_filterEmpty = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))) !== null && _filterEmpty !== void 0 ? _filterEmpty : null;
      children = children.length === 1 ? children[0] : children;
      var tempVisible = visible.value;
      if (props3.visible === void 0 && isNoTitle()) {
        tempVisible = false;
      }
      if (!children) {
        return null;
      }
      var child = getDisabledCompatibleChildren(isValidElement(children) ? children : createVNode("span", null, [children]));
      var childCls = classNames((_classNames = {}, _defineProperty$U(_classNames, openClassName || "".concat(prefixCls.value, "-open"), true), _defineProperty$U(_classNames, child.props && child.props.class, child.props && child.props.class), _classNames));
      var customOverlayClassName = classNames(overlayClassName, _defineProperty$U({}, "".concat(prefixCls.value, "-").concat(color), color && PresetColorRegex$1.test(color)));
      var formattedOverlayInnerStyle;
      var arrowContentStyle;
      if (color && !PresetColorRegex$1.test(color)) {
        formattedOverlayInnerStyle = {
          backgroundColor: color
        };
        arrowContentStyle = {
          backgroundColor: color
        };
      }
      var vcTooltipProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props3), {}, {
        prefixCls: prefixCls.value,
        getPopupContainer: getPopupContainer.value,
        builtinPlacements: tooltipPlacements.value,
        visible: tempVisible,
        ref: tooltip,
        overlayClassName: customOverlayClassName,
        overlayInnerStyle: formattedOverlayInnerStyle,
        onVisibleChange: handleVisibleChange,
        onPopupAlign
      });
      return createVNode(Tooltip$1, vcTooltipProps, {
        default: function _default9() {
          return [visible.value ? cloneElement(child, {
            class: childCls
          }) : child];
        },
        arrowContent: function arrowContent() {
          return createVNode("span", {
            "class": "".concat(prefixCls.value, "-arrow-content"),
            "style": arrowContentStyle
          }, null);
        },
        overlay: getOverlay
      });
    };
  }
});
const Tooltip = withInstall(ToolTip);
var popoverProps = function popoverProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
    content: PropTypes$1.any,
    title: PropTypes$1.any
  });
};
var Popover = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  props: initDefaultProps$1(popoverProps(), _objectSpread2$1(_objectSpread2$1({}, tooltipDefaultProps()), {}, {
    trigger: "hover",
    transitionName: "zoom-big",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup: function setup38(props3, _ref) {
    var expose = _ref.expose, slots = _ref.slots;
    var tooltipRef = ref();
    expose({
      getPopupDomNode: function getPopupDomNode2() {
        var _tooltipRef$value, _tooltipRef$value$get;
        return (_tooltipRef$value = tooltipRef.value) === null || _tooltipRef$value === void 0 ? void 0 : (_tooltipRef$value$get = _tooltipRef$value.getPopupDomNode) === null || _tooltipRef$value$get === void 0 ? void 0 : _tooltipRef$value$get.call(_tooltipRef$value);
      }
    });
    var _useConfigInject = useConfigInject("popover", props3), prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider;
    var rootPrefixCls = computed(function() {
      return configProvider.getPrefixCls();
    });
    var getOverlay = function getOverlay2() {
      var _slots$title, _slots$content;
      var _props$title = props3.title, title = _props$title === void 0 ? filterEmpty((_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots)) : _props$title, _props$content = props3.content, content = _props$content === void 0 ? filterEmpty((_slots$content = slots.content) === null || _slots$content === void 0 ? void 0 : _slots$content.call(slots)) : _props$content;
      var hasTitle = !!(Array.isArray(title) ? title.length : title);
      var hasContent = !!(Array.isArray(content) ? content.length : title);
      if (!hasTitle && !hasContent)
        return void 0;
      return createVNode(Fragment, null, [hasTitle && createVNode("div", {
        "class": "".concat(prefixCls.value, "-title")
      }, [title]), createVNode("div", {
        "class": "".concat(prefixCls.value, "-inner-content")
      }, [content])]);
    };
    return function() {
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["title", "content"])), {}, {
        "prefixCls": prefixCls.value,
        "ref": tooltipRef,
        "transitionName": getTransitionName$2(rootPrefixCls.value, "zoom-big", props3.transitionName)
      }), {
        title: getOverlay,
        default: slots.default
      });
    };
  }
});
const Popover$1 = withInstall(Popover);
var groupProps = function groupProps2() {
  return {
    prefixCls: String,
    maxCount: Number,
    maxStyle: {
      type: Object,
      default: void 0
    },
    maxPopoverPlacement: {
      type: String,
      default: "top"
    },
    maxPopoverTrigger: String,
    size: {
      type: [Number, String, Object],
      default: "default"
    }
  };
};
var Group$4 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: false,
  props: groupProps(),
  setup: function setup39(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("avatar-group", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    useProvideSize$1(props3);
    return function() {
      var _cls;
      var _props$maxPopoverPlac = props3.maxPopoverPlacement, maxPopoverPlacement = _props$maxPopoverPlac === void 0 ? "top" : _props$maxPopoverPlac, maxCount2 = props3.maxCount, maxStyle = props3.maxStyle, _props$maxPopoverTrig = props3.maxPopoverTrigger, maxPopoverTrigger = _props$maxPopoverTrig === void 0 ? "hover" : _props$maxPopoverTrig;
      var cls = (_cls = {}, _defineProperty$U(_cls, prefixCls.value, true), _defineProperty$U(_cls, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_cls, "".concat(attrs.class), !!attrs.class), _cls);
      var children = getPropsSlot(slots, props3);
      var childrenWithProps = flattenChildren(children).map(function(child, index2) {
        return cloneElement(child, {
          key: "avatar-key-".concat(index2)
        });
      });
      var numOfChildren = childrenWithProps.length;
      if (maxCount2 && maxCount2 < numOfChildren) {
        var childrenShow = childrenWithProps.slice(0, maxCount2);
        var childrenHidden = childrenWithProps.slice(maxCount2, numOfChildren);
        childrenShow.push(createVNode(Popover$1, {
          "key": "avatar-popover-key",
          "content": childrenHidden,
          "trigger": maxPopoverTrigger,
          "placement": maxPopoverPlacement,
          "overlayClassName": "".concat(prefixCls.value, "-popover")
        }, {
          default: function _default9() {
            return [createVNode(Avatar$1, {
              "style": maxStyle
            }, {
              default: function _default10() {
                return ["+".concat(numOfChildren - maxCount2)];
              }
            })];
          }
        }));
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": cls,
          "style": attrs.style
        }), [childrenShow]);
      }
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": cls,
        "style": attrs.style
      }), [childrenWithProps]);
    };
  }
});
const Group$5 = Group$4;
Avatar$1.Group = Group$5;
Avatar$1.install = function(app) {
  app.component(Avatar$1.name, Avatar$1);
  app.component(Group$5.name, Group$5);
  return app;
};
var VerticalAlignTopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;
function _objectSpread$C(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$C(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$C(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var VerticalAlignTopOutlined = function VerticalAlignTopOutlined2(props3, context2) {
  var p2 = _objectSpread$C({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$C({}, p2, {
    "icon": VerticalAlignTopOutlinedSvg
  }), null);
};
VerticalAlignTopOutlined.displayName = "VerticalAlignTopOutlined";
VerticalAlignTopOutlined.inheritAttrs = false;
const VerticalAlignTopOutlined$1 = VerticalAlignTopOutlined;
var backTopProps = function backTopProps2() {
  return {
    visibilityHeight: {
      type: Number,
      default: 400
    },
    duration: {
      type: Number,
      default: 450
    },
    target: Function,
    prefixCls: String,
    onClick: Function
  };
};
var BackTop = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABackTop",
  inheritAttrs: false,
  props: backTopProps(),
  setup: function setup40(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("back-top", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var domRef = ref();
    var state = reactive({
      visible: false,
      scrollEvent: null
    });
    var getDefaultTarget2 = function getDefaultTarget3() {
      return domRef.value && domRef.value.ownerDocument ? domRef.value.ownerDocument : window;
    };
    var scrollToTop = function scrollToTop2(e2) {
      var _props$target = props3.target, target = _props$target === void 0 ? getDefaultTarget2 : _props$target, duration = props3.duration;
      scrollTo$1(0, {
        getContainer: target,
        duration
      });
      emit("click", e2);
    };
    var handleScroll = throttleByAnimationFrame(function(e2) {
      var visibilityHeight = props3.visibilityHeight;
      var scrollTop = getScroll$3(e2.target, true);
      state.visible = scrollTop > visibilityHeight;
    });
    var bindScrollEvent = function bindScrollEvent2() {
      var target = props3.target;
      var getTarget = target || getDefaultTarget2;
      var container = getTarget();
      state.scrollEvent = addEventListenerWrap(container, "scroll", function(e2) {
        handleScroll(e2);
      });
      handleScroll({
        target: container
      });
    };
    var scrollRemove = function scrollRemove2() {
      if (state.scrollEvent) {
        state.scrollEvent.remove();
      }
      handleScroll.cancel();
    };
    watch(function() {
      return props3.target;
    }, function() {
      scrollRemove();
      nextTick(function() {
        bindScrollEvent();
      });
    });
    onMounted(function() {
      nextTick(function() {
        bindScrollEvent();
      });
    });
    onActivated(function() {
      nextTick(function() {
        bindScrollEvent();
      });
    });
    onDeactivated(function() {
      scrollRemove();
    });
    onBeforeUnmount(function() {
      scrollRemove();
    });
    return function() {
      var _class, _slots$default;
      var defaultElement = createVNode("div", {
        "class": "".concat(prefixCls.value, "-content")
      }, [createVNode("div", {
        "class": "".concat(prefixCls.value, "-icon")
      }, [createVNode(VerticalAlignTopOutlined$1, null, null)])]);
      var divProps = _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        onClick: scrollToTop,
        class: (_class = {}, _defineProperty$U(_class, "".concat(prefixCls.value), true), _defineProperty$U(_class, "".concat(attrs.class), attrs.class), _defineProperty$U(_class, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _class)
      });
      var transitionProps = getTransitionProps("fade");
      return createVNode(Transition$1, transitionProps, {
        default: function _default9() {
          return [withDirectives(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
            "ref": domRef
          }), [((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)) || defaultElement]), [[vShow, state.visible]])];
        }
      });
    };
  }
});
const index$l = withInstall(BackTop);
function UnitNumber(_ref) {
  var prefixCls = _ref.prefixCls, value = _ref.value, current2 = _ref.current, _ref$offset = _ref.offset, offset3 = _ref$offset === void 0 ? 0 : _ref$offset;
  var style2;
  if (offset3) {
    style2 = {
      position: "absolute",
      top: "".concat(offset3, "00%"),
      left: 0
    };
  }
  return createVNode("p", {
    "style": style2,
    "class": classNames("".concat(prefixCls, "-only-unit"), {
      current: current2
    })
  }, [value]);
}
function getOffset$1(start, end, unit) {
  var index2 = start;
  var offset3 = 0;
  while ((index2 + 10) % 10 !== end) {
    index2 += unit;
    offset3 += unit;
  }
  return offset3;
}
const SingleNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SingleNumber",
  props: {
    prefixCls: String,
    value: String,
    count: Number
  },
  setup: function setup41(props3) {
    var originValue = computed(function() {
      return Number(props3.value);
    });
    var originCount = computed(function() {
      return Math.abs(props3.count);
    });
    var state = reactive({
      prevValue: originValue.value,
      prevCount: originCount.value
    });
    var onTransitionEnd = function onTransitionEnd2() {
      state.prevValue = originValue.value;
      state.prevCount = originCount.value;
    };
    var timeout = ref();
    watch(originValue, function() {
      clearTimeout(timeout.value);
      timeout.value = setTimeout(function() {
        onTransitionEnd();
      }, 1e3);
    }, {
      flush: "post"
    });
    onUnmounted(function() {
      clearTimeout(timeout.value);
    });
    return function() {
      var unitNodes;
      var offsetStyle = {};
      var value = originValue.value;
      if (state.prevValue === value || Number.isNaN(value) || Number.isNaN(state.prevValue)) {
        unitNodes = [UnitNumber(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
          current: true
        }))];
        offsetStyle = {
          transition: "none"
        };
      } else {
        unitNodes = [];
        var end = value + 10;
        var unitNumberList = [];
        for (var index2 = value; index2 <= end; index2 += 1) {
          unitNumberList.push(index2);
        }
        var prevIndex = unitNumberList.findIndex(function(n2) {
          return n2 % 10 === state.prevValue;
        });
        unitNodes = unitNumberList.map(function(n2, index3) {
          var singleUnit = n2 % 10;
          return UnitNumber(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
            value: singleUnit,
            offset: index3 - prevIndex,
            current: index3 === prevIndex
          }));
        });
        var unit = state.prevCount < originCount.value ? 1 : -1;
        offsetStyle = {
          transform: "translateY(".concat(-getOffset$1(state.prevValue, value, unit), "00%)")
        };
      }
      return createVNode("span", {
        "class": "".concat(props3.prefixCls, "-only"),
        "style": offsetStyle,
        "onTransitionend": function onTransitionend() {
          return onTransitionEnd();
        }
      }, [unitNodes]);
    };
  }
});
var _excluded$R = ["prefixCls", "count", "title", "show", "component", "class", "style"];
var scrollNumberProps = {
  prefixCls: String,
  count: PropTypes$1.any,
  component: String,
  title: PropTypes$1.any,
  show: Boolean
};
const ScrollNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollNumber",
  inheritAttrs: false,
  props: scrollNumberProps,
  setup: function setup42(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useConfigInject = useConfigInject("scroll-number", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _slots$default;
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs);
      _props$attrs.prefixCls;
      var count = _props$attrs.count, title = _props$attrs.title;
      _props$attrs.show;
      var _props$attrs$componen = _props$attrs.component, Tag2 = _props$attrs$componen === void 0 ? "sup" : _props$attrs$componen, className = _props$attrs.class, style2 = _props$attrs.style, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$R);
      var newProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        style: style2,
        "data-show": props3.show,
        class: classNames(prefixCls.value, className),
        title
      });
      var numberNodes = count;
      if (count && Number(count) % 1 === 0) {
        var numberList = String(count).split("");
        numberNodes = numberList.map(function(num, i2) {
          return createVNode(SingleNumber, {
            "prefixCls": prefixCls.value,
            "count": Number(count),
            "value": num,
            "key": numberList.length - i2
          }, null);
        });
      }
      if (style2 && style2.borderColor) {
        newProps.style = _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
          boxShadow: "0 0 0 1px ".concat(style2.borderColor, " inset")
        });
      }
      var children = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      if (children && children.length) {
        return cloneElement(children, {
          class: classNames("".concat(prefixCls.value, "-custom-component"))
        }, false);
      }
      return createVNode(Tag2, newProps, {
        default: function _default9() {
          return [numberNodes];
        }
      });
    };
  }
});
function isPresetColor(color) {
  return PresetColorTypes.indexOf(color) !== -1;
}
var _excluded$Q = ["class", "style"];
var ribbonProps = function ribbonProps2() {
  return {
    prefix: String,
    color: {
      type: String
    },
    text: PropTypes$1.any,
    placement: {
      type: String,
      default: "end"
    }
  };
};
const Ribbon = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadgeRibbon",
  inheritAttrs: false,
  props: ribbonProps(),
  slots: ["text"],
  setup: function setup43(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useConfigInject = useConfigInject("ribbon", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var colorInPreset = computed(function() {
      return isPresetColor(props3.color);
    });
    var ribbonCls = computed(function() {
      var _ref2;
      return [prefixCls.value, "".concat(prefixCls.value, "-placement-").concat(props3.placement), (_ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-color-").concat(props3.color), colorInPreset.value), _ref2)];
    });
    return function() {
      var _slots$default, _slots$text;
      var className = attrs.class, style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded$Q);
      var colorStyle = {};
      var cornerColorStyle = {};
      if (props3.color && !colorInPreset.value) {
        colorStyle.background = props3.color;
        cornerColorStyle.color = props3.color;
      }
      return createVNode("div", _objectSpread2$1({
        "class": "".concat(prefixCls.value, "-wrapper")
      }, restAttrs), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots), createVNode("div", {
        "class": [ribbonCls.value, className],
        "style": _objectSpread2$1(_objectSpread2$1({}, colorStyle), style2)
      }, [createVNode("span", {
        "class": "".concat(prefixCls.value, "-text")
      }, [props3.text || ((_slots$text = slots.text) === null || _slots$text === void 0 ? void 0 : _slots$text.call(slots))]), createVNode("div", {
        "class": "".concat(prefixCls.value, "-corner"),
        "style": cornerColorStyle
      }, null)])]);
    };
  }
});
var isNumeric$1 = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
const isNumeric$2 = isNumeric$1;
var badgeProps = function badgeProps2() {
  return {
    count: PropTypes$1.any,
    showZero: {
      type: Boolean,
      default: void 0
    },
    overflowCount: {
      type: Number,
      default: 99
    },
    dot: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    scrollNumberPrefixCls: String,
    status: {
      type: String
    },
    size: {
      type: String,
      default: "default"
    },
    color: String,
    text: PropTypes$1.any,
    offset: Array,
    numberStyle: {
      type: Object,
      default: void 0
    },
    title: String
  };
};
const Badge = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABadge",
  Ribbon,
  inheritAttrs: false,
  props: badgeProps(),
  slots: ["text", "count"],
  setup: function setup44(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("badge", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var numberedDisplayCount = computed(function() {
      return props3.count > props3.overflowCount ? "".concat(props3.overflowCount, "+") : props3.count;
    });
    var hasStatus = computed(function() {
      return props3.status !== null && props3.status !== void 0 || props3.color !== null && props3.color !== void 0;
    });
    var isZero = computed(function() {
      return numberedDisplayCount.value === "0" || numberedDisplayCount.value === 0;
    });
    var showAsDot = computed(function() {
      return props3.dot && !isZero.value;
    });
    var mergedCount = computed(function() {
      return showAsDot.value ? "" : numberedDisplayCount.value;
    });
    var isHidden2 = computed(function() {
      var isEmpty = mergedCount.value === null || mergedCount.value === void 0 || mergedCount.value === "";
      return (isEmpty || isZero.value && !props3.showZero) && !showAsDot.value;
    });
    var livingCount = ref(props3.count);
    var displayCount = ref(mergedCount.value);
    var isDotRef = ref(showAsDot.value);
    watch([function() {
      return props3.count;
    }, mergedCount, showAsDot], function() {
      if (!isHidden2.value) {
        livingCount.value = props3.count;
        displayCount.value = mergedCount.value;
        isDotRef.value = showAsDot.value;
      }
    }, {
      immediate: true
    });
    var statusCls = computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value, "-status-dot"), hasStatus.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-status-").concat(props3.status), !!props3.status), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-status-").concat(props3.color), isPresetColor(props3.color)), _ref2;
    });
    var statusStyle = computed(function() {
      if (props3.color && !isPresetColor(props3.color)) {
        return {
          background: props3.color
        };
      } else {
        return {};
      }
    });
    var scrollNumberCls = computed(function() {
      var _ref3;
      return _ref3 = {}, _defineProperty$U(_ref3, "".concat(prefixCls.value, "-dot"), isDotRef.value), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-count"), !isDotRef.value), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-count-sm"), props3.size === "small"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-multiple-words"), !isDotRef.value && displayCount.value && displayCount.value.toString().length > 1), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-status-").concat(props3.status), !!props3.status), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-status-").concat(props3.color), isPresetColor(props3.color)), _ref3;
    });
    return function() {
      var _slots$default, _slots$count, _classNames;
      var offset3 = props3.offset, title = props3.title, color = props3.color;
      var style2 = attrs.style;
      var text = getPropsSlot(slots, props3, "text");
      var pre = prefixCls.value;
      var count = livingCount.value;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      children = children.length ? children : null;
      var visible = !!(!isHidden2.value || slots.count);
      var mergedStyle = function() {
        if (!offset3) {
          return _objectSpread2$1({}, style2);
        }
        var offsetStyle = {
          marginTop: isNumeric$2(offset3[1]) ? "".concat(offset3[1], "px") : offset3[1]
        };
        if (direction.value === "rtl") {
          offsetStyle.left = "".concat(parseInt(offset3[0], 10), "px");
        } else {
          offsetStyle.right = "".concat(-parseInt(offset3[0], 10), "px");
        }
        return _objectSpread2$1(_objectSpread2$1({}, offsetStyle), style2);
      }();
      var titleNode = title !== null && title !== void 0 ? title : typeof count === "string" || typeof count === "number" ? count : void 0;
      var statusTextNode = visible || !text ? null : createVNode("span", {
        "class": "".concat(pre, "-status-text")
      }, [text]);
      var displayNode = _typeof$3(count) === "object" || count === void 0 && slots.count ? cloneElement(count !== null && count !== void 0 ? count : (_slots$count = slots.count) === null || _slots$count === void 0 ? void 0 : _slots$count.call(slots), {
        style: mergedStyle
      }, false) : null;
      var badgeClassName = classNames(pre, (_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-status"), hasStatus.value), _defineProperty$U(_classNames, "".concat(pre, "-not-a-wrapper"), !children), _defineProperty$U(_classNames, "".concat(pre, "-rtl"), direction.value === "rtl"), _classNames), attrs.class);
      if (!children && hasStatus.value) {
        var statusTextColor = mergedStyle.color;
        return createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": badgeClassName,
          "style": mergedStyle
        }), [createVNode("span", {
          "class": statusCls.value,
          "style": statusStyle.value
        }, null), createVNode("span", {
          "style": {
            color: statusTextColor
          },
          "class": "".concat(pre, "-status-text")
        }, [text])]);
      }
      var transitionProps = getTransitionProps(children ? "".concat(pre, "-zoom") : "", {
        appear: false
      });
      var scrollNumberStyle = _objectSpread2$1(_objectSpread2$1({}, mergedStyle), props3.numberStyle);
      if (color && !isPresetColor(color)) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color;
      }
      return createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": badgeClassName
      }), [children, createVNode(Transition$1, transitionProps, {
        default: function _default9() {
          return [withDirectives(createVNode(ScrollNumber, {
            "prefixCls": props3.scrollNumberPrefixCls,
            "show": visible,
            "class": scrollNumberCls.value,
            "count": displayCount.value,
            "title": titleNode,
            "style": scrollNumberStyle,
            "key": "scrollNumber"
          }, {
            default: function _default10() {
              return [displayNode];
            }
          }), [[vShow, visible]])];
        }
      }), statusTextNode]);
    };
  }
});
Badge.install = function(app) {
  app.component(Badge.name, Badge);
  app.component(Ribbon.name, Ribbon);
  return app;
};
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 4],
    targetOffset
  }
};
const placements$2 = placements$1;
var _excluded$P = ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"];
const Dropdown$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: false
    },
    prefixCls: PropTypes$1.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: PropTypes$1.string.def(""),
    openClassName: String,
    animation: PropTypes$1.any,
    align: PropTypes$1.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: PropTypes$1.string.def("bottomLeft"),
    overlay: PropTypes$1.any,
    trigger: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: PropTypes$1.array,
    hideAction: PropTypes$1.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: false
    },
    mouseEnterDelay: PropTypes$1.number.def(0.15),
    mouseLeaveDelay: PropTypes$1.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  slots: ["overlay"],
  setup: function setup45(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var triggerVisible = ref(!!props3.visible);
    watch(function() {
      return props3.visible;
    }, function(val) {
      if (val !== void 0) {
        triggerVisible.value = val;
      }
    });
    var triggerRef2 = ref();
    expose({
      triggerRef: triggerRef2
    });
    var onClick2 = function onClick3(e2) {
      if (props3.visible === void 0) {
        triggerVisible.value = false;
      }
      emit("overlayClick", e2);
    };
    var onVisibleChange = function onVisibleChange2(visible) {
      if (props3.visible === void 0) {
        triggerVisible.value = visible;
      }
      emit("visibleChange", visible);
    };
    var getMenuElement = function getMenuElement2() {
      var _slots$overlay;
      var overlayElement = (_slots$overlay = slots.overlay) === null || _slots$overlay === void 0 ? void 0 : _slots$overlay.call(slots);
      var extraOverlayProps = {
        prefixCls: "".concat(props3.prefixCls, "-menu"),
        onClick: onClick2,
        getPopupContainer: function getPopupContainer() {
          return triggerRef2.value.getPopupDomNode();
        }
      };
      return createVNode(Fragment, null, [props3.arrow && createVNode("div", {
        "class": "".concat(props3.prefixCls, "-arrow")
      }, null), cloneElement(overlayElement, extraOverlayProps, false)]);
    };
    var minOverlayWidthMatchTrigger = computed(function() {
      var _props$minOverlayWidt = props3.minOverlayWidthMatchTrigger, matchTrigger = _props$minOverlayWidt === void 0 ? !props3.alignPoint : _props$minOverlayWidt;
      return matchTrigger;
    });
    var renderChildren2 = function renderChildren3() {
      var _slots$default;
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      return triggerVisible.value && children ? cloneElement(children[0], {
        class: props3.openClassName || "".concat(props3.prefixCls, "-open")
      }, false) : children;
    };
    var triggerHideAction = computed(function() {
      if (!props3.hideAction && props3.trigger.indexOf("contextmenu") !== -1) {
        return ["click"];
      }
      return props3.hideAction;
    });
    return function() {
      var prefixCls = props3.prefixCls, arrow = props3.arrow, showAction = props3.showAction, overlayStyle = props3.overlayStyle, trigger2 = props3.trigger, placement = props3.placement, align = props3.align, getPopupContainer = props3.getPopupContainer, transitionName2 = props3.transitionName, animation = props3.animation, overlayClassName = props3.overlayClassName, otherProps = _objectWithoutProperties$2(props3, _excluded$P);
      return createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
        "prefixCls": prefixCls,
        "ref": triggerRef2,
        "popupClassName": classNames(overlayClassName, _defineProperty$U({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        "popupStyle": overlayStyle,
        "builtinPlacements": placements$2,
        "action": trigger2,
        "showAction": showAction,
        "hideAction": triggerHideAction.value || [],
        "popupPlacement": placement,
        "popupAlign": align,
        "popupTransitionName": transitionName2,
        "popupAnimation": animation,
        "popupVisible": triggerVisible.value,
        "stretch": minOverlayWidthMatchTrigger.value ? "minWidth" : "",
        "onPopupVisibleChange": onVisibleChange,
        "getPopupContainer": getPopupContainer
      }), {
        popup: getMenuElement,
        default: renderChildren2
      });
    };
  }
});
var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: "transitionstart",
    WebkitTransition: "webkitTransitionStart",
    MozTransition: "mozTransitionStart",
    OTransition: "oTransitionStart",
    msTransition: "MSTransitionStart"
  },
  animationstart: {
    animation: "animationstart",
    WebkitAnimation: "webkitAnimationStart",
    MozAnimation: "mozAnimationStart",
    OAnimation: "oAnimationStart",
    msAnimation: "MSAnimationStart"
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: "transitionend",
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "mozTransitionEnd",
    OTransition: "oTransitionEnd",
    msTransition: "MSTransitionEnd"
  },
  animationend: {
    animation: "animationend",
    WebkitAnimation: "webkitAnimationEnd",
    MozAnimation: "mozAnimationEnd",
    OAnimation: "oAnimationEnd",
    msAnimation: "MSAnimationEnd"
  }
};
var startEvents = [];
var endEvents = [];
function detectEvents() {
  var testEl = document.createElement("div");
  var style2 = testEl.style;
  if (!("AnimationEvent" in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }
  if (!("TransitionEvent" in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }
  function process2(EVENT_NAME_MAP, events2) {
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];
        for (var styleName in baseEvents) {
          if (styleName in style2) {
            events2.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }
  process2(START_EVENT_NAME_MAP, startEvents);
  process2(END_EVENT_NAME_MAP, endEvents);
}
if (typeof window !== "undefined" && typeof document !== "undefined") {
  detectEvents();
}
function addEventListener$1(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}
function removeEventListener$1(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}
var TransitionEvents = {
  startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      setTimeout(eventListener, 0);
      return;
    }
    startEvents.forEach(function(startEvent) {
      addEventListener$1(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }
    startEvents.forEach(function(startEvent) {
      removeEventListener$1(node, startEvent, eventListener);
    });
  },
  endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener$1(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener$1(node, endEvent, eventListener);
    });
  }
};
const TransitionEvents$1 = TransitionEvents;
var styleForPesudo;
function isHidden(element) {
  return !element || element.offsetParent === null;
}
function isNotGrey(color) {
  var match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
const Wave = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    insertExtraNode: Boolean,
    disabled: Boolean
  },
  setup: function setup46(props3, _ref) {
    var slots = _ref.slots, expose = _ref.expose;
    var instance = getCurrentInstance();
    var _useConfigInject = useConfigInject("", props3), csp = _useConfigInject.csp, prefixCls = _useConfigInject.prefixCls;
    expose({
      csp
    });
    var eventIns = null;
    var clickWaveTimeoutId = null;
    var animationStartId = null;
    var animationStart = false;
    var extraNode = null;
    var isUnmounted = false;
    var onTransitionStart = function onTransitionStart2(e2) {
      if (isUnmounted)
        return;
      var node = findDOMNode(instance);
      if (!e2 || e2.target !== node) {
        return;
      }
      if (!animationStart) {
        resetEffect(node);
      }
    };
    var onTransitionEnd = function onTransitionEnd2(e2) {
      if (!e2 || e2.animationName !== "fadeEffect") {
        return;
      }
      resetEffect(e2.target);
    };
    var getAttributeName = function getAttributeName2() {
      var insertExtraNode = props3.insertExtraNode;
      return insertExtraNode ? "".concat(prefixCls.value, "-click-animating") : "".concat(prefixCls.value, "-click-animating-without-extra-node");
    };
    var onClick2 = function onClick3(node, waveColor) {
      var insertExtraNode = props3.insertExtraNode, disabled = props3.disabled;
      if (disabled || !node || isHidden(node) || node.className.indexOf("-leave") >= 0) {
        return;
      }
      extraNode = document.createElement("div");
      extraNode.className = "".concat(prefixCls.value, "-click-animating-node");
      var attributeName = getAttributeName();
      node.removeAttribute(attributeName);
      node.setAttribute(attributeName, "true");
      styleForPesudo = styleForPesudo || document.createElement("style");
      if (waveColor && waveColor !== "#ffffff" && waveColor !== "rgb(255, 255, 255)" && isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && waveColor !== "transparent") {
        var _csp$value;
        if ((_csp$value = csp.value) !== null && _csp$value !== void 0 && _csp$value.nonce) {
          styleForPesudo.nonce = csp.value.nonce;
        }
        extraNode.style.borderColor = waveColor;
        styleForPesudo.innerHTML = "\n        [".concat(prefixCls.value, "-click-animating-without-extra-node='true']::after, .").concat(prefixCls.value, "-click-animating-node {\n          --antd-wave-shadow-color: ").concat(waveColor, ";\n        }");
        if (!document.body.contains(styleForPesudo)) {
          document.body.appendChild(styleForPesudo);
        }
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      TransitionEvents$1.addStartEventListener(node, onTransitionStart);
      TransitionEvents$1.addEndEventListener(node, onTransitionEnd);
    };
    var resetEffect = function resetEffect2(node) {
      if (!node || node === extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = props3.insertExtraNode;
      var attributeName = getAttributeName();
      node.setAttribute(attributeName, "false");
      if (styleForPesudo) {
        styleForPesudo.innerHTML = "";
      }
      if (insertExtraNode && extraNode && node.contains(extraNode)) {
        node.removeChild(extraNode);
      }
      TransitionEvents$1.removeStartEventListener(node, onTransitionStart);
      TransitionEvents$1.removeEndEventListener(node, onTransitionEnd);
    };
    var bindAnimationEvent = function bindAnimationEvent2(node) {
      if (!node || !node.getAttribute || node.getAttribute("disabled") || node.className.indexOf("disabled") >= 0) {
        return;
      }
      var newClick = function newClick2(e2) {
        if (e2.target.tagName === "INPUT" || isHidden(e2.target)) {
          return;
        }
        resetEffect(node);
        var waveColor = getComputedStyle(node).getPropertyValue("border-top-color") || getComputedStyle(node).getPropertyValue("border-color") || getComputedStyle(node).getPropertyValue("background-color");
        clickWaveTimeoutId = setTimeout(function() {
          return onClick2(node, waveColor);
        }, 0);
        wrapperRaf.cancel(animationStartId);
        animationStart = true;
        animationStartId = wrapperRaf(function() {
          animationStart = false;
        }, 10);
      };
      node.addEventListener("click", newClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener("click", newClick, true);
        }
      };
    };
    onMounted(function() {
      nextTick(function() {
        var node = findDOMNode(instance);
        if (node.nodeType !== 1) {
          return;
        }
        eventIns = bindAnimationEvent(node);
      });
    });
    onBeforeUnmount(function() {
      if (eventIns) {
        eventIns.cancel();
      }
      clearTimeout(clickWaveTimeoutId);
      isUnmounted = true;
    });
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)[0];
    };
  }
});
function convertLegacyProps(type4) {
  if (type4 === "danger") {
    return {
      danger: true
    };
  }
  return {
    type: type4
  };
}
var buttonProps = function buttonProps2() {
  return {
    prefixCls: String,
    type: String,
    htmlType: {
      type: String,
      default: "button"
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    loading: {
      type: [Boolean, Object],
      default: function _default9() {
        return false;
      }
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    block: {
      type: Boolean,
      default: void 0
    },
    danger: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    href: String,
    target: String,
    title: String,
    onClick: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  };
};
const buttonTypes = buttonProps;
var getCollapsedWidth = function getCollapsedWidth2(node) {
  if (node) {
    node.style.width = "0px";
    node.style.opacity = "0";
    node.style.transform = "scale(0)";
  }
};
var getRealWidth = function getRealWidth2(node) {
  nextTick(function() {
    if (node) {
      node.style.width = "".concat(node.scrollWidth, "px");
      node.style.opacity = "1";
      node.style.transform = "scale(1)";
    }
  });
};
var resetStyle = function resetStyle2(node) {
  if (node && node.style) {
    node.style.width = null;
    node.style.opacity = null;
    node.style.transform = null;
  }
};
const LoadingIcon = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup: function setup47(props3) {
    return function() {
      var existIcon = props3.existIcon, prefixCls = props3.prefixCls, loading = props3.loading;
      if (existIcon) {
        return createVNode("span", {
          "class": "".concat(prefixCls, "-loading-icon")
        }, [createVNode(LoadingOutlined$1, null, null)]);
      }
      var visible = !!loading;
      return createVNode(Transition, {
        "name": "".concat(prefixCls, "-loading-icon-motion"),
        "onBeforeEnter": getCollapsedWidth,
        "onEnter": getRealWidth,
        "onAfterEnter": resetStyle,
        "onBeforeLeave": getRealWidth,
        "onLeave": function onLeave(node) {
          setTimeout(function() {
            getCollapsedWidth(node);
          });
        },
        "onAfterLeave": resetStyle
      }, {
        default: function _default9() {
          return [visible ? createVNode("span", {
            "class": "".concat(prefixCls, "-loading-icon")
          }, [createVNode(LoadingOutlined$1, null, null)]) : null];
        }
      });
    };
  }
});
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isUnborderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
const Button$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps$1(buttonTypes(), {
    type: "default"
  }),
  slots: ["icon"],
  setup: function setup48(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("btn", props3), prefixCls = _useConfigInject.prefixCls, autoInsertSpaceInButton = _useConfigInject.autoInsertSpaceInButton, direction = _useConfigInject.direction, size2 = _useConfigInject.size;
    var buttonNodeRef = ref(null);
    var delayTimeoutRef = ref(void 0);
    var isNeedInserted = false;
    var innerLoading = ref(false);
    var hasTwoCNChar = ref(false);
    var autoInsertSpace = computed(function() {
      return autoInsertSpaceInButton.value !== false;
    });
    var loadingOrDelay = computed(function() {
      return _typeof$3(props3.loading) === "object" && props3.loading.delay ? props3.loading.delay || true : !!props3.loading;
    });
    watch(loadingOrDelay, function(val) {
      clearTimeout(delayTimeoutRef.value);
      if (typeof loadingOrDelay.value === "number") {
        delayTimeoutRef.value = setTimeout(function() {
          innerLoading.value = val;
        }, loadingOrDelay.value);
      } else {
        innerLoading.value = val;
      }
    }, {
      immediate: true
    });
    var classes = computed(function() {
      var _ref2;
      var type4 = props3.type, _props$shape = props3.shape, shape = _props$shape === void 0 ? "default" : _props$shape, ghost = props3.ghost, block = props3.block, danger = props3.danger;
      var pre = prefixCls.value;
      var sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      var sizeFullname = size2.value;
      var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(pre), true), _defineProperty$U(_ref2, "".concat(pre, "-").concat(type4), type4), _defineProperty$U(_ref2, "".concat(pre, "-").concat(shape), shape !== "default" && shape), _defineProperty$U(_ref2, "".concat(pre, "-").concat(sizeCls), sizeCls), _defineProperty$U(_ref2, "".concat(pre, "-loading"), innerLoading.value), _defineProperty$U(_ref2, "".concat(pre, "-background-ghost"), ghost && !isUnborderedButtonType(type4)), _defineProperty$U(_ref2, "".concat(pre, "-two-chinese-chars"), hasTwoCNChar.value && autoInsertSpace.value), _defineProperty$U(_ref2, "".concat(pre, "-block"), block), _defineProperty$U(_ref2, "".concat(pre, "-dangerous"), !!danger), _defineProperty$U(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var fixTwoCNChar = function fixTwoCNChar2() {
      var node = buttonNodeRef.value;
      if (!node || autoInsertSpaceInButton.value === false) {
        return;
      }
      var buttonText = node.textContent;
      if (isNeedInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar.value) {
          hasTwoCNChar.value = true;
        }
      } else if (hasTwoCNChar.value) {
        hasTwoCNChar.value = false;
      }
    };
    var handleClick2 = function handleClick3(event2) {
      if (innerLoading.value || props3.disabled) {
        event2.preventDefault();
        return;
      }
      emit("click", event2);
    };
    var insertSpace = function insertSpace2(child, needInserted) {
      var SPACE = needInserted ? " " : "";
      if (child.type === Text$2) {
        var text = child.children.trim();
        if (isTwoCNChar(text)) {
          text = text.split("").join(SPACE);
        }
        return createVNode("span", null, [text]);
      }
      return child;
    };
    watchEffect(function() {
      devWarning(!(props3.ghost && isUnborderedButtonType(props3.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    });
    onMounted(fixTwoCNChar);
    onUpdated(fixTwoCNChar);
    onBeforeUnmount(function() {
      delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
    });
    return function() {
      var _slots$icon, _slots$default;
      var _props$icon = props3.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots) : _props$icon;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      isNeedInserted = children.length === 1 && !icon && !isUnborderedButtonType(props3.type);
      var type4 = props3.type, htmlType = props3.htmlType, disabled = props3.disabled, href = props3.href, title = props3.title, target = props3.target, onMousedown2 = props3.onMousedown;
      var iconType = innerLoading.value ? "loading" : icon;
      var buttonProps3 = _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        title,
        disabled,
        class: [classes.value, attrs.class, _defineProperty$U({}, "".concat(prefixCls.value, "-icon-only"), children.length === 0 && !!iconType)],
        onClick: handleClick2,
        onMousedown: onMousedown2
      });
      if (!disabled) {
        delete buttonProps3.disabled;
      }
      var iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon, {
        "existIcon": !!icon,
        "prefixCls": prefixCls.value,
        "loading": !!innerLoading.value
      }, null);
      var kids = children.map(function(child) {
        return insertSpace(child, isNeedInserted && autoInsertSpace.value);
      });
      if (href !== void 0) {
        return createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps3), {}, {
          "href": href,
          "target": target,
          "ref": buttonNodeRef
        }), [iconNode, kids]);
      }
      var buttonNode = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps3), {}, {
        "ref": buttonNodeRef,
        "type": htmlType
      }), [iconNode, kids]);
      if (isUnborderedButtonType(type4)) {
        return buttonNode;
      }
      return createVNode(Wave, {
        "ref": "wave",
        "disabled": !!innerLoading.value
      }, {
        default: function _default9() {
          return [buttonNode];
        }
      });
    };
  }
});
function _defineProperties(target, props3) {
  for (var i2 = 0; i2 < props3.length; i2++) {
    var descriptor = props3[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var UnreachableException = /* @__PURE__ */ _createClass(function UnreachableException2(value) {
  _classCallCheck(this, UnreachableException2);
  this.error = new Error("unreachable case: ".concat(JSON.stringify(value)));
});
var buttonGroupProps = function buttonGroupProps2() {
  return {
    prefixCls: String,
    size: {
      type: String
    }
  };
};
const ButtonGroup$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: buttonGroupProps(),
  setup: function setup49(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("btn-group", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var classes = computed(function() {
      var _ref2;
      var size2 = props3.size;
      var sizeCls = "";
      switch (size2) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          console.warn(new UnreachableException(size2).error);
      }
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-").concat(sizeCls), sizeCls), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": classes.value
      }, [flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))]);
    };
  }
});
Button$1.Group = ButtonGroup$1;
Button$1.install = function(app) {
  app.component(Button$1.name, Button$1);
  app.component(ButtonGroup$1.name, ButtonGroup$1);
  return app;
};
var dropdownProps = function dropdownProps2() {
  return {
    arrow: {
      type: [Boolean, Object],
      default: void 0
    },
    trigger: {
      type: [Array, String]
    },
    overlay: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    align: {
      type: Object
    },
    getPopupContainer: Function,
    prefixCls: String,
    transitionName: String,
    placement: String,
    overlayClassName: String,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    openClassName: String,
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: {
      type: Function
    },
    "onUpdate:visible": {
      type: Function
    }
  };
};
var buttonTypesProps = buttonTypes();
var dropdownButtonProps = function dropdownButtonProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, dropdownProps()), {}, {
    type: buttonTypesProps.type,
    size: String,
    htmlType: buttonTypesProps.htmlType,
    href: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    icon: PropTypes$1.any,
    title: String,
    loading: buttonTypesProps.loading,
    onClick: {
      type: Function
    }
  });
};
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
const EllipsisOutlinedSvg = EllipsisOutlined$2;
function _objectSpread$B(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$B(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$B(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EllipsisOutlined = function EllipsisOutlined2(props3, context2) {
  var p2 = _objectSpread$B({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$B({}, p2, {
    "icon": EllipsisOutlinedSvg
  }), null);
};
EllipsisOutlined.displayName = "EllipsisOutlined";
EllipsisOutlined.inheritAttrs = false;
const EllipsisOutlined$1 = EllipsisOutlined;
var _excluded$O = ["type", "disabled", "loading", "htmlType", "class", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:visible"];
var ButtonGroup = Button$1.Group;
const DropdownButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdownButton",
  inheritAttrs: false,
  __ANT_BUTTON: true,
  props: initDefaultProps$1(dropdownButtonProps(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  slots: ["icon", "leftButton", "rightButton", "overlay"],
  setup: function setup50(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var handleVisibleChange = function handleVisibleChange2(val) {
      emit("update:visible", val);
      emit("visibleChange", val);
    };
    var _useConfigInject = useConfigInject("dropdown-button", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    return function() {
      var _slots$overlay, _slots$icon;
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), _props$attrs$type = _props$attrs.type, type4 = _props$attrs$type === void 0 ? "default" : _props$attrs$type, disabled = _props$attrs.disabled, loading = _props$attrs.loading, htmlType = _props$attrs.htmlType, _props$attrs$class = _props$attrs.class, className = _props$attrs$class === void 0 ? "" : _props$attrs$class, _props$attrs$overlay = _props$attrs.overlay, _overlay = _props$attrs$overlay === void 0 ? (_slots$overlay = slots.overlay) === null || _slots$overlay === void 0 ? void 0 : _slots$overlay.call(slots) : _props$attrs$overlay, trigger2 = _props$attrs.trigger, align = _props$attrs.align, visible = _props$attrs.visible;
      _props$attrs.onVisibleChange;
      var _props$attrs$placemen = _props$attrs.placement, placement = _props$attrs$placemen === void 0 ? direction.value === "rtl" ? "bottomLeft" : "bottomRight" : _props$attrs$placemen, href = _props$attrs.href, title = _props$attrs.title, _props$attrs$icon = _props$attrs.icon, icon = _props$attrs$icon === void 0 ? ((_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots)) || createVNode(EllipsisOutlined$1, null, null) : _props$attrs$icon, mouseEnterDelay = _props$attrs.mouseEnterDelay, mouseLeaveDelay = _props$attrs.mouseLeaveDelay, overlayClassName = _props$attrs.overlayClassName, overlayStyle = _props$attrs.overlayStyle, destroyPopupOnHide = _props$attrs.destroyPopupOnHide, onClick2 = _props$attrs.onClick;
      _props$attrs["onUpdate:visible"];
      var restProps = _objectWithoutProperties$2(_props$attrs, _excluded$O);
      var dropdownProps3 = {
        align,
        disabled,
        trigger: disabled ? [] : trigger2,
        placement,
        getPopupContainer: getPopupContainer.value,
        onVisibleChange: handleVisibleChange,
        mouseEnterDelay,
        mouseLeaveDelay,
        visible,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide
      };
      var leftButton = createVNode(Button$1, {
        "type": type4,
        "disabled": disabled,
        "loading": loading,
        "onClick": onClick2,
        "htmlType": htmlType,
        "href": href,
        "title": title
      }, {
        default: slots.default
      });
      var rightButton = createVNode(Button$1, {
        "type": type4,
        "icon": icon
      }, null);
      return createVNode(ButtonGroup, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "class": classNames(prefixCls.value, className)
      }), {
        default: function _default9() {
          return [slots.leftButton ? slots.leftButton({
            button: leftButton
          }) : leftButton, createVNode(Dropdown$1, dropdownProps3, {
            default: function _default10() {
              return [slots.rightButton ? slots.rightButton({
                button: rightButton
              }) : rightButton];
            },
            overlay: function overlay() {
              return _overlay;
            }
          })];
        }
      });
    };
  }
});
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
const RightOutlinedSvg = RightOutlined$2;
function _objectSpread$A(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$A(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$A(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RightOutlined = function RightOutlined2(props3, context2) {
  var p2 = _objectSpread$A({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$A({}, p2, {
    "icon": RightOutlinedSvg
  }), null);
};
RightOutlined.displayName = "RightOutlined";
RightOutlined.inheritAttrs = false;
const RightOutlined$1 = RightOutlined;
var Dropdown = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdown",
  inheritAttrs: false,
  props: initDefaultProps$1(dropdownProps(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  slots: ["overlay"],
  setup: function setup51(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("dropdown", props3), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    var transitionName2 = computed(function() {
      var _props$placement = props3.placement, placement2 = _props$placement === void 0 ? "" : _props$placement, transitionName3 = props3.transitionName;
      if (transitionName3 !== void 0) {
        return transitionName3;
      }
      if (placement2.indexOf("top") >= 0) {
        return "".concat(rootPrefixCls.value, "-slide-down");
      }
      return "".concat(rootPrefixCls.value, "-slide-up");
    });
    var renderOverlay = function renderOverlay2() {
      var _slots$overlay, _overlayNode$children, _overlayNode$children2;
      var overlay = props3.overlay || ((_slots$overlay = slots.overlay) === null || _slots$overlay === void 0 ? void 0 : _slots$overlay.call(slots));
      var overlayNode = Array.isArray(overlay) ? overlay[0] : overlay;
      if (!overlayNode)
        return null;
      var overlayProps = overlayNode.props || {};
      devWarning(!overlayProps.mode || overlayProps.mode === "vertical", "Dropdown", 'mode="'.concat(overlayProps.mode, `" is not supported for Dropdown's Menu.`));
      var _overlayProps$selecta = overlayProps.selectable, selectable = _overlayProps$selecta === void 0 ? false : _overlayProps$selecta, _overlayProps$expandI = overlayProps.expandIcon, expandIcon = _overlayProps$expandI === void 0 ? (_overlayNode$children = overlayNode.children) === null || _overlayNode$children === void 0 ? void 0 : (_overlayNode$children2 = _overlayNode$children.expandIcon) === null || _overlayNode$children2 === void 0 ? void 0 : _overlayNode$children2.call(_overlayNode$children) : _overlayProps$expandI;
      var overlayNodeExpandIcon = typeof expandIcon !== "undefined" && isValidElement(expandIcon) ? expandIcon : createVNode("span", {
        "class": "".concat(prefixCls.value, "-menu-submenu-arrow")
      }, [createVNode(RightOutlined$1, {
        "class": "".concat(prefixCls.value, "-menu-submenu-arrow-icon")
      }, null)]);
      var fixedModeOverlay = isValidElement(overlayNode) ? cloneElement(overlayNode, {
        mode: "vertical",
        selectable,
        expandIcon: function expandIcon2() {
          return overlayNodeExpandIcon;
        }
      }) : overlayNode;
      return fixedModeOverlay;
    };
    var placement = computed(function() {
      var placement2 = props3.placement;
      if (!placement2) {
        return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
      }
      if (placement2.includes("Center")) {
        var newPlacement = placement2.slice(0, placement2.indexOf("Center"));
        devWarning(!placement2.includes("Center"), "Dropdown", "You are using '".concat(placement2, "' placement in Dropdown, which is deprecated. Try to use '").concat(newPlacement, "' instead."));
        return newPlacement;
      }
      return placement2;
    });
    var handleVisibleChange = function handleVisibleChange2(val) {
      emit("update:visible", val);
      emit("visibleChange", val);
    };
    return function() {
      var _slots$default, _child$props;
      var arrow = props3.arrow, trigger2 = props3.trigger, disabled = props3.disabled, overlayClassName = props3.overlayClassName;
      var child = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)[0];
      var dropdownTrigger = cloneElement(child, _extends$1({
        class: classNames(child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.class, _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), "".concat(prefixCls.value, "-trigger"))
      }, disabled ? {
        disabled
      } : {}));
      var overlayClassNameCustomized = classNames(overlayClassName, _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
      var triggerActions = disabled ? [] : trigger2;
      var alignPoint2;
      if (triggerActions && triggerActions.indexOf("contextmenu") !== -1) {
        alignPoint2 = true;
      }
      var builtinPlacements = getPlacements({
        arrowPointAtCenter: _typeof$3(arrow) === "object" && arrow.pointAtCenter,
        autoAdjustOverflow: true
      });
      var dropdownProps3 = omit$2(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        builtinPlacements,
        overlayClassName: overlayClassNameCustomized,
        arrow,
        alignPoint: alignPoint2,
        prefixCls: prefixCls.value,
        getPopupContainer: getPopupContainer.value,
        transitionName: transitionName2.value,
        trigger: triggerActions,
        onVisibleChange: handleVisibleChange,
        placement: placement.value
      }), ["overlay", "onUpdate:visible"]);
      return createVNode(Dropdown$2, dropdownProps3, {
        default: function _default9() {
          return [dropdownTrigger];
        },
        overlay: renderOverlay
      });
    };
  }
});
Dropdown.Button = DropdownButton;
const Dropdown$1 = Dropdown;
var _excluded$N = ["class", "style"];
var breadcrumbItemProps = function breadcrumbItemProps2() {
  return {
    prefixCls: String,
    href: String,
    separator: PropTypes$1.any,
    overlay: PropTypes$1.any,
    onClick: Function
  };
};
const BreadcrumbItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbItem",
  inheritAttrs: false,
  __ANT_BREADCRUMB_ITEM: true,
  props: breadcrumbItemProps(),
  slots: ["separator", "overlay"],
  setup: function setup52(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("breadcrumb", props3), prefixCls = _useConfigInject.prefixCls;
    var renderBreadcrumbNode = function renderBreadcrumbNode2(breadcrumbItem, prefixCls2) {
      var overlay = getPropsSlot(slots, props3, "overlay");
      if (overlay) {
        return createVNode(Dropdown$1, {
          "overlay": overlay,
          "placement": "bottom"
        }, {
          default: function _default9() {
            return [createVNode("span", {
              "class": "".concat(prefixCls2, "-overlay-link")
            }, [breadcrumbItem, createVNode(DownOutlined$1, null, null)])];
          }
        });
      }
      return breadcrumbItem;
    };
    return function() {
      var _getPropsSlot;
      var separator = (_getPropsSlot = getPropsSlot(slots, props3, "separator")) !== null && _getPropsSlot !== void 0 ? _getPropsSlot : "/";
      var children = getPropsSlot(slots, props3);
      var cls = attrs.class, style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded$N);
      var link2;
      if (props3.href !== void 0) {
        link2 = createVNode("a", _objectSpread2$1({
          "class": "".concat(prefixCls.value, "-link"),
          "onClick": props3.onClick
        }, restAttrs), [children]);
      } else {
        link2 = createVNode("span", _objectSpread2$1({
          "class": "".concat(prefixCls.value, "-link"),
          "onClick": props3.onClick
        }, restAttrs), [children]);
      }
      link2 = renderBreadcrumbNode(link2, prefixCls.value);
      if (children) {
        return createVNode("span", {
          "class": cls,
          "style": style2
        }, [link2, separator && createVNode("span", {
          "class": "".concat(prefixCls.value, "-separator")
        }, [separator])]);
      }
      return null;
    };
  }
});
function shallowEqual(objA, objB, compare2, compareContext) {
  var ret = compare2 ? compare2.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (_typeof$3(objA) !== "object" || !objA || _typeof$3(objB) !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    var valueA = objA[key2];
    var valueB = objB[key2];
    ret = compare2 ? compare2.call(compareContext, valueA, valueB, key2) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function shallowequal(value, other, customizer, thisArg) {
  return shallowEqual(toRaw(value), toRaw(other), customizer, thisArg);
}
var MenuContextKey = Symbol("menuContextKey");
var useProvideMenu = function useProvideMenu2(props3) {
  provide(MenuContextKey, props3);
};
var useInjectMenu = function useInjectMenu2() {
  return inject(MenuContextKey);
};
var ForceRenderKey = Symbol("ForceRenderKey");
var useProvideForceRender = function useProvideForceRender2(forceRender) {
  provide(ForceRenderKey, forceRender);
};
var useInjectForceRender = function useInjectForceRender2() {
  return inject(ForceRenderKey, false);
};
var MenuFirstLevelContextKey = Symbol("menuFirstLevelContextKey");
var useProvideFirstLevel = function useProvideFirstLevel2(firstLevel) {
  provide(MenuFirstLevelContextKey, firstLevel);
};
var useInjectFirstLevel = function useInjectFirstLevel2() {
  return inject(MenuFirstLevelContextKey, true);
};
var MenuContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: false,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    },
    isRootMenu: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup53(props3, _ref) {
    var slots = _ref.slots;
    var menuContext = useInjectMenu();
    var newContext = _objectSpread2$1({}, menuContext);
    if (props3.mode !== void 0) {
      newContext.mode = toRef(props3, "mode");
    }
    if (props3.isRootMenu !== void 0) {
      newContext.isRootMenu = toRef(props3, "isRootMenu");
    }
    if (props3.overflowDisabled !== void 0) {
      newContext.overflowDisabled = toRef(props3, "overflowDisabled");
    }
    useProvideMenu(newContext);
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
const useProvideMenu$1 = useProvideMenu;
function baseFindIndex(array4, predicate, fromIndex, fromRight) {
  var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array4, value, fromIndex) {
  var index2 = fromIndex - 1, length = array4.length;
  while (++index2 < length) {
    if (array4[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array4, value, fromIndex) {
  return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
}
function arrayIncludes(array4, value) {
  var length = array4 == null ? 0 : array4.length;
  return !!length && baseIndexOf(array4, value, 0) > -1;
}
function arrayIncludesWith(array4, value, comparator2) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (comparator2(value, array4[index2])) {
      return true;
    }
  }
  return false;
}
function noop$9() {
}
var INFINITY$3 = 1 / 0;
var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY$3) ? noop$9 : function(values) {
  return new Set$2(values);
};
const createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array4, iteratee, comparator2) {
  var index2 = -1, includes2 = arrayIncludes, length = array4.length, isCommon = true, result = [], seen2 = result;
  if (comparator2) {
    isCommon = false;
    includes2 = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet$1(array4);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes2 = cacheHas;
    seen2 = new SetCache();
  } else {
    seen2 = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator2 || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen2.length;
        while (seenIndex--) {
          if (seen2[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen2.push(computed2);
        }
        result.push(value);
      } else if (!includes2(seen2, computed2, comparator2)) {
        if (seen2 !== result) {
          seen2.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
function uniq(array4) {
  return array4 && array4.length ? baseUniq(array4) : [];
}
var SiderCollapsedKey = Symbol("siderCollapsed");
var SiderHookProviderKey = Symbol("siderHookProvider");
var OVERFLOW_KEY = "$$__vc-menu-more__key";
var KeyPathContext = Symbol("KeyPathContext");
var useInjectKeyPath = function useInjectKeyPath2() {
  return inject(KeyPathContext, {
    parentEventKeys: computed(function() {
      return [];
    }),
    parentKeys: computed(function() {
      return [];
    }),
    parentInfo: {}
  });
};
var useProvideKeyPath = function useProvideKeyPath2(eventKey, key2, menuInfo) {
  var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
  var eventKeys = computed(function() {
    return [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]);
  });
  var keys2 = computed(function() {
    return [].concat(_toConsumableArray(parentKeys.value), [key2]);
  });
  provide(KeyPathContext, {
    parentEventKeys: eventKeys,
    parentKeys: keys2,
    parentInfo: menuInfo
  });
  return keys2;
};
var measure$1 = Symbol("measure");
var PathContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  setup: function setup54(_props, _ref) {
    var slots = _ref.slots;
    provide(measure$1, true);
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var useMeasure = function useMeasure2() {
  return inject(measure$1, false);
};
const useProvideKeyPath$1 = useProvideKeyPath;
function useDirectionStyle(level) {
  var _useInjectMenu = useInjectMenu(), mode = _useInjectMenu.mode, rtl2 = _useInjectMenu.rtl, inlineIndent = _useInjectMenu.inlineIndent;
  return computed(function() {
    return mode.value !== "inline" ? null : rtl2.value ? {
      paddingRight: "".concat(level.value * inlineIndent.value, "px")
    } : {
      paddingLeft: "".concat(level.value * inlineIndent.value, "px")
    };
  });
}
var indexGuid$3 = 0;
var menuItemProps = function menuItemProps2() {
  return {
    id: String,
    role: String,
    disabled: Boolean,
    danger: Boolean,
    title: {
      type: [String, Boolean],
      default: void 0
    },
    icon: PropTypes$1.any,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function,
    onKeydown: Function,
    onFocus: Function
  };
};
const MenuItem$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: false,
  props: menuItemProps(),
  slots: ["icon", "title"],
  setup: function setup55(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var instance = getCurrentInstance();
    var isMeasure = useMeasure();
    var key2 = _typeof$3(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(_typeof$3(instance.vnode.key) !== "symbol", "MenuItem", 'MenuItem `:key="'.concat(String(key2), '"` not support Symbol type'));
    var eventKey = "menu_item_".concat(++indexGuid$3, "_$$_").concat(key2);
    var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentKeys = _useInjectKeyPath.parentKeys;
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, disabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, rtl2 = _useInjectMenu.rtl, inlineCollapsed = _useInjectMenu.inlineCollapsed, siderCollapsed = _useInjectMenu.siderCollapsed, onItemClick2 = _useInjectMenu.onItemClick, selectedKeys = _useInjectMenu.selectedKeys, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo;
    var firstLevel = useInjectFirstLevel();
    var isActive = ref(false);
    var keysPath = computed(function() {
      return [].concat(_toConsumableArray(parentKeys.value), [key2]);
    });
    var menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      parentKeys,
      isLeaf: true
    };
    registerMenuInfo(eventKey, menuInfo);
    onBeforeUnmount(function() {
      unRegisterMenuInfo(eventKey);
    });
    watch(activeKeys, function() {
      isActive.value = !!activeKeys.value.find(function(val) {
        return val === key2;
      });
    }, {
      immediate: true
    });
    var mergedDisabled = computed(function() {
      return disabled.value || props3.disabled;
    });
    var selected = computed(function() {
      return selectedKeys.value.includes(key2);
    });
    var classNames2 = computed(function() {
      var _ref2;
      var itemCls = "".concat(prefixCls.value, "-item");
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(itemCls), true), _defineProperty$U(_ref2, "".concat(itemCls, "-danger"), props3.danger), _defineProperty$U(_ref2, "".concat(itemCls, "-active"), isActive.value), _defineProperty$U(_ref2, "".concat(itemCls, "-selected"), selected.value), _defineProperty$U(_ref2, "".concat(itemCls, "-disabled"), mergedDisabled.value), _ref2;
    });
    var getEventInfo = function getEventInfo2(e2) {
      return {
        key: key2,
        eventKey,
        keyPath: keysPath.value,
        eventKeyPath: [].concat(_toConsumableArray(parentEventKeys.value), [eventKey]),
        domEvent: e2,
        item: _objectSpread2$1(_objectSpread2$1({}, props3), attrs)
      };
    };
    var onInternalClick = function onInternalClick2(e2) {
      if (mergedDisabled.value) {
        return;
      }
      var info = getEventInfo(e2);
      emit("click", e2);
      onItemClick2(info);
    };
    var onMouseEnter = function onMouseEnter2(event2) {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event2);
      }
    };
    var onMouseLeave = function onMouseLeave2(event2) {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event2);
      }
    };
    var onInternalKeyDown = function onInternalKeyDown2(e2) {
      emit("keydown", e2);
      if (e2.which === KeyCode$1.ENTER) {
        var info = getEventInfo(e2);
        emit("click", e2);
        onItemClick2(info);
      }
    };
    var onInternalFocus = function onInternalFocus2(e2) {
      changeActiveKeys(keysPath.value);
      emit("focus", e2);
    };
    var renderItemChildren = function renderItemChildren2(icon, children) {
      var wrapNode = createVNode("span", {
        "class": "".concat(prefixCls.value, "-title-content")
      }, [children]);
      if (!icon || isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed.value && firstLevel && typeof children === "string") {
          return createVNode("div", {
            "class": "".concat(prefixCls.value, "-inline-collapsed-noicon")
          }, [children.charAt(0)]);
        }
      }
      return wrapNode;
    };
    var directionStyle = useDirectionStyle(computed(function() {
      return keysPath.value.length;
    }));
    return function() {
      var _props$title, _slots$title, _slots$default, _ref3;
      if (isMeasure)
        return null;
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var childrenLength = children.length;
      var tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel && childrenLength ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      var tooltipProps3 = {
        title: tooltipTitle
      };
      if (!siderCollapsed.value && !inlineCollapsed.value) {
        tooltipProps3.title = null;
        tooltipProps3.visible = false;
      }
      var optionRoleProps = {};
      if (props3.role === "option") {
        optionRoleProps["aria-selected"] = selected.value;
      }
      var icon = getPropsSlot(slots, props3, "icon");
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, tooltipProps3), {}, {
        "placement": rtl2.value ? "left" : "right",
        "overlayClassName": "".concat(prefixCls.value, "-inline-collapsed-tooltip")
      }), {
        default: function _default9() {
          return [createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "id": props3.id,
            "style": _objectSpread2$1(_objectSpread2$1({}, attrs.style || {}), directionStyle.value),
            "class": [classNames2.value, (_ref3 = {}, _defineProperty$U(_ref3, "".concat(attrs.class), !!attrs.class), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-only-child"), (icon ? childrenLength + 1 : childrenLength) === 1), _ref3)],
            "role": props3.role || "menuitem",
            "tabindex": props3.disabled ? null : -1,
            "data-menu-id": key2,
            "aria-disabled": props3.disabled
          }, optionRoleProps), {}, {
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "onClick": onInternalClick,
            "onKeydown": onInternalKeyDown,
            "onFocus": onInternalFocus,
            "title": typeof title === "string" ? title : void 0
          }), {
            default: function _default10() {
              return [cloneElement(icon, {
                class: "".concat(prefixCls.value, "-item-icon")
              }, false), renderItemChildren(icon, children)];
            }
          })];
        }
      });
    };
  }
});
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow,
    offset: [4, 0]
  }
};
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
const PopupTrigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: ["popup"],
  emits: ["visibleChange"],
  setup: function setup56(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var innerVisible = ref(false);
    var _useInjectMenu = useInjectMenu(), getPopupContainer = _useInjectMenu.getPopupContainer, rtl2 = _useInjectMenu.rtl, subMenuOpenDelay = _useInjectMenu.subMenuOpenDelay, subMenuCloseDelay = _useInjectMenu.subMenuCloseDelay, builtinPlacements = _useInjectMenu.builtinPlacements, triggerSubMenuAction = _useInjectMenu.triggerSubMenuAction, isRootMenu = _useInjectMenu.isRootMenu, forceSubMenuRender = _useInjectMenu.forceSubMenuRender, motion = _useInjectMenu.motion, defaultMotions = _useInjectMenu.defaultMotions;
    var forceRender = useInjectForceRender();
    var placement = computed(function() {
      return rtl2.value ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), builtinPlacements.value) : _objectSpread2$1(_objectSpread2$1({}, placements), builtinPlacements.value);
    });
    var popupPlacement = computed(function() {
      return popupPlacementMap[props3.mode];
    });
    var visibleRef = ref();
    watch(function() {
      return props3.visible;
    }, function(visible) {
      wrapperRaf.cancel(visibleRef.value);
      visibleRef.value = wrapperRaf(function() {
        innerVisible.value = visible;
      });
    }, {
      immediate: true
    });
    onBeforeUnmount(function() {
      wrapperRaf.cancel(visibleRef.value);
    });
    var onVisibleChange = function onVisibleChange2(visible) {
      emit("visibleChange", visible);
    };
    var mergedMotion = computed(function() {
      var _defaultMotions$value, _defaultMotions$value2;
      var m2 = motion.value || ((_defaultMotions$value = defaultMotions.value) === null || _defaultMotions$value === void 0 ? void 0 : _defaultMotions$value[props3.mode]) || ((_defaultMotions$value2 = defaultMotions.value) === null || _defaultMotions$value2 === void 0 ? void 0 : _defaultMotions$value2.other);
      var res = typeof m2 === "function" ? m2() : m2;
      return res ? getTransitionProps(res.name, {
        css: true
      }) : void 0;
    });
    return function() {
      var prefixCls = props3.prefixCls, popupClassName = props3.popupClassName, mode = props3.mode, popupOffset = props3.popupOffset, disabled = props3.disabled;
      return createVNode(Trigger, {
        "prefixCls": prefixCls,
        "popupClassName": classNames("".concat(prefixCls, "-popup"), _defineProperty$U({}, "".concat(prefixCls, "-rtl"), rtl2.value), popupClassName),
        "stretch": mode === "horizontal" ? "minWidth" : null,
        "getPopupContainer": isRootMenu.value ? getPopupContainer.value : function(triggerNode) {
          return triggerNode.parentNode;
        },
        "builtinPlacements": placement.value,
        "popupPlacement": popupPlacement.value,
        "popupVisible": innerVisible.value,
        "popupAlign": popupOffset && {
          offset: popupOffset
        },
        "action": disabled ? [] : [triggerSubMenuAction.value],
        "mouseEnterDelay": subMenuOpenDelay.value,
        "mouseLeaveDelay": subMenuCloseDelay.value,
        "onPopupVisibleChange": onVisibleChange,
        "forceRender": forceRender || forceSubMenuRender.value,
        "popupAnimation": mergedMotion.value
      }, {
        popup: slots.popup,
        default: slots.default
      });
    };
  }
});
var InternalSubMenuList = function InternalSubMenuList2(_props, _ref) {
  var _slots$default;
  var slots = _ref.slots, attrs = _ref.attrs;
  var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, mode = _useInjectMenu.mode;
  return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
    "class": classNames(prefixCls.value, "".concat(prefixCls.value, "-sub"), "".concat(prefixCls.value, "-").concat(mode.value === "inline" ? "inline" : "vertical")),
    "data-menu-list": true
  }), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
};
InternalSubMenuList.displayName = "SubMenuList";
const SubMenuList = InternalSubMenuList;
const InlineSubMenuList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: false,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup: function setup57(props3, _ref) {
    var slots = _ref.slots;
    var fixedMode = computed(function() {
      return "inline";
    });
    var _useInjectMenu = useInjectMenu(), motion = _useInjectMenu.motion, mode = _useInjectMenu.mode, defaultMotions = _useInjectMenu.defaultMotions;
    var sameModeRef = computed(function() {
      return mode.value === fixedMode.value;
    });
    var destroy3 = ref(!sameModeRef.value);
    var mergedOpen = computed(function() {
      return sameModeRef.value ? props3.open : false;
    });
    watch(mode, function() {
      if (sameModeRef.value) {
        destroy3.value = false;
      }
    }, {
      flush: "post"
    });
    var mergedMotion = computed(function() {
      var _defaultMotions$value, _defaultMotions$value2;
      var m2 = motion.value || ((_defaultMotions$value = defaultMotions.value) === null || _defaultMotions$value === void 0 ? void 0 : _defaultMotions$value[fixedMode.value]) || ((_defaultMotions$value2 = defaultMotions.value) === null || _defaultMotions$value2 === void 0 ? void 0 : _defaultMotions$value2.other);
      var res = typeof m2 === "function" ? m2() : m2;
      return _objectSpread2$1(_objectSpread2$1({}, res), {}, {
        appear: props3.keyPath.length <= 1
      });
    });
    return function() {
      var _slots$default;
      if (destroy3.value) {
        return null;
      }
      return createVNode(MenuContextProvider, {
        "mode": fixedMode.value
      }, {
        default: function _default9() {
          return [createVNode(Transition, mergedMotion.value, {
            default: function _default10() {
              return [withDirectives(createVNode(SubMenuList, {
                "id": props3.id
              }, {
                default: function _default11() {
                  return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
                }
              }), [[vShow, mergedOpen.value]])];
            }
          })];
        }
      });
    };
  }
});
var indexGuid$2 = 0;
var subMenuProps = function subMenuProps2() {
  return {
    icon: PropTypes$1.any,
    title: PropTypes$1.any,
    disabled: Boolean,
    level: Number,
    popupClassName: String,
    popupOffset: Array,
    internalPopupClose: Boolean,
    eventKey: String,
    expandIcon: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onTitleClick: Function
  };
};
const SubMenu$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: false,
  props: subMenuProps(),
  slots: ["icon", "title", "expandIcon"],
  setup: function setup58(props3, _ref) {
    var _props$eventKey, _parentInfo$childrenE;
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    useProvideFirstLevel(false);
    var isMeasure = useMeasure();
    var instance = getCurrentInstance();
    var vnodeKey = _typeof$3(instance.vnode.key) === "symbol" ? String(instance.vnode.key) : instance.vnode.key;
    devWarning(_typeof$3(instance.vnode.key) !== "symbol", "SubMenu", 'SubMenu `:key="'.concat(String(vnodeKey), '"` not support Symbol type'));
    var key2 = isValid$2(vnodeKey) ? vnodeKey : "sub_menu_".concat(++indexGuid$2, "_$$_not_set_key");
    var eventKey = (_props$eventKey = props3.eventKey) !== null && _props$eventKey !== void 0 ? _props$eventKey : isValid$2(vnodeKey) ? "sub_menu_".concat(++indexGuid$2, "_$$_").concat(vnodeKey) : key2;
    var _useInjectKeyPath = useInjectKeyPath(), parentEventKeys = _useInjectKeyPath.parentEventKeys, parentInfo = _useInjectKeyPath.parentInfo, parentKeys = _useInjectKeyPath.parentKeys;
    var keysPath = computed(function() {
      return [].concat(_toConsumableArray(parentKeys.value), [key2]);
    });
    var childrenEventKeys = ref([]);
    var menuInfo = {
      eventKey,
      key: key2,
      parentEventKeys,
      childrenEventKeys,
      parentKeys
    };
    (_parentInfo$childrenE = parentInfo.childrenEventKeys) === null || _parentInfo$childrenE === void 0 ? void 0 : _parentInfo$childrenE.value.push(eventKey);
    onBeforeUnmount(function() {
      if (parentInfo.childrenEventKeys) {
        var _parentInfo$childrenE2;
        parentInfo.childrenEventKeys.value = (_parentInfo$childrenE2 = parentInfo.childrenEventKeys) === null || _parentInfo$childrenE2 === void 0 ? void 0 : _parentInfo$childrenE2.value.filter(function(k2) {
          return k2 != eventKey;
        });
      }
    });
    useProvideKeyPath$1(eventKey, key2, menuInfo);
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls, activeKeys = _useInjectMenu.activeKeys, contextDisabled = _useInjectMenu.disabled, changeActiveKeys = _useInjectMenu.changeActiveKeys, mode = _useInjectMenu.mode, inlineCollapsed = _useInjectMenu.inlineCollapsed, antdMenuTheme = _useInjectMenu.antdMenuTheme, openKeys = _useInjectMenu.openKeys, overflowDisabled = _useInjectMenu.overflowDisabled, onOpenChange = _useInjectMenu.onOpenChange, registerMenuInfo = _useInjectMenu.registerMenuInfo, unRegisterMenuInfo = _useInjectMenu.unRegisterMenuInfo, selectedSubMenuKeys = _useInjectMenu.selectedSubMenuKeys, menuExpandIcon = _useInjectMenu.expandIcon;
    var hasKey = vnodeKey !== void 0 && vnodeKey !== null;
    var forceRender = !isMeasure && (useInjectForceRender() || !hasKey);
    useProvideForceRender(forceRender);
    if (isMeasure && hasKey || !isMeasure && !hasKey || forceRender) {
      registerMenuInfo(eventKey, menuInfo);
      onBeforeUnmount(function() {
        unRegisterMenuInfo(eventKey);
      });
    }
    var subMenuPrefixCls = computed(function() {
      return "".concat(prefixCls.value, "-submenu");
    });
    var mergedDisabled = computed(function() {
      return contextDisabled.value || props3.disabled;
    });
    var elementRef = ref();
    var popupRef = ref();
    var originOpen = computed(function() {
      return openKeys.value.includes(key2);
    });
    var open2 = computed(function() {
      return !overflowDisabled.value && originOpen.value;
    });
    var childrenSelected = computed(function() {
      return selectedSubMenuKeys.value.includes(key2);
    });
    var isActive = ref(false);
    watch(activeKeys, function() {
      isActive.value = !!activeKeys.value.find(function(val) {
        return val === key2;
      });
    }, {
      immediate: true
    });
    var onInternalTitleClick = function onInternalTitleClick2(e2) {
      if (mergedDisabled.value) {
        return;
      }
      emit("titleClick", e2, key2);
      if (mode.value === "inline") {
        onOpenChange(key2, !originOpen.value);
      }
    };
    var onMouseEnter = function onMouseEnter2(event2) {
      if (!mergedDisabled.value) {
        changeActiveKeys(keysPath.value);
        emit("mouseenter", event2);
      }
    };
    var onMouseLeave = function onMouseLeave2(event2) {
      if (!mergedDisabled.value) {
        changeActiveKeys([]);
        emit("mouseleave", event2);
      }
    };
    var directionStyle = useDirectionStyle(computed(function() {
      return keysPath.value.length;
    }));
    var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
      if (mode.value !== "inline") {
        onOpenChange(key2, newVisible);
      }
    };
    var onInternalFocus = function onInternalFocus2() {
      changeActiveKeys(keysPath.value);
    };
    var popupId = eventKey && "".concat(eventKey, "-popup");
    var popupClassName = computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-").concat(antdMenuTheme.value), props3.popupClassName);
    });
    var renderTitle = function renderTitle2(title, icon) {
      if (!icon) {
        return inlineCollapsed.value && !parentKeys.value.length && title && typeof title === "string" ? createVNode("div", {
          "class": "".concat(prefixCls.value, "-inline-collapsed-noicon")
        }, [title.charAt(0)]) : createVNode("span", {
          "class": "".concat(prefixCls.value, "-title-content")
        }, [title]);
      }
      var titleIsSpan = isValidElement(title) && title.type === "span";
      return createVNode(Fragment, null, [cloneElement(icon, {
        class: "".concat(prefixCls.value, "-item-icon")
      }, false), titleIsSpan ? title : createVNode("span", {
        "class": "".concat(prefixCls.value, "-title-content")
      }, [title])]);
    };
    var triggerModeRef = computed(function() {
      return mode.value !== "inline" && keysPath.value.length > 1 ? "vertical" : mode.value;
    });
    var renderMode = computed(function() {
      return mode.value === "horizontal" ? "vertical" : mode.value;
    });
    var subMenuTriggerModeRef = computed(function() {
      return triggerModeRef.value === "horizontal" ? "vertical" : triggerModeRef.value;
    });
    var baseTitleNode = function baseTitleNode2() {
      var subMenuPrefixClsValue = subMenuPrefixCls.value;
      var icon = getPropsSlot(slots, props3, "icon");
      var expandIcon = props3.expandIcon || slots.expandIcon || menuExpandIcon.value;
      var title = renderTitle(getPropsSlot(slots, props3, "title"), icon);
      return createVNode("div", {
        "style": directionStyle.value,
        "class": "".concat(subMenuPrefixClsValue, "-title"),
        "tabindex": mergedDisabled.value ? null : -1,
        "ref": elementRef,
        "title": typeof title === "string" ? title : null,
        "data-menu-id": key2,
        "aria-expanded": open2.value,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled.value,
        "onClick": onInternalTitleClick,
        "onFocus": onInternalFocus
      }, [title, mode.value !== "horizontal" && expandIcon ? expandIcon(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        isOpen: open2.value
      })) : createVNode("i", {
        "class": "".concat(subMenuPrefixClsValue, "-arrow")
      }, null)]);
    };
    return function() {
      var _classNames;
      if (isMeasure) {
        var _slots$default;
        if (!hasKey) {
          return null;
        }
        return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }
      var subMenuPrefixClsValue = subMenuPrefixCls.value;
      var titleNode = function titleNode2() {
        return null;
      };
      if (!overflowDisabled.value && mode.value !== "inline") {
        titleNode = function titleNode2() {
          return createVNode(PopupTrigger, {
            "mode": triggerModeRef.value,
            "prefixCls": subMenuPrefixClsValue,
            "visible": !props3.internalPopupClose && open2.value,
            "popupClassName": popupClassName.value,
            "popupOffset": props3.popupOffset,
            "disabled": mergedDisabled.value,
            "onVisibleChange": onPopupVisibleChange
          }, {
            default: function _default9() {
              return [baseTitleNode()];
            },
            popup: function popup() {
              return createVNode(MenuContextProvider, {
                "mode": subMenuTriggerModeRef.value,
                "isRootMenu": false
              }, {
                default: function _default9() {
                  return [createVNode(SubMenuList, {
                    "id": popupId,
                    "ref": popupRef
                  }, {
                    default: slots.default
                  })];
                }
              });
            }
          });
        };
      } else {
        titleNode = function titleNode2() {
          return createVNode(PopupTrigger, null, {
            default: baseTitleNode
          });
        };
      }
      return createVNode(MenuContextProvider, {
        "mode": renderMode.value
      }, {
        default: function _default9() {
          return [createVNode(Overflow$1.Item, _objectSpread2$1(_objectSpread2$1({
            "component": "li"
          }, attrs), {}, {
            "role": "none",
            "class": classNames(subMenuPrefixClsValue, "".concat(subMenuPrefixClsValue, "-").concat(mode.value), attrs.class, (_classNames = {}, _defineProperty$U(_classNames, "".concat(subMenuPrefixClsValue, "-open"), open2.value), _defineProperty$U(_classNames, "".concat(subMenuPrefixClsValue, "-active"), isActive.value), _defineProperty$U(_classNames, "".concat(subMenuPrefixClsValue, "-selected"), childrenSelected.value), _defineProperty$U(_classNames, "".concat(subMenuPrefixClsValue, "-disabled"), mergedDisabled.value), _classNames)),
            "onMouseenter": onMouseEnter,
            "onMouseleave": onMouseLeave,
            "data-submenu-id": key2
          }), {
            default: function _default10() {
              return createVNode(Fragment, null, [titleNode(), !overflowDisabled.value && createVNode(InlineSubMenuList, {
                "id": popupId,
                "open": open2.value,
                "keyPath": keysPath.value
              }, {
                default: slots.default
              })]);
            }
          })];
        }
      });
    };
  }
});
function hasClass(node, className) {
  if (node.classList) {
    return node.classList.contains(className);
  }
  var originClass = node.className;
  return " ".concat(originClass, " ").indexOf(" ".concat(className, " ")) > -1;
}
function addClass(node, className) {
  if (node.classList) {
    node.classList.add(className);
  } else {
    if (!hasClass(node, className)) {
      node.className = "".concat(node.className, " ").concat(className);
    }
  }
}
function removeClass(node, className) {
  if (node.classList) {
    node.classList.remove(className);
  } else {
    if (hasClass(node, className)) {
      var originClass = node.className;
      node.className = " ".concat(originClass, " ").replace(" ".concat(className, " "), " ");
    }
  }
}
var collapseMotion = function collapseMotion2() {
  var name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
  var appear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return {
    name: name2,
    appear,
    css: true,
    onBeforeEnter: function onBeforeEnter(node) {
      node.style.height = "0px";
      node.style.opacity = "0";
      addClass(node, name2);
    },
    onEnter: function onEnter(node) {
      nextTick(function() {
        node.style.height = "".concat(node.scrollHeight, "px");
        node.style.opacity = "1";
      });
    },
    onAfterEnter: function onAfterEnter(node) {
      if (node) {
        removeClass(node, name2);
        node.style.height = null;
        node.style.opacity = null;
      }
    },
    onBeforeLeave: function onBeforeLeave(node) {
      addClass(node, name2);
      node.style.height = "".concat(node.offsetHeight, "px");
      node.style.opacity = null;
    },
    onLeave: function onLeave(node) {
      setTimeout(function() {
        node.style.height = "0px";
        node.style.opacity = "0";
      });
    },
    onAfterLeave: function onAfterLeave(node) {
      if (node) {
        removeClass(node, name2);
        if (node.style) {
          node.style.height = null;
          node.style.opacity = null;
        }
      }
    }
  };
};
const collapseMotion$1 = collapseMotion;
var menuProps = function menuProps2() {
  return {
    id: String,
    prefixCls: String,
    disabled: Boolean,
    inlineCollapsed: Boolean,
    disabledOverflow: Boolean,
    forceSubMenuRender: Boolean,
    openKeys: Array,
    selectedKeys: Array,
    activeKey: String,
    selectable: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    motion: Object,
    theme: {
      type: String,
      default: "light"
    },
    mode: {
      type: String,
      default: "vertical"
    },
    inlineIndent: {
      type: Number,
      default: 24
    },
    subMenuOpenDelay: {
      type: Number,
      default: 0.1
    },
    subMenuCloseDelay: {
      type: Number,
      default: 0.1
    },
    builtinPlacements: {
      type: Object
    },
    triggerSubMenuAction: {
      type: String,
      default: "hover"
    },
    getPopupContainer: Function,
    expandIcon: Function,
    onOpenChange: Function,
    onSelect: Function,
    onDeselect: Function,
    onClick: [Function, Array],
    onFocus: Function,
    onBlur: Function,
    onMousedown: Function,
    "onUpdate:openKeys": Function,
    "onUpdate:selectedKeys": Function,
    "onUpdate:activeKey": Function
  };
};
var EMPTY_LIST$2 = [];
const Menu = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: false,
  props: menuProps(),
  slots: ["expandIcon", "overflowedIndicator"],
  setup: function setup59(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("menu", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var store = ref({});
    var siderCollapsed = inject(SiderCollapsedKey, ref(void 0));
    var inlineCollapsed = computed(function() {
      if (siderCollapsed.value !== void 0) {
        return siderCollapsed.value;
      }
      return props3.inlineCollapsed;
    });
    var isMounted = ref(false);
    onMounted(function() {
      isMounted.value = true;
    });
    watchEffect(function() {
      devWarning(!(props3.inlineCollapsed === true && props3.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline.");
      devWarning(!(siderCollapsed.value !== void 0 && props3.inlineCollapsed === true), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    var activeKeys = ref([]);
    var mergedSelectedKeys = ref([]);
    var keyMapStore = ref({});
    watch(store, function() {
      var newKeyMapStore = {};
      for (var _i = 0, _Object$values = Object.values(store.value); _i < _Object$values.length; _i++) {
        var menuInfo = _Object$values[_i];
        newKeyMapStore[menuInfo.key] = menuInfo;
      }
      keyMapStore.value = newKeyMapStore;
    }, {
      flush: "post"
    });
    watchEffect(function() {
      if (props3.activeKey !== void 0) {
        var keys2 = [];
        var menuInfo = props3.activeKey ? keyMapStore.value[props3.activeKey] : void 0;
        if (menuInfo && props3.activeKey !== void 0) {
          keys2 = uniq([].concat(unref(menuInfo.parentKeys), props3.activeKey));
        } else {
          keys2 = [];
        }
        if (!shallowequal(activeKeys.value, keys2)) {
          activeKeys.value = keys2;
        }
      }
    });
    watch(function() {
      return props3.selectedKeys;
    }, function(selectedKeys) {
      if (selectedKeys) {
        mergedSelectedKeys.value = selectedKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    var selectedSubMenuKeys = ref([]);
    watch([keyMapStore, mergedSelectedKeys], function() {
      var subMenuParentKeys = [];
      mergedSelectedKeys.value.forEach(function(key2) {
        var menuInfo = keyMapStore.value[key2];
        if (menuInfo) {
          subMenuParentKeys = subMenuParentKeys.concat(unref(menuInfo.parentKeys));
        }
      });
      subMenuParentKeys = uniq(subMenuParentKeys);
      if (!shallowequal(selectedSubMenuKeys.value, subMenuParentKeys)) {
        selectedSubMenuKeys.value = subMenuParentKeys;
      }
    }, {
      immediate: true
    });
    var triggerSelection = function triggerSelection2(info) {
      if (!props3.selectable) {
        return;
      }
      var targetKey = info.key;
      var exist = mergedSelectedKeys.value.includes(targetKey);
      var newSelectedKeys;
      if (props3.multiple) {
        if (exist) {
          newSelectedKeys = mergedSelectedKeys.value.filter(function(key2) {
            return key2 !== targetKey;
          });
        } else {
          newSelectedKeys = [].concat(_toConsumableArray(mergedSelectedKeys.value), [targetKey]);
        }
      } else {
        newSelectedKeys = [targetKey];
      }
      var selectInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        selectedKeys: newSelectedKeys
      });
      if (!shallowequal(newSelectedKeys, mergedSelectedKeys.value)) {
        if (props3.selectedKeys === void 0) {
          mergedSelectedKeys.value = newSelectedKeys;
        }
        emit("update:selectedKeys", newSelectedKeys);
        if (exist && props3.multiple) {
          emit("deselect", selectInfo);
        } else {
          emit("select", selectInfo);
        }
      }
      if (mergedMode.value !== "inline" && !props3.multiple && mergedOpenKeys.value.length) {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    };
    var mergedOpenKeys = ref([]);
    watch(function() {
      return props3.openKeys;
    }, function() {
      var openKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mergedOpenKeys.value;
      if (!shallowequal(mergedOpenKeys.value, openKeys)) {
        mergedOpenKeys.value = openKeys.slice();
      }
    }, {
      immediate: true,
      deep: true
    });
    var timeout;
    var changeActiveKeys = function changeActiveKeys2(keys2) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        if (props3.activeKey === void 0) {
          activeKeys.value = keys2;
        }
        emit("update:activeKey", keys2[keys2.length - 1]);
      });
    };
    var disabled = computed(function() {
      return !!props3.disabled;
    });
    var isRtl = computed(function() {
      return direction.value === "rtl";
    });
    var mergedMode = ref("vertical");
    var mergedInlineCollapsed = ref(false);
    watchEffect(function() {
      if ((props3.mode === "inline" || props3.mode === "vertical") && inlineCollapsed.value) {
        mergedMode.value = "vertical";
        mergedInlineCollapsed.value = inlineCollapsed.value;
      } else {
        mergedMode.value = props3.mode;
        mergedInlineCollapsed.value = false;
      }
    });
    var isInlineMode = computed(function() {
      return mergedMode.value === "inline";
    });
    var triggerOpenKeys = function triggerOpenKeys2(keys2) {
      mergedOpenKeys.value = keys2;
      emit("update:openKeys", keys2);
      emit("openChange", keys2);
    };
    var inlineCacheOpenKeys = ref(mergedOpenKeys.value);
    var mountRef = ref(false);
    watch(mergedOpenKeys, function() {
      if (isInlineMode.value) {
        inlineCacheOpenKeys.value = mergedOpenKeys.value;
      }
    }, {
      immediate: true
    });
    watch(isInlineMode, function() {
      if (!mountRef.value) {
        mountRef.value = true;
        return;
      }
      if (isInlineMode.value) {
        mergedOpenKeys.value = inlineCacheOpenKeys.value;
      } else {
        triggerOpenKeys(EMPTY_LIST$2);
      }
    }, {
      immediate: true
    });
    var className = computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-root"), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-").concat(mergedMode.value), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-inline-collapsed"), mergedInlineCollapsed.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-rtl"), isRtl.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-").concat(props3.theme), true), _ref2;
    });
    var rootPrefixCls = computed(function() {
      return getPrefixCls2();
    });
    var defaultMotions = computed(function() {
      return {
        horizontal: {
          name: "".concat(rootPrefixCls.value, "-slide-up")
        },
        inline: collapseMotion$1,
        other: {
          name: "".concat(rootPrefixCls.value, "-zoom-big")
        }
      };
    });
    useProvideFirstLevel(true);
    var getChildrenKeys = function getChildrenKeys2() {
      var eventKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var keys2 = [];
      var storeValue = store.value;
      eventKeys.forEach(function(eventKey) {
        var _storeValue$eventKey = storeValue[eventKey], key2 = _storeValue$eventKey.key, childrenEventKeys = _storeValue$eventKey.childrenEventKeys;
        keys2.push.apply(keys2, [key2].concat(_toConsumableArray(getChildrenKeys2(unref(childrenEventKeys)))));
      });
      return keys2;
    };
    var onInternalClick = function onInternalClick2(info) {
      emit("click", info);
      triggerSelection(info);
    };
    var onInternalOpenChange = function onInternalOpenChange2(key2, open2) {
      var _keyMapStore$value$ke;
      var childrenEventKeys = ((_keyMapStore$value$ke = keyMapStore.value[key2]) === null || _keyMapStore$value$ke === void 0 ? void 0 : _keyMapStore$value$ke.childrenEventKeys) || [];
      var newOpenKeys = mergedOpenKeys.value.filter(function(k2) {
        return k2 !== key2;
      });
      if (open2) {
        newOpenKeys.push(key2);
      } else if (mergedMode.value !== "inline") {
        var subPathKeys = getChildrenKeys(unref(childrenEventKeys));
        newOpenKeys = uniq(newOpenKeys.filter(function(k2) {
          return !subPathKeys.includes(k2);
        }));
      }
      if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
        triggerOpenKeys(newOpenKeys);
      }
    };
    var registerMenuInfo = function registerMenuInfo2(key2, info) {
      store.value = _objectSpread2$1(_objectSpread2$1({}, store.value), {}, _defineProperty$U({}, key2, info));
    };
    var unRegisterMenuInfo = function unRegisterMenuInfo2(key2) {
      delete store.value[key2];
      store.value = _objectSpread2$1({}, store.value);
    };
    var lastVisibleIndex = ref(0);
    var expandIcon = computed(function() {
      return props3.expandIcon || slots.expandIcon ? function(opt) {
        var icon = props3.expandIcon || slots.expandIcon;
        icon = typeof icon === "function" ? icon(opt) : icon;
        return cloneElement(icon, {
          class: "".concat(prefixCls.value, "-submenu-expand-icon")
        }, false);
      } : null;
    });
    useProvideMenu$1({
      store,
      prefixCls,
      activeKeys,
      openKeys: mergedOpenKeys,
      selectedKeys: mergedSelectedKeys,
      changeActiveKeys,
      disabled,
      rtl: isRtl,
      mode: mergedMode,
      inlineIndent: computed(function() {
        return props3.inlineIndent;
      }),
      subMenuCloseDelay: computed(function() {
        return props3.subMenuCloseDelay;
      }),
      subMenuOpenDelay: computed(function() {
        return props3.subMenuOpenDelay;
      }),
      builtinPlacements: computed(function() {
        return props3.builtinPlacements;
      }),
      triggerSubMenuAction: computed(function() {
        return props3.triggerSubMenuAction;
      }),
      getPopupContainer: computed(function() {
        return props3.getPopupContainer;
      }),
      inlineCollapsed: mergedInlineCollapsed,
      antdMenuTheme: computed(function() {
        return props3.theme;
      }),
      siderCollapsed,
      defaultMotions: computed(function() {
        return isMounted.value ? defaultMotions.value : null;
      }),
      motion: computed(function() {
        return isMounted.value ? props3.motion : null;
      }),
      overflowDisabled: ref(void 0),
      onOpenChange: onInternalOpenChange,
      onItemClick: onInternalClick,
      registerMenuInfo,
      unRegisterMenuInfo,
      selectedSubMenuKeys,
      isRootMenu: ref(true),
      expandIcon,
      forceSubMenuRender: computed(function() {
        return props3.forceSubMenuRender;
      })
    });
    return function() {
      var _slots$default, _slots$overflowedIndi;
      var childList = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var allVisible = lastVisibleIndex.value >= childList.length - 1 || mergedMode.value !== "horizontal" || props3.disabledOverflow;
      var wrappedChildList = mergedMode.value !== "horizontal" || props3.disabledOverflow ? childList : childList.map(function(child, index2) {
        return createVNode(MenuContextProvider, {
          "key": child.key,
          "overflowDisabled": index2 > lastVisibleIndex.value
        }, {
          default: function _default9() {
            return child;
          }
        });
      });
      var overflowedIndicator = ((_slots$overflowedIndi = slots.overflowedIndicator) === null || _slots$overflowedIndi === void 0 ? void 0 : _slots$overflowedIndi.call(slots)) || createVNode(EllipsisOutlined$1, null, null);
      return createVNode(Overflow$1, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onMousedown": props3.onMousedown,
        "prefixCls": "".concat(prefixCls.value, "-overflow"),
        "component": "ul",
        "itemComponent": MenuItem$1,
        "class": [className.value, attrs.class],
        "role": "menu",
        "id": props3.id,
        "data": wrappedChildList,
        "renderRawItem": function renderRawItem(node) {
          return node;
        },
        "renderRawRest": function renderRawRest(omitItems) {
          var len = omitItems.length;
          var originOmitItems = len ? childList.slice(-len) : null;
          return createVNode(Fragment, null, [createVNode(SubMenu$1, {
            "eventKey": OVERFLOW_KEY,
            "key": OVERFLOW_KEY,
            "title": overflowedIndicator,
            "disabled": allVisible,
            "internalPopupClose": len === 0
          }, {
            default: function _default9() {
              return originOmitItems;
            }
          }), createVNode(PathContext, null, {
            default: function _default9() {
              return [createVNode(SubMenu$1, {
                "eventKey": OVERFLOW_KEY,
                "key": OVERFLOW_KEY,
                "title": overflowedIndicator,
                "disabled": allVisible,
                "internalPopupClose": len === 0
              }, {
                default: function _default10() {
                  return originOmitItems;
                }
              })];
            }
          })]);
        },
        "maxCount": mergedMode.value !== "horizontal" || props3.disabledOverflow ? Overflow$1.INVALIDATE : Overflow$1.RESPONSIVE,
        "ssr": "full",
        "data-menu-list": true,
        "onVisibleChange": function onVisibleChange(newLastIndex) {
          lastVisibleIndex.value = newLastIndex;
        }
      }), {
        default: function _default9() {
          return [createVNode(Teleport, {
            "to": "body"
          }, {
            default: function _default10() {
              return [createVNode("div", {
                "style": {
                  display: "none"
                },
                "aria-hidden": true
              }, [createVNode(PathContext, null, {
                default: function _default11() {
                  return [wrappedChildList];
                }
              })])];
            }
          })];
        }
      });
    };
  }
});
var menuItemGroupProps = function menuItemGroupProps2() {
  return {
    title: PropTypes$1.any
  };
};
const ItemGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: false,
  props: menuItemGroupProps(),
  slots: ["title"],
  setup: function setup60(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useInjectMenu = useInjectMenu(), prefixCls = _useInjectMenu.prefixCls;
    var groupPrefixCls = computed(function() {
      return "".concat(prefixCls.value, "-item-group");
    });
    var isMeasure = useMeasure();
    return function() {
      var _slots$default, _slots$default2;
      if (isMeasure)
        return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      return createVNode("li", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onClick": function onClick2(e2) {
          return e2.stopPropagation();
        },
        "class": groupPrefixCls.value
      }), [createVNode("div", {
        "title": typeof props3.title === "string" ? props3.title : void 0,
        "class": "".concat(groupPrefixCls.value, "-title")
      }, [getPropsSlot(slots, props3, "title")]), createVNode("ul", {
        "class": "".concat(groupPrefixCls.value, "-list")
      }, [(_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots)])]);
    };
  }
});
var menuDividerProps = function menuDividerProps2() {
  return {
    prefixCls: String,
    dashed: Boolean
  };
};
const Divider$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: menuDividerProps(),
  setup: function setup61(props3) {
    var _useConfigInject = useConfigInject("menu", props3), prefixCls = _useConfigInject.prefixCls;
    var cls = computed(function() {
      var _ref;
      return _ref = {}, _defineProperty$U(_ref, "".concat(prefixCls.value, "-item-divider"), true), _defineProperty$U(_ref, "".concat(prefixCls.value, "-item-divider-dashed"), !!props3.dashed), _ref;
    });
    return function() {
      return createVNode("li", {
        "class": cls.value
      }, null);
    };
  }
});
Menu.install = function(app) {
  app.component(Menu.name, Menu);
  app.component(MenuItem$1.name, MenuItem$1);
  app.component(SubMenu$1.name, SubMenu$1);
  app.component(Divider$1.name, Divider$1);
  app.component(ItemGroup.name, ItemGroup);
  return app;
};
Menu.Item = MenuItem$1;
Menu.Divider = Divider$1;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = ItemGroup;
var breadcrumbProps = function breadcrumbProps2() {
  return {
    prefixCls: String,
    routes: {
      type: Array
    },
    params: PropTypes$1.any,
    separator: PropTypes$1.any,
    itemRender: {
      type: Function
    }
  };
};
function getBreadcrumbName(route2, params) {
  if (!route2.breadcrumbName) {
    return null;
  }
  var paramsKeys = Object.keys(params).join("|");
  var name2 = route2.breadcrumbName.replace(new RegExp(":(".concat(paramsKeys, ")"), "g"), function(replacement, key2) {
    return params[key2] || replacement;
  });
  return name2;
}
function defaultItemRender$1(opt) {
  var route2 = opt.route, params = opt.params, routes2 = opt.routes, paths = opt.paths;
  var isLastItem = routes2.indexOf(route2) === routes2.length - 1;
  var name2 = getBreadcrumbName(route2, params);
  return isLastItem ? createVNode("span", null, [name2]) : createVNode("a", {
    "href": "#/".concat(paths.join("/"))
  }, [name2]);
}
const Breadcrumb$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumb",
  props: breadcrumbProps(),
  slots: ["separator", "itemRender"],
  setup: function setup62(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("breadcrumb", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var getPath = function getPath2(path2, params) {
      path2 = (path2 || "").replace(/^\//, "");
      Object.keys(params).forEach(function(key2) {
        path2 = path2.replace(":".concat(key2), params[key2]);
      });
      return path2;
    };
    var addChildPath = function addChildPath2(paths, childPath, params) {
      var originalPaths = _toConsumableArray(paths);
      var path2 = getPath(childPath || "", params);
      if (path2) {
        originalPaths.push(path2);
      }
      return originalPaths;
    };
    var genForRoutes = function genForRoutes2(_ref2) {
      var _ref2$routes = _ref2.routes, routes2 = _ref2$routes === void 0 ? [] : _ref2$routes, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? {} : _ref2$params, separator = _ref2.separator, _ref2$itemRender = _ref2.itemRender, itemRender = _ref2$itemRender === void 0 ? defaultItemRender$1 : _ref2$itemRender;
      var paths = [];
      return routes2.map(function(route2) {
        var path2 = getPath(route2.path, params);
        if (path2) {
          paths.push(path2);
        }
        var tempPaths = [].concat(paths);
        var overlay = null;
        if (route2.children && route2.children.length) {
          overlay = createVNode(Menu, null, {
            default: function _default9() {
              return [route2.children.map(function(child) {
                return createVNode(Menu.Item, {
                  "key": child.path || child.breadcrumbName
                }, {
                  default: function _default10() {
                    return [itemRender({
                      route: child,
                      params,
                      routes: routes2,
                      paths: addChildPath(tempPaths, child.path, params)
                    })];
                  }
                });
              })];
            }
          });
        }
        return createVNode(BreadcrumbItem, {
          "overlay": overlay,
          "separator": separator,
          "key": path2 || route2.breadcrumbName
        }, {
          default: function _default9() {
            return [itemRender({
              route: route2,
              params,
              routes: routes2,
              paths: tempPaths
            })];
          }
        });
      });
    };
    return function() {
      var _getPropsSlot, _breadcrumbClassName;
      var crumbs;
      var routes2 = props3.routes, _props$params = props3.params, params = _props$params === void 0 ? {} : _props$params;
      var children = flattenChildren(getPropsSlot(slots, props3));
      var separator = (_getPropsSlot = getPropsSlot(slots, props3, "separator")) !== null && _getPropsSlot !== void 0 ? _getPropsSlot : "/";
      var itemRender = props3.itemRender || slots.itemRender || defaultItemRender$1;
      if (routes2 && routes2.length > 0) {
        crumbs = genForRoutes({
          routes: routes2,
          params,
          separator,
          itemRender
        });
      } else if (children.length) {
        crumbs = children.map(function(element, index2) {
          warning$2(_typeof$3(element.type) === "object" && (element.type.__ANT_BREADCRUMB_ITEM || element.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children");
          return cloneVNode(element, {
            separator,
            key: index2
          });
        });
      }
      var breadcrumbClassName = (_breadcrumbClassName = {}, _defineProperty$U(_breadcrumbClassName, prefixCls.value, true), _defineProperty$U(_breadcrumbClassName, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _breadcrumbClassName);
      return createVNode("div", {
        "class": breadcrumbClassName
      }, [crumbs]);
    };
  }
});
var _excluded$M = ["separator", "class"];
var breadcrumbSeparatorProps = function breadcrumbSeparatorProps2() {
  return {
    prefixCls: String
  };
};
const BreadcrumbSeparator = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: true,
  inheritAttrs: false,
  props: breadcrumbSeparatorProps(),
  setup: function setup63(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("breadcrumb", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _slots$default;
      attrs.separator;
      var className = attrs.class, restAttrs = _objectWithoutProperties$2(attrs, _excluded$M);
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      return createVNode("span", _objectSpread2$1({
        "class": ["".concat(prefixCls.value, "-separator"), className]
      }, restAttrs), [children.length > 0 ? children : "/"]);
    };
  }
});
Breadcrumb$1.Item = BreadcrumbItem;
Breadcrumb$1.Separator = BreadcrumbSeparator;
Breadcrumb$1.install = function(app) {
  app.component(Breadcrumb$1.name, Breadcrumb$1);
  app.component(BreadcrumbItem.name, BreadcrumbItem);
  app.component(BreadcrumbSeparator.name, BreadcrumbSeparator);
  return app;
};
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v2 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), f2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = function(t3) {
      return t3 instanceof _2;
    }, S2 = function t3(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, w2 = function(t3, e3) {
      if (p2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, O2 = v2;
    O2.l = S2, O2.i = p2, O2.w = function(t3, e3) {
      return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = S2(t3.locale, null, true), this.parse(t3);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = w2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return w2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < w2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return O2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!O2.u(e3) || e3, h3 = O2.p(t3), l3 = function(t4, e4) {
          var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $3 = function(t4, e4) {
          return O2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case f2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $3(v3 + "Hours", 0);
          case u2:
            return $3(v3 + "Minutes", 1);
          case s2:
            return $3(v3 + "Seconds", 2);
          case i2:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = O2.p(t3), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === f2 || o3 === c2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[O2.p(t3)]();
      }, m3.add = function(r3, h3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $3 = O2.p(h3), y3 = function(t3) {
          var e3 = w2(l3);
          return O2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($3 === f2)
          return this.set(f2, this.$M + r3);
        if ($3 === c2)
          return this.set(c2, this.$y + r3);
        if ($3 === a2)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, c3 = function(t4) {
          return O2.s(s3 % 12 || 12, t4, "0");
        }, d3 = n3.meridiem || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        }, $3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
        return r3.replace(y2, function(t4, e4) {
          return e4 || $3[t4] || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $3, y3 = O2.p(d3), M4 = w2(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e2, v3 = this - M4, g3 = O2.m(this, M4);
        return g3 = ($3 = {}, $3[c2] = g3 / 12, $3[f2] = g3, $3[h2] = g3 / 3, $3[o2] = (v3 - m4) / 6048e5, $3[a2] = (v3 - m4) / 864e5, $3[u2] = v3 / n2, $3[s2] = v3 / e2, $3[i2] = v3 / t2, $3)[y3] || v3, l3 ? g3 : O2.a(g3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = S2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), T2 = _2.prototype;
    return w2.prototype = T2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t3) {
      T2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), w2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, w2), t3.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
      return w2(1e3 * t3);
    }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
const dayjs = dayjs_min.exports;
var weekday$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekday = function(e3) {
        var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
        return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
      };
    };
  });
})(weekday$1);
const weekday = weekday$1.exports;
var localeData$1 = { exports: {} };
(function(module2, exports2) {
  !function(n2, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    return function(n2, e2, t2) {
      var r2 = e2.prototype, o2 = function(n3) {
        return n3 && (n3.indexOf ? n3 : n3.s);
      }, u2 = function(n3, e3, t3, r3, u3) {
        var i3 = n3.name ? n3 : n3.$locale(), a3 = o2(i3[e3]), s3 = o2(i3[t3]), f2 = a3 || s3.map(function(n4) {
          return n4.slice(0, r3);
        });
        if (!u3)
          return f2;
        var d2 = i3.weekStart;
        return f2.map(function(n4, e4) {
          return f2[(e4 + (d2 || 0)) % 7];
        });
      }, i2 = function() {
        return t2.Ls[t2.locale()];
      }, a2 = function(n3, e3) {
        return n3.formats[e3] || function(n4) {
          return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
            return e4 || t3.slice(1);
          });
        }(n3.formats[e3.toUpperCase()]);
      }, s2 = function() {
        var n3 = this;
        return { months: function(e3) {
          return e3 ? e3.format("MMMM") : u2(n3, "months");
        }, monthsShort: function(e3) {
          return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n3.$locale().weekStart || 0;
        }, weekdays: function(e3) {
          return e3 ? e3.format("dddd") : u2(n3, "weekdays");
        }, weekdaysMin: function(e3) {
          return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e3) {
          return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e3) {
          return a2(n3.$locale(), e3);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r2.localeData = function() {
        return s2.bind(this)();
      }, t2.localeData = function() {
        var n3 = i2();
        return { firstDayOfWeek: function() {
          return n3.weekStart || 0;
        }, weekdays: function() {
          return t2.weekdays();
        }, weekdaysShort: function() {
          return t2.weekdaysShort();
        }, weekdaysMin: function() {
          return t2.weekdaysMin();
        }, months: function() {
          return t2.months();
        }, monthsShort: function() {
          return t2.monthsShort();
        }, longDateFormat: function(e3) {
          return a2(n3, e3);
        }, meridiem: n3.meridiem, ordinal: n3.ordinal };
      }, t2.months = function() {
        return u2(i2(), "months");
      }, t2.monthsShort = function() {
        return u2(i2(), "monthsShort", "months", 3);
      }, t2.weekdays = function(n3) {
        return u2(i2(), "weekdays", null, null, n3);
      }, t2.weekdaysShort = function(n3) {
        return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
      }, t2.weekdaysMin = function(n3) {
        return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
      };
    };
  });
})(localeData$1);
const localeData = localeData$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = "week", t2 = "year";
    return function(i2, n2, r2) {
      var f2 = n2.prototype;
      f2.week = function(i3) {
        if (void 0 === i3 && (i3 = null), null !== i3)
          return this.add(7 * (i3 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s2 = r2(this).endOf(e2);
          if (f3.isBefore(s2))
            return 1;
        }
        var a2 = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
        return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
      }, f2.weeks = function(e3) {
        return void 0 === e3 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear$1);
const weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      t2.prototype.weekYear = function() {
        var e3 = this.month(), t3 = this.week(), n2 = this.year();
        return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
      };
    };
  });
})(weekYear$1);
const weekYear = weekYear$1.exports;
var advancedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    return function(e2, t2) {
      var r2 = t2.prototype, n2 = r2.format;
      r2.format = function(e3) {
        var t3 = this, r3 = this.$locale();
        if (!this.isValid())
          return n2.bind(this)(e3);
        var s2 = this.$utils(), a2 = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
          switch (e4) {
            case "Q":
              return Math.ceil((t3.$M + 1) / 3);
            case "Do":
              return r3.ordinal(t3.$D);
            case "gggg":
              return t3.weekYear();
            case "GGGG":
              return t3.isoWeekYear();
            case "wo":
              return r3.ordinal(t3.week(), "W");
            case "w":
            case "ww":
              return s2.s(t3.week(), "w" === e4 ? 1 : 2, "0");
            case "W":
            case "WW":
              return s2.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
            case "k":
            case "kk":
              return s2.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
            case "X":
              return Math.floor(t3.$d.getTime() / 1e3);
            case "x":
              return t3.$d.getTime();
            case "z":
              return "[" + t3.offsetName() + "]";
            case "zzz":
              return "[" + t3.offsetName("long") + "]";
            default:
              return e4;
          }
        });
        return n2.bind(this)(a2);
      };
    };
  });
})(advancedFormat$1);
const advancedFormat = advancedFormat$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    module2.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
    };
    var a2 = function(e3) {
      return function(t3) {
        this[e3] = +t3;
      };
    }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if ("Z" === e4)
          return 0;
        var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
        return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
      }(e3);
    }], h2 = function(e3) {
      var t3 = o2[e3];
      return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
    }, u2 = function(e3, t3) {
      var n3, r3 = o2.meridiem;
      if (r3) {
        for (var i3 = 1; i3 <= 24; i3 += 1)
          if (e3.indexOf(r3(i3, 0, t3)) > -1) {
            n3 = i3 > 12;
            break;
          }
      } else
        n3 = e3 === (t3 ? "pm" : "PM");
      return n3;
    }, d2 = { A: [i2, function(e3) {
      this.afternoon = u2(e3, false);
    }], a: [i2, function(e3) {
      this.afternoon = u2(e3, true);
    }], S: [/\d/, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [n2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [r2, a2("seconds")], ss: [r2, a2("seconds")], m: [r2, a2("minutes")], mm: [r2, a2("minutes")], H: [r2, a2("hours")], h: [r2, a2("hours")], HH: [r2, a2("hours")], hh: [r2, a2("hours")], D: [r2, a2("day")], DD: [n2, a2("day")], Do: [i2, function(e3) {
      var t3 = o2.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t3)
        for (var r3 = 1; r3 <= 31; r3 += 1)
          t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
    }], M: [r2, a2("month")], MM: [n2, a2("month")], MMM: [i2, function(e3) {
      var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1)
        throw new Error();
      this.month = n3 % 12 || n3;
    }], MMMM: [i2, function(e3) {
      var t3 = h2("months").indexOf(e3) + 1;
      if (t3 < 1)
        throw new Error();
      this.month = t3 % 12 || t3;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n2, function(e3) {
      this.year = s2(e3);
    }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
    function c2(n3) {
      var r3, i3;
      r3 = n3, i3 = o2 && o2.formats;
      for (var s3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
        var o3 = r4 && r4.toUpperCase();
        return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
          return t4 || n5.slice(1);
        });
      })).match(t2), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
        var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
        s3[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t3 = {}, n4 = 0, r4 = 0; n4 < a3; n4 += 1) {
          var i4 = s3[n4];
          if ("string" == typeof i4)
            r4 += i4.length;
          else {
            var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
            f4.call(t3, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t4 = e4.afternoon;
          if (void 0 !== t4) {
            var n5 = e4.hours;
            t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t3), t3;
      };
    }
    return function(e3, t3, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
      var r3 = t3.prototype, i3 = r3.parse;
      r3.parse = function(e4) {
        var t4 = e4.date, r4 = e4.utc, s3 = e4.args;
        this.$u = r4;
        var a3 = s3[1];
        if ("string" == typeof a3) {
          var f3 = true === s3[2], h3 = true === s3[3], u3 = f3 || h3, d3 = s3[2];
          h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
            try {
              if (["x", "X"].indexOf(t5) > -1)
                return new Date(("X" === t5 ? 1e3 : 1) * e5);
              var r5 = c2(t5)(e5), i4 = r5.year, o3 = r5.month, s4 = r5.day, a4 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = new Date(), m3 = s4 || (i4 || o3 ? 1 : l3.getDate()), M3 = i4 || l3.getFullYear(), Y2 = 0;
              i4 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
            } catch (e6) {
              return new Date("");
            }
          }(t4, a3, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n3.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i3.call(this, e4);
      };
    };
  });
})(customParseFormat$1);
const customParseFormat = customParseFormat$1.exports;
dayjs.extend(customParseFormat);
dayjs.extend(advancedFormat);
dayjs.extend(weekday);
dayjs.extend(localeData);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(function(_o, c2) {
  var proto = c2.prototype;
  var oldFormat = proto.format;
  proto.format = function f2(formatStr) {
    var str = (formatStr || "").replace("Wo", "wo");
    return oldFormat.bind(this)(str);
  };
});
var localeMap = {
  bn_BD: "bn-bd",
  by_BY: "be",
  en_GB: "en-gb",
  en_US: "en",
  fr_BE: "fr",
  fr_CA: "fr-ca",
  hy_AM: "hy-am",
  kmr_IQ: "ku",
  nl_BE: "nl-be",
  pt_BR: "pt-br",
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
};
var parseLocale = function parseLocale2(locale2) {
  var mapLocale = localeMap[locale2];
  return mapLocale || locale2.split("_")[0];
};
var parseNoMatchNotice = function parseNoMatchNotice2() {
  noteOnce(false, "Not match any format. Please help to fire a issue about this.");
};
var generateConfig = {
  getNow: function getNow2() {
    return dayjs();
  },
  getFixedDate: function getFixedDate(string3) {
    return dayjs(string3, ["YYYY-M-DD", "YYYY-MM-DD"]);
  },
  getEndDate: function getEndDate(date4) {
    return date4.endOf("month");
  },
  getWeekDay: function getWeekDay(date4) {
    var clone3 = date4.locale("en");
    return clone3.weekday() + clone3.localeData().firstDayOfWeek();
  },
  getYear: function getYear(date4) {
    return date4.year();
  },
  getMonth: function getMonth(date4) {
    return date4.month();
  },
  getDate: function getDate(date4) {
    return date4.date();
  },
  getHour: function getHour(date4) {
    return date4.hour();
  },
  getMinute: function getMinute(date4) {
    return date4.minute();
  },
  getSecond: function getSecond(date4) {
    return date4.second();
  },
  addYear: function addYear(date4, diff2) {
    return date4.add(diff2, "year");
  },
  addMonth: function addMonth(date4, diff2) {
    return date4.add(diff2, "month");
  },
  addDate: function addDate(date4, diff2) {
    return date4.add(diff2, "day");
  },
  setYear: function setYear(date4, year) {
    return date4.year(year);
  },
  setMonth: function setMonth(date4, month) {
    return date4.month(month);
  },
  setDate: function setDate(date4, num) {
    return date4.date(num);
  },
  setHour: function setHour(date4, hour) {
    return date4.hour(hour);
  },
  setMinute: function setMinute(date4, minute) {
    return date4.minute(minute);
  },
  setSecond: function setSecond(date4, second) {
    return date4.second(second);
  },
  isAfter: function isAfter(date1, date22) {
    return date1.isAfter(date22);
  },
  isValidate: function isValidate(date4) {
    return date4.isValid();
  },
  locale: {
    getWeekFirstDay: function getWeekFirstDay(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
    },
    getWeekFirstDate: function getWeekFirstDate(locale2, date4) {
      return date4.locale(parseLocale(locale2)).weekday(0);
    },
    getWeek: function getWeek(locale2, date4) {
      return date4.locale(parseLocale(locale2)).week();
    },
    getShortWeekDays: function getShortWeekDays(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
    },
    getShortMonths: function getShortMonths(locale2) {
      return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
    },
    format: function format(locale2, date4, _format) {
      return date4.locale(parseLocale(locale2)).format(_format);
    },
    parse: function parse(locale2, text, formats2) {
      var localeStr = parseLocale(locale2);
      for (var i2 = 0; i2 < formats2.length; i2 += 1) {
        var format5 = formats2[i2];
        var formatText = text;
        if (format5.includes("wo") || format5.includes("Wo")) {
          var year = formatText.split("-")[0];
          var weekStr = formatText.split("-")[1];
          var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
          for (var j2 = 0; j2 <= 52; j2 += 1) {
            var nextWeek = firstWeek.add(j2, "week");
            if (nextWeek.format("Wo") === weekStr) {
              return nextWeek;
            }
          }
          parseNoMatchNotice();
          return null;
        }
        var date4 = dayjs(formatText, format5, true).locale(localeStr);
        if (date4.isValid()) {
          return date4;
        }
      }
      if (!text) {
        parseNoMatchNotice();
      }
      return null;
    }
  },
  toDate: function toDate(value, valueFormat) {
    if (Array.isArray(value)) {
      return value.map(function(val) {
        return typeof val === "string" && val ? dayjs(val, valueFormat) : val || null;
      });
    } else {
      return typeof value === "string" && value ? dayjs(value, valueFormat) : value || null;
    }
  },
  toString: function toString(value, valueFormat) {
    if (Array.isArray(value)) {
      return value.map(function(val) {
        return dayjs.isDayjs(val) ? val.format(valueFormat) : val;
      });
    } else {
      return dayjs.isDayjs(value) ? value.format(valueFormat) : value;
    }
  }
};
const dayjsGenerateConfig = generateConfig;
var MAX_SAFE_INTEGER = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string3, n2) {
  var result = "";
  if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
    return result;
  }
  do {
    if (n2 % 2) {
      result += string3;
    }
    n2 = nativeFloor(n2 / 2);
    if (n2) {
      string3 += string3;
    }
  } while (n2);
  return result;
}
function arrayMap(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var symbolTag$2 = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
}
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$a(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
function baseSlice(array4, start, end) {
  var index2 = -1, length = array4.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array4[index2 + start];
  }
  return result;
}
function castSlice(array4, start, end) {
  var length = array4.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array4 : baseSlice(array4, start, end);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$2 + rsVarRange$2 + "]");
function hasUnicode(string3) {
  return reHasUnicode.test(string3);
}
function baseProperty(key2) {
  return function(object4) {
    return object4 == null ? void 0 : object4[key2];
  };
}
var asciiSize = baseProperty("length");
const asciiSize$1 = asciiSize;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral$1 = "[" + rsAstralRange$1 + "]", rsCombo$1 = "[" + rsComboRange$1 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol$1 = "(?:" + [rsNonAstral$1 + rsCombo$1 + "?", rsCombo$1, rsRegional$1, rsSurrPair$1, rsAstral$1].join("|") + ")";
var reUnicode$1 = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol$1 + rsSeq$1, "g");
function unicodeSize(string3) {
  var result = reUnicode$1.lastIndex = 0;
  while (reUnicode$1.test(string3)) {
    ++result;
  }
  return result;
}
function stringSize(string3) {
  return hasUnicode(string3) ? unicodeSize(string3) : asciiSize$1(string3);
}
function asciiToArray(string3) {
  return string3.split("");
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string3) {
  return string3.match(reUnicode) || [];
}
function stringToArray(string3) {
  return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
}
var nativeCeil = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
  return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
}
var reWhitespace = /\s/;
function trimmedEndIndex(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
function padStart(string3, length, chars) {
  string3 = toString$1(string3);
  length = toInteger(length);
  var strLength = length ? stringSize(string3) : 0;
  return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
}
function useMergeProps(props3) {
  var attrs = useAttrs();
  return _objectSpread2$1(_objectSpread2$1({}, props3), attrs);
}
var PanelContextKey = Symbol("PanelContextProps");
var useProvidePanel = function useProvidePanel2(props3) {
  provide(PanelContextKey, props3);
};
var useInjectPanel = function useInjectPanel2() {
  return inject(PanelContextKey, {});
};
var HIDDEN_STYLE$2 = {
  visibility: "hidden"
};
function Header$3(_props, _ref) {
  var _slots$default;
  var slots = _ref.slots;
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, _props$prevIcon = props3.prevIcon, prevIcon = _props$prevIcon === void 0 ? "\u2039" : _props$prevIcon, _props$nextIcon = props3.nextIcon, nextIcon = _props$nextIcon === void 0 ? "\u203A" : _props$nextIcon, _props$superPrevIcon = props3.superPrevIcon, superPrevIcon = _props$superPrevIcon === void 0 ? "\xAB" : _props$superPrevIcon, _props$superNextIcon = props3.superNextIcon, superNextIcon = _props$superNextIcon === void 0 ? "\xBB" : _props$superNextIcon, onSuperPrev = props3.onSuperPrev, onSuperNext = props3.onSuperNext, onPrev = props3.onPrev, onNext = props3.onNext;
  var _useInjectPanel = useInjectPanel(), hideNextBtn = _useInjectPanel.hideNextBtn, hidePrevBtn = _useInjectPanel.hidePrevBtn;
  return createVNode("div", {
    "class": prefixCls
  }, [onSuperPrev && createVNode("button", {
    "type": "button",
    "onClick": onSuperPrev,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-super-prev-btn"),
    "style": hidePrevBtn.value ? HIDDEN_STYLE$2 : {}
  }, [superPrevIcon]), onPrev && createVNode("button", {
    "type": "button",
    "onClick": onPrev,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-prev-btn"),
    "style": hidePrevBtn.value ? HIDDEN_STYLE$2 : {}
  }, [prevIcon]), createVNode("div", {
    "class": "".concat(prefixCls, "-view")
  }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), onNext && createVNode("button", {
    "type": "button",
    "onClick": onNext,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-next-btn"),
    "style": hideNextBtn.value ? HIDDEN_STYLE$2 : {}
  }, [nextIcon]), onSuperNext && createVNode("button", {
    "type": "button",
    "onClick": onSuperNext,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-super-next-btn"),
    "style": hideNextBtn.value ? HIDDEN_STYLE$2 : {}
  }, [superNextIcon])]);
}
Header$3.displayName = "Header";
Header$3.inheritAttrs = false;
function DecadeHeader(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, viewDate = props3.viewDate, onPrevDecades = props3.onPrevDecades, onNextDecades = props3.onNextDecades;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  var endYear = startYear + DECADE_DISTANCE_COUNT - 1;
  return createVNode(Header$3, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecades,
    "onSuperNext": onNextDecades
  }), {
    default: function _default9() {
      return [startYear, createTextVNode("-"), endYear];
    }
  });
}
DecadeHeader.displayName = "DecadeHeader";
DecadeHeader.inheritAttrs = false;
function setTime(generateConfig2, date4, hour, minute, second) {
  var nextTime = generateConfig2.setHour(date4, hour);
  nextTime = generateConfig2.setMinute(nextTime, minute);
  nextTime = generateConfig2.setSecond(nextTime, second);
  return nextTime;
}
function setDateTime(generateConfig2, date4, defaultDate) {
  if (!defaultDate) {
    return date4;
  }
  var newDate = date4;
  newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
  newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
  newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
  return newDate;
}
function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
  var lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
  if (lowerBoundHour < hour) {
    return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
  }
  var lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
  if (lowerBoundMinute < minute) {
    return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
  }
  var lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
  return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
}
function getLastDay(generateConfig2, date4) {
  var year = generateConfig2.getYear(date4);
  var month = generateConfig2.getMonth(date4) + 1;
  var endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate("".concat(year, "-").concat(month, "-01")));
  var lastDay = generateConfig2.getDate(endDate);
  var monthShow = month < 10 ? "0".concat(month) : "".concat(month);
  return "".concat(year, "-").concat(monthShow, "-").concat(lastDay);
}
function PanelBody(_props) {
  var _useMergeProps = useMergeProps(_props), prefixCls = _useMergeProps.prefixCls, disabledDate = _useMergeProps.disabledDate, onSelect = _useMergeProps.onSelect, picker = _useMergeProps.picker, rowNum = _useMergeProps.rowNum, colNum = _useMergeProps.colNum, prefixColumn = _useMergeProps.prefixColumn, rowClassName = _useMergeProps.rowClassName, baseDate = _useMergeProps.baseDate, getCellClassName = _useMergeProps.getCellClassName, getCellText = _useMergeProps.getCellText, getCellNode = _useMergeProps.getCellNode, getCellDate = _useMergeProps.getCellDate, generateConfig2 = _useMergeProps.generateConfig, titleCell = _useMergeProps.titleCell, headerCells = _useMergeProps.headerCells;
  var _useInjectPanel = useInjectPanel(), onDateMouseenter = _useInjectPanel.onDateMouseenter, onDateMouseleave = _useInjectPanel.onDateMouseleave, mode = _useInjectPanel.mode;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var rows = [];
  for (var i2 = 0; i2 < rowNum; i2 += 1) {
    var row = [];
    var rowStartDate = void 0;
    var _loop = function _loop2(j3) {
      var _objectSpread22;
      var offset3 = i2 * colNum + j3;
      var currentDate = getCellDate(baseDate, offset3);
      var disabled = getCellDateDisabled({
        cellDate: currentDate,
        mode: mode.value,
        disabledDate,
        generateConfig: generateConfig2
      });
      if (j3 === 0) {
        rowStartDate = currentDate;
        if (prefixColumn) {
          row.push(prefixColumn(rowStartDate));
        }
      }
      var title = titleCell && titleCell(currentDate);
      row.push(createVNode("td", {
        "key": j3,
        "title": title,
        "class": classNames(cellPrefixCls, _objectSpread2$1((_objectSpread22 = {}, _defineProperty$U(_objectSpread22, "".concat(cellPrefixCls, "-disabled"), disabled), _defineProperty$U(_objectSpread22, "".concat(cellPrefixCls, "-start"), getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0), _defineProperty$U(_objectSpread22, "".concat(cellPrefixCls, "-end"), title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9), _objectSpread22), getCellClassName(currentDate))),
        "onClick": function onClick2() {
          if (!disabled) {
            onSelect(currentDate);
          }
        },
        "onMouseenter": function onMouseenter2() {
          if (!disabled && onDateMouseenter) {
            onDateMouseenter(currentDate);
          }
        },
        "onMouseleave": function onMouseleave2() {
          if (!disabled && onDateMouseleave) {
            onDateMouseleave(currentDate);
          }
        }
      }, [getCellNode ? getCellNode(currentDate) : createVNode("div", {
        "class": "".concat(cellPrefixCls, "-inner")
      }, [getCellText(currentDate)])]));
    };
    for (var j2 = 0; j2 < colNum; j2 += 1) {
      _loop(j2);
    }
    rows.push(createVNode("tr", {
      "key": i2,
      "class": rowClassName && rowClassName(rowStartDate)
    }, [row]));
  }
  return createVNode("div", {
    "class": "".concat(prefixCls, "-body")
  }, [createVNode("table", {
    "class": "".concat(prefixCls, "-content")
  }, [headerCells && createVNode("thead", null, [createVNode("tr", null, [headerCells])]), createVNode("tbody", null, [rows])])]);
}
PanelBody.displayName = "PanelBody";
PanelBody.inheritAttrs = false;
var DECADE_COL_COUNT = 3;
var DECADE_ROW_COUNT = 4;
function DecadeBody(_props) {
  var props3 = useMergeProps(_props);
  var DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
  var prefixCls = props3.prefixCls, viewDate = props3.viewDate, generateConfig2 = props3.generateConfig;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var yearNumber = generateConfig2.getYear(viewDate);
  var decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
  var startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
  var endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
  var baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
  var getCellClassName = function getCellClassName2(date4) {
    var _ref;
    var startDecadeNumber = generateConfig2.getYear(date4);
    var endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
    return _ref = {}, _defineProperty$U(_ref, "".concat(cellPrefixCls, "-in-view"), startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear), _defineProperty$U(_ref, "".concat(cellPrefixCls, "-selected"), startDecadeNumber === decadeYearNumber), _ref;
  };
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "rowNum": DECADE_ROW_COUNT,
    "colNum": DECADE_COL_COUNT,
    "baseDate": baseDecadeYear,
    "getCellText": function getCellText(date4) {
      var startDecadeNumber = generateConfig2.getYear(date4);
      return "".concat(startDecadeNumber, "-").concat(startDecadeNumber + DECADE_UNIT_DIFF_DES);
    },
    "getCellClassName": getCellClassName,
    "getCellDate": function getCellDate(date4, offset3) {
      return generateConfig2.addYear(date4, offset3 * DECADE_UNIT_DIFF);
    }
  }), null);
}
DecadeBody.displayName = "DecadeBody";
DecadeBody.inheritAttrs = false;
var scrollIds = /* @__PURE__ */ new Map();
function waitElementReady(element, callback) {
  var id;
  function tryOrNextFrame() {
    if (isVisible(element)) {
      callback();
    } else {
      id = wrapperRaf(function() {
        tryOrNextFrame();
      });
    }
  }
  tryOrNextFrame();
  return function() {
    wrapperRaf.cancel(id);
  };
}
function scrollTo(element, to, duration) {
  if (scrollIds.get(element)) {
    wrapperRaf.cancel(scrollIds.get(element));
  }
  if (duration <= 0) {
    scrollIds.set(element, wrapperRaf(function() {
      element.scrollTop = to;
    }));
    return;
  }
  var difference = to - element.scrollTop;
  var perTick = difference / duration * 10;
  scrollIds.set(element, wrapperRaf(function() {
    element.scrollTop += perTick;
    if (element.scrollTop !== to) {
      scrollTo(element, to, duration - 10);
    }
  }));
}
function createKeydownHandler(event2, _ref) {
  var onLeftRight = _ref.onLeftRight, onCtrlLeftRight = _ref.onCtrlLeftRight, onUpDown = _ref.onUpDown, onPageUpDown = _ref.onPageUpDown, onEnter = _ref.onEnter;
  var which = event2.which, ctrlKey = event2.ctrlKey, metaKey = event2.metaKey;
  switch (which) {
    case KeyCode$1.LEFT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(-1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(-1);
        return true;
      }
      break;
    case KeyCode$1.RIGHT:
      if (ctrlKey || metaKey) {
        if (onCtrlLeftRight) {
          onCtrlLeftRight(1);
          return true;
        }
      } else if (onLeftRight) {
        onLeftRight(1);
        return true;
      }
      break;
    case KeyCode$1.UP:
      if (onUpDown) {
        onUpDown(-1);
        return true;
      }
      break;
    case KeyCode$1.DOWN:
      if (onUpDown) {
        onUpDown(1);
        return true;
      }
      break;
    case KeyCode$1.PAGE_UP:
      if (onPageUpDown) {
        onPageUpDown(-1);
        return true;
      }
      break;
    case KeyCode$1.PAGE_DOWN:
      if (onPageUpDown) {
        onPageUpDown(1);
        return true;
      }
      break;
    case KeyCode$1.ENTER:
      if (onEnter) {
        onEnter();
        return true;
      }
      break;
  }
  return false;
}
function getDefaultFormat(format5, picker, showTime, use12Hours) {
  var mergedFormat = format5;
  if (!mergedFormat) {
    switch (picker) {
      case "time":
        mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        mergedFormat = "gggg-wo";
        break;
      case "month":
        mergedFormat = "YYYY-MM";
        break;
      case "quarter":
        mergedFormat = "YYYY-[Q]Q";
        break;
      case "year":
        mergedFormat = "YYYY";
        break;
      default:
        mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  }
  return mergedFormat;
}
function getInputSize(picker, format5, generateConfig2) {
  var defaultSize = picker === "time" ? 8 : 10;
  var length = typeof format5 === "function" ? format5(generateConfig2.getNow()).length : format5.length;
  return Math.max(defaultSize, length) + 2;
}
var globalClickFunc = null;
var clickCallbacks = /* @__PURE__ */ new Set();
function addGlobalMousedownEvent(callback) {
  if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
    globalClickFunc = function globalClickFunc2(e2) {
      _toConsumableArray(clickCallbacks).forEach(function(queueFunc) {
        queueFunc(e2);
      });
    };
    window.addEventListener("mousedown", globalClickFunc);
  }
  clickCallbacks.add(callback);
  return function() {
    clickCallbacks.delete(callback);
    if (clickCallbacks.size === 0) {
      window.removeEventListener("mousedown", globalClickFunc);
      globalClickFunc = null;
    }
  };
}
function getTargetFromEvent(e2) {
  var target = e2.target;
  if (e2.composed && target.shadowRoot) {
    var _e$composedPath;
    return ((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath.call(e2)[0]) || target;
  }
  return target;
}
var getYearNextMode = function getYearNextMode2(next2) {
  if (next2 === "month" || next2 === "date") {
    return "year";
  }
  return next2;
};
var getMonthNextMode = function getMonthNextMode2(next2) {
  if (next2 === "date") {
    return "month";
  }
  return next2;
};
var getQuarterNextMode = function getQuarterNextMode2(next2) {
  if (next2 === "month" || next2 === "date") {
    return "quarter";
  }
  return next2;
};
var getWeekNextMode = function getWeekNextMode2(next2) {
  if (next2 === "date") {
    return "week";
  }
  return next2;
};
var PickerModeMap = {
  year: getYearNextMode,
  month: getMonthNextMode,
  quarter: getQuarterNextMode,
  week: getWeekNextMode,
  time: null,
  date: null
};
function elementsContains(elements, target) {
  return elements.some(function(ele) {
    return ele && ele.contains(target);
  });
}
var DECADE_UNIT_DIFF = 10;
var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
function DecadePanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, onViewDateChange = props3.onViewDateChange, generateConfig2 = props3.generateConfig, viewDate = props3.viewDate, operationRef = props3.operationRef, onSelect = props3.onSelect, onPanelChange = props3.onPanelChange;
  var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, {
        onLeftRight: function onLeftRight(diff2) {
          onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_UNIT_DIFF), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff2) {
          onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_DISTANCE_COUNT), "key");
        },
        onUpDown: function onUpDown(diff2) {
          onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange("year", viewDate);
        }
      });
    }
  };
  var onDecadesChange = function onDecadesChange2(diff2) {
    var newDate = generateConfig2.addYear(viewDate, diff2 * DECADE_DISTANCE_COUNT);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  var onInternalSelect = function onInternalSelect2(date4) {
    onSelect(date4, "mouse");
    onPanelChange("year", date4);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(DecadeHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onPrevDecades": function onPrevDecades() {
      onDecadesChange(-1);
    },
    "onNextDecades": function onNextDecades() {
      onDecadesChange(1);
    }
  }), null), createVNode(DecadeBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onSelect": onInternalSelect
  }), null)]);
}
DecadePanel.displayName = "DecadePanel";
DecadePanel.inheritAttrs = false;
var WEEK_DAY_COUNT = 7;
function isNullEqual(value1, value2) {
  if (!value1 && !value2) {
    return true;
  }
  if (!value1 || !value2) {
    return false;
  }
  return void 0;
}
function isSameDecade(generateConfig2, decade1, decade2) {
  var equal = isNullEqual(decade1, decade2);
  if (typeof equal === "boolean") {
    return equal;
  }
  var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
  var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
  return num1 === num2;
}
function isSameYear(generateConfig2, year1, year2) {
  var equal = isNullEqual(year1, year2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
}
function getQuarter(generateConfig2, date4) {
  var quota = Math.floor(generateConfig2.getMonth(date4) / 3);
  return quota + 1;
}
function isSameQuarter(generateConfig2, quarter1, quarter2) {
  var equal = isNullEqual(quarter1, quarter2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
}
function isSameMonth(generateConfig2, month1, month2) {
  var equal = isNullEqual(month1, month2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
}
function isSameDate(generateConfig2, date1, date22) {
  var equal = isNullEqual(date1, date22);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getYear(date1) === generateConfig2.getYear(date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
}
function isSameTime(generateConfig2, time1, time2) {
  var equal = isNullEqual(time1, time2);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
}
function isSameWeek(generateConfig2, locale2, date1, date22) {
  var equal = isNullEqual(date1, date22);
  if (typeof equal === "boolean") {
    return equal;
  }
  return generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date22);
}
function isEqual(generateConfig2, value1, value2) {
  return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
}
function isInRange(generateConfig2, startDate, endDate, current2) {
  if (!startDate || !endDate || !current2) {
    return false;
  }
  return !isSameDate(generateConfig2, startDate, current2) && !isSameDate(generateConfig2, endDate, current2) && generateConfig2.isAfter(current2, startDate) && generateConfig2.isAfter(endDate, current2);
}
function getWeekStartDate(locale2, generateConfig2, value) {
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
  var monthStartDate = generateConfig2.setDate(value, 1);
  var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
  var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
  if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
    alignStartDate = generateConfig2.addDate(alignStartDate, -7);
  }
  return alignStartDate;
}
function getClosingViewDate(viewDate, picker, generateConfig2) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (picker) {
    case "year":
      return generateConfig2.addYear(viewDate, offset3 * 10);
    case "quarter":
    case "month":
      return generateConfig2.addYear(viewDate, offset3);
    default:
      return generateConfig2.addMonth(viewDate, offset3);
  }
}
function formatValue(value, _ref) {
  var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format5 = _ref.format;
  return typeof format5 === "function" ? format5(value) : generateConfig2.locale.format(locale2.locale, value, format5);
}
function parseValue(value, _ref2) {
  var generateConfig2 = _ref2.generateConfig, locale2 = _ref2.locale, formatList = _ref2.formatList;
  if (!value || typeof formatList[0] === "function") {
    return null;
  }
  return generateConfig2.locale.parse(locale2.locale, value, formatList);
}
function getCellDateDisabled(_ref3) {
  var cellDate = _ref3.cellDate, mode = _ref3.mode, disabledDate = _ref3.disabledDate, generateConfig2 = _ref3.generateConfig;
  if (!disabledDate)
    return false;
  var getDisabledFromRange = function getDisabledFromRange2(currentMode, start, end) {
    var current2 = start;
    while (current2 <= end) {
      var date4 = void 0;
      switch (currentMode) {
        case "date": {
          date4 = generateConfig2.setDate(cellDate, current2);
          if (!disabledDate(date4)) {
            return false;
          }
          break;
        }
        case "month": {
          date4 = generateConfig2.setMonth(cellDate, current2);
          if (!getCellDateDisabled({
            cellDate: date4,
            mode: "month",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
        case "year": {
          date4 = generateConfig2.setYear(cellDate, current2);
          if (!getCellDateDisabled({
            cellDate: date4,
            mode: "year",
            generateConfig: generateConfig2,
            disabledDate
          })) {
            return false;
          }
          break;
        }
      }
      current2 += 1;
    }
    return true;
  };
  switch (mode) {
    case "date":
    case "week": {
      return disabledDate(cellDate);
    }
    case "month": {
      var startDate = 1;
      var endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
      return getDisabledFromRange("date", startDate, endDate);
    }
    case "quarter": {
      var startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
      var endMonth = startMonth + 2;
      return getDisabledFromRange("month", startMonth, endMonth);
    }
    case "year": {
      return getDisabledFromRange("month", 0, 11);
    }
    case "decade": {
      var year = generateConfig2.getYear(cellDate);
      var startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      var endYear = startYear + DECADE_UNIT_DIFF - 1;
      return getDisabledFromRange("year", startYear, endYear);
    }
  }
}
function TimeHeader(_props) {
  var props3 = useMergeProps(_props);
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, locale2 = props3.locale, value = props3.value, format5 = props3.format;
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return createVNode(Header$3, {
    "prefixCls": headerPrefixCls
  }, {
    default: function _default9() {
      return [value ? formatValue(value, {
        locale: locale2,
        format: format5,
        generateConfig: generateConfig2
      }) : "\xA0"];
    }
  });
}
TimeHeader.displayName = "TimeHeader";
TimeHeader.inheritAttrs = false;
const TimeUnitColumn = defineComponent({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup: function setup64(props3) {
    var _useInjectPanel = useInjectPanel(), open2 = _useInjectPanel.open;
    var ulRef = ref(null);
    var liRefs = ref(/* @__PURE__ */ new Map());
    var scrollRef = ref();
    watch(function() {
      return props3.value;
    }, function() {
      var li = liRefs.value.get(props3.value);
      if (li && open2.value !== false) {
        scrollTo(ulRef.value, li.offsetTop, 120);
      }
    });
    onBeforeUnmount(function() {
      var _scrollRef$value;
      (_scrollRef$value = scrollRef.value) === null || _scrollRef$value === void 0 ? void 0 : _scrollRef$value.call(scrollRef);
    });
    watch(open2, function() {
      var _scrollRef$value2;
      (_scrollRef$value2 = scrollRef.value) === null || _scrollRef$value2 === void 0 ? void 0 : _scrollRef$value2.call(scrollRef);
      nextTick(function() {
        if (open2.value) {
          var li = liRefs.value.get(props3.value);
          if (li) {
            scrollRef.value = waitElementReady(li, function() {
              scrollTo(ulRef.value, li.offsetTop, 0);
            });
          }
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    return function() {
      var prefixCls = props3.prefixCls, units = props3.units, onSelect = props3.onSelect, value = props3.value, active = props3.active, hideDisabledOptions = props3.hideDisabledOptions;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      return createVNode("ul", {
        "class": classNames("".concat(prefixCls, "-column"), _defineProperty$U({}, "".concat(prefixCls, "-column-active"), active)),
        "ref": ulRef,
        "style": {
          position: "relative"
        }
      }, [units.map(function(unit) {
        var _classNames2;
        if (hideDisabledOptions && unit.disabled) {
          return null;
        }
        return createVNode("li", {
          "key": unit.value,
          "ref": function ref2(element) {
            liRefs.value.set(unit.value, element);
          },
          "class": classNames(cellPrefixCls, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(cellPrefixCls, "-disabled"), unit.disabled), _defineProperty$U(_classNames2, "".concat(cellPrefixCls, "-selected"), value === unit.value), _classNames2)),
          "onClick": function onClick2() {
            if (unit.disabled) {
              return;
            }
            onSelect(unit.value);
          }
        }, [createVNode("div", {
          "class": "".concat(cellPrefixCls, "-inner")
        }, [unit.label])]);
      })]);
    };
  }
});
function leftPad(str, length) {
  var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  var current2 = String(str);
  while (current2.length < length) {
    current2 = "".concat(fill).concat(str);
  }
  return current2;
}
var tuple2 = function tuple3() {
  for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
    args2[_key] = arguments[_key];
  }
  return args2;
};
function toArray$6(val) {
  if (val === null || val === void 0) {
    return [];
  }
  return Array.isArray(val) ? val : [val];
}
function getDataOrAriaProps(props3) {
  var retProps = {};
  Object.keys(props3).forEach(function(key2) {
    if ((key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role" || key2 === "name") && key2.substr(0, 7) !== "data-__") {
      retProps[key2] = props3[key2];
    }
  });
  return retProps;
}
function getValue$2(values, index2) {
  return values ? values[index2] : null;
}
function updateValues(values, value, index2) {
  var newValues = [getValue$2(values, 0), getValue$2(values, 1)];
  newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
  if (!newValues[0] && !newValues[1]) {
    return null;
  }
  return newValues;
}
function generateUnits(start, end, step, disabledUnits) {
  var units = [];
  for (var i2 = start; i2 <= end; i2 += step) {
    units.push({
      label: leftPad(i2, 2),
      value: i2,
      disabled: (disabledUnits || []).includes(i2)
    });
  }
  return units;
}
var TimeBody = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: false,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup: function setup65(props3) {
    var originHour = computed(function() {
      return props3.value ? props3.generateConfig.getHour(props3.value) : -1;
    });
    var isPM = computed(function() {
      if (props3.use12Hours) {
        return originHour.value >= 12;
      } else {
        return false;
      }
    });
    var hour = computed(function() {
      if (props3.use12Hours) {
        return originHour.value % 12;
      } else {
        return originHour.value;
      }
    });
    var minute = computed(function() {
      return props3.value ? props3.generateConfig.getMinute(props3.value) : -1;
    });
    var second = computed(function() {
      return props3.value ? props3.generateConfig.getSecond(props3.value) : -1;
    });
    var now2 = ref(props3.generateConfig.getNow());
    var mergedDisabledHours = ref();
    var mergedDisabledMinutes = ref();
    var mergedDisabledSeconds = ref();
    onBeforeUpdate(function() {
      now2.value = props3.generateConfig.getNow();
    });
    watchEffect(function() {
      if (props3.disabledTime) {
        var disabledConfig = props3.disabledTime(now2);
        var _ref = [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
        mergedDisabledHours.value = _ref[0];
        mergedDisabledMinutes.value = _ref[1];
        mergedDisabledSeconds.value = _ref[2];
      } else {
        var _ref2 = [props3.disabledHours, props3.disabledMinutes, props3.disabledSeconds];
        mergedDisabledHours.value = _ref2[0];
        mergedDisabledMinutes.value = _ref2[1];
        mergedDisabledSeconds.value = _ref2[2];
      }
    });
    var setTime$1 = function setTime$12(isNewPM, newHour, newMinute, newSecond) {
      var newDate = props3.value || props3.generateConfig.getNow();
      var mergedHour = Math.max(0, newHour);
      var mergedMinute = Math.max(0, newMinute);
      var mergedSecond = Math.max(0, newSecond);
      newDate = setTime(props3.generateConfig, newDate, !props3.use12Hours || !isNewPM ? mergedHour : mergedHour + 12, mergedMinute, mergedSecond);
      return newDate;
    };
    var rawHours = computed(function() {
      var _props$hourStep;
      return generateUnits(0, 23, (_props$hourStep = props3.hourStep) !== null && _props$hourStep !== void 0 ? _props$hourStep : 1, mergedDisabledHours.value && mergedDisabledHours.value());
    });
    var AMPMDisabled = computed(function() {
      if (!props3.use12Hours) {
        return [false, false];
      }
      var AMPMDisabled2 = [true, true];
      rawHours.value.forEach(function(_ref3) {
        var disabled = _ref3.disabled, hourValue = _ref3.value;
        if (disabled)
          return;
        if (hourValue >= 12) {
          AMPMDisabled2[1] = false;
        } else {
          AMPMDisabled2[0] = false;
        }
      });
      return AMPMDisabled2;
    });
    var hours = computed(function() {
      if (!props3.use12Hours)
        return rawHours.value;
      return rawHours.value.filter(isPM.value ? function(hourMeta) {
        return hourMeta.value >= 12;
      } : function(hourMeta) {
        return hourMeta.value < 12;
      }).map(function(hourMeta) {
        var hourValue = hourMeta.value % 12;
        var hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
        return _objectSpread2$1(_objectSpread2$1({}, hourMeta), {}, {
          label: hourLabel,
          value: hourValue
        });
      });
    });
    var minutes = computed(function() {
      var _props$minuteStep;
      return generateUnits(0, 59, (_props$minuteStep = props3.minuteStep) !== null && _props$minuteStep !== void 0 ? _props$minuteStep : 1, mergedDisabledMinutes.value && mergedDisabledMinutes.value(originHour.value));
    });
    var seconds = computed(function() {
      var _props$secondStep;
      return generateUnits(0, 59, (_props$secondStep = props3.secondStep) !== null && _props$secondStep !== void 0 ? _props$secondStep : 1, mergedDisabledSeconds.value && mergedDisabledSeconds.value(originHour.value, minute));
    });
    return function() {
      var prefixCls = props3.prefixCls, operationRef = props3.operationRef, activeColumnIndex = props3.activeColumnIndex, showHour = props3.showHour, showMinute = props3.showMinute, showSecond = props3.showSecond, use12Hours = props3.use12Hours, hideDisabledOptions = props3.hideDisabledOptions, onSelect = props3.onSelect;
      var columns = [];
      var contentPrefixCls = "".concat(prefixCls, "-content");
      var columnPrefixCls = "".concat(prefixCls, "-time-panel");
      operationRef.value = {
        onUpDown: function onUpDown(diff2) {
          var column2 = columns[activeColumnIndex];
          if (column2) {
            var valueIndex = column2.units.findIndex(function(unit) {
              return unit.value === column2.value;
            });
            var unitLen = column2.units.length;
            for (var i2 = 1; i2 < unitLen; i2 += 1) {
              var nextUnit = column2.units[(valueIndex + diff2 * i2 + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column2.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: cloneElement(node, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, createVNode(TimeUnitColumn, {
        "key": "hour"
      }, null), hour.value, hours.value, function(num) {
        onSelect(setTime$1(isPM.value, num, minute.value, second.value), "mouse");
      });
      addColumnNode(showMinute, createVNode(TimeUnitColumn, {
        "key": "minute"
      }, null), minute.value, minutes.value, function(num) {
        onSelect(setTime$1(isPM.value, hour.value, num, second.value), "mouse");
      });
      addColumnNode(showSecond, createVNode(TimeUnitColumn, {
        "key": "second"
      }, null), second.value, seconds.value, function(num) {
        onSelect(setTime$1(isPM.value, hour.value, minute.value, num), "mouse");
      });
      var PMIndex = -1;
      if (typeof isPM.value === "boolean") {
        PMIndex = isPM.value ? 1 : 0;
      }
      addColumnNode(use12Hours === true, createVNode(TimeUnitColumn, {
        "key": "12hours"
      }, null), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMPMDisabled.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: AMPMDisabled.value[1]
      }], function(num) {
        onSelect(setTime$1(!!num, hour.value, minute.value, second.value), "mouse");
      });
      return createVNode("div", {
        "class": contentPrefixCls
      }, [columns.map(function(_ref4) {
        var node = _ref4.node;
        return node;
      })]);
    };
  }
});
const TimeBody$1 = TimeBody;
var countBoolean = function countBoolean2(boolList) {
  return boolList.filter(function(bool) {
    return bool !== false;
  }).length;
};
function TimePanel(_props) {
  var props3 = useMergeProps(_props);
  var generateConfig2 = props3.generateConfig, _props$format = props3.format, format5 = _props$format === void 0 ? "HH:mm:ss" : _props$format, prefixCls = props3.prefixCls, active = props3.active, operationRef = props3.operationRef, showHour = props3.showHour, showMinute = props3.showMinute, showSecond = props3.showSecond, _props$use12Hours = props3.use12Hours, use12Hours = _props$use12Hours === void 0 ? false : _props$use12Hours, onSelect = props3.onSelect, value = props3.value;
  var panelPrefixCls = "".concat(prefixCls, "-time-panel");
  var bodyOperationRef = ref();
  var activeColumnIndex = ref(-1);
  var columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, {
        onLeftRight: function onLeftRight(diff2) {
          activeColumnIndex.value = (activeColumnIndex.value + diff2 + columnsCount) % columnsCount;
        },
        onUpDown: function onUpDown(diff2) {
          if (activeColumnIndex.value === -1) {
            activeColumnIndex.value = 0;
          } else if (bodyOperationRef.value) {
            bodyOperationRef.value.onUpDown(diff2);
          }
        },
        onEnter: function onEnter() {
          onSelect(value || generateConfig2.getNow(), "key");
          activeColumnIndex.value = -1;
        }
      });
    },
    onBlur: function onBlur2() {
      activeColumnIndex.value = -1;
    }
  };
  return createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$U({}, "".concat(panelPrefixCls, "-active"), active))
  }, [createVNode(TimeHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "format": format5,
    "prefixCls": prefixCls
  }), null), createVNode(TimeBody$1, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "activeColumnIndex": activeColumnIndex.value,
    "operationRef": bodyOperationRef
  }), null)]);
}
TimePanel.displayName = "TimePanel";
TimePanel.inheritAttrs = false;
function useCellClassName(_ref) {
  var cellPrefixCls = _ref.cellPrefixCls, generateConfig2 = _ref.generateConfig, rangedValue = _ref.rangedValue, hoverRangedValue = _ref.hoverRangedValue, isInView = _ref.isInView, isSameCell = _ref.isSameCell, offsetCell = _ref.offsetCell, today = _ref.today, value = _ref.value;
  function getClassName(currentDate) {
    var _ref2;
    var prevDate = offsetCell(currentDate, -1);
    var nextDate = offsetCell(currentDate, 1);
    var rangeStart = getValue$2(rangedValue, 0);
    var rangeEnd = getValue$2(rangedValue, 1);
    var hoverStart = getValue$2(hoverRangedValue, 0);
    var hoverEnd = getValue$2(hoverRangedValue, 1);
    var isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
    function isRangeStart(date4) {
      return isSameCell(rangeStart, date4);
    }
    function isRangeEnd(date4) {
      return isSameCell(rangeEnd, date4);
    }
    var isHoverStart = isSameCell(hoverStart, currentDate);
    var isHoverEnd = isSameCell(hoverEnd, currentDate);
    var isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
    var isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
    return _ref2 = {}, _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-in-view"), isInView(currentDate)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-in-range"), isInRange(generateConfig2, rangeStart, rangeEnd, currentDate)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-start"), isRangeStart(currentDate)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-end"), isRangeEnd(currentDate)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-start-single"), isRangeStart(currentDate) && !rangeEnd), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-end-single"), isRangeEnd(currentDate) && !rangeStart), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-start-near-hover"), isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate))), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-end-near-hover"), isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate))), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover"), isRangeHovered), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-start"), isHoverStart), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-end"), isHoverEnd), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start"), isHoverEdgeStart), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end"), isHoverEdgeEnd), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start-near-range"), isHoverEdgeStart && isSameCell(prevDate, rangeEnd)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end-near-range"), isHoverEdgeEnd && isSameCell(nextDate, rangeStart)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-today"), isSameCell(today, currentDate)), _defineProperty$U(_ref2, "".concat(cellPrefixCls, "-selected"), isSameCell(value, currentDate)), _ref2;
  }
  return getClassName;
}
var RangeContextKey = Symbol("RangeContextProps");
var useProvideRange = function useProvideRange2(props3) {
  provide(RangeContextKey, props3);
};
var useInjectRange = function useInjectRange2() {
  return inject(RangeContextKey, {
    rangedValue: ref(),
    hoverRangedValue: ref(),
    inRange: ref(),
    panelPosition: ref()
  });
};
var RangeContextProvider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: false,
  props: {
    value: {
      type: Object,
      default: function _default2() {
        return {};
      }
    }
  },
  setup: function setup66(props3, _ref) {
    var slots = _ref.slots;
    var value = {
      rangedValue: ref(props3.value.rangedValue),
      hoverRangedValue: ref(props3.value.hoverRangedValue),
      inRange: ref(props3.value.inRange),
      panelPosition: ref(props3.value.panelPosition)
    };
    useProvideRange(value);
    watch(function() {
      return props3.value;
    }, function() {
      Object.keys(props3.value).forEach(function(key2) {
        if (value[key2]) {
          value[key2].value = props3.value[key2];
        }
      });
    });
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
function DateBody(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, prefixColumn = props3.prefixColumn, locale2 = props3.locale, rowCount = props3.rowCount, viewDate = props3.viewDate, value = props3.value, dateRender = props3.dateRender;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
  var today = generateConfig2.getNow();
  var headerCells = [];
  var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
  if (prefixColumn) {
    headerCells.push(createVNode("th", {
      "key": "empty",
      "aria-label": "empty cell"
    }, null));
  }
  for (var i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
    headerCells.push(createVNode("th", {
      "key": i2
    }, [weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]]));
  }
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    today,
    value,
    generateConfig: generateConfig2,
    rangedValue: prefixColumn ? null : rangedValue.value,
    hoverRangedValue: prefixColumn ? null : hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameDate(generateConfig2, current2, target);
    },
    isInView: function isInView(date4) {
      return isSameMonth(generateConfig2, date4, viewDate);
    },
    offsetCell: function offsetCell(date4, offset3) {
      return generateConfig2.addDate(date4, offset3);
    }
  });
  var getCellNode = dateRender ? function(date4) {
    return dateRender({
      current: date4,
      today
    });
  } : void 0;
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "rowNum": rowCount,
    "colNum": WEEK_DAY_COUNT,
    "baseDate": baseDate,
    "getCellNode": getCellNode,
    "getCellText": generateConfig2.getDate,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addDate,
    "titleCell": function titleCell(date4) {
      return formatValue(date4, {
        locale: locale2,
        format: "YYYY-MM-DD",
        generateConfig: generateConfig2
      });
    },
    "headerCells": headerCells
  }), null);
}
DateBody.displayName = "DateBody";
DateBody.inheritAttrs = false;
DateBody.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  "prefixColumn?",
  "rowClassName?"
];
function DateHeader(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, locale2 = props3.locale, viewDate = props3.viewDate, onNextMonth = props3.onNextMonth, onPrevMonth = props3.onPrevMonth, onNextYear = props3.onNextYear, onPrevYear = props3.onPrevYear, onYearClick = props3.onYearClick, onMonthClick = props3.onMonthClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var month = generateConfig2.getMonth(viewDate);
  var yearNode = createVNode("button", {
    "type": "button",
    "key": "year",
    "onClick": onYearClick,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-year-btn")
  }, [formatValue(viewDate, {
    locale: locale2,
    format: locale2.yearFormat,
    generateConfig: generateConfig2
  })]);
  var monthNode = createVNode("button", {
    "type": "button",
    "key": "month",
    "onClick": onMonthClick,
    "tabindex": -1,
    "class": "".concat(prefixCls, "-month-btn")
  }, [locale2.monthFormat ? formatValue(viewDate, {
    locale: locale2,
    format: locale2.monthFormat,
    generateConfig: generateConfig2
  }) : monthsLocale[month]]);
  var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
  return createVNode(Header$3, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onPrev": onPrevMonth,
    "onNext": onNextMonth,
    "onSuperNext": onNextYear
  }), {
    default: function _default9() {
      return [monthYearNodes];
    }
  });
}
DateHeader.displayName = "DateHeader";
DateHeader.inheritAttrs = false;
var DATE_ROW_COUNT = 6;
function DatePanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, _props$panelName = props3.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, keyboardConfig = props3.keyboardConfig, active = props3.active, operationRef = props3.operationRef, generateConfig2 = props3.generateConfig, value = props3.value, viewDate = props3.viewDate, onViewDateChange = props3.onViewDateChange, onPanelChange = props3.onPanelChange, _onSelect = props3.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, _objectSpread2$1({
        onLeftRight: function onLeftRight(diff2) {
          _onSelect(generateConfig2.addDate(value || viewDate, diff2), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
        },
        onUpDown: function onUpDown(diff2) {
          _onSelect(generateConfig2.addDate(value || viewDate, diff2 * WEEK_DAY_COUNT), "key");
        },
        onPageUpDown: function onPageUpDown(diff2) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff2), "key");
        }
      }, keyboardConfig));
    }
  };
  var onYearChange = function onYearChange2(diff2) {
    var newDate = generateConfig2.addYear(viewDate, diff2);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  var onMonthChange = function onMonthChange2(diff2) {
    var newDate = generateConfig2.addMonth(viewDate, diff2);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$U({}, "".concat(panelPrefixCls, "-active"), active))
  }, [createVNode(DateHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onPrevMonth": function onPrevMonth() {
      onMonthChange(-1);
    },
    "onNextMonth": function onNextMonth() {
      onMonthChange(1);
    },
    "onMonthClick": function onMonthClick() {
      onPanelChange("month", viewDate);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(DateBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "onSelect": function onSelect(date4) {
      return _onSelect(date4, "mouse");
    },
    "prefixCls": prefixCls,
    "value": value,
    "viewDate": viewDate,
    "rowCount": DATE_ROW_COUNT
  }), null)]);
}
DatePanel.displayName = "DatePanel";
DatePanel.inheritAttrs = false;
var ACTIVE_PANEL = tuple2("date", "time");
function DatetimePanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, operationRef = props3.operationRef, generateConfig2 = props3.generateConfig, value = props3.value, defaultValue = props3.defaultValue, disabledTime = props3.disabledTime, showTime = props3.showTime, onSelect = props3.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
  var activePanel = ref(null);
  var dateOperationRef = ref({});
  var timeOperationRef = ref({});
  var timeProps = _typeof$3(showTime) === "object" ? _objectSpread2$1({}, showTime) : {};
  function getNextActive(offset3) {
    var activeIndex = ACTIVE_PANEL.indexOf(activePanel.value) + offset3;
    var nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
    return nextActivePanel;
  }
  var onBlur2 = function onBlur3(e2) {
    if (timeOperationRef.value.onBlur) {
      timeOperationRef.value.onBlur(e2);
    }
    activePanel.value = null;
  };
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      if (event2.which === KeyCode$1.TAB) {
        var nextActivePanel = getNextActive(event2.shiftKey ? -1 : 1);
        activePanel.value = nextActivePanel;
        if (nextActivePanel) {
          event2.preventDefault();
        }
        return true;
      }
      if (activePanel.value) {
        var _ref = activePanel.value === "date" ? dateOperationRef : timeOperationRef;
        if (_ref.value && _ref.value.onKeydown) {
          _ref.value.onKeydown(event2);
        }
        return true;
      }
      if ([KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP, KeyCode$1.DOWN].includes(event2.which)) {
        activePanel.value = "date";
        return true;
      }
      return false;
    },
    onBlur: onBlur2,
    onClose: onBlur2
  };
  var onInternalSelect = function onInternalSelect2(date4, source2) {
    var selectedDate = date4;
    if (source2 === "date" && !value && timeProps.defaultValue) {
      selectedDate = generateConfig2.setHour(selectedDate, generateConfig2.getHour(timeProps.defaultValue));
      selectedDate = generateConfig2.setMinute(selectedDate, generateConfig2.getMinute(timeProps.defaultValue));
      selectedDate = generateConfig2.setSecond(selectedDate, generateConfig2.getSecond(timeProps.defaultValue));
    } else if (source2 === "time" && !value && defaultValue) {
      selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
      selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
      selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
    }
    if (onSelect) {
      onSelect(selectedDate, "mouse");
    }
  };
  var disabledTimes = disabledTime ? disabledTime(value || null) : {};
  return createVNode("div", {
    "class": classNames(panelPrefixCls, _defineProperty$U({}, "".concat(panelPrefixCls, "-active"), activePanel.value))
  }, [createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "operationRef": dateOperationRef,
    "active": activePanel.value === "date",
    "onSelect": function onSelect2(date4) {
      onInternalSelect(setDateTime(generateConfig2, date4, !value && _typeof$3(showTime) === "object" ? showTime.defaultValue : null), "date");
    }
  }), null), createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "format": void 0
  }, timeProps), disabledTimes), {}, {
    "disabledTime": null,
    "defaultValue": void 0,
    "operationRef": timeOperationRef,
    "active": activePanel.value === "time",
    "onSelect": function onSelect2(date4) {
      onInternalSelect(date4, "time");
    }
  }), null)]);
}
DatetimePanel.displayName = "DatetimePanel";
DatetimePanel.inheritAttrs = false;
function WeekPanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, locale2 = props3.locale, value = props3.value;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var prefixColumn = function prefixColumn2(date4) {
    return createVNode("td", {
      "key": "week",
      "class": classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week"))
    }, [generateConfig2.locale.getWeek(locale2.locale, date4)]);
  };
  var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
  var rowClassName = function rowClassName2(date4) {
    return classNames(rowPrefixCls, _defineProperty$U({}, "".concat(rowPrefixCls, "-selected"), isSameWeek(generateConfig2, locale2.locale, value, date4)));
  };
  return createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "panelName": "week",
    "prefixColumn": prefixColumn,
    "rowClassName": rowClassName,
    "keyboardConfig": {
      onLeftRight: null
    }
  }), null);
}
WeekPanel.displayName = "WeekPanel";
WeekPanel.inheritAttrs = false;
function MonthHeader(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, locale2 = props3.locale, viewDate = props3.viewDate, onNextYear = props3.onNextYear, onPrevYear = props3.onPrevYear, onYearClick = props3.onYearClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return createVNode(Header$3, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: function _default9() {
      return [createVNode("button", {
        "type": "button",
        "onClick": onYearClick,
        "class": "".concat(prefixCls, "-year-btn")
      }, [formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })])];
    }
  });
}
MonthHeader.displayName = "MonthHeader";
MonthHeader.inheritAttrs = false;
var MONTH_COL_COUNT = 3;
var MONTH_ROW_COUNT = 4;
function MonthBody(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, locale2 = props3.locale, value = props3.value, viewDate = props3.viewDate, generateConfig2 = props3.generateConfig, monthCellRender = props3.monthCellRender;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameMonth(generateConfig2, current2, target);
    },
    isInView: function isInView() {
      return true;
    },
    offsetCell: function offsetCell(date4, offset3) {
      return generateConfig2.addMonth(date4, offset3);
    }
  });
  var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
  var baseMonth = generateConfig2.setMonth(viewDate, 0);
  var getCellNode = monthCellRender ? function(date4) {
    return monthCellRender({
      current: date4,
      locale: locale2
    });
  } : void 0;
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "rowNum": MONTH_ROW_COUNT,
    "colNum": MONTH_COL_COUNT,
    "baseDate": baseMonth,
    "getCellNode": getCellNode,
    "getCellText": function getCellText(date4) {
      return locale2.monthFormat ? formatValue(date4, {
        locale: locale2,
        format: locale2.monthFormat,
        generateConfig: generateConfig2
      }) : monthsLocale[generateConfig2.getMonth(date4)];
    },
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addMonth,
    "titleCell": function titleCell(date4) {
      return formatValue(date4, {
        locale: locale2,
        format: "YYYY-MM",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
MonthBody.displayName = "MonthBody";
MonthBody.inheritAttrs = false;
function MonthPanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, operationRef = props3.operationRef, onViewDateChange = props3.onViewDateChange, generateConfig2 = props3.generateConfig, value = props3.value, viewDate = props3.viewDate, onPanelChange = props3.onPanelChange, _onSelect = props3.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-month-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, {
        onLeftRight: function onLeftRight(diff2) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff2), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
        },
        onUpDown: function onUpDown(diff2) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff2 * MONTH_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange("date", value || viewDate);
        }
      });
    }
  };
  var onYearChange = function onYearChange2(diff2) {
    var newDate = generateConfig2.addYear(viewDate, diff2);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(MonthHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(MonthBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date4) {
      _onSelect(date4, "mouse");
      onPanelChange("date", date4);
    }
  }), null)]);
}
MonthPanel.displayName = "MonthPanel";
MonthPanel.inheritAttrs = false;
function QuarterHeader(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, locale2 = props3.locale, viewDate = props3.viewDate, onNextYear = props3.onNextYear, onPrevYear = props3.onPrevYear, onYearClick = props3.onYearClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  return createVNode(Header$3, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevYear,
    "onSuperNext": onNextYear
  }), {
    default: function _default9() {
      return [createVNode("button", {
        "type": "button",
        "onClick": onYearClick,
        "class": "".concat(prefixCls, "-year-btn")
      }, [formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })])];
    }
  });
}
QuarterHeader.displayName = "QuarterHeader";
QuarterHeader.inheritAttrs = false;
var QUARTER_COL_COUNT = 4;
var QUARTER_ROW_COUNT = 1;
function QuarterBody(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, locale2 = props3.locale, value = props3.value, viewDate = props3.viewDate, generateConfig2 = props3.generateConfig;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var getCellClassName = useCellClassName({
    cellPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameQuarter(generateConfig2, current2, target);
    },
    isInView: function isInView() {
      return true;
    },
    offsetCell: function offsetCell(date4, offset3) {
      return generateConfig2.addMonth(date4, offset3 * 3);
    }
  });
  var baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "rowNum": QUARTER_ROW_COUNT,
    "colNum": QUARTER_COL_COUNT,
    "baseDate": baseQuarter,
    "getCellText": function getCellText(date4) {
      return formatValue(date4, {
        locale: locale2,
        format: locale2.quarterFormat || "[Q]Q",
        generateConfig: generateConfig2
      });
    },
    "getCellClassName": getCellClassName,
    "getCellDate": function getCellDate(date4, offset3) {
      return generateConfig2.addMonth(date4, offset3 * 3);
    },
    "titleCell": function titleCell(date4) {
      return formatValue(date4, {
        locale: locale2,
        format: "YYYY-[Q]Q",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
QuarterBody.displayName = "QuarterBody";
QuarterBody.inheritAttrs = false;
function QuarterPanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, operationRef = props3.operationRef, onViewDateChange = props3.onViewDateChange, generateConfig2 = props3.generateConfig, value = props3.value, viewDate = props3.viewDate, onPanelChange = props3.onPanelChange, _onSelect = props3.onSelect;
  var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, {
        onLeftRight: function onLeftRight(diff2) {
          _onSelect(generateConfig2.addMonth(value || viewDate, diff2 * 3), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
        },
        onUpDown: function onUpDown(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
        }
      });
    }
  };
  var onYearChange = function onYearChange2(diff2) {
    var newDate = generateConfig2.addYear(viewDate, diff2);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(QuarterHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onPrevYear": function onPrevYear() {
      onYearChange(-1);
    },
    "onNextYear": function onNextYear() {
      onYearChange(1);
    },
    "onYearClick": function onYearClick() {
      onPanelChange("year", viewDate);
    }
  }), null), createVNode(QuarterBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date4) {
      _onSelect(date4, "mouse");
    }
  }), null)]);
}
QuarterPanel.displayName = "QuarterPanel";
QuarterPanel.inheritAttrs = false;
function YearHeader(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, generateConfig2 = props3.generateConfig, viewDate = props3.viewDate, onPrevDecade = props3.onPrevDecade, onNextDecade = props3.onNextDecade, onDecadeClick = props3.onDecadeClick;
  var _useInjectPanel = useInjectPanel(), hideHeader = _useInjectPanel.hideHeader;
  if (hideHeader.value) {
    return null;
  }
  var headerPrefixCls = "".concat(prefixCls, "-header");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  var endYear = startYear + YEAR_DECADE_COUNT - 1;
  return createVNode(Header$3, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": headerPrefixCls,
    "onSuperPrev": onPrevDecade,
    "onSuperNext": onNextDecade
  }), {
    default: function _default9() {
      return [createVNode("button", {
        "type": "button",
        "onClick": onDecadeClick,
        "class": "".concat(prefixCls, "-decade-btn")
      }, [startYear, createTextVNode("-"), endYear])];
    }
  });
}
YearHeader.displayName = "YearHeader";
YearHeader.inheritAttrs = false;
var YEAR_COL_COUNT = 3;
var YEAR_ROW_COUNT = 4;
function YearBody(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, value = props3.value, viewDate = props3.viewDate, locale2 = props3.locale, generateConfig2 = props3.generateConfig;
  var _useInjectRange = useInjectRange(), rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
  var yearPrefixCls = "".concat(prefixCls, "-cell");
  var yearNumber = generateConfig2.getYear(viewDate);
  var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
  var endYear = startYear + YEAR_DECADE_COUNT - 1;
  var baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
  var isInView = function isInView2(date4) {
    var currentYearNumber = generateConfig2.getYear(date4);
    return startYear <= currentYearNumber && currentYearNumber <= endYear;
  };
  var getCellClassName = useCellClassName({
    cellPrefixCls: yearPrefixCls,
    value,
    generateConfig: generateConfig2,
    rangedValue: rangedValue.value,
    hoverRangedValue: hoverRangedValue.value,
    isSameCell: function isSameCell(current2, target) {
      return isSameYear(generateConfig2, current2, target);
    },
    isInView,
    offsetCell: function offsetCell(date4, offset3) {
      return generateConfig2.addYear(date4, offset3);
    }
  });
  return createVNode(PanelBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "rowNum": YEAR_ROW_COUNT,
    "colNum": YEAR_COL_COUNT,
    "baseDate": baseYear,
    "getCellText": generateConfig2.getYear,
    "getCellClassName": getCellClassName,
    "getCellDate": generateConfig2.addYear,
    "titleCell": function titleCell(date4) {
      return formatValue(date4, {
        locale: locale2,
        format: "YYYY",
        generateConfig: generateConfig2
      });
    }
  }), null);
}
YearBody.displayName = "YearBody";
YearBody.inheritAttrs = false;
var YEAR_DECADE_COUNT = 10;
function YearPanel(_props) {
  var props3 = useMergeProps(_props);
  var prefixCls = props3.prefixCls, operationRef = props3.operationRef, onViewDateChange = props3.onViewDateChange, generateConfig2 = props3.generateConfig, value = props3.value, viewDate = props3.viewDate, sourceMode = props3.sourceMode, _onSelect = props3.onSelect, onPanelChange = props3.onPanelChange;
  var panelPrefixCls = "".concat(prefixCls, "-year-panel");
  operationRef.value = {
    onKeydown: function onKeydown(event2) {
      return createKeydownHandler(event2, {
        onLeftRight: function onLeftRight(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
        },
        onCtrlLeftRight: function onCtrlLeftRight(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2 * YEAR_DECADE_COUNT), "key");
        },
        onUpDown: function onUpDown(diff2) {
          _onSelect(generateConfig2.addYear(value || viewDate, diff2 * YEAR_COL_COUNT), "key");
        },
        onEnter: function onEnter() {
          onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
        }
      });
    }
  };
  var onDecadeChange = function onDecadeChange2(diff2) {
    var newDate = generateConfig2.addYear(viewDate, diff2 * 10);
    onViewDateChange(newDate);
    onPanelChange(null, newDate);
  };
  return createVNode("div", {
    "class": panelPrefixCls
  }, [createVNode(YearHeader, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onPrevDecade": function onPrevDecade() {
      onDecadeChange(-1);
    },
    "onNextDecade": function onNextDecade() {
      onDecadeChange(1);
    },
    "onDecadeClick": function onDecadeClick() {
      onPanelChange("decade", viewDate);
    }
  }), null), createVNode(YearBody, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    "prefixCls": prefixCls,
    "onSelect": function onSelect(date4) {
      onPanelChange(sourceMode === "date" ? "date" : "month", date4);
      _onSelect(date4, "mouse");
    }
  }), null)]);
}
YearPanel.displayName = "YearPanel";
YearPanel.inheritAttrs = false;
function getExtraFooter(prefixCls, mode, renderExtraFooter) {
  if (!renderExtraFooter) {
    return null;
  }
  return createVNode("div", {
    "class": "".concat(prefixCls, "-footer-extra")
  }, [renderExtraFooter(mode)]);
}
function getRanges(_ref) {
  var prefixCls = _ref.prefixCls, _ref$rangeList = _ref.rangeList, rangeList = _ref$rangeList === void 0 ? [] : _ref$rangeList, _ref$components = _ref.components, components2 = _ref$components === void 0 ? {} : _ref$components, needConfirmButton = _ref.needConfirmButton, onNow = _ref.onNow, onOk = _ref.onOk, okDisabled = _ref.okDisabled, showNow = _ref.showNow, locale2 = _ref.locale;
  var presetNode;
  var okNode;
  if (rangeList.length) {
    var Item3 = components2.rangeItem || "span";
    presetNode = createVNode(Fragment, null, [rangeList.map(function(_ref2) {
      var label = _ref2.label, onClick2 = _ref2.onClick, onMouseenter2 = _ref2.onMouseenter, onMouseleave2 = _ref2.onMouseleave;
      return createVNode("li", {
        "key": label,
        "class": "".concat(prefixCls, "-preset")
      }, [createVNode(Item3, {
        "onClick": onClick2,
        "onMouseenter": onMouseenter2,
        "onMouseleave": onMouseleave2
      }, {
        default: function _default9() {
          return [label];
        }
      })]);
    })]);
  }
  if (needConfirmButton) {
    var Button2 = components2.button || "button";
    if (onNow && !presetNode && showNow !== false) {
      presetNode = createVNode("li", {
        "class": "".concat(prefixCls, "-now")
      }, [createVNode("a", {
        "class": "".concat(prefixCls, "-now-btn"),
        "onClick": onNow
      }, [locale2.now])]);
    }
    okNode = needConfirmButton && createVNode("li", {
      "class": "".concat(prefixCls, "-ok")
    }, [createVNode(Button2, {
      "disabled": okDisabled,
      "onClick": onOk
    }, {
      default: function _default9() {
        return [locale2.ok];
      }
    })]);
  }
  if (!presetNode && !okNode) {
    return null;
  }
  return createVNode("ul", {
    "class": "".concat(prefixCls, "-ranges")
  }, [presetNode, okNode]);
}
function PickerPanel() {
  return defineComponent({
    name: "PickerPanel",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup: function setup219(props3, _ref) {
      var attrs = _ref.attrs;
      var needConfirmButton = computed(function() {
        return props3.picker === "date" && !!props3.showTime || props3.picker === "time";
      });
      var isHourStepValid = computed(function() {
        return 24 % props3.hourStep === 0;
      });
      var isMinuteStepValid = computed(function() {
        return 60 % props3.minuteStep === 0;
      });
      var isSecondStepValid = computed(function() {
        return 60 % props3.secondStep === 0;
      });
      var panelContext = useInjectPanel();
      var operationRef = panelContext.operationRef, panelDivRef = panelContext.panelRef, onContextSelect = panelContext.onSelect, hideRanges = panelContext.hideRanges, defaultOpenValue = panelContext.defaultOpenValue;
      var _useInjectRange = useInjectRange(), inRange = _useInjectRange.inRange, panelPosition = _useInjectRange.panelPosition, rangedValue = _useInjectRange.rangedValue, hoverRangedValue = _useInjectRange.hoverRangedValue;
      var panelRef = ref({});
      var _useMergedState = useMergedState(null, {
        value: toRef(props3, "value"),
        defaultValue: props3.defaultValue,
        postState: function postState(val) {
          if (!val && defaultOpenValue !== null && defaultOpenValue !== void 0 && defaultOpenValue.value && props3.picker === "time") {
            return defaultOpenValue.value;
          }
          return val;
        }
      }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(null, {
        value: toRef(props3, "pickerValue"),
        defaultValue: props3.defaultPickerValue || mergedValue.value,
        postState: function postState(date4) {
          var generateConfig2 = props3.generateConfig, showTime = props3.showTime, defaultValue = props3.defaultValue;
          var now2 = generateConfig2.getNow();
          if (!date4)
            return now2;
          if (!mergedValue.value && props3.showTime) {
            if (_typeof$3(showTime) === "object") {
              return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, showTime.defaultValue || now2);
            }
            if (defaultValue) {
              return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, defaultValue);
            }
            return setDateTime(generateConfig2, Array.isArray(date4) ? date4[0] : date4, now2);
          }
          return date4;
        }
      }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), viewDate = _useMergedState4[0], setInnerViewDate = _useMergedState4[1];
      var setViewDate = function setViewDate2(date4) {
        setInnerViewDate(date4);
        if (props3.onPickerValueChange) {
          props3.onPickerValueChange(date4);
        }
      };
      var getInternalNextMode = function getInternalNextMode2(nextMode) {
        var getNextMode = PickerModeMap[props3.picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      var _useMergedState5 = useMergedState(function() {
        if (props3.picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: toRef(props3, "mode")
      }), _useMergedState6 = _slicedToArray$2(_useMergedState5, 2), mergedMode = _useMergedState6[0], setInnerMode = _useMergedState6[1];
      watch(function() {
        return props3.picker;
      }, function() {
        setInnerMode(props3.picker);
      });
      var sourceMode = ref(mergedMode.value);
      var setSourceMode = function setSourceMode2(val) {
        sourceMode.value = val;
      };
      var onInternalPanelChange = function onInternalPanelChange2(newMode, viewValue) {
        var onPanelChange = props3.onPanelChange, generateConfig2 = props3.generateConfig;
        var nextMode = getInternalNextMode(newMode || mergedMode.value);
        setSourceMode(mergedMode.value);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode.value !== nextMode || isEqual(generateConfig2, viewDate.value, viewDate.value))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      var triggerSelect = function triggerSelect2(date4, type4) {
        var forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var picker = props3.picker, generateConfig2 = props3.generateConfig, onSelect = props3.onSelect, onChange3 = props3.onChange, disabledDate = props3.disabledDate;
        if (mergedMode.value === picker || forceTriggerSelect) {
          setInnerValue(date4);
          if (onSelect) {
            onSelect(date4);
          }
          if (onContextSelect) {
            onContextSelect(date4, type4);
          }
          if (onChange3 && !isEqual(generateConfig2, date4, mergedValue.value) && !(disabledDate !== null && disabledDate !== void 0 && disabledDate(date4))) {
            onChange3(date4);
          }
        }
      };
      var onInternalKeydown = function onInternalKeydown2(e2) {
        if (panelRef.value && panelRef.value.onKeydown) {
          if ([KeyCode$1.LEFT, KeyCode$1.RIGHT, KeyCode$1.UP, KeyCode$1.DOWN, KeyCode$1.PAGE_UP, KeyCode$1.PAGE_DOWN, KeyCode$1.ENTER].includes(e2.which)) {
            e2.preventDefault();
          }
          return panelRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var onInternalBlur = function onInternalBlur2(e2) {
        if (panelRef.value && panelRef.value.onBlur) {
          panelRef.value.onBlur(e2);
        }
      };
      var onNow = function onNow2() {
        var generateConfig2 = props3.generateConfig, hourStep = props3.hourStep, minuteStep = props3.minuteStep, secondStep = props3.secondStep;
        var now2 = generateConfig2.getNow();
        var lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now2), generateConfig2.getMinute(now2), generateConfig2.getSecond(now2), isHourStepValid.value ? hourStep : 1, isMinuteStepValid.value ? minuteStep : 1, isSecondStepValid.value ? secondStep : 1);
        var adjustedNow = setTime(
          generateConfig2,
          now2,
          lowerBoundTime[0],
          lowerBoundTime[1],
          lowerBoundTime[2]
        );
        triggerSelect(adjustedNow, "submit");
      };
      var classString = computed(function() {
        var _classNames;
        var prefixCls = props3.prefixCls, direction = props3.direction;
        return classNames("".concat(prefixCls, "-panel"), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-panel-has-range"), rangedValue && rangedValue.value && rangedValue.value[0] && rangedValue.value[1]), _defineProperty$U(_classNames, "".concat(prefixCls, "-panel-has-range-hover"), hoverRangedValue && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1]), _defineProperty$U(_classNames, "".concat(prefixCls, "-panel-rtl"), direction === "rtl"), _classNames));
      });
      useProvidePanel(_objectSpread2$1(_objectSpread2$1({}, panelContext), {}, {
        mode: mergedMode,
        hideHeader: computed(function() {
          var _panelContext$hideHea;
          return props3.hideHeader !== void 0 ? props3.hideHeader : (_panelContext$hideHea = panelContext.hideHeader) === null || _panelContext$hideHea === void 0 ? void 0 : _panelContext$hideHea.value;
        }),
        hidePrevBtn: computed(function() {
          return inRange.value && panelPosition.value === "right";
        }),
        hideNextBtn: computed(function() {
          return inRange.value && panelPosition.value === "left";
        })
      }));
      watch(function() {
        return props3.value;
      }, function() {
        if (props3.value) {
          setInnerViewDate(props3.value);
        }
      });
      return function() {
        var _props$prefixCls = props3.prefixCls, prefixCls = _props$prefixCls === void 0 ? "ant-picker" : _props$prefixCls, locale2 = props3.locale, generateConfig2 = props3.generateConfig, disabledDate = props3.disabledDate, _props$picker = props3.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$tabindex = props3.tabindex, tabindex = _props$tabindex === void 0 ? 0 : _props$tabindex, showNow = props3.showNow, showTime = props3.showTime, showToday = props3.showToday, renderExtraFooter = props3.renderExtraFooter, onMousedown2 = props3.onMousedown, _onOk = props3.onOk, components2 = props3.components;
        if (operationRef && panelPosition.value !== "right") {
          operationRef.value = {
            onKeydown: onInternalKeydown,
            onClose: function onClose() {
              if (panelRef.value && panelRef.value.onClose) {
                panelRef.value.onClose();
              }
            }
          };
        }
        var panelNode;
        var pickerProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props3), {}, {
          operationRef: panelRef,
          prefixCls,
          viewDate: viewDate.value,
          value: mergedValue.value,
          onViewDateChange: setViewDate,
          sourceMode: sourceMode.value,
          onPanelChange: onInternalPanelChange,
          disabledDate
        });
        delete pickerProps.onChange;
        delete pickerProps.onSelect;
        switch (mergedMode.value) {
          case "decade":
            panelNode = createVNode(DecadePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "year":
            panelNode = createVNode(YearPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "month":
            panelNode = createVNode(MonthPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "quarter":
            panelNode = createVNode(QuarterPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "week":
            panelNode = createVNode(WeekPanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          case "time":
            delete pickerProps.showTime;
            panelNode = createVNode(TimePanel, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickerProps), _typeof$3(showTime) === "object" ? showTime : null), {}, {
              "onSelect": function onSelect(date4, type4) {
                setViewDate(date4);
                triggerSelect(date4, type4);
              }
            }), null);
            break;
          default:
            if (showTime) {
              panelNode = createVNode(DatetimePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": function onSelect(date4, type4) {
                  setViewDate(date4);
                  triggerSelect(date4, type4);
                }
              }), null);
            } else {
              panelNode = createVNode(DatePanel, _objectSpread2$1(_objectSpread2$1({}, pickerProps), {}, {
                "onSelect": function onSelect(date4, type4) {
                  setViewDate(date4);
                  triggerSelect(date4, type4);
                }
              }), null);
            }
        }
        var extraFooter;
        var rangesNode;
        if (!(hideRanges !== null && hideRanges !== void 0 && hideRanges.value)) {
          extraFooter = getExtraFooter(prefixCls, mergedMode.value, renderExtraFooter);
          rangesNode = getRanges({
            prefixCls,
            components: components2,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !mergedValue.value || disabledDate && disabledDate(mergedValue.value),
            locale: locale2,
            showNow,
            onNow: needConfirmButton.value && onNow,
            onOk: function onOk() {
              if (mergedValue.value) {
                triggerSelect(mergedValue.value, "submit", true);
                if (_onOk) {
                  _onOk(mergedValue.value);
                }
              }
            }
          });
        }
        var todayNode;
        if (showToday && mergedMode.value === "date" && picker === "date" && !showTime) {
          var now2 = generateConfig2.getNow();
          var todayCls = "".concat(prefixCls, "-today-btn");
          var disabled = disabledDate && disabledDate(now2);
          todayNode = createVNode("a", {
            "class": classNames(todayCls, disabled && "".concat(todayCls, "-disabled")),
            "aria-disabled": disabled,
            "onClick": function onClick2() {
              if (!disabled) {
                triggerSelect(now2, "mouse", true);
              }
            }
          }, [locale2.today]);
        }
        return createVNode("div", {
          "tabindex": tabindex,
          "class": classNames(classString.value, attrs.class),
          "style": attrs.style,
          "onKeydown": onInternalKeydown,
          "onBlur": onInternalBlur,
          "onMousedown": onMousedown2,
          "ref": panelDivRef
        }, [panelNode, extraFooter || rangesNode || todayNode ? createVNode("div", {
          "class": "".concat(prefixCls, "-footer")
        }, [extraFooter, rangesNode, todayNode]) : null]);
      };
    }
  });
}
var InterPickerPanel = PickerPanel();
const PickerPanel$1 = function(props3) {
  return createVNode(InterPickerPanel, props3);
};
var BUILT_IN_PLACEMENTS$1 = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function PickerTrigger(props3, _ref) {
  var _classNames;
  var slots = _ref.slots;
  var _useMergeProps = useMergeProps(props3), prefixCls = _useMergeProps.prefixCls, popupStyle = _useMergeProps.popupStyle, visible = _useMergeProps.visible, dropdownClassName = _useMergeProps.dropdownClassName, dropdownAlign = _useMergeProps.dropdownAlign, transitionName2 = _useMergeProps.transitionName, getPopupContainer = _useMergeProps.getPopupContainer, range3 = _useMergeProps.range, popupPlacement = _useMergeProps.popupPlacement, direction = _useMergeProps.direction;
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var getPopupPlacement = function getPopupPlacement2() {
    if (popupPlacement !== void 0) {
      return popupPlacement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return createVNode(Trigger, {
    "showAction": [],
    "hideAction": [],
    "popupPlacement": getPopupPlacement(),
    "builtinPlacements": BUILT_IN_PLACEMENTS$1,
    "prefixCls": dropdownPrefixCls,
    "popupTransitionName": transitionName2,
    "popupAlign": dropdownAlign,
    "popupVisible": visible,
    "popupClassName": classNames(dropdownClassName, (_classNames = {}, _defineProperty$U(_classNames, "".concat(dropdownPrefixCls, "-range"), range3), _defineProperty$U(_classNames, "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl"), _classNames)),
    "popupStyle": popupStyle,
    "getPopupContainer": getPopupContainer,
    "tryPopPortal": true
  }, {
    default: slots.default,
    popup: slots.popupElement
  });
}
function usePickerInput(_ref) {
  var open2 = _ref.open, value = _ref.value, isClickOutside = _ref.isClickOutside, triggerOpen = _ref.triggerOpen, forwardKeydown = _ref.forwardKeydown, _onKeydown = _ref.onKeydown, blurToCancel = _ref.blurToCancel, onSubmit = _ref.onSubmit, onCancel = _ref.onCancel, _onFocus = _ref.onFocus, _onBlur = _ref.onBlur;
  var typing = ref(false);
  var focused = ref(false);
  var preventBlurRef = ref(false);
  var valueChangedRef = ref(false);
  var preventDefaultRef = ref(false);
  var inputProps3 = computed(function() {
    return {
      onMousedown: function onMousedown2() {
        typing.value = true;
        triggerOpen(true);
      },
      onKeydown: function onKeydown(e2) {
        var preventDefault = function preventDefault2() {
          preventDefaultRef.value = true;
        };
        _onKeydown(e2, preventDefault);
        if (preventDefaultRef.value)
          return;
        switch (e2.which) {
          case KeyCode$1.ENTER: {
            if (!open2.value) {
              triggerOpen(true);
            } else if (onSubmit() !== false) {
              typing.value = true;
            }
            e2.preventDefault();
            return;
          }
          case KeyCode$1.TAB: {
            if (typing.value && open2.value && !e2.shiftKey) {
              typing.value = false;
              e2.preventDefault();
            } else if (!typing.value && open2.value) {
              if (!forwardKeydown(e2) && e2.shiftKey) {
                typing.value = true;
                e2.preventDefault();
              }
            }
            return;
          }
          case KeyCode$1.ESC: {
            typing.value = true;
            onCancel();
            return;
          }
        }
        if (!open2.value && ![KeyCode$1.SHIFT].includes(e2.which)) {
          triggerOpen(true);
        } else if (!typing.value) {
          forwardKeydown(e2);
        }
      },
      onFocus: function onFocus2(e2) {
        typing.value = true;
        focused.value = true;
        if (_onFocus) {
          _onFocus(e2);
        }
      },
      onBlur: function onBlur2(e2) {
        if (preventBlurRef.value || !isClickOutside(document.activeElement)) {
          preventBlurRef.value = false;
          return;
        }
        if (blurToCancel.value) {
          setTimeout(function() {
            var _document = document, activeElement = _document.activeElement;
            while (activeElement && activeElement.shadowRoot) {
              activeElement = activeElement.shadowRoot.activeElement;
            }
            if (isClickOutside(activeElement)) {
              onCancel();
            }
          }, 0);
        } else if (open2.value) {
          triggerOpen(false);
          if (valueChangedRef.value) {
            onSubmit();
          }
        }
        focused.value = false;
        if (_onBlur) {
          _onBlur(e2);
        }
      }
    };
  });
  watch(open2, function() {
    valueChangedRef.value = false;
  });
  watch(value, function() {
    valueChangedRef.value = true;
  });
  var globalMousedownEvent = ref();
  onMounted(function() {
    globalMousedownEvent.value = addGlobalMousedownEvent(function(e2) {
      var target = getTargetFromEvent(e2);
      if (open2.value) {
        var clickedOutside = isClickOutside(target);
        if (!clickedOutside) {
          preventBlurRef.value = true;
          wrapperRaf(function() {
            preventBlurRef.value = false;
          });
        } else if (!focused.value || clickedOutside) {
          triggerOpen(false);
        }
      }
    });
  });
  onBeforeUnmount(function() {
    globalMousedownEvent.value && globalMousedownEvent.value();
  });
  return [inputProps3, {
    focused,
    typing
  }];
}
function useTextValueMapping(_ref) {
  var valueTexts = _ref.valueTexts, onTextChange = _ref.onTextChange;
  var text = ref("");
  function triggerTextChange(value) {
    text.value = value;
    onTextChange(value);
  }
  function resetText() {
    text.value = valueTexts.value[0];
  }
  watch(function() {
    return _toConsumableArray(valueTexts.value);
  }, function(cur) {
    var pre = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (cur.join("||") !== pre.join("||") && valueTexts.value.every(function(valText) {
      return valText !== text.value;
    })) {
      resetText();
    }
  }, {
    immediate: true
  });
  return [text, triggerTextChange, resetText];
}
function useValueTexts(value, _ref) {
  var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
  var texts = useMemo(function() {
    if (!value.value) {
      return [[""], ""];
    }
    var firstValueText2 = "";
    var fullValueTexts2 = [];
    for (var i2 = 0; i2 < formatList.value.length; i2 += 1) {
      var format5 = formatList.value[i2];
      var formatStr = formatValue(value.value, {
        generateConfig: generateConfig2.value,
        locale: locale2.value,
        format: format5
      });
      fullValueTexts2.push(formatStr);
      if (i2 === 0) {
        firstValueText2 = formatStr;
      }
    }
    return [fullValueTexts2, firstValueText2];
  }, [value, formatList], function(next2, prev2) {
    return prev2[0] !== next2[0] || !shallowequal(prev2[1], next2[1]);
  });
  var fullValueTexts = computed(function() {
    return texts.value[0];
  });
  var firstValueText = computed(function() {
    return texts.value[1];
  });
  return [fullValueTexts, firstValueText];
}
function useHoverValue(valueText, _ref) {
  var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
  var innerValue = ref(null);
  var rafId;
  function setValue2(val) {
    var immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    wrapperRaf.cancel(rafId);
    if (immediately) {
      innerValue.value = val;
      return;
    }
    rafId = wrapperRaf(function() {
      innerValue.value = val;
    });
  }
  var _useValueTexts = useValueTexts(innerValue, {
    formatList,
    generateConfig: generateConfig2,
    locale: locale2
  }), _useValueTexts2 = _slicedToArray$2(_useValueTexts, 2), firstText = _useValueTexts2[1];
  function onEnter(date4) {
    setValue2(date4);
  }
  function onLeave() {
    var immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    setValue2(null, immediately);
  }
  watch(valueText, function() {
    onLeave(true);
  });
  onBeforeUnmount(function() {
    wrapperRaf.cancel(rafId);
  });
  return [firstText, onEnter, onLeave];
}
function Picker() {
  return defineComponent({
    name: "Picker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup: function setup219(props3, _ref) {
      var attrs = _ref.attrs, expose = _ref.expose;
      var inputRef = ref(null);
      var picker = computed(function() {
        var _props$picker;
        return (_props$picker = props3.picker) !== null && _props$picker !== void 0 ? _props$picker : "date";
      });
      var needConfirmButton = computed(function() {
        return picker.value === "date" && !!props3.showTime || picker.value === "time";
      });
      var formatList = computed(function() {
        return toArray$6(getDefaultFormat(props3.format, picker.value, props3.showTime, props3.use12Hours));
      });
      var panelDivRef = ref(null);
      var inputDivRef = ref(null);
      var containerRef = ref(null);
      var _useMergedState = useMergedState(null, {
        value: toRef(props3, "value"),
        defaultValue: props3.defaultValue
      }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var selectedValue = ref(mergedValue.value);
      var setSelectedValue = function setSelectedValue2(val) {
        selectedValue.value = val;
      };
      var operationRef = ref(null);
      var _useMergedState3 = useMergedState(false, {
        value: toRef(props3, "open"),
        defaultValue: props3.defaultOpen,
        postState: function postState(postOpen) {
          return props3.disabled ? false : postOpen;
        },
        onChange: function onChange3(newOpen) {
          if (props3.onOpenChange) {
            props3.onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), mergedOpen = _useMergedState4[0], triggerInnerOpen = _useMergedState4[1];
      var _useValueTexts = useValueTexts(selectedValue, {
        formatList,
        generateConfig: toRef(props3, "generateConfig"),
        locale: toRef(props3, "locale")
      }), _useValueTexts2 = _slicedToArray$2(_useValueTexts, 2), valueTexts = _useValueTexts2[0], firstValueText = _useValueTexts2[1];
      var _useTextValueMapping = useTextValueMapping({
        valueTexts,
        onTextChange: function onTextChange(newText) {
          var inputDate = parseValue(newText, {
            locale: props3.locale,
            formatList: formatList.value,
            generateConfig: props3.generateConfig
          });
          if (inputDate && (!props3.disabledDate || !props3.disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      }), _useTextValueMapping2 = _slicedToArray$2(_useTextValueMapping, 3), text = _useTextValueMapping2[0], triggerTextChange = _useTextValueMapping2[1], resetText = _useTextValueMapping2[2];
      var triggerChange = function triggerChange2(newValue) {
        var onChange3 = props3.onChange, generateConfig2 = props3.generateConfig, locale2 = props3.locale;
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange3 && !isEqual(generateConfig2, mergedValue.value, newValue)) {
          onChange3(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList.value[0]
          }) : "");
        }
      };
      var triggerOpen = function triggerOpen2(newOpen) {
        if (props3.disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      var forwardKeydown = function forwardKeydown2(e2) {
        if (mergedOpen.value && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var onInternalMouseup = function onInternalMouseup2() {
        if (props3.onMouseup) {
          props3.onMouseup.apply(props3, arguments);
        }
        if (inputRef.value) {
          inputRef.value.focus();
          triggerOpen(true);
        }
      };
      var _usePickerInput = usePickerInput({
        blurToCancel: needConfirmButton,
        open: mergedOpen,
        value: text,
        triggerOpen,
        forwardKeydown,
        isClickOutside: function isClickOutside(target) {
          return !elementsContains([panelDivRef.value, inputDivRef.value, containerRef.value], target);
        },
        onSubmit: function onSubmit() {
          if (!selectedValue.value || props3.disabledDate && props3.disabledDate(selectedValue.value)) {
            return false;
          }
          triggerChange(selectedValue.value);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: function onCancel() {
          triggerOpen(false);
          setSelectedValue(mergedValue.value);
          resetText();
        },
        onKeydown: function onKeydown(e2, preventDefault) {
          var _props$onKeydown;
          (_props$onKeydown = props3.onKeydown) === null || _props$onKeydown === void 0 ? void 0 : _props$onKeydown.call(props3, e2, preventDefault);
        },
        onFocus: function onFocus2(e2) {
          var _props$onFocus;
          (_props$onFocus = props3.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props3, e2);
        },
        onBlur: function onBlur2(e2) {
          var _props$onBlur;
          (_props$onBlur = props3.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props3, e2);
        }
      }), _usePickerInput2 = _slicedToArray$2(_usePickerInput, 2), inputProps3 = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], focused = _usePickerInput2$.focused, typing = _usePickerInput2$.typing;
      watch([mergedOpen, valueTexts], function() {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!valueTexts.value.length || valueTexts.value[0] === "") {
            triggerTextChange("");
          } else if (firstValueText.value !== text.value) {
            resetText();
          }
        }
      });
      watch(picker, function() {
        if (!mergedOpen.value) {
          resetText();
        }
      });
      watch(mergedValue, function() {
        setSelectedValue(mergedValue.value);
      });
      var _useHoverValue = useHoverValue(text, {
        formatList,
        generateConfig: toRef(props3, "generateConfig"),
        locale: toRef(props3, "locale")
      }), _useHoverValue2 = _slicedToArray$2(_useHoverValue, 3), hoverValue = _useHoverValue2[0], onEnter = _useHoverValue2[1], onLeave = _useHoverValue2[2];
      var onContextSelect = function onContextSelect2(date4, type4) {
        if (type4 === "submit" || type4 !== "key" && !needConfirmButton.value) {
          triggerChange(date4);
          triggerOpen(false);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(function() {
          return picker.value === "time";
        }),
        panelRef: panelDivRef,
        onSelect: onContextSelect,
        open: mergedOpen,
        defaultOpenValue: toRef(props3, "defaultOpenValue"),
        onDateMouseenter: onEnter,
        onDateMouseleave: onLeave
      });
      expose({
        focus: function focus() {
          if (inputRef.value) {
            inputRef.value.focus();
          }
        },
        blur: function blur() {
          if (inputRef.value) {
            inputRef.value.blur();
          }
        }
      });
      var getPortal = useProviderTrigger();
      return function() {
        var _classNames2;
        var _props$prefixCls = props3.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, id = props3.id, tabindex = props3.tabindex, dropdownClassName = props3.dropdownClassName, dropdownAlign = props3.dropdownAlign, popupStyle = props3.popupStyle, transitionName2 = props3.transitionName, generateConfig2 = props3.generateConfig, locale2 = props3.locale, inputReadOnly = props3.inputReadOnly, allowClear = props3.allowClear, autofocus = props3.autofocus, _props$picker2 = props3.picker, picker2 = _props$picker2 === void 0 ? "date" : _props$picker2;
        props3.defaultOpenValue;
        var suffixIcon = props3.suffixIcon, clearIcon = props3.clearIcon, disabled = props3.disabled, placeholder = props3.placeholder, getPopupContainer = props3.getPopupContainer, panelRender = props3.panelRender, onMousedown2 = props3.onMousedown, onMouseenter2 = props3.onMouseenter, onMouseleave2 = props3.onMouseleave, onContextmenu2 = props3.onContextmenu, onClick2 = props3.onClick, _onSelect = props3.onSelect, direction = props3.direction, _props$autocomplete = props3.autocomplete, autocomplete = _props$autocomplete === void 0 ? "off" : _props$autocomplete;
        var panelProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
          class: classNames(_defineProperty$U({}, "".concat(prefixCls, "-panel-focused"), !typing.value)),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        var panelNode = createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1({}, panelProps), {}, {
          "generateConfig": generateConfig2,
          "value": selectedValue.value,
          "locale": locale2,
          "tabindex": -1,
          "onSelect": function onSelect(date4) {
            _onSelect === null || _onSelect === void 0 ? void 0 : _onSelect(date4);
            setSelectedValue(date4);
          },
          "direction": direction,
          "onPanelChange": function onPanelChange(viewDate, mode) {
            var onPanelChange2 = props3.onPanelChange;
            onLeave(true);
            onPanelChange2 === null || onPanelChange2 === void 0 ? void 0 : onPanelChange2(viewDate, mode);
          }
        }), null);
        if (panelRender) {
          panelNode = panelRender(panelNode);
        }
        var panel = createVNode("div", {
          "class": "".concat(prefixCls, "-panel-container"),
          "onMousedown": function onMousedown3(e2) {
            e2.preventDefault();
          }
        }, [panelNode]);
        var suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": "".concat(prefixCls, "-suffix")
          }, [suffixIcon]);
        }
        var clearNode;
        if (allowClear && mergedValue.value && !disabled) {
          clearNode = createVNode("span", {
            "onMousedown": function onMousedown3(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": function onMouseup(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              triggerChange(null);
              triggerOpen(false);
            },
            "class": "".concat(prefixCls, "-clear"),
            "role": "button"
          }, [clearIcon || createVNode("span", {
            "class": "".concat(prefixCls, "-clear-btn")
          }, null)]);
        }
        var mergedInputProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          id,
          tabindex,
          disabled,
          readonly: inputReadOnly || typeof formatList.value[0] === "function" || !typing.value,
          value: hoverValue.value || text.value,
          onInput: function onInput(e2) {
            triggerTextChange(e2.target.value);
          },
          autofocus,
          placeholder,
          ref: inputRef,
          title: text.value
        }, inputProps3.value), {}, {
          size: getInputSize(picker2, formatList.value[0], generateConfig2)
        }, getDataOrAriaProps(props3)), {}, {
          autocomplete
        });
        var inputNode = props3.inputRender ? props3.inputRender(mergedInputProps) : createVNode("input", mergedInputProps, null);
        var popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
        return createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "popupPlacement": popupPlacement,
          "direction": direction
        }, {
          default: function _default9() {
            return [createVNode("div", {
              "ref": containerRef,
              "class": classNames(prefixCls, attrs.class, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_classNames2, "".concat(prefixCls, "-focused"), focused.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
              "style": attrs.style,
              "onMousedown": onMousedown2,
              "onMouseup": onInternalMouseup,
              "onMouseenter": onMouseenter2,
              "onMouseleave": onMouseleave2,
              "onContextmenu": onContextmenu2,
              "onClick": onClick2
            }, [createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), _defineProperty$U({}, "".concat(prefixCls, "-input-placeholder"), !!hoverValue.value)),
              "ref": inputDivRef
            }, [inputNode, suffixNode, clearNode]), getPortal()])];
          },
          popupElement: function popupElement() {
            return panel;
          }
        });
      };
    }
  });
}
const Picker$1 = Picker();
function useRangeDisabled(_ref, openRecordsRef) {
  var picker = _ref.picker, locale2 = _ref.locale, selectedValue = _ref.selectedValue, disabledDate = _ref.disabledDate, disabled = _ref.disabled, generateConfig2 = _ref.generateConfig;
  var startDate = computed(function() {
    return getValue$2(selectedValue.value, 0);
  });
  var endDate = computed(function() {
    return getValue$2(selectedValue.value, 1);
  });
  function weekFirstDate(date4) {
    return generateConfig2.value.locale.getWeekFirstDate(locale2.value.locale, date4);
  }
  function monthNumber(date4) {
    var year = generateConfig2.value.getYear(date4);
    var month = generateConfig2.value.getMonth(date4);
    return year * 100 + month;
  }
  function quarterNumber(date4) {
    var year = generateConfig2.value.getYear(date4);
    var quarter = getQuarter(generateConfig2.value, date4);
    return year * 10 + quarter;
  }
  var disabledStartDate = function disabledStartDate2(date4) {
    var _disabledDate$value;
    if (disabledDate && disabledDate !== null && disabledDate !== void 0 && (_disabledDate$value = disabledDate.value) !== null && _disabledDate$value !== void 0 && _disabledDate$value.call(disabledDate, date4)) {
      return true;
    }
    if (disabled[1] && endDate) {
      return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(date4, endDate.value);
    }
    if (openRecordsRef.value[1] && endDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date4) > quarterNumber(endDate.value);
        case "month":
          return monthNumber(date4) > monthNumber(endDate.value);
        case "week":
          return weekFirstDate(date4) > weekFirstDate(endDate.value);
        default:
          return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(date4, endDate.value);
      }
    }
    return false;
  };
  var disabledEndDate = function disabledEndDate2(date4) {
    var _disabledDate$value2;
    if ((_disabledDate$value2 = disabledDate.value) !== null && _disabledDate$value2 !== void 0 && _disabledDate$value2.call(disabledDate, date4)) {
      return true;
    }
    if (disabled[0] && startDate) {
      return !isSameDate(generateConfig2.value, date4, endDate.value) && generateConfig2.value.isAfter(startDate.value, date4);
    }
    if (openRecordsRef.value[0] && startDate.value) {
      switch (picker.value) {
        case "quarter":
          return quarterNumber(date4) < quarterNumber(startDate.value);
        case "month":
          return monthNumber(date4) < monthNumber(startDate.value);
        case "week":
          return weekFirstDate(date4) < weekFirstDate(startDate.value);
        default:
          return !isSameDate(generateConfig2.value, date4, startDate.value) && generateConfig2.value.isAfter(startDate.value, date4);
      }
    }
    return false;
  };
  return [disabledStartDate, disabledEndDate];
}
function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
  var startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
  function getDistance(compareFunc) {
    if (compareFunc(startDate, endDate)) {
      return "same";
    }
    if (compareFunc(startNext, endDate)) {
      return "closing";
    }
    return "far";
  }
  switch (picker) {
    case "year":
      return getDistance(function(start, end) {
        return isSameDecade(generateConfig2, start, end);
      });
    case "quarter":
    case "month":
      return getDistance(function(start, end) {
        return isSameYear(generateConfig2, start, end);
      });
    default:
      return getDistance(function(start, end) {
        return isSameMonth(generateConfig2, start, end);
      });
  }
}
function getRangeViewDate(values, index2, picker, generateConfig2) {
  var startDate = getValue$2(values, 0);
  var endDate = getValue$2(values, 1);
  if (index2 === 0) {
    return startDate;
  }
  if (startDate && endDate) {
    var distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
    switch (distance) {
      case "same":
        return startDate;
      case "closing":
        return startDate;
      default:
        return getClosingViewDate(endDate, picker, generateConfig2, -1);
    }
  }
  return startDate;
}
function useRangeViewDates(_ref) {
  var values = _ref.values, picker = _ref.picker, defaultDates = _ref.defaultDates, generateConfig2 = _ref.generateConfig;
  var defaultViewDates = ref([getValue$2(defaultDates, 0), getValue$2(defaultDates, 1)]);
  var viewDates = ref(null);
  var startDate = computed(function() {
    return getValue$2(values.value, 0);
  });
  var endDate = computed(function() {
    return getValue$2(values.value, 1);
  });
  var getViewDate = function getViewDate2(index2) {
    if (defaultViewDates.value[index2]) {
      return defaultViewDates.value[index2];
    }
    return getValue$2(viewDates.value, index2) || getRangeViewDate(values.value, index2, picker.value, generateConfig2.value) || startDate.value || endDate.value || generateConfig2.value.getNow();
  };
  var startViewDate = ref(null);
  var endViewDate = ref(null);
  watchEffect(function() {
    startViewDate.value = getViewDate(0);
    endViewDate.value = getViewDate(1);
  });
  function setViewDate(viewDate, index2) {
    if (viewDate) {
      var newViewDates = updateValues(viewDates.value, viewDate, index2);
      defaultViewDates.value = updateValues(defaultViewDates.value, null, index2) || [null, null];
      var anotherIndex = (index2 + 1) % 2;
      if (!getValue$2(values.value, anotherIndex)) {
        newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
      }
      viewDates.value = newViewDates;
    } else if (startDate.value || endDate.value) {
      viewDates.value = null;
    }
  }
  return [startViewDate, endViewDate, setViewDate];
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
function unrefElement(elRef) {
  var _plain$$el;
  var plain = resolveUnref(elRef);
  return (_plain$$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _plain$$el !== void 0 ? _plain$$el : plain;
}
function tryOnMounted(fn) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useSupported(callback) {
  var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isSupported = ref();
  var update = function update2() {
    return isSupported.value = Boolean(callback());
  };
  update();
  tryOnMounted(update, sync);
  return isSupported;
}
var _window, _window$navigator;
var isClient = typeof window !== "undefined";
isClient && ((_window = window) === null || _window === void 0 ? void 0 : (_window$navigator = _window.navigator) === null || _window$navigator === void 0 ? void 0 : _window$navigator.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
var defaultWindow = isClient ? window : void 0;
var _excluded$L = ["window"];
function useResizeObserver(target, callback) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _options$window = options.window, window2 = _options$window === void 0 ? defaultWindow : _options$window, observerOptions = _objectWithoutProperties$2(options, _excluded$L);
  var observer;
  var isSupported = useSupported(function() {
    return window2 && "ResizeObserver" in window2;
  });
  var cleanup2 = function cleanup3() {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  var stopWatch = watch(function() {
    return unrefElement(target);
  }, function(el) {
    cleanup2();
    if (isSupported.value && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, {
    immediate: true,
    flush: "post"
  });
  var stop2 = function stop3() {
    cleanup2();
    stopWatch();
  };
  tryOnScopeDispose(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
function useElementSize(target) {
  var initialSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  };
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _options$box = options.box, box = _options$box === void 0 ? "content-box" : _options$box;
  var width = ref(initialSize.width);
  var height = ref(initialSize.height);
  useResizeObserver(target, function(_ref) {
    var _ref2 = _slicedToArray$2(_ref, 1), entry = _ref2[0];
    var boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
    if (boxSize) {
      width.value = boxSize.reduce(function(acc, _ref3) {
        var inlineSize = _ref3.inlineSize;
        return acc + inlineSize;
      }, 0);
      height.value = boxSize.reduce(function(acc, _ref4) {
        var blockSize = _ref4.blockSize;
        return acc + blockSize;
      }, 0);
    } else {
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }
  }, options);
  watch(function() {
    return unrefElement(target);
  }, function(ele) {
    width.value = ele ? initialSize.width : 0;
    height.value = ele ? initialSize.height : 0;
  });
  return {
    width,
    height
  };
}
function reorderValues(values, generateConfig2) {
  if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
    return [values[1], values[0]];
  }
  return values;
}
function canValueTrigger(value, index2, disabled, allowEmpty) {
  if (value) {
    return true;
  }
  if (allowEmpty && allowEmpty[index2]) {
    return true;
  }
  if (disabled[(index2 + 1) % 2]) {
    return true;
  }
  return false;
}
function RangerPicker() {
  return defineComponent({
    name: "RangerPicker",
    inheritAttrs: false,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes"],
    setup: function setup219(props3, _ref) {
      var attrs = _ref.attrs, expose = _ref.expose;
      var needConfirmButton = computed(function() {
        return props3.picker === "date" && !!props3.showTime || props3.picker === "time";
      });
      var getPortal = useProviderTrigger();
      var openRecordsRef = ref({});
      var containerRef = ref(null);
      var panelDivRef = ref(null);
      var startInputDivRef = ref(null);
      var endInputDivRef = ref(null);
      var separatorRef = ref(null);
      var startInputRef = ref(null);
      var endInputRef = ref(null);
      var arrowRef = ref(null);
      var formatList = computed(function() {
        return toArray$6(getDefaultFormat(props3.format, props3.picker, props3.showTime, props3.use12Hours));
      });
      var _useMergedState = useMergedState(0, {
        value: toRef(props3, "activePickerIndex")
      }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedActivePickerIndex = _useMergedState2[0], setMergedActivePickerIndex = _useMergedState2[1];
      var operationRef = ref(null);
      var mergedDisabled = computed(function() {
        var disabled = props3.disabled;
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      });
      var _useMergedState3 = useMergedState(null, {
        value: toRef(props3, "value"),
        defaultValue: props3.defaultValue,
        postState: function postState(values) {
          return props3.picker === "time" && !props3.order ? values : reorderValues(values, props3.generateConfig);
        }
      }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), mergedValue = _useMergedState4[0], setInnerValue = _useMergedState4[1];
      var _useRangeViewDates = useRangeViewDates({
        values: mergedValue,
        picker: toRef(props3, "picker"),
        defaultDates: props3.defaultPickerValue,
        generateConfig: toRef(props3, "generateConfig")
      }), _useRangeViewDates2 = _slicedToArray$2(_useRangeViewDates, 3), startViewDate = _useRangeViewDates2[0], endViewDate = _useRangeViewDates2[1], setViewDate = _useRangeViewDates2[2];
      var _useMergedState5 = useMergedState(mergedValue.value, {
        postState: function postState(values) {
          var postValues = values;
          if (mergedDisabled.value[0] && mergedDisabled.value[1]) {
            return postValues;
          }
          for (var i2 = 0; i2 < 2; i2 += 1) {
            if (mergedDisabled[i2] && !getValue$2(postValues, i2) && !getValue$2(props3.allowEmpty, i2)) {
              postValues = updateValues(postValues, props3.generateConfig.getNow(), i2);
            }
          }
          return postValues;
        }
      }), _useMergedState6 = _slicedToArray$2(_useMergedState5, 2), selectedValue = _useMergedState6[0], setSelectedValue = _useMergedState6[1];
      var _useMergedState7 = useMergedState([props3.picker, props3.picker], {
        value: toRef(props3, "mode")
      }), _useMergedState8 = _slicedToArray$2(_useMergedState7, 2), mergedModes = _useMergedState8[0], setInnerModes = _useMergedState8[1];
      watch(function() {
        return props3.picker;
      }, function() {
        setInnerModes([props3.picker, props3.picker]);
      });
      var triggerModesChange = function triggerModesChange2(modes, values) {
        var _props$onPanelChange;
        setInnerModes(modes);
        (_props$onPanelChange = props3.onPanelChange) === null || _props$onPanelChange === void 0 ? void 0 : _props$onPanelChange.call(props3, values, modes);
      };
      var _useRangeDisabled = useRangeDisabled({
        picker: toRef(props3, "picker"),
        selectedValue,
        locale: toRef(props3, "locale"),
        disabled: mergedDisabled,
        disabledDate: toRef(props3, "disabledDate"),
        generateConfig: toRef(props3, "generateConfig")
      }, openRecordsRef), _useRangeDisabled2 = _slicedToArray$2(_useRangeDisabled, 2), disabledStartDate = _useRangeDisabled2[0], disabledEndDate = _useRangeDisabled2[1];
      var _useMergedState9 = useMergedState(false, {
        value: toRef(props3, "open"),
        defaultValue: props3.defaultOpen,
        postState: function postState(postOpen) {
          return mergedDisabled.value[mergedActivePickerIndex.value] ? false : postOpen;
        },
        onChange: function onChange3(newOpen) {
          var _props$onOpenChange;
          (_props$onOpenChange = props3.onOpenChange) === null || _props$onOpenChange === void 0 ? void 0 : _props$onOpenChange.call(props3, newOpen);
          if (!newOpen && operationRef.value && operationRef.value.onClose) {
            operationRef.value.onClose();
          }
        }
      }), _useMergedState10 = _slicedToArray$2(_useMergedState9, 2), mergedOpen = _useMergedState10[0], triggerInnerOpen = _useMergedState10[1];
      var startOpen = computed(function() {
        return mergedOpen.value && mergedActivePickerIndex.value === 0;
      });
      var endOpen = computed(function() {
        return mergedOpen.value && mergedActivePickerIndex.value === 1;
      });
      var panelLeft = ref(0);
      var arrowLeft = ref(0);
      var popupMinWidth = ref(0);
      var _useElementSize = useElementSize(containerRef), containerWidth = _useElementSize.width;
      watch([mergedOpen, containerWidth], function() {
        if (!mergedOpen.value && containerRef.value) {
          popupMinWidth.value = containerWidth.value;
        }
      });
      var _useElementSize2 = useElementSize(panelDivRef), panelDivWidth = _useElementSize2.width;
      var _useElementSize3 = useElementSize(arrowRef), arrowWidth = _useElementSize3.width;
      var _useElementSize4 = useElementSize(startInputDivRef), startInputDivWidth = _useElementSize4.width;
      var _useElementSize5 = useElementSize(separatorRef), separatorWidth = _useElementSize5.width;
      watch([mergedActivePickerIndex, mergedOpen, panelDivWidth, arrowWidth, startInputDivWidth, separatorWidth, function() {
        return props3.direction;
      }], function() {
        arrowLeft.value = 0;
        if (mergedOpen.value && mergedActivePickerIndex.value) {
          if (startInputDivRef.value && separatorRef.value && panelDivRef.value) {
            arrowLeft.value = startInputDivWidth.value + separatorWidth.value;
            if (panelDivWidth.value && arrowWidth.value && arrowLeft.value > panelDivWidth.value - arrowWidth.value - (props3.direction === "rtl" || arrowRef.value.offsetLeft > arrowLeft.value ? 0 : arrowRef.value.offsetLeft)) {
              panelLeft.value = arrowLeft.value;
            }
          }
        } else if (mergedActivePickerIndex.value === 0) {
          panelLeft.value = 0;
        }
      }, {
        immediate: true
      });
      var triggerRef2 = ref();
      function _triggerOpen(newOpen, index2) {
        if (newOpen) {
          clearTimeout(triggerRef2.value);
          openRecordsRef.value[index2] = true;
          setMergedActivePickerIndex(index2);
          triggerInnerOpen(newOpen);
          if (!mergedOpen.value) {
            setViewDate(null, index2);
          }
        } else if (mergedActivePickerIndex.value === index2) {
          triggerInnerOpen(newOpen);
          var openRecords = openRecordsRef.value;
          triggerRef2.value = setTimeout(function() {
            if (openRecords === openRecordsRef.value) {
              openRecordsRef.value = {};
            }
          });
        }
      }
      function triggerOpenAndFocus(index2) {
        _triggerOpen(true, index2);
        setTimeout(function() {
          var inputRef = [startInputRef, endInputRef][index2];
          if (inputRef.value) {
            inputRef.value.focus();
          }
        }, 0);
      }
      function triggerChange(newValue, sourceIndex) {
        var values = newValue;
        var startValue = getValue$2(values, 0);
        var endValue = getValue$2(values, 1);
        var generateConfig2 = props3.generateConfig, locale2 = props3.locale, picker = props3.picker, order = props3.order, onCalendarChange = props3.onCalendarChange, allowEmpty = props3.allowEmpty, onChange3 = props3.onChange, showTime = props3.showTime;
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || picker !== "week" && picker !== "quarter" && picker !== "time" && !(showTime ? isEqual(generateConfig2, startValue, endValue) : isSameDate(generateConfig2, startValue, endValue))) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
            openRecordsRef.value = _defineProperty$U({}, sourceIndex, true);
          } else if (picker !== "time" || order !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        var startStr2 = values && values[0] ? formatValue(values[0], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        var endStr2 = values && values[1] ? formatValue(values[1], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList.value[0]
        }) : "";
        if (onCalendarChange) {
          var info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], info);
        }
        var canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled.value, allowEmpty);
        var canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled.value, allowEmpty);
        var canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
        if (canTrigger) {
          setInnerValue(values);
          if (onChange3 && (!isEqual(generateConfig2, getValue$2(mergedValue.value, 0), startValue) || !isEqual(generateConfig2, getValue$2(mergedValue.value, 1), endValue))) {
            onChange3(values, [startStr2, endStr2]);
          }
        }
        var nextOpenIndex = null;
        if (sourceIndex === 0 && !mergedDisabled.value[1]) {
          nextOpenIndex = 1;
        } else if (sourceIndex === 1 && !mergedDisabled.value[0]) {
          nextOpenIndex = 0;
        }
        if (nextOpenIndex !== null && nextOpenIndex !== mergedActivePickerIndex.value && (!openRecordsRef.value[nextOpenIndex] || !getValue$2(values, nextOpenIndex)) && getValue$2(values, sourceIndex)) {
          triggerOpenAndFocus(nextOpenIndex);
        } else {
          _triggerOpen(false, sourceIndex);
        }
      }
      var forwardKeydown = function forwardKeydown2(e2) {
        if (mergedOpen && operationRef.value && operationRef.value.onKeydown) {
          return operationRef.value.onKeydown(e2);
        }
        {
          return false;
        }
      };
      var sharedTextHooksProps = {
        formatList,
        generateConfig: toRef(props3, "generateConfig"),
        locale: toRef(props3, "locale")
      };
      var _useValueTexts = useValueTexts(computed(function() {
        return getValue$2(selectedValue.value, 0);
      }), sharedTextHooksProps), _useValueTexts2 = _slicedToArray$2(_useValueTexts, 2), startValueTexts = _useValueTexts2[0], firstStartValueText = _useValueTexts2[1];
      var _useValueTexts3 = useValueTexts(computed(function() {
        return getValue$2(selectedValue.value, 1);
      }), sharedTextHooksProps), _useValueTexts4 = _slicedToArray$2(_useValueTexts3, 2), endValueTexts = _useValueTexts4[0], firstEndValueText = _useValueTexts4[1];
      var _onTextChange = function onTextChange(newText, index2) {
        var inputDate = parseValue(newText, {
          locale: props3.locale,
          formatList: formatList.value,
          generateConfig: props3.generateConfig
        });
        var disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue.value, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      var _useTextValueMapping = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 0);
        }
      }), _useTextValueMapping2 = _slicedToArray$2(_useTextValueMapping, 3), startText = _useTextValueMapping2[0], triggerStartTextChange = _useTextValueMapping2[1], resetStartText = _useTextValueMapping2[2];
      var _useTextValueMapping3 = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 1);
        }
      }), _useTextValueMapping4 = _slicedToArray$2(_useTextValueMapping3, 3), endText = _useTextValueMapping4[0], triggerEndTextChange = _useTextValueMapping4[1], resetEndText = _useTextValueMapping4[2];
      var _useState = useState(null), _useState2 = _slicedToArray$2(_useState, 2), rangeHoverValue = _useState2[0], setRangeHoverValue = _useState2[1];
      var _useState3 = useState(null), _useState4 = _slicedToArray$2(_useState3, 2), hoverRangedValue = _useState4[0], setHoverRangedValue = _useState4[1];
      var _useHoverValue = useHoverValue(startText, sharedTextHooksProps), _useHoverValue2 = _slicedToArray$2(_useHoverValue, 3), startHoverValue = _useHoverValue2[0], onStartEnter = _useHoverValue2[1], onStartLeave = _useHoverValue2[2];
      var _useHoverValue3 = useHoverValue(endText, sharedTextHooksProps), _useHoverValue4 = _slicedToArray$2(_useHoverValue3, 3), endHoverValue = _useHoverValue4[0], onEndEnter = _useHoverValue4[1], onEndLeave = _useHoverValue4[2];
      var onDateMouseenter = function onDateMouseenter2(date4) {
        setHoverRangedValue(updateValues(selectedValue.value, date4, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartEnter(date4);
        } else {
          onEndEnter(date4);
        }
      };
      var onDateMouseleave = function onDateMouseleave2() {
        setHoverRangedValue(updateValues(selectedValue.value, null, mergedActivePickerIndex.value));
        if (mergedActivePickerIndex.value === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      var getSharedInputHookProps = function getSharedInputHookProps2(index2, resetText) {
        return {
          forwardKeydown,
          onBlur: function onBlur2(e2) {
            var _props$onBlur;
            (_props$onBlur = props3.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props3, e2);
          },
          isClickOutside: function isClickOutside(target) {
            return !elementsContains([panelDivRef.value, startInputDivRef.value, endInputDivRef.value, containerRef.value], target);
          },
          onFocus: function onFocus2(e2) {
            var _props$onFocus;
            setMergedActivePickerIndex(index2);
            (_props$onFocus = props3.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props3, e2);
          },
          triggerOpen: function triggerOpen(newOpen) {
            _triggerOpen(newOpen, index2);
          },
          onSubmit: function onSubmit() {
            if (!selectedValue.value || props3.disabledDate && props3.disabledDate(selectedValue.value[index2])) {
              return false;
            }
            triggerChange(selectedValue.value, index2);
            resetText();
          },
          onCancel: function onCancel() {
            _triggerOpen(false, index2);
            setSelectedValue(mergedValue.value);
            resetText();
          }
        };
      };
      var _usePickerInput = usePickerInput(_objectSpread2$1(_objectSpread2$1({}, getSharedInputHookProps(0, resetStartText)), {}, {
        blurToCancel: needConfirmButton,
        open: startOpen,
        value: startText,
        onKeydown: function onKeydown(e2, preventDefault) {
          var _props$onKeydown;
          (_props$onKeydown = props3.onKeydown) === null || _props$onKeydown === void 0 ? void 0 : _props$onKeydown.call(props3, e2, preventDefault);
        }
      })), _usePickerInput2 = _slicedToArray$2(_usePickerInput, 2), startInputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], startFocused = _usePickerInput2$.focused, startTyping = _usePickerInput2$.typing;
      var _usePickerInput3 = usePickerInput(_objectSpread2$1(_objectSpread2$1({}, getSharedInputHookProps(1, resetEndText)), {}, {
        blurToCancel: needConfirmButton,
        open: endOpen,
        value: endText,
        onKeydown: function onKeydown(e2, preventDefault) {
          var _props$onKeydown2;
          (_props$onKeydown2 = props3.onKeydown) === null || _props$onKeydown2 === void 0 ? void 0 : _props$onKeydown2.call(props3, e2, preventDefault);
        }
      })), _usePickerInput4 = _slicedToArray$2(_usePickerInput3, 2), endInputProps = _usePickerInput4[0], _usePickerInput4$ = _usePickerInput4[1], endFocused = _usePickerInput4$.focused, endTyping = _usePickerInput4$.typing;
      var onPickerClick = function onPickerClick2(e2) {
        var _props$onClick;
        (_props$onClick = props3.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props3, e2);
        if (!mergedOpen.value && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          if (!mergedDisabled.value[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled.value[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      var onPickerMousedown = function onPickerMousedown2(e2) {
        var _props$onMousedown;
        (_props$onMousedown = props3.onMousedown) === null || _props$onMousedown === void 0 ? void 0 : _props$onMousedown.call(props3, e2);
        if (mergedOpen.value && (startFocused.value || endFocused.value) && !startInputRef.value.contains(e2.target) && !endInputRef.value.contains(e2.target)) {
          e2.preventDefault();
        }
      };
      var startStr = computed(function() {
        var _mergedValue$value;
        return (_mergedValue$value = mergedValue.value) !== null && _mergedValue$value !== void 0 && _mergedValue$value[0] ? formatValue(mergedValue.value[0], {
          locale: props3.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props3.generateConfig
        }) : "";
      });
      var endStr = computed(function() {
        var _mergedValue$value2;
        return (_mergedValue$value2 = mergedValue.value) !== null && _mergedValue$value2 !== void 0 && _mergedValue$value2[1] ? formatValue(mergedValue.value[1], {
          locale: props3.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: props3.generateConfig
        }) : "";
      });
      watch([mergedOpen, startValueTexts, endValueTexts], function() {
        if (!mergedOpen.value) {
          setSelectedValue(mergedValue.value);
          if (!startValueTexts.value.length || startValueTexts.value[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText.value !== startText.value) {
            resetStartText();
          }
          if (!endValueTexts.value.length || endValueTexts.value[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText.value !== endText.value) {
            resetEndText();
          }
        }
      });
      watch([startStr, endStr], function() {
        setSelectedValue(mergedValue.value);
      });
      expose({
        focus: function focus() {
          if (startInputRef.value) {
            startInputRef.value.focus();
          }
        },
        blur: function blur() {
          if (startInputRef.value) {
            startInputRef.value.blur();
          }
          if (endInputRef.value) {
            endInputRef.value.blur();
          }
        }
      });
      var rangeList = computed(function() {
        return Object.keys(props3.ranges || {}).map(function(label) {
          var range3 = props3.ranges[label];
          var newValues = typeof range3 === "function" ? range3() : range3;
          return {
            label,
            onClick: function onClick2() {
              triggerChange(newValues, null);
              _triggerOpen(false, mergedActivePickerIndex.value);
            },
            onMouseenter: function onMouseenter2() {
              setRangeHoverValue(newValues);
            },
            onMouseleave: function onMouseleave2() {
              setRangeHoverValue(null);
            }
          };
        });
      });
      var panelHoverRangedValue = computed(function() {
        if (mergedOpen.value && hoverRangedValue.value && hoverRangedValue.value[0] && hoverRangedValue.value[1] && props3.generateConfig.isAfter(hoverRangedValue.value[1], hoverRangedValue.value[0])) {
          return hoverRangedValue.value;
        } else {
          return null;
        }
      });
      function renderPanel() {
        var panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var generateConfig2 = props3.generateConfig, showTime = props3.showTime, dateRender = props3.dateRender, direction = props3.direction, _disabledTime = props3.disabledTime, prefixCls = props3.prefixCls, locale2 = props3.locale;
        var panelShowTime = showTime;
        if (showTime && _typeof$3(showTime) === "object" && showTime.defaultValue) {
          var timeDefaultValues = showTime.defaultValue;
          panelShowTime = _objectSpread2$1(_objectSpread2$1({}, showTime), {}, {
            defaultValue: getValue$2(timeDefaultValues, mergedActivePickerIndex.value) || void 0
          });
        }
        var panelDateRender = null;
        if (dateRender) {
          panelDateRender = function panelDateRender2(_ref2) {
            var date4 = _ref2.current, today = _ref2.today;
            return dateRender({
              current: date4,
              today,
              info: {
                range: mergedActivePickerIndex.value ? "end" : "start"
              }
            });
          };
        }
        return createVNode(RangeContextProvider, {
          "value": {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue.value || selectedValue.value,
            hoverRangedValue: panelHoverRangedValue.value
          }
        }, {
          default: function _default9() {
            return [createVNode(PickerPanel$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), panelProps), {}, {
              "dateRender": panelDateRender,
              "showTime": panelShowTime,
              "mode": mergedModes.value[mergedActivePickerIndex.value],
              "generateConfig": generateConfig2,
              "style": void 0,
              "direction": direction,
              "disabledDate": mergedActivePickerIndex.value === 0 ? disabledStartDate : disabledEndDate,
              "disabledTime": function disabledTime(date4) {
                if (_disabledTime) {
                  return _disabledTime(date4, mergedActivePickerIndex.value === 0 ? "start" : "end");
                }
                return false;
              },
              "class": classNames(_defineProperty$U({}, "".concat(prefixCls, "-panel-focused"), mergedActivePickerIndex.value === 0 ? !startTyping.value : !endTyping.value)),
              "value": getValue$2(selectedValue.value, mergedActivePickerIndex.value),
              "locale": locale2,
              "tabIndex": -1,
              "onPanelChange": function onPanelChange(date4, newMode) {
                if (mergedActivePickerIndex.value === 0) {
                  onStartLeave(true);
                }
                if (mergedActivePickerIndex.value === 1) {
                  onEndLeave(true);
                }
                triggerModesChange(updateValues(mergedModes.value, newMode, mergedActivePickerIndex.value), updateValues(selectedValue.value, date4, mergedActivePickerIndex.value));
                var viewDate = date4;
                if (panelPosition === "right" && mergedModes.value[mergedActivePickerIndex.value] === newMode) {
                  viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
                }
                setViewDate(viewDate, mergedActivePickerIndex.value);
              },
              "onOk": null,
              "onSelect": void 0,
              "onChange": void 0,
              "defaultValue": mergedActivePickerIndex.value === 0 ? getValue$2(selectedValue.value, 1) : getValue$2(selectedValue.value, 0)
            }), null)];
          }
        });
      }
      var onContextSelect = function onContextSelect2(date4, type4) {
        var values = updateValues(selectedValue.value, date4, mergedActivePickerIndex.value);
        if (type4 === "submit" || type4 !== "key" && !needConfirmButton.value) {
          triggerChange(values, mergedActivePickerIndex.value);
          if (mergedActivePickerIndex.value === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
        } else {
          setSelectedValue(values);
        }
      };
      useProvidePanel({
        operationRef,
        hideHeader: computed(function() {
          return props3.picker === "time";
        }),
        onDateMouseenter,
        onDateMouseleave,
        hideRanges: computed(function() {
          return true;
        }),
        onSelect: onContextSelect,
        open: mergedOpen
      });
      return function() {
        var _classNames2, _classNames3, _classNames4;
        var _props$prefixCls = props3.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, id = props3.id, popupStyle = props3.popupStyle, dropdownClassName = props3.dropdownClassName, transitionName2 = props3.transitionName, dropdownAlign = props3.dropdownAlign, getPopupContainer = props3.getPopupContainer, generateConfig2 = props3.generateConfig, locale2 = props3.locale, placeholder = props3.placeholder, autofocus = props3.autofocus, _props$picker = props3.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props3.showTime, _props$separator = props3.separator, separator = _props$separator === void 0 ? "~" : _props$separator, disabledDate = props3.disabledDate, panelRender = props3.panelRender, allowClear = props3.allowClear, suffixIcon = props3.suffixIcon, clearIcon = props3.clearIcon, inputReadOnly = props3.inputReadOnly, renderExtraFooter = props3.renderExtraFooter, onMouseenter2 = props3.onMouseenter, onMouseleave2 = props3.onMouseleave, onMouseup = props3.onMouseup, _onOk = props3.onOk, components2 = props3.components, direction = props3.direction, _props$autocomplete = props3.autocomplete, autocomplete = _props$autocomplete === void 0 ? "off" : _props$autocomplete;
        var arrowPositionStyle = direction === "rtl" ? {
          right: "".concat(arrowLeft.value, "px")
        } : {
          left: "".concat(arrowLeft.value, "px")
        };
        function renderPanels() {
          var panels;
          var extraNode = getExtraFooter(prefixCls, mergedModes.value[mergedActivePickerIndex.value], renderExtraFooter);
          var rangesNode = getRanges({
            prefixCls,
            components: components2,
            needConfirmButton: needConfirmButton.value,
            okDisabled: !getValue$2(selectedValue.value, mergedActivePickerIndex.value) || disabledDate && disabledDate(selectedValue.value[mergedActivePickerIndex.value]),
            locale: locale2,
            rangeList: rangeList.value,
            onOk: function onOk() {
              if (getValue$2(selectedValue.value, mergedActivePickerIndex.value)) {
                triggerChange(selectedValue.value, mergedActivePickerIndex.value);
                if (_onOk) {
                  _onOk(selectedValue.value);
                }
              }
            }
          });
          if (picker !== "time" && !showTime) {
            var viewDate = mergedActivePickerIndex.value === 0 ? startViewDate.value : endViewDate.value;
            var nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
            var currentMode = mergedModes.value[mergedActivePickerIndex.value];
            var showDoublePanel = currentMode === picker;
            var leftPanel = renderPanel(showDoublePanel ? "left" : false, {
              pickerValue: viewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(newViewDate, mergedActivePickerIndex.value);
              }
            });
            var rightPanel = renderPanel("right", {
              pickerValue: nextViewDate,
              onPickerValueChange: function onPickerValueChange(newViewDate) {
                setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex.value);
              }
            });
            if (direction === "rtl") {
              panels = createVNode(Fragment, null, [rightPanel, showDoublePanel && leftPanel]);
            } else {
              panels = createVNode(Fragment, null, [leftPanel, showDoublePanel && rightPanel]);
            }
          } else {
            panels = renderPanel();
          }
          var mergedNodes = createVNode(Fragment, null, [createVNode("div", {
            "class": "".concat(prefixCls, "-panels")
          }, [panels]), (extraNode || rangesNode) && createVNode("div", {
            "class": "".concat(prefixCls, "-footer")
          }, [extraNode, rangesNode])]);
          if (panelRender) {
            mergedNodes = panelRender(mergedNodes);
          }
          return createVNode("div", {
            "class": "".concat(prefixCls, "-panel-container"),
            "style": {
              marginLeft: "".concat(panelLeft.value, "px")
            },
            "ref": panelDivRef,
            "onMousedown": function onMousedown2(e2) {
              e2.preventDefault();
            }
          }, [mergedNodes]);
        }
        var rangePanel = createVNode("div", {
          "class": classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper")),
          "style": {
            minWidth: "".concat(popupMinWidth.value, "px")
          }
        }, [createVNode("div", {
          "ref": arrowRef,
          "class": "".concat(prefixCls, "-range-arrow"),
          "style": arrowPositionStyle
        }, null), renderPanels()]);
        var suffixNode;
        if (suffixIcon) {
          suffixNode = createVNode("span", {
            "class": "".concat(prefixCls, "-suffix")
          }, [suffixIcon]);
        }
        var clearNode;
        if (allowClear && (getValue$2(mergedValue.value, 0) && !mergedDisabled.value[0] || getValue$2(mergedValue.value, 1) && !mergedDisabled.value[1])) {
          clearNode = createVNode("span", {
            "onMousedown": function onMousedown2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
            },
            "onMouseup": function onMouseup2(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              var values = mergedValue.value;
              if (!mergedDisabled.value[0]) {
                values = updateValues(values, null, 0);
              }
              if (!mergedDisabled.value[1]) {
                values = updateValues(values, null, 1);
              }
              triggerChange(values, null);
              _triggerOpen(false, mergedActivePickerIndex.value);
            },
            "class": "".concat(prefixCls, "-clear")
          }, [clearIcon || createVNode("span", {
            "class": "".concat(prefixCls, "-clear-btn")
          }, null)]);
        }
        var inputSharedProps = {
          size: getInputSize(picker, formatList.value[0], generateConfig2)
        };
        var activeBarLeft = 0;
        var activeBarWidth = 0;
        if (startInputDivRef.value && endInputDivRef.value && separatorRef.value) {
          if (mergedActivePickerIndex.value === 0) {
            activeBarWidth = startInputDivRef.value.offsetWidth;
          } else {
            activeBarLeft = arrowLeft.value;
            activeBarWidth = endInputDivRef.value.offsetWidth;
          }
        }
        var activeBarPositionStyle = direction === "rtl" ? {
          right: "".concat(activeBarLeft, "px")
        } : {
          left: "".concat(activeBarLeft, "px")
        };
        return createVNode(PickerTrigger, {
          "visible": mergedOpen.value,
          "popupStyle": popupStyle,
          "prefixCls": prefixCls,
          "dropdownClassName": dropdownClassName,
          "dropdownAlign": dropdownAlign,
          "getPopupContainer": getPopupContainer,
          "transitionName": transitionName2,
          "range": true,
          "direction": direction
        }, {
          default: function _default9() {
            return [createVNode("div", _objectSpread2$1({
              "ref": containerRef,
              "class": classNames(prefixCls, "".concat(prefixCls, "-range"), attrs.class, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled.value[0] && mergedDisabled.value[1]), _defineProperty$U(_classNames2, "".concat(prefixCls, "-focused"), mergedActivePickerIndex.value === 0 ? startFocused.value : endFocused.value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
              "style": attrs.style,
              "onClick": onPickerClick,
              "onMouseenter": onMouseenter2,
              "onMouseleave": onMouseleave2,
              "onMousedown": onPickerMousedown,
              "onMouseup": onMouseup
            }, getDataOrAriaProps(props3)), [createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), (_classNames3 = {}, _defineProperty$U(_classNames3, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex.value === 0), _defineProperty$U(_classNames3, "".concat(prefixCls, "-input-placeholder"), !!startHoverValue.value), _classNames3)),
              "ref": startInputDivRef
            }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "id": id,
              "disabled": mergedDisabled.value[0],
              "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !startTyping.value,
              "value": startHoverValue.value || startText.value,
              "onInput": function onInput(e2) {
                triggerStartTextChange(e2.target.value);
              },
              "autofocus": autofocus,
              "placeholder": getValue$2(placeholder, 0) || "",
              "ref": startInputRef
            }, startInputProps.value), inputSharedProps), {}, {
              "autocomplete": autocomplete
            }), null)]), createVNode("div", {
              "class": "".concat(prefixCls, "-range-separator"),
              "ref": separatorRef
            }, [separator]), createVNode("div", {
              "class": classNames("".concat(prefixCls, "-input"), (_classNames4 = {}, _defineProperty$U(_classNames4, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex.value === 1), _defineProperty$U(_classNames4, "".concat(prefixCls, "-input-placeholder"), !!endHoverValue.value), _classNames4)),
              "ref": endInputDivRef
            }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "disabled": mergedDisabled.value[1],
              "readonly": inputReadOnly || typeof formatList.value[0] === "function" || !endTyping.value,
              "value": endHoverValue.value || endText.value,
              "onInput": function onInput(e2) {
                triggerEndTextChange(e2.target.value);
              },
              "placeholder": getValue$2(placeholder, 1) || "",
              "ref": endInputRef
            }, endInputProps.value), inputSharedProps), {}, {
              "autocomplete": autocomplete
            }), null)]), createVNode("div", {
              "class": "".concat(prefixCls, "-active-bar"),
              "style": _objectSpread2$1(_objectSpread2$1({}, activeBarPositionStyle), {}, {
                width: "".concat(activeBarWidth, "px"),
                position: "absolute"
              })
            }, null), suffixNode, clearNode, getPortal()])];
          },
          popupElement: function popupElement() {
            return rangePanel;
          }
        });
      };
    }
  });
}
var InterRangerPicker = RangerPicker();
const VCRangePicker = InterRangerPicker;
var _excluded$K = ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"];
var checkboxProps$1 = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: PropTypes$1.any,
  required: Boolean
};
const VcCheckbox = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: false,
  props: initDefaultProps$1(checkboxProps$1, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: false
  }),
  emits: ["click", "change"],
  setup: function setup67(props3, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var checked = ref(props3.checked === void 0 ? props3.defaultChecked : props3.checked);
    var inputRef = ref();
    watch(function() {
      return props3.checked;
    }, function() {
      checked.value = props3.checked;
    });
    expose({
      focus: function focus() {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();
      },
      blur: function blur() {
        var _inputRef$value2;
        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.blur();
      }
    });
    var eventShiftKey = ref();
    var handleChange2 = function handleChange3(e2) {
      if (props3.disabled) {
        return;
      }
      if (props3.checked === void 0) {
        checked.value = e2.target.checked;
      }
      e2.shiftKey = eventShiftKey.value;
      var eventObj = {
        target: _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
          checked: e2.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e2.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e2.preventDefault();
        },
        nativeEvent: e2
      };
      if (props3.checked !== void 0) {
        inputRef.value.checked = !!props3.checked;
      }
      emit("change", eventObj);
      eventShiftKey.value = false;
    };
    var onClick2 = function onClick3(e2) {
      emit("click", e2);
      eventShiftKey.value = e2.shiftKey;
    };
    return function() {
      var _classNames;
      var prefixCls = props3.prefixCls, name2 = props3.name, id = props3.id, type4 = props3.type, disabled = props3.disabled, readonly2 = props3.readonly, tabindex = props3.tabindex, autofocus = props3.autofocus, value = props3.value, required4 = props3.required, others = _objectWithoutProperties$2(props3, _excluded$K);
      var className = attrs.class, onFocus2 = attrs.onFocus, onBlur2 = attrs.onBlur, onKeydown = attrs.onKeydown, onKeypress = attrs.onKeypress, onKeyup = attrs.onKeyup;
      var othersAndAttrs = _objectSpread2$1(_objectSpread2$1({}, others), attrs);
      var globalProps = Object.keys(othersAndAttrs).reduce(function(prev2, key2) {
        if (key2.substr(0, 5) === "aria-" || key2.substr(0, 5) === "data-" || key2 === "role") {
          prev2[key2] = othersAndAttrs[key2];
        }
        return prev2;
      }, {});
      var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-checked"), checked.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      var inputProps3 = _objectSpread2$1(_objectSpread2$1({
        name: name2,
        id,
        type: type4,
        readonly: readonly2,
        disabled,
        tabindex,
        class: "".concat(prefixCls, "-input"),
        checked: !!checked.value,
        autofocus,
        value
      }, globalProps), {}, {
        onChange: handleChange2,
        onClick: onClick2,
        onFocus: onFocus2,
        onBlur: onBlur2,
        onKeydown,
        onKeypress,
        onKeyup,
        required: required4
      });
      return createVNode("span", {
        "class": classString
      }, [createVNode("input", _objectSpread2$1({
        "ref": inputRef
      }, inputProps3), null), createVNode("span", {
        "class": "".concat(prefixCls, "-inner")
      }, null)]);
    };
  }
});
var _excluded$J = ["prefixCls", "id"];
var radioProps = function radioProps2() {
  return {
    prefixCls: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onFocus: Function,
    onBlur: Function,
    onClick: Function,
    "onUpdate:checked": Function,
    "onUpdate:value": Function
  };
};
const Radio = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  props: radioProps(),
  setup: function setup68(props3, _ref) {
    var emit = _ref.emit, expose = _ref.expose, slots = _ref.slots;
    var formItemContext = useInjectFormItemContext();
    var vcCheckbox = ref();
    var radioGroupContext = inject("radioGroupContext", void 0);
    var _useConfigInject = useConfigInject("radio", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var focus = function focus2() {
      vcCheckbox.value.focus();
    };
    var blur = function blur2() {
      vcCheckbox.value.blur();
    };
    expose({
      focus,
      blur
    });
    var handleChange2 = function handleChange3(event2) {
      var targetChecked = event2.target.checked;
      emit("update:checked", targetChecked);
      emit("update:value", targetChecked);
      emit("change", event2);
      formItemContext.onFieldChange();
    };
    var onChange3 = function onChange4(e2) {
      emit("change", e2);
      if (radioGroupContext && radioGroupContext.onRadioChange) {
        radioGroupContext.onRadioChange(e2);
      }
    };
    return function() {
      var _classNames;
      var radioGroup = radioGroupContext;
      props3.prefixCls;
      var _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = _objectWithoutProperties$2(props3, _excluded$J);
      var rProps = _objectSpread2$1({
        prefixCls: prefixCls.value,
        id
      }, omit$2(restProps, ["onUpdate:checked", "onUpdate:value"]));
      if (radioGroup) {
        rProps.name = radioGroup.props.name;
        rProps.onChange = onChange3;
        rProps.checked = props3.value === radioGroup.stateValue.value;
        rProps.disabled = props3.disabled || radioGroup.props.disabled;
      } else {
        rProps.onChange = handleChange2;
      }
      var wrapperClassString = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper"), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper-checked"), rProps.checked), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper-disabled"), rProps.disabled), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper-rtl"), direction.value === "rtl"), _classNames));
      return createVNode("label", {
        "class": wrapperClassString
      }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, rProps), {}, {
        "type": "radio",
        "ref": vcCheckbox
      }), null), slots.default && createVNode("span", null, [slots.default()])]);
    };
  }
});
var RadioGroupSizeTypes = tuple$1("large", "default", "small");
var radioGroupProps = function radioGroupProps2() {
  return {
    prefixCls: String,
    value: PropTypes$1.any,
    size: PropTypes$1.oneOf(RadioGroupSizeTypes),
    options: {
      type: Array
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    name: String,
    buttonStyle: {
      type: String,
      default: "outline"
    },
    id: String,
    optionType: {
      type: String,
      default: "default"
    },
    onChange: Function,
    "onUpdate:value": Function
  };
};
const Group$3 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  props: radioGroupProps(),
  setup: function setup69(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("radio", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size2 = _useConfigInject.size;
    var stateValue = ref(props3.value);
    var updatingValue = ref(false);
    watch(function() {
      return props3.value;
    }, function(val) {
      stateValue.value = val;
      updatingValue.value = false;
    });
    var onRadioChange = function onRadioChange2(ev) {
      var lastValue = stateValue.value;
      var value = ev.target.value;
      if (!("value" in props3)) {
        stateValue.value = value;
      }
      if (!updatingValue.value && value !== lastValue) {
        updatingValue.value = true;
        emit("update:value", value);
        emit("change", ev);
        formItemContext.onFieldChange();
      }
      nextTick(function() {
        updatingValue.value = false;
      });
    };
    provide("radioGroupContext", {
      onRadioChange,
      stateValue,
      props: props3
    });
    return function() {
      var _classNames;
      var options = props3.options, optionType = props3.optionType, buttonStyle = props3.buttonStyle, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var groupPrefixCls = "".concat(prefixCls.value, "-group");
      var classString = classNames(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), (_classNames = {}, _defineProperty$U(_classNames, "".concat(groupPrefixCls, "-").concat(size2.value), size2.value), _defineProperty$U(_classNames, "".concat(groupPrefixCls, "-rtl"), direction.value === "rtl"), _classNames));
      var children = null;
      if (options && options.length > 0) {
        var optionsPrefixCls = optionType === "button" ? "".concat(prefixCls.value, "-button") : prefixCls.value;
        children = options.map(function(option) {
          if (typeof option === "string" || typeof option === "number") {
            return createVNode(Radio, {
              "key": option,
              "prefixCls": optionsPrefixCls,
              "disabled": props3.disabled,
              "value": option,
              "checked": stateValue.value === option
            }, {
              default: function _default9() {
                return [option];
              }
            });
          }
          var value = option.value, disabled = option.disabled, label = option.label;
          return createVNode(Radio, {
            "key": "radio-group-value-options-".concat(value),
            "prefixCls": optionsPrefixCls,
            "disabled": disabled || props3.disabled,
            "value": value,
            "checked": stateValue.value === value
          }, {
            default: function _default9() {
              return [label];
            }
          });
        });
      } else {
        var _slots$default;
        children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }
      return createVNode("div", {
        "class": classString,
        "id": id
      }, [children]);
    };
  }
});
const Button = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  props: radioProps(),
  setup: function setup70(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("radio-button", props3), prefixCls = _useConfigInject.prefixCls;
    var radioGroupContext = inject("radioGroupContext", void 0);
    return function() {
      var _slots$default;
      var rProps = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        prefixCls: prefixCls.value
      });
      if (radioGroupContext) {
        rProps.onChange = radioGroupContext.onRadioChange;
        rProps.checked = rProps.value === radioGroupContext.stateValue.value;
        rProps.disabled = rProps.disabled || radioGroupContext.props.disabled;
      }
      return createVNode(Radio, rProps, {
        default: function _default9() {
          return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
        }
      });
    };
  }
});
Radio.Group = Group$3;
Radio.Button = Button;
Radio.install = function(app) {
  app.component(Radio.name, Radio);
  app.component(Radio.Group.name, Radio.Group);
  app.component(Radio.Button.name, Radio.Button);
  return app;
};
var YearSelectOffset = 10;
var YearSelectTotal = 20;
function YearSelect(props3) {
  var fullscreen = props3.fullscreen, validRange = props3.validRange, generateConfig2 = props3.generateConfig, locale2 = props3.locale, prefixCls = props3.prefixCls, value = props3.value, _onChange = props3.onChange, divRef = props3.divRef;
  var year = generateConfig2.getYear(value || generateConfig2.getNow());
  var start = year - YearSelectOffset;
  var end = start + YearSelectTotal;
  if (validRange) {
    start = generateConfig2.getYear(validRange[0]);
    end = generateConfig2.getYear(validRange[1]) + 1;
  }
  var suffix = locale2 && locale2.year === "\u5E74" ? "\u5E74" : "";
  var options = [];
  for (var index2 = start; index2 < end; index2++) {
    options.push({
      label: "".concat(index2).concat(suffix),
      value: index2
    });
  }
  return createVNode(VcSelect, {
    "size": fullscreen ? void 0 : "small",
    "options": options,
    "value": year,
    "class": "".concat(prefixCls, "-year-select"),
    "onChange": function onChange3(numYear) {
      var newDate = generateConfig2.setYear(value, numYear);
      if (validRange) {
        var _validRange = _slicedToArray$2(validRange, 2), startDate = _validRange[0], endDate = _validRange[1];
        var newYear = generateConfig2.getYear(newDate);
        var newMonth = generateConfig2.getMonth(newDate);
        if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
        }
        if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
          newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
        }
      }
      _onChange(newDate);
    },
    "getPopupContainer": function getPopupContainer() {
      return divRef.value;
    }
  }, null);
}
YearSelect.inheritAttrs = false;
function MonthSelect(props3) {
  var prefixCls = props3.prefixCls, fullscreen = props3.fullscreen, validRange = props3.validRange, value = props3.value, generateConfig2 = props3.generateConfig, locale2 = props3.locale, _onChange2 = props3.onChange, divRef = props3.divRef;
  var month = generateConfig2.getMonth(value || generateConfig2.getNow());
  var start = 0;
  var end = 11;
  if (validRange) {
    var _validRange2 = _slicedToArray$2(validRange, 2), rangeStart = _validRange2[0], rangeEnd = _validRange2[1];
    var currentYear = generateConfig2.getYear(value);
    if (generateConfig2.getYear(rangeEnd) === currentYear) {
      end = generateConfig2.getMonth(rangeEnd);
    }
    if (generateConfig2.getYear(rangeStart) === currentYear) {
      start = generateConfig2.getMonth(rangeStart);
    }
  }
  var months = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
  var options = [];
  for (var index2 = start; index2 <= end; index2 += 1) {
    options.push({
      label: months[index2],
      value: index2
    });
  }
  return createVNode(VcSelect, {
    "size": fullscreen ? void 0 : "small",
    "class": "".concat(prefixCls, "-month-select"),
    "value": month,
    "options": options,
    "onChange": function onChange3(newMonth) {
      _onChange2(generateConfig2.setMonth(value, newMonth));
    },
    "getPopupContainer": function getPopupContainer() {
      return divRef.value;
    }
  }, null);
}
MonthSelect.inheritAttrs = false;
function ModeSwitch(props3) {
  var prefixCls = props3.prefixCls, locale2 = props3.locale, mode = props3.mode, fullscreen = props3.fullscreen, onModeChange = props3.onModeChange;
  return createVNode(Group$3, {
    "onChange": function onChange3(_ref) {
      var value = _ref.target.value;
      onModeChange(value);
    },
    "value": mode,
    "size": fullscreen ? void 0 : "small",
    "class": "".concat(prefixCls, "-mode-switch")
  }, {
    default: function _default9() {
      return [createVNode(Button, {
        "value": "month"
      }, {
        default: function _default10() {
          return [locale2.month];
        }
      }), createVNode(Button, {
        "value": "year"
      }, {
        default: function _default10() {
          return [locale2.year];
        }
      })];
    }
  });
}
ModeSwitch.inheritAttrs = false;
const CalendarHeader = defineComponent({
  name: "CalendarHeader",
  inheritAttrs: false,
  props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
  setup: function setup71(_props, _ref2) {
    var attrs = _ref2.attrs;
    var divRef = ref(null);
    return function() {
      var props3 = _objectSpread2$1(_objectSpread2$1({}, _props), attrs);
      var prefixCls = props3.prefixCls, fullscreen = props3.fullscreen, mode = props3.mode, onChange3 = props3.onChange, onModeChange = props3.onModeChange;
      var sharedProps = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        onChange: onChange3,
        fullscreen,
        divRef
      });
      return createVNode("div", {
        "class": "".concat(prefixCls, "-header"),
        "ref": divRef
      }, [createVNode(YearSelect, sharedProps, null), mode === "month" && createVNode(MonthSelect, sharedProps, null), createVNode(ModeSwitch, _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
        "onModeChange": onModeChange
      }), null)]);
    };
  }
});
function generateCalendar(generateConfig2) {
  function isSameYear2(date1, date22) {
    return date1 && date22 && generateConfig2.getYear(date1) === generateConfig2.getYear(date22);
  }
  function isSameMonth2(date1, date22) {
    return isSameYear2(date1, date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22);
  }
  function isSameDate2(date1, date22) {
    return isSameMonth2(date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
  }
  var Calendar2 = defineComponent({
    name: "ACalendar",
    inheritAttrs: false,
    props: ["prefixCls", "locale", "validRange", "disabledDate", "dateFullCellRender", "dateCellRender", "monthFullCellRender", "monthCellRender", "headerRender", "value", "defaultValue", "mode", "fullscreen", "onChange", "onPanelChange", "onSelect", "valueFormat"],
    slots: ["dateFullCellRender", "dateCellRender", "monthFullCellRender", "monthCellRender", "headerRender"],
    setup: function setup219(props3, _ref) {
      var emit = _ref.emit, slots = _ref.slots, attrs = _ref.attrs;
      var _useConfigInject = useConfigInject("picker", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
      var calendarPrefixCls = computed(function() {
        return "".concat(prefixCls.value, "-calendar");
      });
      var maybeToString = function maybeToString2(date4) {
        return props3.valueFormat ? generateConfig2.toString(date4, props3.valueFormat) : date4;
      };
      var value = computed(function() {
        if (props3.value) {
          return props3.valueFormat ? generateConfig2.toDate(props3.value, props3.valueFormat) : props3.value;
        }
        return props3.value === "" ? void 0 : props3.value;
      });
      var defaultValue = computed(function() {
        if (props3.defaultValue) {
          return props3.valueFormat ? generateConfig2.toDate(props3.defaultValue, props3.valueFormat) : props3.defaultValue;
        }
        return props3.defaultValue === "" ? void 0 : props3.defaultValue;
      });
      var _useMergedState = useMergedState(function() {
        return value.value || generateConfig2.getNow();
      }, {
        defaultValue: defaultValue.value,
        value
      }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState("month", {
        value: toRef(props3, "mode")
      }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), mergedMode = _useMergedState4[0], setMergedMode = _useMergedState4[1];
      var panelMode = computed(function() {
        return mergedMode.value === "year" ? "month" : "date";
      });
      var mergedDisabledDate = computed(function() {
        return function(date4) {
          var _props$disabledDate;
          var notInRange = props3.validRange ? generateConfig2.isAfter(props3.validRange[0], date4) || generateConfig2.isAfter(date4, props3.validRange[1]) : false;
          return notInRange || !!((_props$disabledDate = props3.disabledDate) !== null && _props$disabledDate !== void 0 && _props$disabledDate.call(props3, date4));
        };
      });
      var triggerPanelChange = function triggerPanelChange2(date4, newMode) {
        emit("panelChange", maybeToString(date4), newMode);
      };
      var triggerChange = function triggerChange2(date4) {
        setMergedValue(date4);
        if (!isSameDate2(date4, mergedValue.value)) {
          if (panelMode.value === "date" && !isSameMonth2(date4, mergedValue.value) || panelMode.value === "month" && !isSameYear2(date4, mergedValue.value)) {
            triggerPanelChange(date4, mergedMode.value);
          }
          var val = maybeToString(date4);
          emit("update:value", val);
          emit("change", val);
        }
      };
      var triggerModeChange = function triggerModeChange2(newMode) {
        setMergedMode(newMode);
        triggerPanelChange(mergedValue.value, newMode);
      };
      var onInternalSelect = function onInternalSelect2(date4) {
        triggerChange(date4);
        emit("select", maybeToString(date4));
      };
      var defaultLocale2 = computed(function() {
        var locale2 = props3.locale;
        var result = _objectSpread2$1(_objectSpread2$1({}, enUS), locale2);
        result.lang = _objectSpread2$1(_objectSpread2$1({}, result.lang), (locale2 || {}).lang);
        return result;
      });
      var _useLocaleReceiver = useLocaleReceiver("Calendar", defaultLocale2), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), mergedLocale = _useLocaleReceiver2[0];
      return function() {
        var _classNames3;
        var today = generateConfig2.getNow();
        var _props$dateFullCellRe = props3.dateFullCellRender, dateFullCellRender = _props$dateFullCellRe === void 0 ? slots === null || slots === void 0 ? void 0 : slots.dateFullCellRender : _props$dateFullCellRe, _props$dateCellRender = props3.dateCellRender, dateCellRender = _props$dateCellRender === void 0 ? slots === null || slots === void 0 ? void 0 : slots.dateCellRender : _props$dateCellRender, _props$monthFullCellR = props3.monthFullCellRender, monthFullCellRender = _props$monthFullCellR === void 0 ? slots === null || slots === void 0 ? void 0 : slots.monthFullCellRender : _props$monthFullCellR, _props$monthCellRende = props3.monthCellRender, monthCellRender = _props$monthCellRende === void 0 ? slots === null || slots === void 0 ? void 0 : slots.monthCellRender : _props$monthCellRende, _props$headerRender = props3.headerRender, headerRender = _props$headerRender === void 0 ? slots === null || slots === void 0 ? void 0 : slots.headerRender : _props$headerRender, _props$fullscreen = props3.fullscreen, fullscreen = _props$fullscreen === void 0 ? true : _props$fullscreen, validRange = props3.validRange;
        var dateRender = function dateRender2(_ref2) {
          var date4 = _ref2.current;
          if (dateFullCellRender) {
            return dateFullCellRender({
              current: date4
            });
          }
          return createVNode("div", {
            "class": classNames("".concat(prefixCls.value, "-cell-inner"), "".concat(calendarPrefixCls.value, "-date"), _defineProperty$U({}, "".concat(calendarPrefixCls.value, "-date-today"), isSameDate2(today, date4)))
          }, [createVNode("div", {
            "class": "".concat(calendarPrefixCls.value, "-date-value")
          }, [padStart(String(generateConfig2.getDate(date4)), 2, "0")]), createVNode("div", {
            "class": "".concat(calendarPrefixCls.value, "-date-content")
          }, [dateCellRender && dateCellRender({
            current: date4
          })])]);
        };
        var monthRender = function monthRender2(_ref3, locale2) {
          var date4 = _ref3.current;
          if (monthFullCellRender) {
            return monthFullCellRender({
              current: date4
            });
          }
          var months = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
          return createVNode("div", {
            "class": classNames("".concat(prefixCls.value, "-cell-inner"), "".concat(calendarPrefixCls.value, "-date"), _defineProperty$U({}, "".concat(calendarPrefixCls.value, "-date-today"), isSameMonth2(today, date4)))
          }, [createVNode("div", {
            "class": "".concat(calendarPrefixCls.value, "-date-value")
          }, [months[generateConfig2.getMonth(date4)]]), createVNode("div", {
            "class": "".concat(calendarPrefixCls.value, "-date-content")
          }, [monthCellRender && monthCellRender({
            current: date4
          })])]);
        };
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(calendarPrefixCls.value, (_classNames3 = {}, _defineProperty$U(_classNames3, "".concat(calendarPrefixCls.value, "-full"), fullscreen), _defineProperty$U(_classNames3, "".concat(calendarPrefixCls.value, "-mini"), !fullscreen), _defineProperty$U(_classNames3, "".concat(calendarPrefixCls.value, "-rtl"), direction.value === "rtl"), _classNames3), attrs.class)
        }), [headerRender ? headerRender({
          value: mergedValue.value,
          type: mergedMode.value,
          onChange: onInternalSelect,
          onTypeChange: triggerModeChange
        }) : createVNode(CalendarHeader, {
          "prefixCls": calendarPrefixCls.value,
          "value": mergedValue.value,
          "generateConfig": generateConfig2,
          "mode": mergedMode.value,
          "fullscreen": fullscreen,
          "locale": mergedLocale.value.lang,
          "validRange": validRange,
          "onChange": onInternalSelect,
          "onModeChange": triggerModeChange
        }, null), createVNode(PickerPanel$1, {
          "value": mergedValue.value,
          "prefixCls": prefixCls.value,
          "locale": mergedLocale.value.lang,
          "generateConfig": generateConfig2,
          "dateRender": dateRender,
          "monthCellRender": function monthCellRender2(obj) {
            return monthRender(obj, mergedLocale.value.lang);
          },
          "onSelect": onInternalSelect,
          "mode": panelMode.value,
          "picker": panelMode.value,
          "disabledDate": mergedDisabledDate.value,
          "hideHeader": true
        }, null)]);
      };
    }
  });
  Calendar2.install = function(app) {
    app.component(Calendar2.name, Calendar2);
    return app;
  };
  return Calendar2;
}
var Calendar = generateCalendar(dayjsGenerateConfig);
const Calendar$1 = withInstall(Calendar);
function useRaf(callback) {
  var rafRef = ref();
  var removedRef = ref(false);
  function trigger2() {
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    if (!removedRef.value) {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = wrapperRaf(function() {
        callback.apply(void 0, args2);
      });
    }
  }
  onBeforeUnmount(function() {
    removedRef.value = true;
    wrapperRaf.cancel(rafRef.value);
  });
  return trigger2;
}
function useRafState(defaultState) {
  var batchRef = ref([]);
  var state = ref(typeof defaultState === "function" ? defaultState() : defaultState);
  var flushUpdate = useRaf(function() {
    var value = state.value;
    batchRef.value.forEach(function(callback) {
      value = callback(value);
    });
    batchRef.value = [];
    state.value = value;
  });
  function updater(callback) {
    batchRef.value.push(callback);
    flushUpdate();
  }
  return [state, updater];
}
const TabNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup: function setup72(props3, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var domRef = ref();
    function onInternalClick(e2) {
      var _props$tab;
      if ((_props$tab = props3.tab) !== null && _props$tab !== void 0 && _props$tab.disabled) {
        return;
      }
      props3.onClick(e2);
    }
    expose({
      domRef
    });
    function onRemoveTab(event2) {
      var _props$tab2;
      event2.preventDefault();
      event2.stopPropagation();
      props3.editable.onEdit("remove", {
        key: (_props$tab2 = props3.tab) === null || _props$tab2 === void 0 ? void 0 : _props$tab2.key,
        event: event2
      });
    }
    var removable = computed(function() {
      var _props$tab3;
      return props3.editable && props3.closable !== false && !((_props$tab3 = props3.tab) !== null && _props$tab3 !== void 0 && _props$tab3.disabled);
    });
    return function() {
      var _classNames, _editable$removeIcon;
      var prefixCls = props3.prefixCls, id = props3.id, active = props3.active, _props$tab4 = props3.tab, key2 = _props$tab4.key, tab = _props$tab4.tab, disabled = _props$tab4.disabled, closeIcon = _props$tab4.closeIcon, renderWrapper = props3.renderWrapper, removeAriaLabel = props3.removeAriaLabel, editable = props3.editable, onFocus2 = props3.onFocus;
      var tabPrefix = "".concat(prefixCls, "-tab");
      var node = createVNode("div", {
        "key": key2,
        "ref": domRef,
        "class": classNames(tabPrefix, (_classNames = {}, _defineProperty$U(_classNames, "".concat(tabPrefix, "-with-remove"), removable.value), _defineProperty$U(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$U(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
        "style": attrs.style,
        "onClick": onInternalClick
      }, [createVNode("div", {
        "role": "tab",
        "aria-selected": active,
        "id": id && "".concat(id, "-tab-").concat(key2),
        "class": "".concat(tabPrefix, "-btn"),
        "aria-controls": id && "".concat(id, "-panel-").concat(key2),
        "aria-disabled": disabled,
        "tabindex": disabled ? null : 0,
        "onClick": function onClick2(e2) {
          e2.stopPropagation();
          onInternalClick(e2);
        },
        "onKeydown": function onKeydown(e2) {
          if ([KeyCode$1.SPACE, KeyCode$1.ENTER].includes(e2.which)) {
            e2.preventDefault();
            onInternalClick(e2);
          }
        },
        "onFocus": onFocus2
      }, [typeof tab === "function" ? tab() : tab]), removable.value && createVNode("button", {
        "type": "button",
        "aria-label": removeAriaLabel || "remove",
        "tabindex": 0,
        "class": "".concat(tabPrefix, "-remove"),
        "onClick": function onClick2(e2) {
          e2.stopPropagation();
          onRemoveTab(e2);
        }
      }, [(closeIcon === null || closeIcon === void 0 ? void 0 : closeIcon()) || ((_editable$removeIcon = editable.removeIcon) === null || _editable$removeIcon === void 0 ? void 0 : _editable$removeIcon.call(editable)) || "\xD7"])]);
      return renderWrapper ? renderWrapper(node) : node;
    };
  }
});
var DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes) {
  var offsetMap = ref(/* @__PURE__ */ new Map());
  watchEffect(function() {
    var _tabsValue$;
    var map = /* @__PURE__ */ new Map();
    var tabsValue = tabs.value;
    var lastOffset = tabSizes.value.get((_tabsValue$ = tabsValue[0]) === null || _tabsValue$ === void 0 ? void 0 : _tabsValue$.key) || DEFAULT_SIZE$1;
    var rightOffset = lastOffset.left + lastOffset.width;
    for (var i2 = 0; i2 < tabsValue.length; i2 += 1) {
      var key2 = tabsValue[i2].key;
      var data9 = tabSizes.value.get(key2);
      if (!data9) {
        var _tabsValue;
        data9 = tabSizes.value.get((_tabsValue = tabsValue[i2 - 1]) === null || _tabsValue === void 0 ? void 0 : _tabsValue.key) || DEFAULT_SIZE$1;
      }
      var entity = map.get(key2) || _objectSpread2$1({}, data9);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key2, entity);
    }
    offsetMap.value = new Map(map);
  });
  return offsetMap;
}
const AddButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup73(props3, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var domRef = ref();
    expose({
      domRef
    });
    return function() {
      var prefixCls = props3.prefixCls, editable = props3.editable, locale2 = props3.locale;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return createVNode("button", {
        "ref": domRef,
        "type": "button",
        "class": "".concat(prefixCls, "-nav-add"),
        "style": attrs.style,
        "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
        "onClick": function onClick2(event2) {
          editable.onEdit("add", {
            event: event2
          });
        }
      }, [editable.addIcon ? editable.addIcon() : "+"]);
    };
  }
});
var operationNodeProps = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: PropTypes$1.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  }
};
const OperationNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: false,
  props: operationNodeProps,
  emits: ["tabClick"],
  slots: ["moreIcon"],
  setup: function setup74(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useState = useState(false), _useState2 = _slicedToArray$2(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
    var _useState3 = useState(null), _useState4 = _slicedToArray$2(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
    var selectOffset = function selectOffset2(offset3) {
      var enabledTabs = props3.tabs.filter(function(tab2) {
        return !tab2.disabled;
      });
      var selectedIndex = enabledTabs.findIndex(function(tab2) {
        return tab2.key === selectedKey.value;
      }) || 0;
      var len = enabledTabs.length;
      for (var i2 = 0; i2 < len; i2 += 1) {
        selectedIndex = (selectedIndex + offset3 + len) % len;
        var tab = enabledTabs[selectedIndex];
        if (!tab.disabled) {
          setSelectedKey(tab.key);
          return;
        }
      }
    };
    var onKeyDown = function onKeyDown2(e2) {
      var which = e2.which;
      if (!open2.value) {
        if ([KeyCode$1.DOWN, KeyCode$1.SPACE, KeyCode$1.ENTER].includes(which)) {
          setOpen(true);
          e2.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode$1.UP:
          selectOffset(-1);
          e2.preventDefault();
          break;
        case KeyCode$1.DOWN:
          selectOffset(1);
          e2.preventDefault();
          break;
        case KeyCode$1.ESC:
          setOpen(false);
          break;
        case KeyCode$1.SPACE:
        case KeyCode$1.ENTER:
          if (selectedKey.value !== null)
            props3.onTabClick(selectedKey.value, e2);
          break;
      }
    };
    var popupId = computed(function() {
      return "".concat(props3.id, "-more-popup");
    });
    var selectedItemId = computed(function() {
      return selectedKey.value !== null ? "".concat(popupId.value, "-").concat(selectedKey.value) : null;
    });
    var onRemoveTab = function onRemoveTab2(event2, key2) {
      event2.preventDefault();
      event2.stopPropagation();
      props3.editable.onEdit("remove", {
        key: key2,
        event: event2
      });
    };
    onMounted(function() {
      watch(selectedKey, function() {
        var ele = document.getElementById(selectedItemId.value);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    watch(open2, function() {
      if (!open2.value) {
        setSelectedKey(null);
      }
    });
    return function() {
      var _slots$moreIcon;
      var prefixCls = props3.prefixCls, id = props3.id, tabs = props3.tabs, locale2 = props3.locale, mobile = props3.mobile, _props$moreIcon = props3.moreIcon, moreIcon = _props$moreIcon === void 0 ? ((_slots$moreIcon = slots.moreIcon) === null || _slots$moreIcon === void 0 ? void 0 : _slots$moreIcon.call(slots)) || createVNode(EllipsisOutlined$1, null, null) : _props$moreIcon, moreTransitionName = props3.moreTransitionName, editable = props3.editable, tabBarGutter = props3.tabBarGutter, rtl2 = props3.rtl, onTabClick = props3.onTabClick;
      var dropdownPrefix = "".concat(prefixCls, "-dropdown");
      var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
      var moreStyle = _defineProperty$U({}, rtl2 ? "marginRight" : "marginLeft", tabBarGutter);
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      var overlayClassName = classNames(_defineProperty$U({}, "".concat(dropdownPrefix, "-rtl"), rtl2));
      var moreNode = mobile ? null : createVNode(Dropdown$2, {
        "prefixCls": dropdownPrefix,
        "trigger": ["hover"],
        "visible": open2.value,
        "transitionName": moreTransitionName,
        "onVisibleChange": setOpen,
        "overlayClassName": overlayClassName,
        "mouseEnterDelay": 0.1,
        "mouseLeaveDelay": 0.1
      }, {
        overlay: function overlay() {
          return createVNode(Menu, {
            "onClick": function onClick2(_ref2) {
              var key2 = _ref2.key, domEvent = _ref2.domEvent;
              onTabClick(key2, domEvent);
              setOpen(false);
            },
            "id": popupId.value,
            "tabindex": -1,
            "role": "listbox",
            "aria-activedescendant": selectedItemId.value,
            "selectedKeys": [selectedKey.value],
            "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
          }, {
            default: function _default9() {
              return [tabs.map(function(tab) {
                var _tab$closeIcon, _editable$removeIcon;
                var removable = editable && tab.closable !== false && !tab.disabled;
                return createVNode(MenuItem$1, {
                  "key": tab.key,
                  "id": "".concat(popupId.value, "-").concat(tab.key),
                  "role": "option",
                  "aria-controls": id && "".concat(id, "-panel-").concat(tab.key),
                  "disabled": tab.disabled
                }, {
                  default: function _default10() {
                    return [createVNode("span", null, [typeof tab.tab === "function" ? tab.tab() : tab.tab]), removable && createVNode("button", {
                      "type": "button",
                      "aria-label": props3.removeAriaLabel || "remove",
                      "tabindex": 0,
                      "class": "".concat(dropdownPrefix, "-menu-item-remove"),
                      "onClick": function onClick2(e2) {
                        e2.stopPropagation();
                        onRemoveTab(e2, tab.key);
                      }
                    }, [((_tab$closeIcon = tab.closeIcon) === null || _tab$closeIcon === void 0 ? void 0 : _tab$closeIcon.call(tab)) || ((_editable$removeIcon = editable.removeIcon) === null || _editable$removeIcon === void 0 ? void 0 : _editable$removeIcon.call(editable)) || "\xD7"])];
                  }
                });
              })];
            }
          });
        },
        default: function _default9() {
          return createVNode("button", {
            "type": "button",
            "class": "".concat(prefixCls, "-nav-more"),
            "style": moreStyle,
            "tabindex": -1,
            "aria-hidden": "true",
            "aria-haspopup": "listbox",
            "aria-controls": popupId.value,
            "id": "".concat(id, "-more"),
            "aria-expanded": open2.value,
            "onKeydown": onKeyDown
          }, [moreIcon]);
        }
      });
      return createVNode("div", {
        "class": classNames("".concat(prefixCls, "-nav-operations"), attrs.class),
        "style": attrs.style
      }, [moreNode, createVNode(AddButton, {
        "prefixCls": prefixCls,
        "locale": locale2,
        "editable": editable
      }, null)]);
    };
  }
});
var TabsContextKey = Symbol("tabsContextKey");
var useProvideTabs = function useProvideTabs2(props3) {
  provide(TabsContextKey, props3);
};
var useInjectTabs = function useInjectTabs2() {
  return inject(TabsContextKey, {
    tabs: ref([]),
    prefixCls: ref()
  });
};
defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabsContextProvider",
  inheritAttrs: false,
  props: {
    tabs: {
      type: Object,
      default: void 0
    },
    prefixCls: {
      type: String,
      default: void 0
    }
  },
  setup: function setup75(props3, _ref) {
    var slots = _ref.slots;
    useProvideTabs(toRefs(props3));
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL$1 = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL$1);
function useTouchMove(domRef, onOffset) {
  var _useState = useState(), _useState2 = _slicedToArray$2(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
  var _useState3 = useState(0), _useState4 = _slicedToArray$2(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
  var _useState5 = useState(0), _useState6 = _slicedToArray$2(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
  var _useState7 = useState(), _useState8 = _slicedToArray$2(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
  var motionInterval = ref();
  function onTouchStart(e2) {
    var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    clearInterval(motionInterval.value);
  }
  function onTouchMove(e2) {
    if (!touchPosition.value)
      return;
    e2.preventDefault();
    var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
    var offsetX = screenX - touchPosition.value.x;
    var offsetY = screenY - touchPosition.value.y;
    onOffset(offsetX, offsetY);
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var now2 = Date.now();
    setLastTimeDiff(now2 - lastTimestamp.value);
    setLastTimestamp(now2);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition.value)
      return;
    var lastOffsetValue = lastOffset.value;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffsetValue) {
      var distanceX = lastOffsetValue.x / lastTimeDiff.value;
      var distanceY = lastOffsetValue.y / lastTimeDiff.value;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionInterval.value = setInterval(function() {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          clearInterval(motionInterval.value);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL$1, currentY * REFRESH_INTERVAL$1);
      }, REFRESH_INTERVAL$1);
    }
  }
  var lastWheelDirectionRef = ref();
  function onWheel(e2) {
    var deltaX = e2.deltaX, deltaY = e2.deltaY;
    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.value === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.value = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.value = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e2.preventDefault();
    }
  }
  var touchEventsRef = ref({
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  });
  function onProxyTouchStart(e2) {
    touchEventsRef.value.onTouchStart(e2);
  }
  function onProxyTouchMove(e2) {
    touchEventsRef.value.onTouchMove(e2);
  }
  function onProxyTouchEnd(e2) {
    touchEventsRef.value.onTouchEnd(e2);
  }
  function onProxyWheel(e2) {
    touchEventsRef.value.onWheel(e2);
  }
  onMounted(function() {
    var _domRef$value, _domRef$value2;
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    (_domRef$value = domRef.value) === null || _domRef$value === void 0 ? void 0 : _domRef$value.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    (_domRef$value2 = domRef.value) === null || _domRef$value2 === void 0 ? void 0 : _domRef$value2.addEventListener("wheel", onProxyWheel, {
      passive: false
    });
  });
  onBeforeUnmount(function() {
    document.removeEventListener("touchmove", onProxyTouchMove);
    document.removeEventListener("touchend", onProxyTouchEnd);
  });
}
function useSyncState(defaultState, onChange3) {
  var stateRef = ref(defaultState);
  function setState2(updater) {
    var newValue = typeof updater === "function" ? updater(stateRef.value) : updater;
    if (newValue !== stateRef.value) {
      onChange3(newValue, stateRef.value);
    }
    stateRef.value = newValue;
  }
  return [stateRef, setState2];
}
var useRefs = function useRefs2() {
  var refs = ref(/* @__PURE__ */ new Map());
  var setRef2 = function setRef3(key2) {
    return function(el) {
      refs.value.set(key2, el);
    };
  };
  onBeforeUpdate(function() {
    refs.value = /* @__PURE__ */ new Map();
  });
  return [setRef2, refs];
};
const useRefs$1 = useRefs;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object4) {
  if (isArray$a(value)) {
    return false;
  }
  var type4 = typeof value;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args2 = arguments, key2 = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args2);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string3) {
  var result = [];
  if (string3.charCodeAt(0) === 46) {
    result.push("");
  }
  string3.replace(rePropName$1, function(match2, number4, quote2, subString) {
    result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number4 || match2);
  });
  return result;
});
const stringToPath$2 = stringToPath$1;
function castPath(value, object4) {
  if (isArray$a(value)) {
    return value;
  }
  return isKey(value, object4) ? [value] : stringToPath$2(toString$1(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object4, path2) {
  path2 = castPath(path2, object4);
  var index2 = 0, length = path2.length;
  while (object4 != null && index2 < length) {
    object4 = object4[toKey(path2[index2++])];
  }
  return index2 && index2 == length ? object4 : void 0;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
const defineProperty$1 = defineProperty;
function baseAssignValue(object4, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object4[key2] = value;
  }
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue(object4, key2, value) {
  var objValue = object4[key2];
  if (!(hasOwnProperty$2.call(object4, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object4)) {
    baseAssignValue(object4, key2, value);
  }
}
function baseSet(object4, path2, value, customizer) {
  if (!isObject$2(object4)) {
    return object4;
  }
  path2 = castPath(path2, object4);
  var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object4;
  while (nested != null && ++index2 < length) {
    var key2 = toKey(path2[index2]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object4;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object4;
}
function basePickBy(object4, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path2 = paths[index2], value = baseGet(object4, path2);
    if (predicate(value, path2)) {
      baseSet(result, castPath(path2, object4), value);
    }
  }
  return result;
}
function baseHasIn(object4, key2) {
  return object4 != null && key2 in Object(object4);
}
function hasPath(object4, path2, hasFunc) {
  path2 = castPath(path2, object4);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key2 = toKey(path2[index2]);
    if (!(result = object4 != null && hasFunc(object4, key2))) {
      break;
    }
    object4 = object4[key2];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object4 == null ? 0 : object4.length;
  return !!length && isLength(length) && isIndex(key2, length) && (isArray$a(object4) || isArguments$1(object4));
}
function hasIn(object4, path2) {
  return object4 != null && hasPath(object4, path2, baseHasIn);
}
function basePick(object4, paths) {
  return basePickBy(object4, paths, function(value, path2) {
    return hasIn(object4, path2);
  });
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$a(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array4, depth, predicate, isStrict, result) {
  var index2 = -1, length = array4.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array4[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? baseFlatten(array4, 1) : [];
}
function apply(func, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args2[0]);
    case 2:
      return func.call(thisArg, args2[0], args2[1]);
    case 3:
      return func.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func.apply(thisArg, args2);
}
var nativeMax$2 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args2 = arguments, index2 = -1, length = nativeMax$2(args2.length - start, 0), array4 = Array(length);
    while (++index2 < length) {
      array4[index2] = args2[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args2[index2];
    }
    otherArgs[start] = transform2(array4);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
function identity(value) {
  return value;
}
var baseSetToString = !defineProperty$1 ? identity : function(func, string3) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string3),
    "writable": true
  });
};
const baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
const setToString$1 = setToString;
function flatRest(func) {
  return setToString$1(overRest(func, void 0, flatten), func + "");
}
var pick = flatRest(function(object4, paths) {
  return object4 == null ? {} : basePick(object4, paths);
});
const pick$1 = pick;
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
var tabNavListProps = function tabNavListProps2() {
  return {
    id: {
      type: String
    },
    tabPosition: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    editable: {
      type: Object
    },
    moreIcon: PropTypes$1.any,
    moreTransitionName: {
      type: String
    },
    mobile: {
      type: Boolean
    },
    tabBarGutter: {
      type: Number
    },
    renderTabBar: {
      type: Function
    },
    locale: {
      type: Object,
      default: void 0
    },
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    }
  };
};
const TabNavList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: false,
  props: tabNavListProps(),
  slots: ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"],
  emits: ["tabClick", "tabScroll"],
  setup: function setup76(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useInjectTabs = useInjectTabs(), tabs = _useInjectTabs.tabs, prefixCls = _useInjectTabs.prefixCls;
    var tabsWrapperRef = ref();
    var tabListRef = ref();
    var operationsRef = ref();
    var innerAddButtonRef = ref();
    var _useRefs = useRefs$1(), _useRefs2 = _slicedToArray$2(_useRefs, 2), setRef2 = _useRefs2[0], btnRefs = _useRefs2[1];
    var tabPositionTopOrBottom = computed(function() {
      return props3.tabPosition === "top" || props3.tabPosition === "bottom";
    });
    var _useSyncState = useSyncState(0, function(next2, prev2) {
      if (tabPositionTopOrBottom.value && props3.onTabScroll) {
        props3.onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    }), _useSyncState2 = _slicedToArray$2(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
    var _useSyncState3 = useSyncState(0, function(next2, prev2) {
      if (!tabPositionTopOrBottom.value && props3.onTabScroll) {
        props3.onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    }), _useSyncState4 = _slicedToArray$2(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
    var _useState = useState(0), _useState2 = _slicedToArray$2(_useState, 2), wrapperScrollWidth = _useState2[0], setWrapperScrollWidth = _useState2[1];
    var _useState3 = useState(0), _useState4 = _slicedToArray$2(_useState3, 2), wrapperScrollHeight = _useState4[0], setWrapperScrollHeight = _useState4[1];
    var _useState5 = useState(null), _useState6 = _slicedToArray$2(_useState5, 2), wrapperWidth = _useState6[0], setWrapperWidth = _useState6[1];
    var _useState7 = useState(null), _useState8 = _slicedToArray$2(_useState7, 2), wrapperHeight = _useState8[0], setWrapperHeight = _useState8[1];
    var _useState9 = useState(0), _useState10 = _slicedToArray$2(_useState9, 2), addWidth = _useState10[0], setAddWidth = _useState10[1];
    var _useState11 = useState(0), _useState12 = _slicedToArray$2(_useState11, 2), addHeight = _useState12[0], setAddHeight = _useState12[1];
    var _useRafState = useRafState(/* @__PURE__ */ new Map()), _useRafState2 = _slicedToArray$2(_useRafState, 2), tabSizes = _useRafState2[0], setTabSizes = _useRafState2[1];
    var tabOffsets = useOffsets(tabs, tabSizes);
    var operationsHiddenClassName = computed(function() {
      return "".concat(prefixCls.value, "-nav-operations-hidden");
    });
    var transformMin = ref(0);
    var transformMax = ref(0);
    watchEffect(function() {
      if (!tabPositionTopOrBottom.value) {
        transformMin.value = Math.min(0, wrapperHeight.value - wrapperScrollHeight.value);
        transformMax.value = 0;
      } else if (props3.rtl) {
        transformMin.value = 0;
        transformMax.value = Math.max(0, wrapperScrollWidth.value - wrapperWidth.value);
      } else {
        transformMin.value = Math.min(0, wrapperWidth.value - wrapperScrollWidth.value);
        transformMax.value = 0;
      }
    });
    var alignInRange = function alignInRange2(value) {
      if (value < transformMin.value) {
        return transformMin.value;
      }
      if (value > transformMax.value) {
        return transformMax.value;
      }
      return value;
    };
    var touchMovingRef = ref();
    var _useState13 = useState(), _useState14 = _slicedToArray$2(_useState13, 2), lockAnimation = _useState14[0], setLockAnimation = _useState14[1];
    var doLockAnimation = function doLockAnimation2() {
      setLockAnimation(Date.now());
    };
    var clearTouchMoving = function clearTouchMoving2() {
      clearTimeout(touchMovingRef.value);
    };
    var doMove = function doMove2(setState2, offset3) {
      setState2(function(value) {
        var newValue = alignInRange(value + offset3);
        return newValue;
      });
    };
    useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
      if (tabPositionTopOrBottom.value) {
        if (wrapperWidth.value >= wrapperScrollWidth.value) {
          return false;
        }
        doMove(setTransformLeft, offsetX);
      } else {
        if (wrapperHeight.value >= wrapperScrollHeight.value) {
          return false;
        }
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    watch(lockAnimation, function() {
      clearTouchMoving();
      if (lockAnimation.value) {
        touchMovingRef.value = setTimeout(function() {
          setLockAnimation(0);
        }, 100);
      }
    });
    var scrollToTab = function scrollToTab2() {
      var key2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props3.activeKey;
      var tabOffset = tabOffsets.value.get(key2) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom.value) {
        var newTransform = transformLeft.value;
        if (props3.rtl) {
          if (tabOffset.right < transformLeft.value) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft.value + wrapperWidth.value) {
            newTransform = tabOffset.right + tabOffset.width - wrapperWidth.value;
          }
        } else if (tabOffset.left < -transformLeft.value) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft.value + wrapperWidth.value) {
          newTransform = -(tabOffset.left + tabOffset.width - wrapperWidth.value);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        var _newTransform = transformTop.value;
        if (tabOffset.top < -transformTop.value) {
          _newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop.value + wrapperHeight.value) {
          _newTransform = -(tabOffset.top + tabOffset.height - wrapperHeight.value);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(_newTransform));
      }
    };
    var visibleStart = ref(0);
    var visibleEnd = ref(0);
    watchEffect(function() {
      var _ref3;
      var unit;
      var position;
      var transformSize;
      var basicSize;
      var tabContentSize;
      var addSize;
      var tabOffsetsValue = tabOffsets.value;
      if (["top", "bottom"].includes(props3.tabPosition)) {
        unit = "width";
        basicSize = wrapperWidth.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addWidth.value;
        position = props3.rtl ? "right" : "left";
        transformSize = Math.abs(transformLeft.value);
      } else {
        unit = "height";
        basicSize = wrapperHeight.value;
        tabContentSize = wrapperScrollWidth.value;
        addSize = addHeight.value;
        position = "top";
        transformSize = -transformTop.value;
      }
      var mergedBasicSize = basicSize;
      if (tabContentSize + addSize > basicSize && tabContentSize < basicSize) {
        mergedBasicSize = basicSize - addSize;
      }
      var tabsVal = tabs.value;
      if (!tabsVal.length) {
        var _ref2;
        return _ref2 = [0, 0], visibleStart.value = _ref2[0], visibleEnd.value = _ref2[1], _ref2;
      }
      var len = tabsVal.length;
      var endIndex = len;
      for (var i2 = 0; i2 < len; i2 += 1) {
        var offset3 = tabOffsetsValue.get(tabsVal[i2].key) || DEFAULT_SIZE;
        if (offset3[position] + offset3[unit] > transformSize + mergedBasicSize) {
          endIndex = i2 - 1;
          break;
        }
      }
      var startIndex = 0;
      for (var _i = len - 1; _i >= 0; _i -= 1) {
        var _offset = tabOffsetsValue.get(tabsVal[_i].key) || DEFAULT_SIZE;
        if (_offset[position] < transformSize) {
          startIndex = _i + 1;
          break;
        }
      }
      return _ref3 = [startIndex, endIndex], visibleStart.value = _ref3[0], visibleEnd.value = _ref3[1], _ref3;
    });
    var onListHolderResize = function onListHolderResize2() {
      var _tabsWrapperRef$value, _tabsWrapperRef$value2, _innerAddButtonRef$va, _tabListRef$value, _tabListRef$value2;
      var offsetWidth = ((_tabsWrapperRef$value = tabsWrapperRef.value) === null || _tabsWrapperRef$value === void 0 ? void 0 : _tabsWrapperRef$value.offsetWidth) || 0;
      var offsetHeight = ((_tabsWrapperRef$value2 = tabsWrapperRef.value) === null || _tabsWrapperRef$value2 === void 0 ? void 0 : _tabsWrapperRef$value2.offsetHeight) || 0;
      var addDom = ((_innerAddButtonRef$va = innerAddButtonRef.value) === null || _innerAddButtonRef$va === void 0 ? void 0 : _innerAddButtonRef$va.$el) || {};
      var newAddWidth = addDom.offsetWidth || 0;
      var newAddHeight = addDom.offsetHeight || 0;
      setWrapperWidth(offsetWidth);
      setWrapperHeight(offsetHeight);
      setAddWidth(newAddWidth);
      setAddHeight(newAddHeight);
      var newWrapperScrollWidth = (((_tabListRef$value = tabListRef.value) === null || _tabListRef$value === void 0 ? void 0 : _tabListRef$value.offsetWidth) || 0) - newAddWidth;
      var newWrapperScrollHeight = (((_tabListRef$value2 = tabListRef.value) === null || _tabListRef$value2 === void 0 ? void 0 : _tabListRef$value2.offsetHeight) || 0) - newAddHeight;
      setWrapperScrollWidth(newWrapperScrollWidth);
      setWrapperScrollHeight(newWrapperScrollHeight);
      setTabSizes(function() {
        var newSizes = /* @__PURE__ */ new Map();
        tabs.value.forEach(function(_ref4) {
          var key2 = _ref4.key;
          var btnRef = btnRefs.value.get(key2);
          var btnNode = (btnRef === null || btnRef === void 0 ? void 0 : btnRef.$el) || btnRef;
          if (btnNode) {
            newSizes.set(key2, {
              width: btnNode.offsetWidth,
              height: btnNode.offsetHeight,
              left: btnNode.offsetLeft,
              top: btnNode.offsetTop
            });
          }
        });
        return newSizes;
      });
    };
    var hiddenTabs = computed(function() {
      return [].concat(_toConsumableArray(tabs.value.slice(0, visibleStart.value)), _toConsumableArray(tabs.value.slice(visibleEnd.value + 1)));
    });
    var _useState15 = useState(), _useState16 = _slicedToArray$2(_useState15, 2), inkStyle = _useState16[0], setInkStyle = _useState16[1];
    var activeTabOffset = computed(function() {
      return tabOffsets.value.get(props3.activeKey);
    });
    var inkBarRafRef = ref();
    var cleanInkBarRaf = function cleanInkBarRaf2() {
      wrapperRaf.cancel(inkBarRafRef.value);
    };
    watch([activeTabOffset, tabPositionTopOrBottom, function() {
      return props3.rtl;
    }], function() {
      var newInkStyle = {};
      if (activeTabOffset.value) {
        if (tabPositionTopOrBottom.value) {
          if (props3.rtl) {
            newInkStyle.right = toPx(activeTabOffset.value.right);
          } else {
            newInkStyle.left = toPx(activeTabOffset.value.left);
          }
          newInkStyle.width = toPx(activeTabOffset.value.width);
        } else {
          newInkStyle.top = toPx(activeTabOffset.value.top);
          newInkStyle.height = toPx(activeTabOffset.value.height);
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.value = wrapperRaf(function() {
        setInkStyle(newInkStyle);
      });
    });
    watch([function() {
      return props3.activeKey;
    }, activeTabOffset, tabOffsets, tabPositionTopOrBottom], function() {
      scrollToTab();
    }, {
      flush: "post"
    });
    watch([function() {
      return props3.rtl;
    }, function() {
      return props3.tabBarGutter;
    }, function() {
      return props3.activeKey;
    }, function() {
      return tabs.value;
    }], function() {
      onListHolderResize();
    }, {
      flush: "post"
    });
    var ExtraContent = function ExtraContent2(_ref5) {
      var position = _ref5.position, prefixCls2 = _ref5.prefixCls, extra = _ref5.extra;
      if (!extra)
        return null;
      var content = extra === null || extra === void 0 ? void 0 : extra({
        position
      });
      return content ? createVNode("div", {
        "class": "".concat(prefixCls2, "-extra-content")
      }, [content]) : null;
    };
    onBeforeUnmount(function() {
      clearTouchMoving();
      cleanInkBarRaf();
    });
    return function() {
      var _classNames;
      var id = props3.id, animated = props3.animated, activeKey = props3.activeKey, rtl2 = props3.rtl, editable = props3.editable, locale2 = props3.locale, tabPosition = props3.tabPosition, tabBarGutter = props3.tabBarGutter, onTabClick = props3.onTabClick;
      var className = attrs.class, style2 = attrs.style;
      var pre = prefixCls.value;
      var hasDropdown = !!hiddenTabs.value.length;
      var wrapPrefix = "".concat(pre, "-nav-wrap");
      var pingLeft;
      var pingRight;
      var pingTop;
      var pingBottom;
      if (tabPositionTopOrBottom.value) {
        if (rtl2) {
          pingRight = transformLeft.value > 0;
          pingLeft = transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        } else {
          pingLeft = transformLeft.value < 0;
          pingRight = -transformLeft.value + wrapperWidth.value < wrapperScrollWidth.value;
        }
      } else {
        pingTop = transformTop.value < 0;
        pingBottom = -transformTop.value + wrapperHeight.value < wrapperScrollHeight.value;
      }
      var tabNodeStyle = {};
      if (tabPosition === "top" || tabPosition === "bottom") {
        tabNodeStyle[rtl2 ? "marginRight" : "marginLeft"] = typeof tabBarGutter === "number" ? "".concat(tabBarGutter, "px") : tabBarGutter;
      } else {
        tabNodeStyle.marginTop = typeof tabBarGutter === "number" ? "".concat(tabBarGutter, "px") : tabBarGutter;
      }
      var tabNodes = tabs.value.map(function(tab, i2) {
        var key2 = tab.key;
        return createVNode(TabNode, {
          "id": id,
          "prefixCls": pre,
          "key": key2,
          "tab": tab,
          "style": i2 === 0 ? void 0 : tabNodeStyle,
          "closable": tab.closable,
          "editable": editable,
          "active": key2 === activeKey,
          "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
          "ref": setRef2(key2),
          "onClick": function onClick2(e2) {
            onTabClick(key2, e2);
          },
          "onFocus": function onFocus2() {
            scrollToTab(key2);
            doLockAnimation();
            if (!tabsWrapperRef.value) {
              return;
            }
            if (!rtl2) {
              tabsWrapperRef.value.scrollLeft = 0;
            }
            tabsWrapperRef.value.scrollTop = 0;
          }
        }, slots);
      });
      return createVNode("div", {
        "role": "tablist",
        "class": classNames("".concat(pre, "-nav"), className),
        "style": style2,
        "onKeydown": function onKeydown() {
          doLockAnimation();
        }
      }, [createVNode(ExtraContent, {
        "position": "left",
        "prefixCls": pre,
        "extra": slots.leftExtra
      }, null), createVNode(ResizeObserver$1, {
        "onResize": onListHolderResize
      }, {
        default: function _default9() {
          return [createVNode("div", {
            "class": classNames(wrapPrefix, (_classNames = {}, _defineProperty$U(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$U(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$U(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$U(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
            "ref": tabsWrapperRef
          }, [createVNode(ResizeObserver$1, {
            "onResize": onListHolderResize
          }, {
            default: function _default10() {
              return [createVNode("div", {
                "ref": tabListRef,
                "class": "".concat(pre, "-nav-list"),
                "style": {
                  transform: "translate(".concat(transformLeft.value, "px, ").concat(transformTop.value, "px)"),
                  transition: lockAnimation.value ? "none" : void 0
                }
              }, [tabNodes, createVNode(AddButton, {
                "ref": innerAddButtonRef,
                "prefixCls": pre,
                "locale": locale2,
                "editable": editable,
                "style": _objectSpread2$1(_objectSpread2$1({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
                  visibility: hasDropdown ? "hidden" : null
                })
              }, null), createVNode("div", {
                "class": classNames("".concat(pre, "-ink-bar"), _defineProperty$U({}, "".concat(pre, "-ink-bar-animated"), animated.inkBar)),
                "style": inkStyle.value
              }, null)])];
            }
          })])];
        }
      }), createVNode(OperationNode, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        "removeAriaLabel": locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        "ref": operationsRef,
        "prefixCls": pre,
        "tabs": hiddenTabs.value,
        "class": !hasDropdown && operationsHiddenClassName.value
      }), pick$1(slots, ["moreIcon"])), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.rightExtra
      }, null), createVNode(ExtraContent, {
        "position": "right",
        "prefixCls": pre,
        "extra": slots.tabBarExtraContent
      }, null)]);
    };
  }
});
const TabPanelList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: false,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup: function setup77(props3) {
    var _useInjectTabs = useInjectTabs(), tabs = _useInjectTabs.tabs, prefixCls = _useInjectTabs.prefixCls;
    return function() {
      var id = props3.id, activeKey = props3.activeKey, animated = props3.animated, tabPosition = props3.tabPosition, rtl2 = props3.rtl, destroyInactiveTabPane = props3.destroyInactiveTabPane;
      var tabPaneAnimated = animated.tabPane;
      var pre = prefixCls.value;
      var activeIndex = tabs.value.findIndex(function(tab) {
        return tab.key === activeKey;
      });
      return createVNode("div", {
        "class": "".concat(pre, "-content-holder")
      }, [createVNode("div", {
        "class": ["".concat(pre, "-content"), "".concat(pre, "-content-").concat(tabPosition), _defineProperty$U({}, "".concat(pre, "-content-animated"), tabPaneAnimated)],
        "style": activeIndex && tabPaneAnimated ? _defineProperty$U({}, rtl2 ? "marginRight" : "marginLeft", "-".concat(activeIndex, "00%")) : null
      }, [tabs.value.map(function(tab) {
        return cloneElement(tab.node, {
          key: tab.key,
          prefixCls: pre,
          tabKey: tab.key,
          id,
          animated: tabPaneAnimated,
          active: tab.key === activeKey,
          destroyInactiveTabPane
        });
      })])]);
    };
  }
});
var PlusOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
const PlusOutlinedSvg = PlusOutlined$2;
function _objectSpread$z(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$z(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$z(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusOutlined = function PlusOutlined2(props3, context2) {
  var p2 = _objectSpread$z({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$z({}, p2, {
    "icon": PlusOutlinedSvg
  }), null);
};
PlusOutlined.displayName = "PlusOutlined";
PlusOutlined.inheritAttrs = false;
const PlusOutlined$1 = PlusOutlined;
var uuid$3 = 0;
var tabsProps = function tabsProps2() {
  return {
    prefixCls: {
      type: String
    },
    id: {
      type: String
    },
    activeKey: {
      type: [String, Number]
    },
    defaultActiveKey: {
      type: [String, Number]
    },
    direction: {
      type: String
    },
    animated: {
      type: [Boolean, Object]
    },
    renderTabBar: {
      type: Function
    },
    tabBarGutter: {
      type: Number
    },
    tabBarStyle: {
      type: Object
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    },
    hideAdd: Boolean,
    type: {
      type: String
    },
    size: {
      type: String
    },
    centered: Boolean,
    onEdit: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onTabClick: {
      type: Function
    },
    onTabScroll: {
      type: Function
    },
    "onUpdate:activeKey": {
      type: Function
    },
    locale: {
      type: Object,
      default: void 0
    },
    onPrevClick: Function,
    onNextClick: Function,
    tabBarExtraContent: PropTypes$1.any
  };
};
function parseTabList(children) {
  return children.map(function(node) {
    if (isValidElement(node)) {
      var props3 = _objectSpread2$1({}, node.props || {});
      for (var _i = 0, _Object$entries = Object.entries(props3); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray$2(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
        delete props3[k2];
        props3[camelize$2(k2)] = v2;
      }
      var slots = node.children || {};
      var key2 = node.key !== void 0 ? node.key : void 0;
      var _props$tab = props3.tab, tab = _props$tab === void 0 ? slots.tab : _props$tab, disabled = props3.disabled, forceRender = props3.forceRender, closable = props3.closable, animated = props3.animated, active = props3.active, destroyInactiveTabPane = props3.destroyInactiveTabPane;
      return _objectSpread2$1(_objectSpread2$1({
        key: key2
      }, props3), {}, {
        node,
        closeIcon: slots.closeIcon,
        tab,
        disabled: disabled === "" || disabled,
        forceRender: forceRender === "" || forceRender,
        closable: closable === "" || closable,
        animated: animated === "" || animated,
        active: active === "" || active,
        destroyInactiveTabPane: destroyInactiveTabPane === "" || destroyInactiveTabPane
      });
    }
    return null;
  }).filter(function(tab) {
    return tab;
  });
}
var InternalTabs = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, initDefaultProps$1(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  })), {}, {
    tabs: {
      type: Array
    }
  }),
  slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon", "renderTabBar"],
  setup: function setup78(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    devWarning(!(props3.onPrevClick !== void 0) && !(props3.onNextClick !== void 0), "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead.");
    devWarning(!(props3.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead.");
    devWarning(!(slots.tabBarExtraContent !== void 0), "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    var _useConfigInject = useConfigInject("tabs", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size2 = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
    var rtl2 = computed(function() {
      return direction.value === "rtl";
    });
    var mergedAnimated = computed(function() {
      var animated = props3.animated, tabPosition = props3.tabPosition;
      if (animated === false || ["left", "right"].includes(tabPosition)) {
        return {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        return {
          inkBar: true,
          tabPane: true
        };
      } else {
        return _objectSpread2$1({
          inkBar: true,
          tabPane: false
        }, _typeof$3(animated) === "object" ? animated : {});
      }
    });
    var _useState = useState(false), _useState2 = _slicedToArray$2(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
    onMounted(function() {
      setMobile(isMobile$2());
    });
    var _useMergedState = useMergedState(function() {
      var _props$tabs$;
      return (_props$tabs$ = props3.tabs[0]) === null || _props$tabs$ === void 0 ? void 0 : _props$tabs$.key;
    }, {
      value: computed(function() {
        return props3.activeKey;
      }),
      defaultValue: props3.defaultActiveKey
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
    var _useState3 = useState(function() {
      return props3.tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey.value;
      });
    }), _useState4 = _slicedToArray$2(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
    watchEffect(function() {
      var newActiveIndex = props3.tabs.findIndex(function(tab) {
        return tab.key === mergedActiveKey.value;
      });
      if (newActiveIndex === -1) {
        var _props$tabs$newActive;
        newActiveIndex = Math.max(0, Math.min(activeIndex.value, props3.tabs.length - 1));
        setMergedActiveKey((_props$tabs$newActive = props3.tabs[newActiveIndex]) === null || _props$tabs$newActive === void 0 ? void 0 : _props$tabs$newActive.key);
      }
      setActiveIndex(newActiveIndex);
    });
    var _useMergedState3 = useMergedState(null, {
      value: computed(function() {
        return props3.id;
      })
    }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
    var mergedTabPosition = computed(function() {
      if (mobile.value && !["left", "right"].includes(props3.tabPosition)) {
        return "top";
      } else {
        return props3.tabPosition;
      }
    });
    onMounted(function() {
      if (!props3.id) {
        setMergedId("rc-tabs-".concat(uuid$3));
        uuid$3 += 1;
      }
    });
    var onInternalTabClick = function onInternalTabClick2(key2, e2) {
      var _props$onTabClick;
      (_props$onTabClick = props3.onTabClick) === null || _props$onTabClick === void 0 ? void 0 : _props$onTabClick.call(props3, key2, e2);
      var isActiveChanged = key2 !== mergedActiveKey.value;
      setMergedActiveKey(key2);
      if (isActiveChanged) {
        var _props$onChange;
        (_props$onChange = props3.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props3, key2);
      }
    };
    useProvideTabs({
      tabs: computed(function() {
        return props3.tabs;
      }),
      prefixCls
    });
    return function() {
      var _classNames;
      var id = props3.id, type4 = props3.type, tabBarGutter = props3.tabBarGutter, tabBarStyle = props3.tabBarStyle, locale2 = props3.locale, destroyInactiveTabPane = props3.destroyInactiveTabPane, _props$renderTabBar = props3.renderTabBar, renderTabBar = _props$renderTabBar === void 0 ? slots.renderTabBar : _props$renderTabBar, onTabScroll = props3.onTabScroll, hideAdd = props3.hideAdd, centered = props3.centered;
      var sharedProps = {
        id: mergedId.value,
        activeKey: mergedActiveKey.value,
        animated: mergedAnimated.value,
        tabPosition: mergedTabPosition.value,
        rtl: rtl2.value,
        mobile: mobile.value
      };
      var editable;
      if (type4 === "editable-card") {
        editable = {
          onEdit: function onEdit(editType, _ref2) {
            var _props$onEdit;
            var key2 = _ref2.key, event2 = _ref2.event;
            (_props$onEdit = props3.onEdit) === null || _props$onEdit === void 0 ? void 0 : _props$onEdit.call(props3, editType === "add" ? event2 : key2, editType);
          },
          removeIcon: function removeIcon() {
            return createVNode(CloseOutlined$1, null, null);
          },
          addIcon: slots.addIcon ? slots.addIcon : function() {
            return createVNode(PlusOutlined$1, null, null);
          },
          showAdd: hideAdd !== true
        };
      }
      var tabNavBar;
      var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
        moreTransitionName: "".concat(rootPrefixCls.value, "-slide-up"),
        editable,
        locale: locale2,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        style: tabBarStyle
      });
      if (renderTabBar) {
        tabNavBar = renderTabBar(_objectSpread2$1(_objectSpread2$1({}, tabNavBarProps), {}, {
          DefaultTabBar: TabNavList
        }));
      } else {
        tabNavBar = createVNode(TabNavList, tabNavBarProps, pick$1(slots, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      }
      var pre = prefixCls.value;
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "id": id,
        "class": classNames(pre, "".concat(pre, "-").concat(mergedTabPosition.value), (_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-").concat(size2.value), size2.value), _defineProperty$U(_classNames, "".concat(pre, "-card"), ["card", "editable-card"].includes(type4)), _defineProperty$U(_classNames, "".concat(pre, "-editable-card"), type4 === "editable-card"), _defineProperty$U(_classNames, "".concat(pre, "-centered"), centered), _defineProperty$U(_classNames, "".concat(pre, "-mobile"), mobile.value), _defineProperty$U(_classNames, "".concat(pre, "-editable"), type4 === "editable-card"), _defineProperty$U(_classNames, "".concat(pre, "-rtl"), rtl2.value), _classNames), attrs.class)
      }), [tabNavBar, createVNode(TabPanelList, _objectSpread2$1(_objectSpread2$1({
        "destroyInactiveTabPane": destroyInactiveTabPane
      }, sharedProps), {}, {
        "animated": mergedAnimated.value
      }), null)]);
    };
  }
});
const Tabs = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: false,
  props: initDefaultProps$1(tabsProps(), {
    tabPosition: "top",
    animated: {
      inkBar: true,
      tabPane: false
    }
  }),
  slots: ["tabBarExtraContent", "leftExtra", "rightExtra", "moreIcon", "addIcon", "removeIcon", "renderTabBar"],
  setup: function setup79(props3, _ref3) {
    var attrs = _ref3.attrs, slots = _ref3.slots, emit = _ref3.emit;
    var handleChange2 = function handleChange3(key2) {
      emit("update:activeKey", key2);
      emit("change", key2);
    };
    return function() {
      var _slots$default;
      var tabs = parseTabList(flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)));
      return createVNode(InternalTabs, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["onUpdate:activeKey"])), attrs), {}, {
        "onChange": handleChange2,
        "tabs": tabs
      }), slots);
    };
  }
});
var tabPaneProps = function tabPaneProps2() {
  return {
    tab: PropTypes$1.any,
    disabled: {
      type: Boolean
    },
    forceRender: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    animated: {
      type: Boolean
    },
    active: {
      type: Boolean
    },
    destroyInactiveTabPane: {
      type: Boolean
    },
    prefixCls: {
      type: String
    },
    tabKey: {
      type: [String, Number]
    },
    id: {
      type: String
    }
  };
};
const TabPane$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: false,
  __ANT_TAB_PANE: true,
  props: tabPaneProps(),
  slots: ["closeIcon", "tab"],
  setup: function setup80(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var visited = ref(props3.forceRender);
    watch([function() {
      return props3.active;
    }, function() {
      return props3.destroyInactiveTabPane;
    }], function() {
      if (props3.active) {
        visited.value = true;
      } else if (props3.destroyInactiveTabPane) {
        visited.value = false;
      }
    }, {
      immediate: true
    });
    var mergedStyle = computed(function() {
      if (!props3.active) {
        if (props3.animated) {
          return {
            visibility: "hidden",
            height: 0,
            overflowY: "hidden"
          };
        } else {
          return {
            display: "none"
          };
        }
      }
      return {};
    });
    return function() {
      var _slots$default;
      var prefixCls = props3.prefixCls, forceRender = props3.forceRender, id = props3.id, active = props3.active, tabKey = props3.tabKey;
      return createVNode("div", {
        "id": id && "".concat(id, "-panel-").concat(tabKey),
        "role": "tabpanel",
        "tabindex": active ? 0 : -1,
        "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
        "aria-hidden": !active,
        "style": [mergedStyle.value, attrs.style],
        "class": ["".concat(prefixCls, "-tabpane"), active && "".concat(prefixCls, "-tabpane-active"), attrs.class]
      }, [(active || visited.value || forceRender) && ((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))]);
    };
  }
});
Tabs.TabPane = TabPane$1;
Tabs.install = function(app) {
  app.component(Tabs.name, Tabs);
  app.component(TabPane$1.name, TabPane$1);
  return app;
};
var canUseDocElement = function canUseDocElement2() {
  return canUseDom() && window.document.documentElement;
};
var isStyleNameSupport = function isStyleNameSupport2(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function(name2) {
      return name2 in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement("div");
  var origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
var flexGapSupported;
var detectFlexGapSupported = function detectFlexGapSupported2() {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  var flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
const useFlexGapSupport = function() {
  var flexible = ref(false);
  onMounted(function() {
    flexible.value = detectFlexGapSupported();
  });
  return flexible;
};
var RowContextKey = Symbol("rowContextKey");
var useProvideRow = function useProvideRow2(state) {
  provide(RowContextKey, state);
};
var useInjectRow = function useInjectRow2() {
  return inject(RowContextKey, {
    gutter: computed(function() {
      return void 0;
    }),
    wrap: computed(function() {
      return void 0;
    }),
    supportFlexGap: computed(function() {
      return void 0;
    })
  });
};
tuple$1("top", "middle", "bottom", "stretch");
tuple$1("start", "end", "center", "space-around", "space-between");
var rowProps = function rowProps2() {
  return {
    align: String,
    justify: String,
    prefixCls: String,
    gutter: {
      type: [Number, Array, Object],
      default: 0
    },
    wrap: {
      type: Boolean,
      default: void 0
    }
  };
};
var ARow = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARow",
  props: rowProps(),
  setup: function setup81(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("row", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var token2;
    var screens2 = ref({
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true,
      xxxl: true
    });
    var supportFlexGap = useFlexGapSupport();
    onMounted(function() {
      token2 = ResponsiveObserve.subscribe(function(screen) {
        var currentGutter = props3.gutter || 0;
        if (!Array.isArray(currentGutter) && _typeof$3(currentGutter) === "object" || Array.isArray(currentGutter) && (_typeof$3(currentGutter[0]) === "object" || _typeof$3(currentGutter[1]) === "object")) {
          screens2.value = screen;
        }
      });
    });
    onBeforeUnmount(function() {
      ResponsiveObserve.unsubscribe(token2);
    });
    var gutter = computed(function() {
      var results = [0, 0];
      var _props$gutter = props3.gutter, gutter2 = _props$gutter === void 0 ? 0 : _props$gutter;
      var normalizedGutter = Array.isArray(gutter2) ? gutter2 : [gutter2, 0];
      normalizedGutter.forEach(function(g2, index2) {
        if (_typeof$3(g2) === "object") {
          for (var i2 = 0; i2 < responsiveArray.length; i2++) {
            var breakpoint = responsiveArray[i2];
            if (screens2.value[breakpoint] && g2[breakpoint] !== void 0) {
              results[index2] = g2[breakpoint];
              break;
            }
          }
        } else {
          results[index2] = g2 || 0;
        }
      });
      return results;
    });
    useProvideRow({
      gutter,
      supportFlexGap,
      wrap: computed(function() {
        return props3.wrap;
      })
    });
    var classes = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-no-wrap"), props3.wrap === false), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(props3.justify), props3.justify), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(props3.align), props3.align), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
    });
    var rowStyle = computed(function() {
      var gt = gutter.value;
      var style2 = {};
      var horizontalGutter = gt[0] > 0 ? "".concat(gt[0] / -2, "px") : void 0;
      var verticalGutter = gt[1] > 0 ? "".concat(gt[1] / -2, "px") : void 0;
      if (horizontalGutter) {
        style2.marginLeft = horizontalGutter;
        style2.marginRight = horizontalGutter;
      }
      if (supportFlexGap.value) {
        style2.rowGap = "".concat(gt[1], "px");
      } else if (verticalGutter) {
        style2.marginTop = verticalGutter;
        style2.marginBottom = verticalGutter;
      }
      return style2;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": classes.value,
        "style": rowStyle.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const Row$3 = ARow;
function parseFlex(flex) {
  if (typeof flex === "number") {
    return "".concat(flex, " ").concat(flex, " auto");
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return "0 0 ".concat(flex);
  }
  return flex;
}
var colProps = function colProps2() {
  return {
    span: [String, Number],
    order: [String, Number],
    offset: [String, Number],
    push: [String, Number],
    pull: [String, Number],
    xs: {
      type: [String, Number, Object],
      default: void 0
    },
    sm: {
      type: [String, Number, Object],
      default: void 0
    },
    md: {
      type: [String, Number, Object],
      default: void 0
    },
    lg: {
      type: [String, Number, Object],
      default: void 0
    },
    xl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxxl: {
      type: [String, Number, Object],
      default: void 0
    },
    prefixCls: String,
    flex: [String, Number]
  };
};
const Col$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACol",
  props: colProps(),
  setup: function setup82(props3, _ref) {
    var slots = _ref.slots;
    var _useInjectRow = useInjectRow(), gutter = _useInjectRow.gutter, supportFlexGap = _useInjectRow.supportFlexGap, wrap = _useInjectRow.wrap;
    var _useConfigInject = useConfigInject("col", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var classes = computed(function() {
      var _classNames;
      var span = props3.span, order = props3.order, offset3 = props3.offset, push2 = props3.push, pull = props3.pull;
      var pre = prefixCls.value;
      var sizeClassObj = {};
      ["xs", "sm", "md", "lg", "xl", "xxl", "xxxl"].forEach(function(size2) {
        var _objectSpread22;
        var sizeProps = {};
        var propSize = props3[size2];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (_typeof$3(propSize) === "object") {
          sizeProps = propSize || {};
        }
        sizeClassObj = _objectSpread2$1(_objectSpread2$1({}, sizeClassObj), {}, (_objectSpread22 = {}, _defineProperty$U(_objectSpread22, "".concat(pre, "-").concat(size2, "-").concat(sizeProps.span), sizeProps.span !== void 0), _defineProperty$U(_objectSpread22, "".concat(pre, "-").concat(size2, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), _defineProperty$U(_objectSpread22, "".concat(pre, "-").concat(size2, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), _defineProperty$U(_objectSpread22, "".concat(pre, "-").concat(size2, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), _defineProperty$U(_objectSpread22, "".concat(pre, "-").concat(size2, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _defineProperty$U(_objectSpread22, "".concat(pre, "-rtl"), direction.value === "rtl"), _objectSpread22));
      });
      return classNames(pre, (_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-").concat(span), span !== void 0), _defineProperty$U(_classNames, "".concat(pre, "-order-").concat(order), order), _defineProperty$U(_classNames, "".concat(pre, "-offset-").concat(offset3), offset3), _defineProperty$U(_classNames, "".concat(pre, "-push-").concat(push2), push2), _defineProperty$U(_classNames, "".concat(pre, "-pull-").concat(pull), pull), _classNames), sizeClassObj);
    });
    var mergedStyle = computed(function() {
      var flex = props3.flex;
      var gutterVal = gutter.value;
      var style2 = {};
      if (gutterVal && gutterVal[0] > 0) {
        var horizontalGutter = "".concat(gutterVal[0] / 2, "px");
        style2.paddingLeft = horizontalGutter;
        style2.paddingRight = horizontalGutter;
      }
      if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
        var verticalGutter = "".concat(gutterVal[1] / 2, "px");
        style2.paddingTop = verticalGutter;
        style2.paddingBottom = verticalGutter;
      }
      if (flex) {
        style2.flex = parseFlex(flex);
        if (wrap.value === false && !style2.minWidth) {
          style2.minWidth = 0;
        }
      }
      return style2;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": classes.value,
        "style": mergedStyle.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const index$k = {
  useBreakpoint
};
const Row$2 = withInstall(Row$3);
const Col = withInstall(Col$1);
var TabPane = Tabs.TabPane;
var cardProps = function cardProps2() {
  return {
    prefixCls: String,
    title: PropTypes$1.any,
    extra: PropTypes$1.any,
    bordered: {
      type: Boolean,
      default: true
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    headStyle: {
      type: Object,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    type: {
      type: String
    },
    size: {
      type: String
    },
    actions: PropTypes$1.any,
    tabList: {
      type: Array
    },
    tabBarExtraContent: PropTypes$1.any,
    activeTabKey: String,
    defaultActiveTabKey: String,
    cover: PropTypes$1.any,
    onTabChange: {
      type: Function
    }
  };
};
var Card = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACard",
  props: cardProps(),
  slots: ["title", "extra", "tabBarExtraContent", "actions", "cover", "customTab"],
  setup: function setup83(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size2 = _useConfigInject.size;
    var getAction = function getAction2(actions) {
      var actionList = actions.map(function(action, index2) {
        return isVNode(action) && !isEmptyElement(action) || !isVNode(action) ? createVNode("li", {
          "style": {
            width: "".concat(100 / actions.length, "%")
          },
          "key": "action-".concat(index2)
        }, [createVNode("span", null, [action])]) : null;
      });
      return actionList;
    };
    var triggerTabChange = function triggerTabChange2(key2) {
      var _props$onTabChange;
      (_props$onTabChange = props3.onTabChange) === null || _props$onTabChange === void 0 ? void 0 : _props$onTabChange.call(props3, key2);
    };
    var isContainGrid = function isContainGrid2() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var containGrid;
      obj.forEach(function(element) {
        if (element && isPlainObject$1(element.type) && element.type.__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    };
    return function() {
      var _slots$tabBarExtraCon, _slots$title, _slots$extra, _slots$actions, _slots$cover, _slots$default, _classString, _tabsProps;
      var _props$headStyle = props3.headStyle, headStyle = _props$headStyle === void 0 ? {} : _props$headStyle, _props$bodyStyle = props3.bodyStyle, bodyStyle = _props$bodyStyle === void 0 ? {} : _props$bodyStyle, loading = props3.loading, _props$bordered = props3.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, type4 = props3.type, tabList = props3.tabList, hoverable = props3.hoverable, activeTabKey = props3.activeTabKey, defaultActiveTabKey = props3.defaultActiveTabKey, _props$tabBarExtraCon = props3.tabBarExtraContent, tabBarExtraContent = _props$tabBarExtraCon === void 0 ? filterEmptyWithUndefined((_slots$tabBarExtraCon = slots.tabBarExtraContent) === null || _slots$tabBarExtraCon === void 0 ? void 0 : _slots$tabBarExtraCon.call(slots)) : _props$tabBarExtraCon, _props$title = props3.title, title = _props$title === void 0 ? filterEmptyWithUndefined((_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots)) : _props$title, _props$extra = props3.extra, extra = _props$extra === void 0 ? filterEmptyWithUndefined((_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots)) : _props$extra, _props$actions = props3.actions, actions = _props$actions === void 0 ? filterEmptyWithUndefined((_slots$actions = slots.actions) === null || _slots$actions === void 0 ? void 0 : _slots$actions.call(slots)) : _props$actions, _props$cover = props3.cover, cover = _props$cover === void 0 ? filterEmptyWithUndefined((_slots$cover = slots.cover) === null || _slots$cover === void 0 ? void 0 : _slots$cover.call(slots)) : _props$cover;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var pre = prefixCls.value;
      var classString = (_classString = {}, _defineProperty$U(_classString, "".concat(pre), true), _defineProperty$U(_classString, "".concat(pre, "-loading"), loading), _defineProperty$U(_classString, "".concat(pre, "-bordered"), bordered), _defineProperty$U(_classString, "".concat(pre, "-hoverable"), !!hoverable), _defineProperty$U(_classString, "".concat(pre, "-contain-grid"), isContainGrid(children)), _defineProperty$U(_classString, "".concat(pre, "-contain-tabs"), tabList && tabList.length), _defineProperty$U(_classString, "".concat(pre, "-").concat(size2.value), size2.value), _defineProperty$U(_classString, "".concat(pre, "-type-").concat(type4), !!type4), _defineProperty$U(_classString, "".concat(pre, "-rtl"), direction.value === "rtl"), _classString);
      var loadingBlockStyle = bodyStyle.padding === 0 || bodyStyle.padding === "0px" ? {
        padding: "24px"
      } : void 0;
      var block = createVNode("div", {
        "class": "".concat(pre, "-loading-block")
      }, null);
      var loadingBlock = createVNode("div", {
        "class": "".concat(pre, "-loading-content"),
        "style": loadingBlockStyle
      }, [createVNode(Row$2, {
        "gutter": 8
      }, {
        default: function _default9() {
          return [createVNode(Col, {
            "span": 22
          }, {
            default: function _default10() {
              return [block];
            }
          })];
        }
      }), createVNode(Row$2, {
        "gutter": 8
      }, {
        default: function _default9() {
          return [createVNode(Col, {
            "span": 8
          }, {
            default: function _default10() {
              return [block];
            }
          }), createVNode(Col, {
            "span": 15
          }, {
            default: function _default10() {
              return [block];
            }
          })];
        }
      }), createVNode(Row$2, {
        "gutter": 8
      }, {
        default: function _default9() {
          return [createVNode(Col, {
            "span": 6
          }, {
            default: function _default10() {
              return [block];
            }
          }), createVNode(Col, {
            "span": 18
          }, {
            default: function _default10() {
              return [block];
            }
          })];
        }
      }), createVNode(Row$2, {
        "gutter": 8
      }, {
        default: function _default9() {
          return [createVNode(Col, {
            "span": 13
          }, {
            default: function _default10() {
              return [block];
            }
          }), createVNode(Col, {
            "span": 9
          }, {
            default: function _default10() {
              return [block];
            }
          })];
        }
      }), createVNode(Row$2, {
        "gutter": 8
      }, {
        default: function _default9() {
          return [createVNode(Col, {
            "span": 4
          }, {
            default: function _default10() {
              return [block];
            }
          }), createVNode(Col, {
            "span": 3
          }, {
            default: function _default10() {
              return [block];
            }
          }), createVNode(Col, {
            "span": 16
          }, {
            default: function _default10() {
              return [block];
            }
          })];
        }
      })]);
      var hasActiveTabKey = activeTabKey !== void 0;
      var tabsProps3 = (_tabsProps = {
        size: "large"
      }, _defineProperty$U(_tabsProps, hasActiveTabKey ? "activeKey" : "defaultActiveKey", hasActiveTabKey ? activeTabKey : defaultActiveTabKey), _defineProperty$U(_tabsProps, "onChange", triggerTabChange), _defineProperty$U(_tabsProps, "class", "".concat(pre, "-head-tabs")), _tabsProps);
      var head;
      var tabs = tabList && tabList.length ? createVNode(Tabs, tabsProps3, {
        default: function _default9() {
          return [tabList.map(function(item) {
            var temp = item.tab, itemSlots = item.slots;
            var name2 = itemSlots === null || itemSlots === void 0 ? void 0 : itemSlots.tab;
            devWarning(!itemSlots, "Card", "tabList slots is deprecated, Please use `customTab` instead.");
            var tab = temp !== void 0 ? temp : slots[name2] ? slots[name2](item) : null;
            tab = renderSlot(slots, "customTab", item, function() {
              return [tab];
            });
            return createVNode(TabPane, {
              "tab": tab,
              "key": item.key,
              "disabled": item.disabled
            }, null);
          })];
        },
        rightExtra: tabBarExtraContent ? function() {
          return tabBarExtraContent;
        } : null
      }) : null;
      if (title || extra || tabs) {
        head = createVNode("div", {
          "class": "".concat(pre, "-head"),
          "style": headStyle
        }, [createVNode("div", {
          "class": "".concat(pre, "-head-wrapper")
        }, [title && createVNode("div", {
          "class": "".concat(pre, "-head-title")
        }, [title]), extra && createVNode("div", {
          "class": "".concat(pre, "-extra")
        }, [extra])]), tabs]);
      }
      var coverDom = cover ? createVNode("div", {
        "class": "".concat(pre, "-cover")
      }, [cover]) : null;
      var body = createVNode("div", {
        "class": "".concat(pre, "-body"),
        "style": bodyStyle
      }, [loading ? loadingBlock : children]);
      var actionDom = actions && actions.length ? createVNode("ul", {
        "class": "".concat(pre, "-actions")
      }, [getAction(actions)]) : null;
      return createVNode("div", {
        "class": classString,
        "ref": "cardContainerRef"
      }, [head, coverDom, children && children.length ? body : null, actionDom]);
    };
  }
});
const Card$1 = Card;
var cardMetaProps = function cardMetaProps2() {
  return {
    prefixCls: String,
    title: PropTypes$1.any,
    description: PropTypes$1.any,
    avatar: PropTypes$1.any
  };
};
const Meta = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardMeta",
  props: cardMetaProps(),
  slots: ["title", "description", "avatar"],
  setup: function setup84(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var classString = _defineProperty$U({}, "".concat(prefixCls.value, "-meta"), true);
      var avatar = getPropsSlot(slots, props3, "avatar");
      var title = getPropsSlot(slots, props3, "title");
      var description = getPropsSlot(slots, props3, "description");
      var avatarDom = avatar ? createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-avatar")
      }, [avatar]) : null;
      var titleDom = title ? createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-title")
      }, [title]) : null;
      var descriptionDom = description ? createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-description")
      }, [description]) : null;
      var MetaDetail = titleDom || descriptionDom ? createVNode("div", {
        "class": "".concat(prefixCls.value, "-meta-detail")
      }, [titleDom, descriptionDom]) : null;
      return createVNode("div", {
        "class": classString
      }, [avatarDom, MetaDetail]);
    };
  }
});
var cardGridProps = function cardGridProps2() {
  return {
    prefixCls: String,
    hoverable: {
      type: Boolean,
      default: true
    }
  };
};
const Grid = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACardGrid",
  __ANT_CARD_GRID: true,
  props: cardGridProps(),
  setup: function setup85(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("card", props3), prefixCls = _useConfigInject.prefixCls;
    var classNames2 = computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value, "-grid"), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-grid-hoverable"), props3.hoverable), _ref2;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": classNames2.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
Card$1.Meta = Meta;
Card$1.Grid = Grid;
Card$1.install = function(app) {
  app.component(Card$1.name, Card$1);
  app.component(Meta.name, Meta);
  app.component(Grid.name, Grid);
  return app;
};
var collapseProps = function collapseProps2() {
  return {
    prefixCls: String,
    activeKey: {
      type: [Array, Number, String]
    },
    defaultActiveKey: {
      type: [Array, Number, String]
    },
    accordion: {
      type: Boolean,
      default: void 0
    },
    destroyInactivePanel: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    expandIcon: Function,
    openAnimation: PropTypes$1.object,
    expandIconPosition: PropTypes$1.oneOf(tuple$1("left", "right")),
    collapsible: {
      type: String
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    "onUpdate:activeKey": Function
  };
};
var collapsePanelProps = function collapsePanelProps2() {
  return {
    openAnimation: PropTypes$1.object,
    prefixCls: String,
    header: PropTypes$1.any,
    headerClass: String,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    isActive: {
      type: Boolean,
      default: void 0
    },
    destroyInactivePanel: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    accordion: {
      type: Boolean,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    expandIcon: Function,
    extra: PropTypes$1.any,
    panelKey: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    collapsible: {
      type: String
    },
    role: String,
    onItemClick: {
      type: Function
    }
  };
};
function getActiveKeysArray(activeKey) {
  var currentActiveKey = activeKey;
  if (!Array.isArray(currentActiveKey)) {
    var activeKeyType = _typeof$3(currentActiveKey);
    currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
  }
  return currentActiveKey.map(function(key2) {
    return String(key2);
  });
}
const Collapse = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapse",
  inheritAttrs: false,
  props: initDefaultProps$1(collapseProps(), {
    accordion: false,
    destroyInactivePanel: false,
    bordered: true,
    openAnimation: collapseMotion$1("ant-motion-collapse", false),
    expandIconPosition: "left"
  }),
  slots: ["expandIcon"],
  setup: function setup86(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var stateActiveKey = ref(getActiveKeysArray(firstNotUndefined([props3.activeKey, props3.defaultActiveKey])));
    watch(function() {
      return props3.activeKey;
    }, function() {
      stateActiveKey.value = getActiveKeysArray(props3.activeKey);
    }, {
      deep: true
    });
    var _useConfigInject = useConfigInject("collapse", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var iconPosition = computed(function() {
      var expandIconPosition = props3.expandIconPosition;
      if (expandIconPosition !== void 0) {
        return expandIconPosition;
      }
      return direction.value === "rtl" ? "right" : "left";
    });
    var renderExpandIcon2 = function renderExpandIcon3(panelProps) {
      var _props$expandIcon = props3.expandIcon, expandIcon = _props$expandIcon === void 0 ? slots.expandIcon : _props$expandIcon;
      var icon = expandIcon ? expandIcon(panelProps) : createVNode(RightOutlined$1, {
        "rotate": panelProps.isActive ? 90 : void 0
      }, null);
      return createVNode("div", null, [isValidElement(Array.isArray(expandIcon) ? icon[0] : icon) ? cloneElement(icon, {
        class: "".concat(prefixCls.value, "-arrow")
      }, false) : icon]);
    };
    var setActiveKey = function setActiveKey2(activeKey) {
      if (props3.activeKey === void 0) {
        stateActiveKey.value = activeKey;
      }
      var newKey = props3.accordion ? activeKey[0] : activeKey;
      emit("update:activeKey", newKey);
      emit("change", newKey);
    };
    var onClickItem = function onClickItem2(key2) {
      var activeKey = stateActiveKey.value;
      if (props3.accordion) {
        activeKey = activeKey[0] === key2 ? [] : [key2];
      } else {
        activeKey = _toConsumableArray(activeKey);
        var index2 = activeKey.indexOf(key2);
        var isActive = index2 > -1;
        if (isActive) {
          activeKey.splice(index2, 1);
        } else {
          activeKey.push(key2);
        }
      }
      setActiveKey(activeKey);
    };
    var getNewChild = function getNewChild2(child, index2) {
      var _child$key, _child$children, _child$children$heade;
      if (isEmptyElement(child))
        return;
      var activeKey = stateActiveKey.value;
      var accordion = props3.accordion, destroyInactivePanel = props3.destroyInactivePanel, collapsible = props3.collapsible, openAnimation = props3.openAnimation;
      var key2 = String((_child$key = child.key) !== null && _child$key !== void 0 ? _child$key : index2);
      var _ref2 = child.props || {}, _ref2$header = _ref2.header, header = _ref2$header === void 0 ? (_child$children = child.children) === null || _child$children === void 0 ? void 0 : (_child$children$heade = _child$children.header) === null || _child$children$heade === void 0 ? void 0 : _child$children$heade.call(_child$children) : _ref2$header, headerClass = _ref2.headerClass, childCollapsible = _ref2.collapsible, disabled = _ref2.disabled;
      var isActive = false;
      if (accordion) {
        isActive = activeKey[0] === key2;
      } else {
        isActive = activeKey.indexOf(key2) > -1;
      }
      var mergeCollapsible = childCollapsible !== null && childCollapsible !== void 0 ? childCollapsible : collapsible;
      if (disabled || disabled === "") {
        mergeCollapsible = "disabled";
      }
      var newProps = {
        key: key2,
        panelKey: key2,
        header,
        headerClass,
        isActive,
        prefixCls: prefixCls.value,
        destroyInactivePanel,
        openAnimation,
        accordion,
        onItemClick: mergeCollapsible === "disabled" ? null : onClickItem,
        expandIcon: renderExpandIcon2,
        collapsible: mergeCollapsible
      };
      return cloneElement(child, newProps);
    };
    var getItems = function getItems2() {
      var _slots$default;
      return flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)).map(getNewChild);
    };
    return function() {
      var _classNames;
      var accordion = props3.accordion, bordered = props3.bordered, ghost = props3.ghost;
      var collapseClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, prefixCls.value, true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-borderless"), !bordered), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-icon-position-").concat(iconPosition.value), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-ghost"), !!ghost), _defineProperty$U(_classNames, attrs.class, !!attrs.class), _classNames));
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "class": collapseClassName
      }, getDataAndAriaProps(attrs)), {}, {
        "style": attrs.style,
        "role": accordion ? "tablist" : null
      }), [getItems()]);
    };
  }
});
const PanelContent = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContent",
  props: collapsePanelProps(),
  setup: function setup87(props3, _ref) {
    var slots = _ref.slots;
    var rendered = ref(false);
    watchEffect(function() {
      if (props3.isActive || props3.forceRender) {
        rendered.value = true;
      }
    });
    return function() {
      var _classNames, _slots$default;
      if (!rendered.value)
        return null;
      var prefixCls = props3.prefixCls, isActive = props3.isActive, role = props3.role;
      return createVNode("div", {
        "ref": ref,
        "class": classNames("".concat(prefixCls, "-content"), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-content-active"), isActive), _defineProperty$U(_classNames, "".concat(prefixCls, "-content-inactive"), !isActive), _classNames)),
        "role": role
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-content-box")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
    };
  }
});
const CollapsePanel = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapsePanel",
  inheritAttrs: false,
  props: initDefaultProps$1(collapsePanelProps(), {
    showArrow: true,
    isActive: false,
    onItemClick: function onItemClick() {
    },
    headerClass: "",
    forceRender: false
  }),
  slots: ["expandIcon", "extra", "header"],
  setup: function setup88(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    devWarning(props3.disabled === void 0, "Collapse.Panel", '`disabled` is deprecated. Please use `collapsible="disabled"` instead.');
    var _useConfigInject = useConfigInject("collapse", props3), prefixCls = _useConfigInject.prefixCls;
    var handleItemClick = function handleItemClick2() {
      emit("itemClick", props3.panelKey);
    };
    var handleKeyPress = function handleKeyPress2(e2) {
      if (e2.key === "Enter" || e2.keyCode === 13 || e2.which === 13) {
        handleItemClick();
      }
    };
    return function() {
      var _slots$header, _slots$extra, _classNames, _classNames2;
      var _props$header = props3.header, header = _props$header === void 0 ? (_slots$header = slots.header) === null || _slots$header === void 0 ? void 0 : _slots$header.call(slots) : _props$header, headerClass = props3.headerClass, isActive = props3.isActive, showArrow = props3.showArrow, destroyInactivePanel = props3.destroyInactivePanel, accordion = props3.accordion, forceRender = props3.forceRender, openAnimation = props3.openAnimation, _props$expandIcon = props3.expandIcon, expandIcon = _props$expandIcon === void 0 ? slots.expandIcon : _props$expandIcon, _props$extra = props3.extra, extra = _props$extra === void 0 ? (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots) : _props$extra, collapsible = props3.collapsible;
      var disabled = collapsible === "disabled";
      var prefixClsValue = prefixCls.value;
      var headerCls = classNames("".concat(prefixClsValue, "-header"), (_classNames = {}, _defineProperty$U(_classNames, headerClass, headerClass), _defineProperty$U(_classNames, "".concat(prefixClsValue, "-header-collapsible-only"), collapsible === "header"), _classNames));
      var itemCls = classNames((_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixClsValue, "-item"), true), _defineProperty$U(_classNames2, "".concat(prefixClsValue, "-item-active"), isActive), _defineProperty$U(_classNames2, "".concat(prefixClsValue, "-item-disabled"), disabled), _defineProperty$U(_classNames2, "".concat(prefixClsValue, "-no-arrow"), !showArrow), _defineProperty$U(_classNames2, "".concat(attrs.class), !!attrs.class), _classNames2));
      var icon = createVNode("i", {
        "class": "arrow"
      }, null);
      if (showArrow && typeof expandIcon === "function") {
        icon = expandIcon(props3);
      }
      var panelContent = withDirectives(createVNode(PanelContent, {
        "prefixCls": prefixClsValue,
        "isActive": isActive,
        "forceRender": forceRender,
        "role": accordion ? "tabpanel" : null
      }, {
        default: slots.default
      }), [[vShow, isActive]]);
      var transitionProps = _objectSpread2$1({
        appear: false,
        css: false
      }, openAnimation);
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": itemCls
      }), [createVNode("div", {
        "class": headerCls,
        "onClick": function onClick2() {
          return collapsible !== "header" && handleItemClick();
        },
        "role": accordion ? "tab" : "button",
        "tabindex": disabled ? -1 : 0,
        "aria-expanded": isActive,
        "onKeypress": handleKeyPress
      }, [showArrow && icon, collapsible === "header" ? createVNode("span", {
        "onClick": handleItemClick,
        "class": "".concat(prefixClsValue, "-header-text")
      }, [header]) : header, extra && createVNode("div", {
        "class": "".concat(prefixClsValue, "-extra")
      }, [extra])]), createVNode(Transition, transitionProps, {
        default: function _default9() {
          return [!destroyInactivePanel || isActive ? panelContent : null];
        }
      })]);
    };
  }
});
Collapse.Panel = CollapsePanel;
Collapse.install = function(app) {
  app.component(Collapse.name, Collapse);
  app.component(CollapsePanel.name, CollapsePanel);
  return app;
};
var camel2hyphen = function camel2hyphen2(str) {
  return str.replace(/[A-Z]/g, function(match2) {
    return "-" + match2.toLowerCase();
  }).toLowerCase();
};
var isDimension = function isDimension2(feature) {
  var re = /[height|width]$/;
  return re.test(feature);
};
var obj2mq = function obj2mq2(obj) {
  var mq = "";
  var features = Object.keys(obj);
  features.forEach(function(feature, index2) {
    var value = obj[feature];
    feature = camel2hyphen(feature);
    if (isDimension(feature) && typeof value === "number") {
      value = value + "px";
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += "not " + feature;
    } else {
      mq += "(" + feature + ": " + value + ")";
    }
    if (index2 < features.length - 1) {
      mq += " and ";
    }
  });
  return mq;
};
function json2mq(query) {
  var mq = "";
  if (typeof query === "string") {
    return query;
  }
  if (query instanceof Array) {
    query.forEach(function(q2, index2) {
      mq += obj2mq(q2);
      if (index2 < query.length - 1) {
        mq += ", ";
      }
    });
    return mq;
  }
  return obj2mq(query);
}
var now$1 = function() {
  return root$2.Date.now();
};
const now$2 = now$1;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args2 = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args2);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$2();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$2());
  }
  function debounced() {
    var time = now$2(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var defaultProps$2 = {
  accessibility: {
    type: Boolean,
    default: true
  },
  adaptiveHeight: {
    type: Boolean,
    default: false
  },
  afterChange: PropTypes$1.any.def(null),
  arrows: {
    type: Boolean,
    default: true
  },
  autoplay: {
    type: Boolean,
    default: false
  },
  autoplaySpeed: PropTypes$1.number.def(3e3),
  beforeChange: PropTypes$1.any.def(null),
  centerMode: {
    type: Boolean,
    default: false
  },
  centerPadding: PropTypes$1.string.def("50px"),
  cssEase: PropTypes$1.string.def("ease"),
  dots: {
    type: Boolean,
    default: false
  },
  dotsClass: PropTypes$1.string.def("slick-dots"),
  draggable: {
    type: Boolean,
    default: true
  },
  unslick: {
    type: Boolean,
    default: false
  },
  easing: PropTypes$1.string.def("linear"),
  edgeFriction: PropTypes$1.number.def(0.35),
  fade: {
    type: Boolean,
    default: false
  },
  focusOnSelect: {
    type: Boolean,
    default: false
  },
  infinite: {
    type: Boolean,
    default: true
  },
  initialSlide: PropTypes$1.number.def(0),
  lazyLoad: PropTypes$1.any.def(null),
  verticalSwiping: {
    type: Boolean,
    default: false
  },
  asNavFor: PropTypes$1.any.def(null),
  pauseOnDotsHover: {
    type: Boolean,
    default: false
  },
  pauseOnFocus: {
    type: Boolean,
    default: false
  },
  pauseOnHover: {
    type: Boolean,
    default: true
  },
  responsive: PropTypes$1.array,
  rows: PropTypes$1.number.def(1),
  rtl: {
    type: Boolean,
    default: false
  },
  slide: PropTypes$1.string.def("div"),
  slidesPerRow: PropTypes$1.number.def(1),
  slidesToScroll: PropTypes$1.number.def(1),
  slidesToShow: PropTypes$1.number.def(1),
  speed: PropTypes$1.number.def(500),
  swipe: {
    type: Boolean,
    default: true
  },
  swipeEvent: PropTypes$1.any.def(null),
  swipeToSlide: {
    type: Boolean,
    default: false
  },
  touchMove: {
    type: Boolean,
    default: true
  },
  touchThreshold: PropTypes$1.number.def(5),
  useCSS: {
    type: Boolean,
    default: true
  },
  useTransform: {
    type: Boolean,
    default: true
  },
  variableWidth: {
    type: Boolean,
    default: false
  },
  vertical: {
    type: Boolean,
    default: false
  },
  waitForAnimate: {
    type: Boolean,
    default: true
  },
  children: PropTypes$1.array,
  __propsSymbol__: PropTypes$1.any
};
const defaultProps$3 = defaultProps$2;
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
const initialState$1 = initialState;
function clamp(number4, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number4, upperBound));
}
var safePreventDefault = function safePreventDefault2(event2) {
  var passiveEvents = ["touchstart", "touchmove", "wheel"];
  if (!passiveEvents.includes(event2.type)) {
    event2.preventDefault();
  }
};
var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth2(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var swipeAngle;
  var xDist = touchObject.startX - touchObject.curX;
  var yDist = touchObject.startY - touchObject.curY;
  var r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = function extractObject2(spec, keys2) {
  var newObject = {};
  keys2.forEach(function(key2) {
    return newObject[key2] = spec[key2];
  });
  return newObject;
};
var initializedState = function initializedState2(spec) {
  var slideCount = spec.children.length;
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth(listNode));
  var trackNode = spec.trackRef;
  var trackWidth = Math.ceil(getWidth(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = function slideHandler2(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating)
    return {};
  var animationSlide = index2;
  var finalSlide;
  var animationLeft;
  var finalLeft;
  var state = {};
  var nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0) {
        finalSlide = slideCount - slideCount % slidesToScroll;
      }
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = function changeSlide2(spec, options) {
  var previousInt, slideOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  var unevenOffset = slideCount % slidesToScroll !== 0;
  var indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = function keyHandler2(e2, accessibility, rtl2) {
  if (e2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility) {
    return "";
  }
  if (e2.keyCode === 37)
    return rtl2 ? "next" : "previous";
  if (e2.keyCode === 39)
    return rtl2 ? "previous" : "next";
  return "";
};
var swipeStart = function swipeStart2(e2, swipe, draggable) {
  e2.target.tagName === "IMG" && safePreventDefault(e2);
  if (!swipe || !draggable && e2.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      startY: e2.touches ? e2.touches[0].pageY : e2.clientY,
      curX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      curY: e2.touches ? e2.touches[0].pageY : e2.clientY
    }
  };
};
var swipeMove = function swipeMove2(e2, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl2 = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e2);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e2);
  var swipeLeft;
  var state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e2.touches ? e2.touches[0].pageX : e2.clientX;
  touchObject.curY = e2.touches ? e2.touches[0].pageY : e2.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl2 ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping) {
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  }
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl2) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread2$1(_objectSpread2$1({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e2);
  }
  return state;
};
var swipeEnd = function swipeEnd2(e2, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e2);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e2);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = function getNavigableIndexes2(spec) {
  var max3 = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max3) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
};
var getSlideCount = function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {
  return keysArray.reduce(function(value, key2) {
    return value && spec.hasOwnProperty(key2);
  }, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform2 = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
      WebkitTransform,
      transform: transform2,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = {
      opacity: 1
    };
  if (trackWidth)
    style2.width = trackWidth + "px";
  if (trackHeight)
    style2.height = trackHeight + "px";
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
};
var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getTrackLeft = function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
};
var getTotalSlides = function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = function slidesOnRight2(_ref) {
  var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl2 = _ref.rtl, centerPadding = _ref.centerPadding;
  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl2 && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl2) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl2 = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl2 && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl2) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var getSlideClasses = function getSlideClasses2(spec) {
  var slickActive, slickCenter;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  var slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
  };
};
var getSlideStyle = function getSlideStyle2(spec) {
  var style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth + (typeof spec.slideWidth === "number" ? "px" : "");
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical) {
      style2.top = -spec.index * parseInt(spec.slideHeight) + "px";
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth) + "px";
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getKey$1 = function getKey(child, fallbackKey) {
  return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides2(spec, children) {
  var key2;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = children.length;
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  children.forEach(function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = createVNode("div");
    }
    var childStyle = getSlideStyle(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.class || "";
    var slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      index: index2
    }));
    slides.push(cloneElement(child, {
      key: "original" + getKey$1(child, index2),
      tabindex: "-1",
      "data-index": index2,
      "aria-hidden": !slideClasses["slick-active"],
      class: classNames(slideClasses, slideClass),
      style: _objectSpread2$1(_objectSpread2$1({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: function onClick2() {
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && spec.fade === false) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
        key2 = -preCloneNo;
        if (key2 >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          index: key2
        }));
        preCloneSlides.push(cloneElement(child, {
          key: "precloned" + getKey$1(child, key2),
          class: classNames(slideClasses, slideClass),
          tabindex: "-1",
          "data-index": key2,
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2$1(_objectSpread2$1({}, child.props.style || {}), childStyle),
          onClick: function onClick2() {
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (childrenCount !== spec.slidesToShow) {
        key2 = childrenCount + index2;
        if (key2 < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          index: key2
        }));
        postCloneSlides.push(cloneElement(child, {
          key: "postcloned" + getKey$1(child, key2),
          tabindex: "-1",
          "data-index": key2,
          "aria-hidden": !slideClasses["slick-active"],
          class: classNames(slideClasses, slideClass),
          style: _objectSpread2$1(_objectSpread2$1({}, child.props.style || {}), childStyle),
          onClick: function onClick2() {
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track$2 = function Track(_2, _ref) {
  var attrs = _ref.attrs, slots = _ref.slots;
  var slides = renderSlides(attrs, flattenChildren(slots === null || slots === void 0 ? void 0 : slots.default()));
  var onMouseenter2 = attrs.onMouseenter, onMouseover = attrs.onMouseover, onMouseleave2 = attrs.onMouseleave;
  var mouseEvents = {
    onMouseenter: onMouseenter2,
    onMouseover,
    onMouseleave: onMouseleave2
  };
  var trackProps = _objectSpread2$1({
    class: "slick-track",
    style: attrs.trackStyle
  }, mouseEvents);
  return createVNode("div", trackProps, [slides]);
};
Track$2.inheritAttrs = false;
const Track$3 = Track$2;
var getDotCount = function getDotCount2(spec) {
  var dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = function Dots2(_2, _ref) {
  var attrs = _ref.attrs;
  var slideCount = attrs.slideCount, slidesToScroll = attrs.slidesToScroll, slidesToShow = attrs.slidesToShow, infinite = attrs.infinite, currentSlide = attrs.currentSlide, appendDots2 = attrs.appendDots, customPaging2 = attrs.customPaging, clickHandler2 = attrs.clickHandler, dotsClass = attrs.dotsClass, onMouseenter2 = attrs.onMouseenter, onMouseover = attrs.onMouseover, onMouseleave2 = attrs.onMouseleave;
  var dotCount = getDotCount({
    slideCount,
    slidesToScroll,
    slidesToShow,
    infinite
  });
  var mouseEvents = {
    onMouseenter: onMouseenter2,
    onMouseover,
    onMouseleave: onMouseleave2
  };
  var dots = [];
  var _loop = function _loop2(i3) {
    var _rightBound = (i3 + 1) * slidesToScroll - 1;
    var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
    var _leftBound = rightBound - (slidesToScroll - 1);
    var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
    var className = classNames({
      "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
    });
    var dotOptions = {
      message: "dots",
      index: i3,
      slidesToScroll,
      currentSlide
    };
    function onClick2(e2) {
      if (e2) {
        e2.preventDefault();
      }
      clickHandler2(dotOptions);
    }
    dots = dots.concat(createVNode("li", {
      "key": i3,
      "class": className
    }, [cloneElement(customPaging2({
      i: i3
    }), {
      onClick: onClick2
    })]));
  };
  for (var i2 = 0; i2 < dotCount; i2++) {
    _loop(i2);
  }
  return cloneElement(appendDots2({
    dots
  }), _objectSpread2$1({
    class: dotsClass
  }, mouseEvents));
};
Dots.inheritAttrs = false;
const Dots$1 = Dots;
function noop$8() {
}
function handler2(options, handle, e2) {
  if (e2) {
    e2.preventDefault();
  }
  handle(options, e2);
}
var PrevArrow = function PrevArrow2(_2, _ref) {
  var attrs = _ref.attrs;
  var clickHandler2 = attrs.clickHandler, infinite = attrs.infinite, currentSlide = attrs.currentSlide, slideCount = attrs.slideCount, slidesToShow = attrs.slidesToShow;
  var prevClasses = {
    "slick-arrow": true,
    "slick-prev": true
  };
  var prevHandler = function prevHandler2(e2) {
    handler2({
      message: "previous"
    }, clickHandler2, e2);
  };
  if (!infinite && (currentSlide === 0 || slideCount <= slidesToShow)) {
    prevClasses["slick-disabled"] = true;
    prevHandler = noop$8;
  }
  var prevArrowProps = {
    key: "0",
    "data-role": "none",
    class: prevClasses,
    style: {
      display: "block"
    },
    onClick: prevHandler
  };
  var customProps = {
    currentSlide,
    slideCount
  };
  var prevArrow;
  if (attrs.prevArrow) {
    prevArrow = cloneElement(attrs.prevArrow(_objectSpread2$1(_objectSpread2$1({}, prevArrowProps), customProps)), {
      key: "0",
      class: prevClasses,
      style: {
        display: "block"
      },
      onClick: prevHandler
    }, false);
  } else {
    prevArrow = createVNode("button", _objectSpread2$1({
      "key": "0",
      "type": "button"
    }, prevArrowProps), [" ", createTextVNode("Previous")]);
  }
  return prevArrow;
};
PrevArrow.inheritAttrs = false;
var NextArrow = function NextArrow2(_2, _ref2) {
  var attrs = _ref2.attrs;
  var clickHandler2 = attrs.clickHandler, currentSlide = attrs.currentSlide, slideCount = attrs.slideCount;
  var nextClasses = {
    "slick-arrow": true,
    "slick-next": true
  };
  var nextHandler = function nextHandler2(e2) {
    handler2({
      message: "next"
    }, clickHandler2, e2);
  };
  if (!canGoNext(attrs)) {
    nextClasses["slick-disabled"] = true;
    nextHandler = noop$8;
  }
  var nextArrowProps = {
    key: "1",
    "data-role": "none",
    class: classNames(nextClasses),
    style: {
      display: "block"
    },
    onClick: nextHandler
  };
  var customProps = {
    currentSlide,
    slideCount
  };
  var nextArrow;
  if (attrs.nextArrow) {
    nextArrow = cloneElement(attrs.nextArrow(_objectSpread2$1(_objectSpread2$1({}, nextArrowProps), customProps)), {
      key: "1",
      class: classNames(nextClasses),
      style: {
        display: "block"
      },
      onClick: nextHandler
    }, false);
  } else {
    nextArrow = createVNode("button", _objectSpread2$1({
      "key": "1",
      "type": "button"
    }, nextArrowProps), [" ", createTextVNode("Next")]);
  }
  return nextArrow;
};
NextArrow.inheritAttrs = false;
var _excluded$I = ["animating"];
function noop$7() {
}
const InnerSlider = {
  name: "InnerSlider",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: _objectSpread2$1({}, defaultProps$3),
  data: function data2() {
    this.preProps = _objectSpread2$1({}, this.$props);
    this.list = null;
    this.track = null;
    this.callbackTimers = [];
    this.clickable = true;
    this.debouncedResize = null;
    var ssrState = this.ssrInit();
    return _objectSpread2$1(_objectSpread2$1({}, initialState$1), {}, {
      currentSlide: this.initialSlide,
      slideCount: this.children.length
    }, ssrState);
  },
  watch: {
    __propsSymbol__: function __propsSymbol__() {
      var _this = this;
      var nextProps = this.$props;
      var spec = _objectSpread2$1(_objectSpread2$1({
        listRef: this.list,
        trackRef: this.track
      }, nextProps), this.$data);
      var setTrackStyle = false;
      for (var _i = 0, _Object$keys = Object.keys(this.preProps); _i < _Object$keys.length; _i++) {
        var key2 = _Object$keys[_i];
        if (!nextProps.hasOwnProperty(key2)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof$3(nextProps[key2]) === "object" || typeof nextProps[key2] === "function" || _typeof$3(nextProps[key2]) === "symbol") {
          continue;
        }
        if (nextProps[key2] !== this.preProps[key2]) {
          setTrackStyle = true;
          break;
        }
      }
      this.updateState(spec, setTrackStyle, function() {
        if (_this.currentSlide >= nextProps.children.length) {
          _this.changeSlide({
            message: "index",
            index: nextProps.children.length - nextProps.slidesToShow,
            currentSlide: _this.currentSlide
          });
        }
        if (!_this.preProps.autoplay && nextProps.autoplay) {
          _this.handleAutoPlay("playing");
        } else if (nextProps.autoplay) {
          _this.handleAutoPlay("update");
        } else {
          _this.pause("paused");
        }
      });
      this.preProps = _objectSpread2$1({}, nextProps);
    }
  },
  mounted: function mounted3() {
    var _this2 = this;
    this.__emit("init");
    if (this.lazyLoad) {
      var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data));
      if (slidesToLoad.length > 0) {
        this.setState(function(prevState) {
          return {
            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.__emit("lazyLoad", slidesToLoad);
      }
    }
    this.$nextTick(function() {
      var spec = _objectSpread2$1({
        listRef: _this2.list,
        trackRef: _this2.track,
        children: _this2.children
      }, _this2.$props);
      _this2.updateState(spec, true, function() {
        _this2.adaptHeight();
        _this2.autoplay && _this2.handleAutoPlay("playing");
      });
      if (_this2.lazyLoad === "progressive") {
        _this2.lazyLoadTimer = setInterval(_this2.progressiveLazyLoad, 1e3);
      }
      _this2.ro = new index$m(function() {
        if (_this2.animating) {
          _this2.onWindowResized(false);
          _this2.callbackTimers.push(setTimeout(function() {
            return _this2.onWindowResized();
          }, _this2.speed));
        } else {
          _this2.onWindowResized();
        }
      });
      _this2.ro.observe(_this2.list);
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this2.$props.pauseOnFocus ? _this2.onSlideFocus : null;
        slide.onblur = _this2.$props.pauseOnFocus ? _this2.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this2.onWindowResized);
      } else {
        window.attachEvent("onresize", _this2.onWindowResized);
      }
    });
  },
  beforeUnmount: function beforeUnmount3() {
    var _this$ro;
    if (this.animationEndCallback) {
      clearTimeout(this.animationEndCallback);
    }
    if (this.lazyLoadTimer) {
      clearInterval(this.lazyLoadTimer);
    }
    if (this.callbackTimers.length) {
      this.callbackTimers.forEach(function(timer) {
        return clearTimeout(timer);
      });
      this.callbackTimers = [];
    }
    if (window.addEventListener) {
      window.removeEventListener("resize", this.onWindowResized);
    } else {
      window.detachEvent("onresize", this.onWindowResized);
    }
    if (this.autoplayTimer) {
      clearInterval(this.autoplayTimer);
    }
    (_this$ro = this.ro) === null || _this$ro === void 0 ? void 0 : _this$ro.disconnect();
  },
  updated: function updated2() {
    this.checkImagesLoad();
    this.__emit("reInit");
    if (this.lazyLoad) {
      var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data));
      if (slidesToLoad.length > 0) {
        this.setState(function(prevState) {
          return {
            lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.__emit("lazyLoad");
      }
    }
    this.adaptHeight();
  },
  methods: {
    listRefHandler: function listRefHandler(ref2) {
      this.list = ref2;
    },
    trackRefHandler: function trackRefHandler(ref2) {
      this.track = ref2;
    },
    adaptHeight: function adaptHeight() {
      if (this.adaptiveHeight && this.list) {
        var elem = this.list.querySelector('[data-index="'.concat(this.currentSlide, '"]'));
        this.list.style.height = getHeight(elem) + "px";
      }
    },
    onWindowResized: function onWindowResized(setTrackStyle) {
      var _this3 = this;
      if (this.debouncedResize)
        this.debouncedResize.cancel();
      this.debouncedResize = debounce(function() {
        return _this3.resizeWindow(setTrackStyle);
      }, 50);
      this.debouncedResize();
    },
    resizeWindow: function resizeWindow() {
      var _this4 = this;
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(this.track);
      if (!isTrackMounted)
        return;
      var spec = _objectSpread2$1(_objectSpread2$1({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props), this.$data);
      this.updateState(spec, setTrackStyle, function() {
        if (_this4.autoplay) {
          _this4.handleAutoPlay("update");
        } else {
          _this4.pause("paused");
        }
      });
      this.setState({
        animating: false
      });
      clearTimeout(this.animationEndCallback);
      delete this.animationEndCallback;
    },
    updateState: function updateState(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = _objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);
      if (setTrackStyle || this.children.length !== spec.children.length) {
        updatedState["trackStyle"] = trackStyle;
      }
      this.setState(updatedState, callback);
    },
    ssrInit: function ssrInit() {
      var children = this.children;
      if (this.variableWidth) {
        var _trackWidth = 0;
        var _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
          slideCount: children.length
        }));
        var postClones = getPostClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
          slideCount: children.length
        }));
        children.forEach(function(child) {
          var _child$props$style, _child$props$style$wi;
          var childWidth = ((_child$props$style = child.props.style) === null || _child$props$style === void 0 ? void 0 : (_child$props$style$wi = _child$props$style.width) === null || _child$props$style$wi === void 0 ? void 0 : _child$props$style$wi.split("px")[0]) || 0;
          childrenWidths.push(childWidth);
          _trackWidth += childWidth;
        });
        for (var i2 = 0; i2 < preClones; i2++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i2];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i2];
        }
        for (var _i2 = 0; _i2 < postClones; _i2++) {
          _trackWidth += childrenWidths[_i2];
        }
        for (var _i3 = 0; _i3 < this.currentSlide; _i3++) {
          _trackLeft += childrenWidths[_i3];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (this.centerMode) {
          var currentWidth = "".concat(childrenWidths[this.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = children.length;
      var spec = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
        slideCount: childrenCount
      });
      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / this.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + this.currentSlide) * trackWidth / 100;
      if (this.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    },
    checkImagesLoad: function checkImagesLoad() {
      var _this5 = this;
      var images = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length;
      var loadedCount = 0;
      Array.prototype.forEach.call(images, function(image) {
        var handler5 = function handler6() {
          return ++loadedCount && loadedCount >= imagesCount && _this5.onWindowResized();
        };
        if (!image.onclick) {
          image.onclick = function() {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;
          image.onclick = function() {
            prevClickHandler();
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (_this5.$props.lazyLoad) {
            image.onload = function() {
              _this5.adaptHeight();
              _this5.callbackTimers.push(setTimeout(_this5.onWindowResized, _this5.speed));
            };
          } else {
            image.onload = handler5;
            image.onerror = function() {
              handler5();
              _this5.__emit("lazyLoadError");
            };
          }
        }
      });
    },
    progressiveLazyLoad: function progressiveLazyLoad() {
      var slidesToLoad = [];
      var spec = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data);
      for (var index2 = this.currentSlide; index2 < this.slideCount + getPostClones(spec); index2++) {
        if (this.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index = this.currentSlide - 1; _index >= -getPreClones(spec); _index--) {
        if (this.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        this.__emit("lazyLoad", slidesToLoad);
      } else {
        if (this.lazyLoadTimer) {
          clearInterval(this.lazyLoadTimer);
          delete this.lazyLoadTimer;
        }
      }
    },
    slideHandler: function slideHandler$1(index2) {
      var _this6 = this;
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$$props = this.$props, asNavFor = _this$$props.asNavFor, currentSlide = _this$$props.currentSlide, beforeChange = _this$$props.beforeChange, speed = _this$$props.speed, afterChange = _this$$props.afterChange;
      var _slideHandler2 = slideHandler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        index: index2
      }, this.$props), this.$data), {}, {
        trackRef: this.track,
        useCSS: this.useCSS && !dontAnimate
      })), state = _slideHandler2.state, nextState = _slideHandler2.nextState;
      if (!state)
        return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this6.lazyLoadedList.indexOf(value) < 0;
      });
      if (this.$attrs.onLazyLoad && slidesToLoad.length > 0) {
        this.__emit("lazyLoad", slidesToLoad);
      }
      if (!this.$props.waitForAnimate && this.animationEndCallback) {
        clearTimeout(this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete this.animationEndCallback;
      }
      this.setState(state, function() {
        if (asNavFor && _this6.asNavForIndex !== index2) {
          _this6.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        _this6.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties$2(nextState, _excluded$I);
          _this6.setState(firstBatch, function() {
            _this6.callbackTimers.push(setTimeout(function() {
              return _this6.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this6.animationEndCallback;
          });
        }, speed);
      });
    },
    changeSlide: function changeSlide$1(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data);
      var targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        this.slideHandler(targetSlide, dontAnimate);
      } else {
        this.slideHandler(targetSlide);
      }
      this.$props.autoplay && this.handleAutoPlay("update");
      if (this.$props.focusOnSelect) {
        var nodes = this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    },
    clickHandler: function clickHandler(e2) {
      if (this.clickable === false) {
        e2.stopPropagation();
        e2.preventDefault();
      }
      this.clickable = true;
    },
    keyHandler: function keyHandler$1(e2) {
      var dir = keyHandler(e2, this.accessibility, this.rtl);
      dir !== "" && this.changeSlide({
        message: dir
      });
    },
    selectHandler: function selectHandler(options) {
      this.changeSlide(options);
    },
    disableBodyScroll: function disableBodyScroll() {
      var preventDefault = function preventDefault2(e2) {
        e2 = e2 || window.event;
        if (e2.preventDefault)
          e2.preventDefault();
        e2.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    },
    enableBodyScroll: function enableBodyScroll() {
      window.ontouchmove = null;
    },
    swipeStart: function swipeStart$1(e2) {
      if (this.verticalSwiping) {
        this.disableBodyScroll();
      }
      var state = swipeStart(e2, this.swipe, this.draggable);
      state !== "" && this.setState(state);
    },
    swipeMove: function swipeMove$1(e2) {
      var state = swipeMove(e2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        this.clickable = false;
      }
      this.setState(state);
    },
    swipeEnd: function swipeEnd$1(e2) {
      var state = swipeEnd(e2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data), {}, {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!state)
        return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      this.slideHandler(triggerSlideHandler);
      if (this.$props.verticalSwiping) {
        this.enableBodyScroll();
      }
    },
    touchEnd: function touchEnd(e2) {
      this.swipeEnd(e2);
      this.clickable = true;
    },
    slickPrev: function slickPrev() {
      var _this7 = this;
      this.callbackTimers.push(setTimeout(function() {
        return _this7.changeSlide({
          message: "previous"
        });
      }, 0));
    },
    slickNext: function slickNext() {
      var _this8 = this;
      this.callbackTimers.push(setTimeout(function() {
        return _this8.changeSlide({
          message: "next"
        });
      }, 0));
    },
    slickGoTo: function slickGoTo(slide) {
      var _this9 = this;
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      this.callbackTimers.push(setTimeout(function() {
        return _this9.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this9.currentSlide
        }, dontAnimate);
      }, 0));
    },
    play: function play() {
      var nextIndex;
      if (this.rtl) {
        nextIndex = this.currentSlide - this.slidesToScroll;
      } else {
        if (canGoNext(_objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data))) {
          nextIndex = this.currentSlide + this.slidesToScroll;
        } else {
          return false;
        }
      }
      this.slideHandler(nextIndex);
    },
    handleAutoPlay: function handleAutoPlay(playType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
      }
      var autoplaying = this.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50);
      this.setState({
        autoplaying: "playing"
      });
    },
    pause: function pause(pauseType) {
      if (this.autoplayTimer) {
        clearInterval(this.autoplayTimer);
        this.autoplayTimer = null;
      }
      var autoplaying = this.autoplaying;
      if (pauseType === "paused") {
        this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          this.setState({
            autoplaying: "hovered"
          });
        }
      }
    },
    onDotsOver: function onDotsOver() {
      this.autoplay && this.pause("hovered");
    },
    onDotsLeave: function onDotsLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onTrackOver: function onTrackOver() {
      this.autoplay && this.pause("hovered");
    },
    onTrackLeave: function onTrackLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onSlideFocus: function onSlideFocus() {
      this.autoplay && this.pause("focused");
    },
    onSlideBlur: function onSlideBlur() {
      this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur");
    },
    customPaging: function customPaging(_ref) {
      var i2 = _ref.i;
      return createVNode("button", null, [i2 + 1]);
    },
    appendDots: function appendDots(_ref2) {
      var dots = _ref2.dots;
      return createVNode("ul", {
        "style": {
          display: "block"
        }
      }, [dots]);
    }
  },
  render: function render4() {
    var _listProps, _this10 = this;
    var className = classNames("slick-slider", this.$attrs.class, {
      "slick-vertical": this.vertical,
      "slick-initialized": true
    });
    var spec = _objectSpread2$1(_objectSpread2$1({}, this.$props), this.$data);
    var trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
    var pauseOnHover = this.$props.pauseOnHover;
    trackProps = _objectSpread2$1(_objectSpread2$1({}, trackProps), {}, {
      focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
      ref: this.trackRefHandler,
      onMouseleave: pauseOnHover ? this.onTrackLeave : noop$7,
      onMouseover: pauseOnHover ? this.onTrackOver : noop$7
    });
    var dots;
    if (this.dots === true && this.slideCount >= this.slidesToShow) {
      var dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "infinite", "appendDots"]);
      dotProps.customPaging = this.customPaging;
      dotProps.appendDots = this.appendDots;
      var _this$$slots = this.$slots, customPaging2 = _this$$slots.customPaging, appendDots2 = _this$$slots.appendDots;
      if (customPaging2) {
        dotProps.customPaging = customPaging2;
      }
      if (appendDots2) {
        dotProps.appendDots = appendDots2;
      }
      var pauseOnDotsHover = this.$props.pauseOnDotsHover;
      dotProps = _objectSpread2$1(_objectSpread2$1({}, dotProps), {}, {
        clickHandler: this.changeSlide,
        onMouseover: pauseOnDotsHover ? this.onDotsOver : noop$7,
        onMouseleave: pauseOnDotsHover ? this.onDotsLeave : noop$7
      });
      dots = createVNode(Dots$1, dotProps, null);
    }
    var prevArrow, nextArrow;
    var arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow"]);
    arrowProps.clickHandler = this.changeSlide;
    var _this$$slots2 = this.$slots, prevArrowCustom = _this$$slots2.prevArrow, nextArrowCustom = _this$$slots2.nextArrow;
    if (prevArrowCustom) {
      arrowProps.prevArrow = prevArrowCustom;
    }
    if (nextArrowCustom) {
      arrowProps.nextArrow = nextArrowCustom;
    }
    if (this.arrows) {
      prevArrow = createVNode(PrevArrow, arrowProps, null);
      nextArrow = createVNode(NextArrow, arrowProps, null);
    }
    var verticalHeightStyle = null;
    if (this.vertical) {
      verticalHeightStyle = {
        height: typeof this.listHeight === "number" ? "".concat(this.listHeight, "px") : this.listHeight
      };
    }
    var centerPaddingStyle = null;
    if (this.vertical === false) {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: "0px " + this.centerPadding
        };
      }
    } else {
      if (this.centerMode === true) {
        centerPaddingStyle = {
          padding: this.centerPadding + " 0px"
        };
      }
    }
    var listStyle = _objectSpread2$1(_objectSpread2$1({}, verticalHeightStyle), centerPaddingStyle);
    var touchMove = this.touchMove;
    var listProps3 = (_listProps = {
      ref: this.listRefHandler,
      class: "slick-list",
      style: listStyle,
      onClick: this.clickHandler,
      onMousedown: touchMove ? this.swipeStart : noop$7,
      onMousemove: this.dragging && touchMove ? this.swipeMove : noop$7,
      onMouseup: touchMove ? this.swipeEnd : noop$7,
      onMouseleave: this.dragging && touchMove ? this.swipeEnd : noop$7
    }, _defineProperty$U(_listProps, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", touchMove ? this.swipeStart : noop$7), _defineProperty$U(_listProps, supportsPassive$1 ? "onTouchmovePassive" : "onTouchmove", this.dragging && touchMove ? this.swipeMove : noop$7), _defineProperty$U(_listProps, "onTouchend", touchMove ? this.touchEnd : noop$7), _defineProperty$U(_listProps, "onTouchcancel", this.dragging && touchMove ? this.swipeEnd : noop$7), _defineProperty$U(_listProps, "onKeydown", this.accessibility ? this.keyHandler : noop$7), _listProps);
    var innerSliderProps = {
      class: className,
      dir: "ltr",
      style: this.$attrs.style
    };
    if (this.unslick) {
      listProps3 = {
        class: "slick-list",
        ref: this.listRefHandler
      };
      innerSliderProps = {
        class: className
      };
    }
    return createVNode("div", innerSliderProps, [!this.unslick ? prevArrow : "", createVNode("div", listProps3, [createVNode(Track$3, trackProps, {
      default: function _default9() {
        return [_this10.children];
      }
    })]), !this.unslick ? nextArrow : "", !this.unslick ? dots : ""]);
  }
};
const Slider$2 = defineComponent({
  name: "Slider",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: _objectSpread2$1({}, defaultProps$3),
  data: function data3() {
    this._responsiveMediaHandlers = [];
    return {
      breakpoint: null
    };
  },
  mounted: function mounted4() {
    var _this = this;
    if (this.responsive) {
      var breakpoints = this.responsive.map(function(breakpt) {
        return breakpt.breakpoint;
      });
      breakpoints.sort(function(x2, y2) {
        return x2 - y2;
      });
      breakpoints.forEach(function(breakpoint, index2) {
        var bQuery;
        if (index2 === 0) {
          bQuery = json2mq({
            minWidth: 0,
            maxWidth: breakpoint
          });
        } else {
          bQuery = json2mq({
            minWidth: breakpoints[index2 - 1] + 1,
            maxWidth: breakpoint
          });
        }
        canUseDOM() && _this.media(bQuery, function() {
          _this.setState({
            breakpoint
          });
        });
      });
      var query = json2mq({
        minWidth: breakpoints.slice(-1)[0]
      });
      canUseDOM() && this.media(query, function() {
        _this.setState({
          breakpoint: null
        });
      });
    }
  },
  beforeUnmount: function beforeUnmount4() {
    this._responsiveMediaHandlers.forEach(function(obj) {
      obj.mql.removeListener(obj.listener);
    });
  },
  methods: {
    innerSliderRefHandler: function innerSliderRefHandler(ref2) {
      this.innerSlider = ref2;
    },
    media: function media(query, handler5) {
      var mql = window.matchMedia(query);
      var listener = function listener2(_ref) {
        var matches2 = _ref.matches;
        if (matches2) {
          handler5();
        }
      };
      mql.addListener(listener);
      listener(mql);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    },
    slickPrev: function slickPrev2() {
      var _this$innerSlider;
      (_this$innerSlider = this.innerSlider) === null || _this$innerSlider === void 0 ? void 0 : _this$innerSlider.slickPrev();
    },
    slickNext: function slickNext2() {
      var _this$innerSlider2;
      (_this$innerSlider2 = this.innerSlider) === null || _this$innerSlider2 === void 0 ? void 0 : _this$innerSlider2.slickNext();
    },
    slickGoTo: function slickGoTo2(slide) {
      var _this$innerSlider3;
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      (_this$innerSlider3 = this.innerSlider) === null || _this$innerSlider3 === void 0 ? void 0 : _this$innerSlider3.slickGoTo(slide, dontAnimate);
    },
    slickPause: function slickPause() {
      var _this$innerSlider4;
      (_this$innerSlider4 = this.innerSlider) === null || _this$innerSlider4 === void 0 ? void 0 : _this$innerSlider4.pause("paused");
    },
    slickPlay: function slickPlay() {
      var _this$innerSlider5;
      (_this$innerSlider5 = this.innerSlider) === null || _this$innerSlider5 === void 0 ? void 0 : _this$innerSlider5.handleAutoPlay("play");
    }
  },
  render: function render5() {
    var _this2 = this;
    var settings;
    var newProps;
    if (this.breakpoint) {
      newProps = this.responsive.filter(function(resp) {
        return resp.breakpoint === _this2.breakpoint;
      });
      settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2$1(_objectSpread2$1({}, this.$props), newProps[0].settings);
    } else {
      settings = _objectSpread2$1({}, this.$props);
    }
    if (settings.centerMode) {
      if (settings.slidesToScroll > 1 && false) {
        console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
      }
      settings.slidesToScroll = 1;
    }
    if (settings.fade) {
      if (settings.slidesToShow > 1 && false) {
        console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
      }
      if (settings.slidesToScroll > 1 && false) {
        console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
      }
      settings.slidesToShow = 1;
      settings.slidesToScroll = 1;
    }
    var children = getSlot(this) || [];
    children = children.filter(function(child) {
      if (typeof child === "string") {
        return !!child.trim();
      }
      return !!child;
    });
    if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
      console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
      settings.variableWidth = false;
    }
    var newChildren = [];
    var currentWidth = null;
    for (var i2 = 0; i2 < children.length; i2 += settings.rows * settings.slidesPerRow) {
      var newSlide = [];
      for (var j2 = i2; j2 < i2 + settings.rows * settings.slidesPerRow; j2 += settings.slidesPerRow) {
        var row = [];
        for (var k2 = j2; k2 < j2 + settings.slidesPerRow; k2 += 1) {
          var _children$k$props;
          if (settings.variableWidth && (_children$k$props = children[k2].props) !== null && _children$k$props !== void 0 && _children$k$props.style) {
            currentWidth = children[k2].props.style.width;
          }
          if (k2 >= children.length)
            break;
          row.push(cloneElement(children[k2], {
            key: 100 * i2 + 10 * j2 + k2,
            tabindex: -1,
            style: {
              width: "".concat(100 / settings.slidesPerRow, "%"),
              display: "inline-block"
            }
          }));
        }
        newSlide.push(createVNode("div", {
          "key": 10 * i2 + j2
        }, [row]));
      }
      if (settings.variableWidth) {
        newChildren.push(createVNode("div", {
          "key": i2,
          "style": {
            width: currentWidth
          }
        }, [newSlide]));
      } else {
        newChildren.push(createVNode("div", {
          "key": i2
        }, [newSlide]));
      }
    }
    if (settings === "unslick") {
      var className = "regular slider " + (this.className || "");
      return createVNode("div", {
        "class": className
      }, [children]);
    } else if (newChildren.length <= settings.slidesToShow) {
      settings.unslick = true;
    }
    var sliderProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, this.$attrs), settings), {}, {
      children: newChildren,
      ref: this.innerSliderRefHandler
    });
    return createVNode(InnerSlider, _objectSpread2$1(_objectSpread2$1({}, sliderProps3), {}, {
      "__propsSymbol__": []
    }), this.$slots);
  }
});
var _excluded$H = ["class", "style"];
var carouselProps = function carouselProps2() {
  return {
    effect: String,
    dots: {
      type: Boolean,
      default: true
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    autoplay: {
      type: Boolean,
      default: void 0
    },
    easing: String,
    beforeChange: Function,
    afterChange: Function,
    prefixCls: String,
    accessibility: {
      type: Boolean,
      default: void 0
    },
    nextArrow: PropTypes$1.any,
    prevArrow: PropTypes$1.any,
    pauseOnHover: {
      type: Boolean,
      default: void 0
    },
    adaptiveHeight: {
      type: Boolean,
      default: void 0
    },
    arrows: {
      type: Boolean,
      default: false
    },
    autoplaySpeed: Number,
    centerMode: {
      type: Boolean,
      default: void 0
    },
    centerPadding: String,
    cssEase: String,
    dotsClass: String,
    draggable: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: void 0
    },
    focusOnSelect: {
      type: Boolean,
      default: void 0
    },
    infinite: {
      type: Boolean,
      default: void 0
    },
    initialSlide: Number,
    lazyLoad: String,
    rtl: {
      type: Boolean,
      default: void 0
    },
    slide: String,
    slidesToShow: Number,
    slidesToScroll: Number,
    speed: Number,
    swipe: {
      type: Boolean,
      default: void 0
    },
    swipeToSlide: {
      type: Boolean,
      default: void 0
    },
    swipeEvent: Function,
    touchMove: {
      type: Boolean,
      default: void 0
    },
    touchThreshold: Number,
    variableWidth: {
      type: Boolean,
      default: void 0
    },
    useCSS: {
      type: Boolean,
      default: void 0
    },
    slickGoTo: Number,
    responsive: Array,
    dotPosition: {
      type: String,
      default: void 0
    },
    verticalSwiping: {
      type: Boolean,
      default: false
    }
  };
};
var Carousel = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACarousel",
  inheritAttrs: false,
  props: carouselProps(),
  setup: function setup89(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var slickRef = ref();
    var goTo = function goTo2(slide) {
      var _slickRef$value;
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      (_slickRef$value = slickRef.value) === null || _slickRef$value === void 0 ? void 0 : _slickRef$value.slickGoTo(slide, dontAnimate);
    };
    expose({
      goTo,
      autoplay: function autoplay(palyType) {
        var _slickRef$value2, _slickRef$value2$inne;
        (_slickRef$value2 = slickRef.value) === null || _slickRef$value2 === void 0 ? void 0 : (_slickRef$value2$inne = _slickRef$value2.innerSlider) === null || _slickRef$value2$inne === void 0 ? void 0 : _slickRef$value2$inne.handleAutoPlay(palyType);
      },
      prev: function prev2() {
        var _slickRef$value3;
        (_slickRef$value3 = slickRef.value) === null || _slickRef$value3 === void 0 ? void 0 : _slickRef$value3.slickPrev();
      },
      next: function next2() {
        var _slickRef$value4;
        (_slickRef$value4 = slickRef.value) === null || _slickRef$value4 === void 0 ? void 0 : _slickRef$value4.slickNext();
      },
      innerSlider: computed(function() {
        var _slickRef$value5;
        return (_slickRef$value5 = slickRef.value) === null || _slickRef$value5 === void 0 ? void 0 : _slickRef$value5.innerSlider;
      })
    });
    watchEffect(function() {
      warning$2(props3.vertical === void 0, "Carousel", "`vertical` is deprecated, please use `dotPosition` instead.");
    });
    var _useConfigInject = useConfigInject("carousel", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var dotPosition = computed(function() {
      if (props3.dotPosition)
        return props3.dotPosition;
      if (props3.vertical !== void 0)
        return props3.vertical ? "right" : "bottom";
      return "bottom";
    });
    var vertical = computed(function() {
      return dotPosition.value === "left" || dotPosition.value === "right";
    });
    var dsClass = computed(function() {
      var _classNames;
      var dotsClass = "slick-dots";
      return classNames((_classNames = {}, _defineProperty$U(_classNames, dotsClass, true), _defineProperty$U(_classNames, "".concat(dotsClass, "-").concat(dotPosition.value), true), _defineProperty$U(_classNames, "".concat(props3.dotsClass), !!props3.dotsClass), _classNames));
    });
    return function() {
      var _classNames2;
      var dots = props3.dots, arrows = props3.arrows, draggable = props3.draggable, effect2 = props3.effect;
      var cls = attrs.class, style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded$H);
      var fade = effect2 === "fade" ? true : props3.fade;
      var className = classNames(prefixCls.value, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-vertical"), vertical.value), _defineProperty$U(_classNames2, "".concat(cls), !!cls), _classNames2));
      return createVNode("div", {
        "class": className,
        "style": style2
      }, [createVNode(Slider$2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": slickRef
      }, props3), restAttrs), {}, {
        "dots": !!dots,
        "dotsClass": dsClass.value,
        "arrows": arrows,
        "draggable": draggable,
        "fade": fade,
        "vertical": vertical.value
      }), slots)]);
    };
  }
});
const index$j = withInstall(Carousel);
var VALUE_SPLIT = "__RC_CASCADER_SPLIT__";
var SHOW_PARENT$1 = "SHOW_PARENT";
var SHOW_CHILD$1 = "SHOW_CHILD";
function toPathKey(value) {
  return value.join(VALUE_SPLIT);
}
function toPathKeys(value) {
  return value.map(toPathKey);
}
function toPathValueStr(pathKey) {
  return pathKey.split(VALUE_SPLIT);
}
function fillFieldNames$2(fieldNames) {
  var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, children = _ref.children;
  var val = value || "value";
  return {
    label: label || "label",
    value: val,
    key: val,
    children: children || "children"
  };
}
function isLeaf(option, fieldNames) {
  var _option$isLeaf, _option$fieldNames$ch;
  return (_option$isLeaf = option.isLeaf) !== null && _option$isLeaf !== void 0 ? _option$isLeaf : !((_option$fieldNames$ch = option[fieldNames.children]) !== null && _option$fieldNames$ch !== void 0 && _option$fieldNames$ch.length);
}
function scrollIntoParentView(element) {
  var parent2 = element.parentElement;
  if (!parent2) {
    return;
  }
  var elementToParent = element.offsetTop - parent2.offsetTop;
  if (elementToParent - parent2.scrollTop < 0) {
    parent2.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent2.scrollTop > parent2.offsetHeight) {
    parent2.scrollTo({
      top: elementToParent + element.offsetHeight - parent2.offsetHeight
    });
  }
}
var TreeContextKey = Symbol("TreeContextKey");
var TreeContext = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup: function setup90(props3, _ref) {
    var slots = _ref.slots;
    provide(TreeContextKey, computed(function() {
      return props3.value;
    }));
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var useInjectTreeContext = function useInjectTreeContext2() {
  return inject(TreeContextKey, computed(function() {
    return {};
  }));
};
var KeysStateKey = Symbol("KeysStateKey");
var useProvideKeysState = function useProvideKeysState2(state) {
  provide(KeysStateKey, state);
};
var useInjectKeysState = function useInjectKeysState2() {
  return inject(KeysStateKey, {
    expandedKeys: shallowRef([]),
    selectedKeys: shallowRef([]),
    loadedKeys: shallowRef([]),
    loadingKeys: shallowRef([]),
    checkedKeys: shallowRef([]),
    halfCheckedKeys: shallowRef([]),
    expandedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    selectedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    loadingKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    checkedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    halfCheckedKeysSet: computed(function() {
      return /* @__PURE__ */ new Set();
    }),
    flattenNodes: shallowRef([])
  });
};
var Indent = function Indent2(_ref) {
  var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd2 = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i2 = 0; i2 < level; i2 += 1) {
    var _ref2;
    list.push(createVNode("span", {
      "key": i2,
      "class": (_ref2 = {}, _defineProperty$U(_ref2, baseClassName, true), _defineProperty$U(_ref2, "".concat(baseClassName, "-start"), isStart[i2]), _defineProperty$U(_ref2, "".concat(baseClassName, "-end"), isEnd2[i2]), _ref2)
    }, null));
  }
  return createVNode("span", {
    "aria-hidden": "true",
    "class": "".concat(prefixCls, "-indent")
  }, [list]);
};
const Indent$1 = Indent;
var treeNodeProps = {
  eventKey: [String, Number],
  prefixCls: String,
  title: PropTypes$1.any,
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: PropTypes$1.any,
  switcherIcon: PropTypes$1.any,
  domRef: {
    type: Function
  }
};
var nodeListProps = {
  prefixCls: {
    type: String
  },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
};
var treeProps$1 = function treeProps() {
  return {
    prefixCls: String,
    focusable: {
      type: Boolean,
      default: void 0
    },
    activeKey: [Number, String],
    tabindex: Number,
    children: PropTypes$1.any,
    treeData: {
      type: Array
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes$1.any,
    selectable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    draggable: {
      type: [Function, Boolean]
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Object, Array]
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    allowDrop: {
      type: Function
    },
    dropIndicatorRender: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onDblclick: {
      type: Function
    },
    onScroll: {
      type: Function
    },
    onExpand: {
      type: Function
    },
    onCheck: {
      type: Function
    },
    onSelect: {
      type: Function
    },
    onLoad: {
      type: Function
    },
    loadData: {
      type: Function
    },
    loadedKeys: {
      type: Array
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onRightClick: {
      type: Function
    },
    onDragstart: {
      type: Function
    },
    onDragenter: {
      type: Function
    },
    onDragover: {
      type: Function
    },
    onDragleave: {
      type: Function
    },
    onDragend: {
      type: Function
    },
    onDrop: {
      type: Function
    },
    onActiveChange: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    motion: PropTypes$1.any,
    switcherIcon: PropTypes$1.any,
    height: Number,
    itemHeight: Number,
    virtual: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    }
  };
};
var _excluded$G = ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"];
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
const VcTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeNode",
  inheritAttrs: false,
  props: treeNodeProps,
  isTreeNode: 1,
  slots: ["title", "icon", "switcherIcon"],
  setup: function setup91(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    warning$3(!("slots" in props3.data), "treeData slots is deprecated, please use ".concat(Object.keys(props3.data.slots || {}).map(function(key2) {
      return "`v-slot:" + key2 + "` ";
    }), "instead"));
    var dragNodeHighlight = ref(false);
    var context2 = useInjectTreeContext();
    var _useInjectKeysState = useInjectKeysState(), expandedKeysSet = _useInjectKeysState.expandedKeysSet, selectedKeysSet = _useInjectKeysState.selectedKeysSet, loadedKeysSet = _useInjectKeysState.loadedKeysSet, loadingKeysSet = _useInjectKeysState.loadingKeysSet, checkedKeysSet = _useInjectKeysState.checkedKeysSet, halfCheckedKeysSet = _useInjectKeysState.halfCheckedKeysSet;
    var _context$value = context2.value, dragOverNodeKey = _context$value.dragOverNodeKey, dropPosition = _context$value.dropPosition, keyEntities = _context$value.keyEntities;
    var mergedTreeNodeProps = computed(function() {
      return getTreeNodeProps(props3.eventKey, {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      });
    });
    var expanded = eagerComputed(function() {
      return mergedTreeNodeProps.value.expanded;
    });
    var selected = eagerComputed(function() {
      return mergedTreeNodeProps.value.selected;
    });
    var checked = eagerComputed(function() {
      return mergedTreeNodeProps.value.checked;
    });
    var loaded = eagerComputed(function() {
      return mergedTreeNodeProps.value.loaded;
    });
    var loading = eagerComputed(function() {
      return mergedTreeNodeProps.value.loading;
    });
    var halfChecked = eagerComputed(function() {
      return mergedTreeNodeProps.value.halfChecked;
    });
    var dragOver = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOver;
    });
    var dragOverGapTop = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOverGapTop;
    });
    var dragOverGapBottom = eagerComputed(function() {
      return mergedTreeNodeProps.value.dragOverGapBottom;
    });
    var pos2 = eagerComputed(function() {
      return mergedTreeNodeProps.value.pos;
    });
    var selectHandle = ref();
    var hasChildren = computed(function() {
      var eventKey = props3.eventKey;
      var keyEntities2 = context2.value.keyEntities;
      var _ref2 = keyEntities2[eventKey] || {}, children = _ref2.children;
      return !!(children || []).length;
    });
    var isLeaf2 = computed(function() {
      var isLeaf3 = props3.isLeaf;
      var loadData = context2.value.loadData;
      var has2 = hasChildren.value;
      if (isLeaf3 === false) {
        return false;
      }
      return isLeaf3 || !loadData && !has2 || loadData && loaded.value && !has2;
    });
    var nodeState = computed(function() {
      if (isLeaf2.value) {
        return null;
      }
      return expanded.value ? ICON_OPEN : ICON_CLOSE;
    });
    var isDisabled = computed(function() {
      var disabled = props3.disabled;
      var treeDisabled = context2.value.disabled;
      return !!(treeDisabled || disabled);
    });
    var isCheckable = computed(function() {
      var checkable = props3.checkable;
      var treeCheckable = context2.value.checkable;
      if (!treeCheckable || checkable === false)
        return false;
      return treeCheckable;
    });
    var isSelectable = computed(function() {
      var selectable = props3.selectable;
      var treeSelectable = context2.value.selectable;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    });
    var renderArgsData = computed(function() {
      var data9 = props3.data, active = props3.active, checkable = props3.checkable, disableCheckbox = props3.disableCheckbox, disabled = props3.disabled, selectable = props3.selectable;
      return _objectSpread2$1(_objectSpread2$1({
        active,
        checkable,
        disableCheckbox,
        disabled,
        selectable
      }, data9), {}, {
        dataRef: data9,
        data: data9,
        isLeaf: isLeaf2.value,
        checked: checked.value,
        expanded: expanded.value,
        loading: loading.value,
        selected: selected.value,
        halfChecked: halfChecked.value
      });
    });
    var instance = getCurrentInstance();
    var eventData = computed(function() {
      var eventKey = props3.eventKey;
      var keyEntities2 = context2.value.keyEntities;
      var _ref3 = keyEntities2[eventKey] || {}, parent2 = _ref3.parent;
      return _objectSpread2$1(_objectSpread2$1({}, convertNodePropsToEventData(_extends$1({}, props3, mergedTreeNodeProps.value))), {}, {
        parent: parent2
      });
    });
    var dragNodeEvent = reactive({
      eventData,
      eventKey: computed(function() {
        return props3.eventKey;
      }),
      selectHandle,
      pos: pos2,
      key: instance.vnode.key
    });
    expose(dragNodeEvent);
    var onSelectorDoubleClick = function onSelectorDoubleClick2(e2) {
      var onNodeDoubleClick = context2.value.onNodeDoubleClick;
      onNodeDoubleClick(e2, eventData.value);
    };
    var onSelect = function onSelect2(e2) {
      if (isDisabled.value)
        return;
      var onNodeSelect = context2.value.onNodeSelect;
      e2.preventDefault();
      onNodeSelect(e2, eventData.value);
    };
    var onCheck = function onCheck2(e2) {
      if (isDisabled.value)
        return;
      var disableCheckbox = props3.disableCheckbox;
      var onNodeCheck = context2.value.onNodeCheck;
      if (!isCheckable.value || disableCheckbox)
        return;
      e2.preventDefault();
      var targetChecked = !checked.value;
      onNodeCheck(e2, eventData.value, targetChecked);
    };
    var onSelectorClick = function onSelectorClick2(e2) {
      var onNodeClick = context2.value.onNodeClick;
      onNodeClick(e2, eventData.value);
      if (isSelectable.value) {
        onSelect(e2);
      } else {
        onCheck(e2);
      }
    };
    var onMouseEnter = function onMouseEnter2(e2) {
      var onNodeMouseEnter = context2.value.onNodeMouseEnter;
      onNodeMouseEnter(e2, eventData.value);
    };
    var onMouseLeave = function onMouseLeave2(e2) {
      var onNodeMouseLeave = context2.value.onNodeMouseLeave;
      onNodeMouseLeave(e2, eventData.value);
    };
    var onContextmenu2 = function onContextmenu3(e2) {
      var onNodeContextMenu = context2.value.onNodeContextMenu;
      onNodeContextMenu(e2, eventData.value);
    };
    var onDragStart = function onDragStart2(e2) {
      var onNodeDragStart = context2.value.onNodeDragStart;
      e2.stopPropagation();
      dragNodeHighlight.value = true;
      onNodeDragStart(e2, dragNodeEvent);
      try {
        e2.dataTransfer.setData("text/plain", "");
      } catch (error) {
      }
    };
    var onDragEnter = function onDragEnter2(e2) {
      var onNodeDragEnter = context2.value.onNodeDragEnter;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragEnter(e2, dragNodeEvent);
    };
    var onDragOver = function onDragOver2(e2) {
      var onNodeDragOver = context2.value.onNodeDragOver;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragOver(e2, dragNodeEvent);
    };
    var onDragLeave = function onDragLeave2(e2) {
      var onNodeDragLeave = context2.value.onNodeDragLeave;
      e2.stopPropagation();
      onNodeDragLeave(e2, dragNodeEvent);
    };
    var onDragEnd = function onDragEnd2(e2) {
      var onNodeDragEnd = context2.value.onNodeDragEnd;
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDragEnd(e2, dragNodeEvent);
    };
    var onDrop = function onDrop2(e2) {
      var onNodeDrop = context2.value.onNodeDrop;
      e2.preventDefault();
      e2.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDrop(e2, dragNodeEvent);
    };
    var onExpand = function onExpand2(e2) {
      var onNodeExpand = context2.value.onNodeExpand;
      if (loading.value)
        return;
      onNodeExpand(e2, eventData.value);
    };
    var isDraggable = function isDraggable2() {
      var data9 = props3.data;
      var draggable = context2.value.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data9)));
    };
    var renderDragHandler = function renderDragHandler2() {
      var _context$value2 = context2.value, draggable = _context$value2.draggable, prefixCls = _context$value2.prefixCls;
      return draggable !== null && draggable !== void 0 && draggable.icon ? createVNode("span", {
        "class": "".concat(prefixCls, "-draggable-icon")
      }, [draggable.icon]) : null;
    };
    var renderSwitcherIconDom = function renderSwitcherIconDom2() {
      var _context$value$slots, _props$data, _props$data$slots;
      var _props$switcherIcon = props3.switcherIcon, switcherIconFromProps = _props$switcherIcon === void 0 ? slots.switcherIcon || ((_context$value$slots = context2.value.slots) === null || _context$value$slots === void 0 ? void 0 : _context$value$slots[(_props$data = props3.data) === null || _props$data === void 0 ? void 0 : (_props$data$slots = _props$data.slots) === null || _props$data$slots === void 0 ? void 0 : _props$data$slots.switcherIcon]) : _props$switcherIcon;
      var switcherIconFromCtx = context2.value.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(renderArgsData.value);
      }
      return switcherIcon;
    };
    var syncLoadData = function syncLoadData2() {
      var _context$value3 = context2.value, loadData = _context$value3.loadData, onNodeLoad = _context$value3.onNodeLoad;
      if (loading.value) {
        return;
      }
      if (loadData && expanded.value && !isLeaf2.value) {
        if (!hasChildren.value && !loaded.value) {
          onNodeLoad(eventData.value);
        }
      }
    };
    onMounted(function() {
      syncLoadData();
    });
    onUpdated(function() {
      syncLoadData();
    });
    var renderSwitcher = function renderSwitcher2() {
      var prefixCls = context2.value.prefixCls;
      var switcherIconDom = renderSwitcherIconDom();
      if (isLeaf2.value) {
        return switcherIconDom !== false ? createVNode("span", {
          "class": classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, [switcherIconDom]) : null;
      }
      var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded.value ? ICON_OPEN : ICON_CLOSE));
      return switcherIconDom !== false ? createVNode("span", {
        "onClick": onExpand,
        "class": switcherCls
      }, [switcherIconDom]) : null;
    };
    var renderCheckbox = function renderCheckbox2() {
      var _context$value$custom, _context$value4;
      var disableCheckbox = props3.disableCheckbox;
      var prefixCls = context2.value.prefixCls;
      var disabled = isDisabled.value;
      var checkable = isCheckable.value;
      if (!checkable)
        return null;
      return createVNode("span", {
        "class": classNames("".concat(prefixCls, "-checkbox"), checked.value && "".concat(prefixCls, "-checkbox-checked"), !checked.value && halfChecked.value && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        "onClick": onCheck
      }, [(_context$value$custom = (_context$value4 = context2.value).customCheckable) === null || _context$value$custom === void 0 ? void 0 : _context$value$custom.call(_context$value4)]);
    };
    var renderIcon3 = function renderIcon4() {
      var prefixCls = context2.value.prefixCls;
      return createVNode("span", {
        "class": classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(nodeState.value || "docu"), loading.value && "".concat(prefixCls, "-icon_loading"))
      }, null);
    };
    var renderDropIndicator = function renderDropIndicator2() {
      var disabled = props3.disabled, eventKey = props3.eventKey;
      var _context$value5 = context2.value, draggable = _context$value5.draggable, dropLevelOffset = _context$value5.dropLevelOffset, dropPosition2 = _context$value5.dropPosition, prefixCls = _context$value5.prefixCls, indent = _context$value5.indent, dropIndicatorRender2 = _context$value5.dropIndicatorRender, dragOverNodeKey2 = _context$value5.dragOverNodeKey, direction = _context$value5.direction;
      var rootDraggable = draggable !== false;
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey2 === eventKey;
      return showIndicator ? dropIndicatorRender2({
        dropPosition: dropPosition2,
        dropLevelOffset,
        indent,
        prefixCls,
        direction
      }) : null;
    };
    var renderSelector = function renderSelector2() {
      var _context$value$slots2, _props$data2, _props$data2$slots, _context$value$slots3;
      var _props$icon = props3.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, data9 = props3.data;
      var title = slots.title || ((_context$value$slots2 = context2.value.slots) === null || _context$value$slots2 === void 0 ? void 0 : _context$value$slots2[(_props$data2 = props3.data) === null || _props$data2 === void 0 ? void 0 : (_props$data2$slots = _props$data2.slots) === null || _props$data2$slots === void 0 ? void 0 : _props$data2$slots.title]) || ((_context$value$slots3 = context2.value.slots) === null || _context$value$slots3 === void 0 ? void 0 : _context$value$slots3.title) || props3.title;
      var _context$value6 = context2.value, prefixCls = _context$value6.prefixCls, showIcon = _context$value6.showIcon, treeIcon = _context$value6.icon, loadData = _context$value6.loadData;
      var disabled = isDisabled.value;
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      var $icon;
      if (showIcon) {
        var _context$value$slots4, _data$slots;
        var currentIcon = icon || ((_context$value$slots4 = context2.value.slots) === null || _context$value$slots4 === void 0 ? void 0 : _context$value$slots4[data9 === null || data9 === void 0 ? void 0 : (_data$slots = data9.slots) === null || _data$slots === void 0 ? void 0 : _data$slots.icon]) || treeIcon;
        $icon = currentIcon ? createVNode("span", {
          "class": classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, [typeof currentIcon === "function" ? currentIcon(renderArgsData.value) : currentIcon]) : renderIcon3();
      } else if (loadData && loading.value) {
        $icon = renderIcon3();
      }
      var titleNode;
      if (typeof title === "function") {
        titleNode = title(renderArgsData.value);
      } else {
        titleNode = title;
      }
      titleNode = titleNode === void 0 ? defaultTitle : titleNode;
      var $title = createVNode("span", {
        "class": "".concat(prefixCls, "-title")
      }, [titleNode]);
      return createVNode("span", {
        "ref": selectHandle,
        "title": typeof title === "string" ? title : "",
        "class": classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(nodeState.value || "normal"), !disabled && (selected.value || dragNodeHighlight.value) && "".concat(prefixCls, "-node-selected")),
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave,
        "onContextmenu": onContextmenu2,
        "onClick": onSelectorClick,
        "onDblclick": onSelectorDoubleClick
      }, [$icon, $title, renderDropIndicator()]);
    };
    return function() {
      var _classNames;
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), eventKey = _props$attrs.eventKey, isLeaf3 = _props$attrs.isLeaf, isStart = _props$attrs.isStart, isEnd2 = _props$attrs.isEnd, domRef = _props$attrs.domRef, active = _props$attrs.active;
      _props$attrs.data;
      var onMousemove = _props$attrs.onMousemove, selectable = _props$attrs.selectable, otherProps = _objectWithoutProperties$2(_props$attrs, _excluded$G);
      var _context$value7 = context2.value, prefixCls = _context$value7.prefixCls, filterTreeNode = _context$value7.filterTreeNode, keyEntities2 = _context$value7.keyEntities, dropContainerKey = _context$value7.dropContainerKey, dropTargetKey = _context$value7.dropTargetKey, draggingNodeKey = _context$value7.draggingNodeKey;
      var disabled = isDisabled.value;
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref4 = keyEntities2[eventKey] || {}, level = _ref4.level;
      var isEndNode = isEnd2[isEnd2.length - 1];
      var mergedDraggable = isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== void 0 ? {
        "aria-selected": !!selectable
      } : void 0;
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "ref": domRef,
        "class": classNames(attrs.class, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded.value ? "open" : "close"), !isLeaf3), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-selected"), selected.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-loading"), loading.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$U(_classNames, "".concat(prefixCls, "-treenode-draggable"), draggableWithoutDisabled), _defineProperty$U(_classNames, "dragging", dragging), _defineProperty$U(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty$U(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty$U(_classNames, "drag-over", !disabled && dragOver.value), _defineProperty$U(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop.value), _defineProperty$U(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom.value), _defineProperty$U(_classNames, "filter-node", filterTreeNode && filterTreeNode(eventData.value)), _classNames)),
        "style": attrs.style,
        "draggable": draggableWithoutDisabled,
        "aria-grabbed": dragging,
        "onDragstart": draggableWithoutDisabled ? onDragStart : void 0,
        "onDragenter": mergedDraggable ? onDragEnter : void 0,
        "onDragover": mergedDraggable ? onDragOver : void 0,
        "onDragleave": mergedDraggable ? onDragLeave : void 0,
        "onDrop": mergedDraggable ? onDrop : void 0,
        "onDragend": mergedDraggable ? onDragEnd : void 0,
        "onMousemove": onMousemove
      }, ariaSelected), dataOrAriaAttributeProps), [createVNode(Indent$1, {
        "prefixCls": prefixCls,
        "level": level,
        "isStart": isStart,
        "isEnd": isEnd2
      }, null), renderDragHandler(), renderSwitcher(), renderCheckbox(), renderSelector()]);
    };
  }
});
function arrDel(list, value) {
  if (!list)
    return [];
  var clone3 = list.slice();
  var index2 = clone3.indexOf(value);
  if (index2 >= 0) {
    clone3.splice(index2, 1);
  }
  return clone3;
}
function arrAdd(list, value) {
  var clone3 = (list || []).slice();
  if (clone3.indexOf(value) === -1) {
    clone3.push(value);
  }
  return clone3;
}
function posToArr(pos2) {
  return pos2.split("-");
}
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach(function(_ref) {
      var key2 = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key2);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event2, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeysSet, direction) {
  var _abstractDropNodeEnti;
  var clientX = event2.clientX, clientY = event2.clientY;
  var _event$target$getBoun = event2.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
  var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  var abstractDropNodeEntity = keyEntities[targetNode.eventKey];
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  if (!expandKeysSet.has(initialAbstractDropNodeKey)) {
    for (var i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.eventData;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeysSet.has(dragOverNodeKey)) {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props3) {
  if (!selectedKeys)
    return void 0;
  var multiple = props3.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  var keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (_typeof$3(keys2) === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key2) {
    if (expandedKeys.has(key2))
      return;
    var entity = keyEntities[key2];
    if (!entity)
      return;
    expandedKeys.add(key2);
    var parent2 = entity.parent, node = entity.node;
    if (node.disabled)
      return;
    if (parent2) {
      conductUp(parent2.key);
    }
  }
  (keyList || []).forEach(function(key2) {
    conductUp(key2);
  });
  return _toConsumableArray(expandedKeys);
}
var _excluded$F = ["title", "icon", "switcherIcon"];
function getKey2(key2, pos2) {
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  return pos2;
}
function fillFieldNames$1(fieldNames) {
  var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key2 = _ref.key, children = _ref.children;
  var mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key2 || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig() {
    var node = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var treeNodes = filterEmpty(node);
    return treeNodes.map(function(treeNode) {
      var _slots$title, _slots$icon, _slots$switcherIcon, _slots$default;
      if (!isTreeNode(treeNode)) {
        return null;
      }
      var slots = treeNode.children || {};
      var key2 = treeNode.key;
      var props3 = {};
      for (var _i = 0, _Object$entries = Object.entries(treeNode.props); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray$2(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
        props3[camelize$2(k2)] = v2;
      }
      var isLeaf2 = props3.isLeaf, checkable = props3.checkable, selectable = props3.selectable, disabled = props3.disabled, disableCheckbox = props3.disableCheckbox;
      var newProps = {
        isLeaf: isLeaf2 || isLeaf2 === "" || void 0,
        checkable: checkable || checkable === "" || void 0,
        selectable: selectable || selectable === "" || void 0,
        disabled: disabled || disabled === "" || void 0,
        disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
      };
      var slotsProps = _objectSpread2$1(_objectSpread2$1({}, props3), newProps);
      var _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots, slotsProps) : _props$title, _props$icon = props3.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots, slotsProps) : _props$icon, _props$switcherIcon = props3.switcherIcon, switcherIcon = _props$switcherIcon === void 0 ? (_slots$switcherIcon = slots.switcherIcon) === null || _slots$switcherIcon === void 0 ? void 0 : _slots$switcherIcon.call(slots, slotsProps) : _props$switcherIcon, rest = _objectWithoutProperties$2(props3, _excluded$F);
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var dataNode = _objectSpread2$1(_objectSpread2$1({}, rest), {}, {
        title,
        icon,
        switcherIcon,
        key: key2,
        isLeaf: isLeaf2
      }, newProps);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames$1(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map(function(treeNode, index2) {
      var pos2 = getPosition(parent2 ? parent2.pos : "0", index2);
      var mergedKey = getKey2(treeNode[fieldKey], pos2);
      var mergedTitle;
      for (var i2 = 0; i2 < fieldTitles.length; i2 += 1) {
        var fieldTitle = fieldTitles[i2];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = _objectSpread2$1(_objectSpread2$1({}, omit$2(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
        title: mergedTitle,
        key: mergedKey,
        parent: parent2,
        pos: pos2,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent2 ? parent2.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent2 ? parent2.isEnd : []), [index2 === list.length - 1])
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  var mergedConfig = {};
  if (_typeof$3(config) === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames$1(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey2(node, pos2) {
      return getKey2(node[fieldKey], pos2);
    };
  }
  function processNode(node, index2, parent2, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos2 = node ? getPosition(parent2.pos, index2) : "0";
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    if (node) {
      var key2 = syntheticGetKey(node, pos2);
      var data9 = {
        node,
        index: index2,
        pos: pos2,
        key: key2,
        parentPos: parent2.node ? parent2.pos : null,
        level: parent2.level + 1,
        nodes: connectNodes
      };
      callback(data9);
    }
    if (children) {
      children.forEach(function(subNode, subIndex) {
        processNode(subNode, subIndex, {
          node,
          pos: pos2,
          level: parent2 ? parent2.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
  var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function(item) {
    var node = item.node, index2 = item.index, pos2 = item.pos, key2 = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
    var entity = {
      node,
      nodes,
      index: index2,
      key: key2,
      pos: pos2,
      level
    };
    var mergedKey = getKey2(key2, pos2);
    posEntities[pos2] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key2, _ref3) {
  var expandedKeysSet = _ref3.expandedKeysSet, selectedKeysSet = _ref3.selectedKeysSet, loadedKeysSet = _ref3.loadedKeysSet, loadingKeysSet = _ref3.loadingKeysSet, checkedKeysSet = _ref3.checkedKeysSet, halfCheckedKeysSet = _ref3.halfCheckedKeysSet, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key2];
  var treeNodeProps2 = {
    eventKey: key2,
    expanded: expandedKeysSet.has(key2),
    selected: selectedKeysSet.has(key2),
    loaded: loadedKeysSet.has(key2),
    loading: loadingKeysSet.has(key2),
    checked: checkedKeysSet.has(key2),
    halfChecked: halfCheckedKeysSet.has(key2),
    pos: String(entity ? entity.pos : ""),
    parent: entity.parent,
    dragOver: dragOverNodeKey === key2 && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
  };
  return treeNodeProps2;
}
function convertNodePropsToEventData(props3) {
  var data9 = props3.data, expanded = props3.expanded, selected = props3.selected, checked = props3.checked, loaded = props3.loaded, loading = props3.loading, halfChecked = props3.halfChecked, dragOver = props3.dragOver, dragOverGapTop = props3.dragOverGapTop, dragOverGapBottom = props3.dragOverGapBottom, pos2 = props3.pos, active = props3.active, eventKey = props3.eventKey;
  var eventData = _objectSpread2$1(_objectSpread2$1({
    dataRef: data9
  }, data9), {}, {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos: pos2,
    active,
    eventKey,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get: function get4() {
        return props3;
      }
    });
  }
  return eventData;
}
const useEntities = function(options, fieldNames) {
  var entities = computed(function() {
    return convertDataToEntities(options.value, {
      fieldNames: fieldNames.value,
      initWrapper: function initWrapper(wrapper) {
        return _objectSpread2$1(_objectSpread2$1({}, wrapper), {}, {
          pathKeyEntities: {}
        });
      },
      processEntity: function processEntity(entity, wrapper) {
        var pathKey = entity.nodes.map(function(node) {
          return node[fieldNames.value.value];
        }).join(VALUE_SPLIT);
        wrapper.pathKeyEntities[pathKey] = entity;
        entity.key = pathKey;
      }
    }).pathKeyEntities;
  });
  return entities;
};
function useSearchConfig(showSearch) {
  var mergedShowSearch = ref(false);
  var mergedSearchConfig = ref({});
  watchEffect(function() {
    if (!showSearch.value) {
      mergedShowSearch.value = false;
      mergedSearchConfig.value = {};
      return;
    }
    var searchConfig = {
      matchInputWidth: true,
      limit: 50
    };
    if (showSearch.value && _typeof$3(showSearch.value) === "object") {
      searchConfig = _objectSpread2$1(_objectSpread2$1({}, searchConfig), showSearch.value);
    }
    if (searchConfig.limit <= 0) {
      delete searchConfig.limit;
    }
    mergedShowSearch.value = true;
    mergedSearchConfig.value = searchConfig;
    return;
  });
  return {
    showSearch: mergedShowSearch,
    searchConfig: mergedSearchConfig
  };
}
var SEARCH_MARK = "__rc_cascader_search_mark__";
var defaultFilter = function defaultFilter2(search, options, _ref) {
  var label = _ref.label;
  return options.some(function(opt) {
    return String(opt[label]).toLowerCase().includes(search.toLowerCase());
  });
};
var defaultRender$1 = function defaultRender(_ref2) {
  var path2 = _ref2.path, fieldNames = _ref2.fieldNames;
  return path2.map(function(opt) {
    return opt[fieldNames.label];
  }).join(" / ");
};
const useSearchOptions = function(search, options, fieldNames, prefixCls, config, changeOnSelect) {
  return computed(function() {
    var _config$value = config.value, _config$value$filter = _config$value.filter, filter = _config$value$filter === void 0 ? defaultFilter : _config$value$filter, _config$value$render = _config$value.render, render14 = _config$value$render === void 0 ? defaultRender$1 : _config$value$render, _config$value$limit = _config$value.limit, limit = _config$value$limit === void 0 ? 50 : _config$value$limit, sort = _config$value.sort;
    var filteredOptions = [];
    if (!search.value) {
      return [];
    }
    function dig(list, pathOptions) {
      list.forEach(function(option) {
        if (!sort && limit > 0 && filteredOptions.length >= limit) {
          return;
        }
        var connectedPathOptions = [].concat(_toConsumableArray(pathOptions), [option]);
        var children = option[fieldNames.value.children];
        if (!children || children.length === 0 || changeOnSelect.value) {
          if (filter(search.value, connectedPathOptions, {
            label: fieldNames.value.label
          })) {
            var _objectSpread22;
            filteredOptions.push(_objectSpread2$1(_objectSpread2$1({}, option), {}, (_objectSpread22 = {}, _defineProperty$U(_objectSpread22, fieldNames.value.label, render14({
              inputValue: search.value,
              path: connectedPathOptions,
              prefixCls: prefixCls.value,
              fieldNames: fieldNames.value
            })), _defineProperty$U(_objectSpread22, SEARCH_MARK, connectedPathOptions), _objectSpread22)));
          }
        }
        if (children) {
          dig(option[fieldNames.value.children], connectedPathOptions);
        }
      });
    }
    dig(options.value, []);
    if (sort) {
      filteredOptions.sort(function(a2, b2) {
        return sort(a2[SEARCH_MARK], b2[SEARCH_MARK], search.value, fieldNames.value);
      });
    }
    return limit > 0 ? filteredOptions.slice(0, limit) : filteredOptions;
  });
};
function formatStrategyValues$1(pathKeys, keyPathEntities, showCheckedStrategy) {
  var valueSet = new Set(pathKeys);
  return pathKeys.filter(function(key2) {
    var entity = keyPathEntities[key2];
    var parent2 = entity ? entity.parent : null;
    var children = entity ? entity.children : null;
    return showCheckedStrategy === SHOW_CHILD$1 ? !(children && children.some(function(child) {
      return child.key && valueSet.has(child.key);
    })) : !(parent2 && !parent2.node.disabled && valueSet.has(parent2.key));
  });
}
function toPathOptions(valueCells, options, fieldNames) {
  var stringMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var currentList = options;
  var valueOptions = [];
  var _loop = function _loop2(i3) {
    var _currentList, _currentList2, _foundOption$fieldNam;
    var valueCell = valueCells[i3];
    var foundIndex = (_currentList = currentList) === null || _currentList === void 0 ? void 0 : _currentList.findIndex(function(option) {
      var val = option[fieldNames.value];
      return stringMode ? String(val) === String(valueCell) : val === valueCell;
    });
    var foundOption = foundIndex !== -1 ? (_currentList2 = currentList) === null || _currentList2 === void 0 ? void 0 : _currentList2[foundIndex] : null;
    valueOptions.push({
      value: (_foundOption$fieldNam = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.value]) !== null && _foundOption$fieldNam !== void 0 ? _foundOption$fieldNam : valueCell,
      index: foundIndex,
      option: foundOption
    });
    currentList = foundOption === null || foundOption === void 0 ? void 0 : foundOption[fieldNames.children];
  };
  for (var i2 = 0; i2 < valueCells.length; i2 += 1) {
    _loop(i2);
  }
  return valueOptions;
}
const useMissingValues = function(options, fieldNames, rawValues) {
  return computed(function() {
    var missingValues = [];
    var existsValues = [];
    rawValues.value.forEach(function(valueCell) {
      var pathOptions = toPathOptions(valueCell, options.value, fieldNames.value);
      if (pathOptions.every(function(opt) {
        return opt.option;
      })) {
        existsValues.push(valueCell);
      } else {
        missingValues.push(valueCell);
      }
    });
    return [existsValues, missingValues];
  });
};
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach(function(key2) {
    if (!checkedKeys.has(key2)) {
      filteredKeys.add(key2);
    }
  });
  return filteredKeys;
}
function isCheckDisabled$1(node) {
  var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent2 = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent2.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent2.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref2) {
        var key2 = _ref2.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent2.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent2.key);
      }
      visitedKeys.add(parent2.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = new Set(halfKeys);
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent2 = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent2.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent2.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref3) {
        var key2 = _ref3.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent2.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent2.key);
      }
      visitedKeys.add(parent2.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, maxLevel, levelEntities, getCheckDisabled) {
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled$1;
  }
  var keys2 = new Set(keyList.filter(function(key2) {
    var hasEntity = !!keyEntities[key2];
    return hasEntity;
  }));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
const useDisplayValues = function(rawValues, options, fieldNames, multiple, displayRender) {
  return computed(function() {
    var mergedDisplayRender = displayRender.value || function(_ref) {
      var labels = _ref.labels;
      var mergedLabels = multiple.value ? labels.slice(-1) : labels;
      var SPLIT = " / ";
      if (mergedLabels.every(function(label) {
        return ["string", "number"].includes(_typeof$3(label));
      })) {
        return mergedLabels.join(SPLIT);
      }
      return mergedLabels.reduce(function(list, label, index2) {
        var keyedLabel = isValidElement(label) ? cloneElement(label, {
          key: index2
        }) : label;
        if (index2 === 0) {
          return [keyedLabel];
        }
        return [].concat(_toConsumableArray(list), [SPLIT, keyedLabel]);
      }, []);
    };
    return rawValues.value.map(function(valueCells) {
      var valueOptions = toPathOptions(valueCells, options.value, fieldNames.value);
      var label = mergedDisplayRender({
        labels: valueOptions.map(function(_ref2) {
          var _option$fieldNames$va;
          var option = _ref2.option, value2 = _ref2.value;
          return (_option$fieldNames$va = option === null || option === void 0 ? void 0 : option[fieldNames.value.label]) !== null && _option$fieldNames$va !== void 0 ? _option$fieldNames$va : value2;
        }),
        selectedOptions: valueOptions.map(function(_ref3) {
          var option = _ref3.option;
          return option;
        })
      });
      var value = toPathKey(valueCells);
      return {
        label,
        value,
        key: value,
        valueCells
      };
    });
  });
};
var CascaderContextKey = Symbol("CascaderContextKey");
var useProvideCascader = function useProvideCascader2(props3) {
  provide(CascaderContextKey, props3);
};
var useInjectCascader = function useInjectCascader2() {
  return inject(CascaderContextKey);
};
const useActive = function() {
  var baseProps3 = useBaseProps();
  var _useInjectCascader = useInjectCascader(), values = _useInjectCascader.values;
  var _useState = useState([]), _useState2 = _slicedToArray$2(_useState, 2), activeValueCells = _useState2[0], setActiveValueCells = _useState2[1];
  watch(function() {
    return baseProps3.open;
  }, function() {
    if (baseProps3.open && !baseProps3.multiple) {
      var firstValueCells = values.value[0];
      setActiveValueCells(firstValueCells || []);
    }
  }, {
    immediate: true
  });
  return [activeValueCells, setActiveValueCells];
};
const useKeyboard = function(context2, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect) {
  var baseProps3 = useBaseProps();
  var rtl2 = computed(function() {
    return baseProps3.direction === "rtl";
  });
  var _ref = [ref([]), ref(), ref([])], validActiveValueCells = _ref[0], lastActiveIndex = _ref[1], lastActiveOptions = _ref[2];
  watchEffect(function() {
    var activeIndex = -1;
    var currentOptions = options.value;
    var mergedActiveIndexes = [];
    var mergedActiveValueCells = [];
    var len = activeValueCells.value.length;
    var _loop = function _loop2(i3) {
      var nextActiveIndex = currentOptions.findIndex(function(option) {
        return option[fieldNames.value.value] === activeValueCells.value[i3];
      });
      if (nextActiveIndex === -1) {
        return "break";
      }
      activeIndex = nextActiveIndex;
      mergedActiveIndexes.push(activeIndex);
      mergedActiveValueCells.push(activeValueCells.value[i3]);
      currentOptions = currentOptions[activeIndex][fieldNames.value.children];
    };
    for (var i2 = 0; i2 < len && currentOptions; i2 += 1) {
      var _ret = _loop(i2);
      if (_ret === "break")
        break;
    }
    var activeOptions = options.value;
    for (var _i = 0; _i < mergedActiveIndexes.length - 1; _i += 1) {
      activeOptions = activeOptions[mergedActiveIndexes[_i]][fieldNames.value.children];
    }
    var _ref2 = [mergedActiveValueCells, activeIndex, activeOptions];
    validActiveValueCells.value = _ref2[0];
    lastActiveIndex.value = _ref2[1];
    lastActiveOptions.value = _ref2[2];
  });
  var internalSetActiveValueCells = function internalSetActiveValueCells2(next2) {
    setActiveValueCells(next2);
  };
  var offsetActiveOption = function offsetActiveOption2(offset3) {
    var len = lastActiveOptions.value.length;
    var currentIndex = lastActiveIndex.value;
    if (currentIndex === -1 && offset3 < 0) {
      currentIndex = len;
    }
    for (var i2 = 0; i2 < len; i2 += 1) {
      currentIndex = (currentIndex + offset3 + len) % len;
      var option = lastActiveOptions.value[currentIndex];
      if (option && !option.disabled) {
        var value = option[fieldNames.value.value];
        var nextActiveCells = validActiveValueCells.value.slice(0, -1).concat(value);
        internalSetActiveValueCells(nextActiveCells);
        return;
      }
    }
  };
  var prevColumn = function prevColumn2() {
    if (validActiveValueCells.value.length > 1) {
      var nextActiveCells = validActiveValueCells.value.slice(0, -1);
      internalSetActiveValueCells(nextActiveCells);
    } else {
      baseProps3.toggleOpen(false);
    }
  };
  var nextColumn = function nextColumn2() {
    var _lastActiveOptions$va;
    var nextOptions = ((_lastActiveOptions$va = lastActiveOptions.value[lastActiveIndex.value]) === null || _lastActiveOptions$va === void 0 ? void 0 : _lastActiveOptions$va[fieldNames.value.children]) || [];
    var nextOption = nextOptions.find(function(option) {
      return !option.disabled;
    });
    if (nextOption) {
      var nextActiveCells = [].concat(_toConsumableArray(validActiveValueCells.value), [nextOption[fieldNames.value.value]]);
      internalSetActiveValueCells(nextActiveCells);
    }
  };
  context2.expose({
    onKeydown: function onKeydown(event2) {
      var which = event2.which;
      switch (which) {
        case KeyCode$1.UP:
        case KeyCode$1.DOWN: {
          var offset3 = 0;
          if (which === KeyCode$1.UP) {
            offset3 = -1;
          } else if (which === KeyCode$1.DOWN) {
            offset3 = 1;
          }
          if (offset3 !== 0) {
            offsetActiveOption(offset3);
          }
          break;
        }
        case KeyCode$1.LEFT: {
          if (rtl2.value) {
            nextColumn();
          } else {
            prevColumn();
          }
          break;
        }
        case KeyCode$1.RIGHT: {
          if (rtl2.value) {
            prevColumn();
          } else {
            nextColumn();
          }
          break;
        }
        case KeyCode$1.BACKSPACE: {
          if (!baseProps3.searchValue) {
            prevColumn();
          }
          break;
        }
        case KeyCode$1.ENTER: {
          if (validActiveValueCells.value.length) {
            var option = lastActiveOptions.value[lastActiveIndex.value];
            var originOptions = (option === null || option === void 0 ? void 0 : option[SEARCH_MARK]) || [];
            if (originOptions.length) {
              onKeyBoardSelect(originOptions.map(function(opt) {
                return opt[fieldNames.value.value];
              }), originOptions[originOptions.length - 1]);
            } else {
              onKeyBoardSelect(validActiveValueCells.value, option);
            }
          }
          break;
        }
        case KeyCode$1.ESC: {
          baseProps3.toggleOpen(false);
          if (open) {
            event2.stopPropagation();
          }
        }
      }
    },
    onKeyup: function onKeyup() {
    }
  });
};
function Checkbox$2(_ref) {
  var _ref2;
  var prefixCls = _ref.prefixCls, checked = _ref.checked, halfChecked = _ref.halfChecked, disabled = _ref.disabled, onClick2 = _ref.onClick;
  var _useInjectCascader = useInjectCascader(), customSlots = _useInjectCascader.customSlots, checkable = _useInjectCascader.checkable;
  var mergedCheckable = checkable.value !== false ? customSlots.value.checkable : checkable.value;
  var customCheckbox = typeof mergedCheckable === "function" ? mergedCheckable() : typeof mergedCheckable === "boolean" ? null : mergedCheckable;
  return createVNode("span", {
    "class": (_ref2 = {}, _defineProperty$U(_ref2, prefixCls, true), _defineProperty$U(_ref2, "".concat(prefixCls, "-checked"), checked), _defineProperty$U(_ref2, "".concat(prefixCls, "-indeterminate"), !checked && halfChecked), _defineProperty$U(_ref2, "".concat(prefixCls, "-disabled"), disabled), _ref2),
    "onClick": onClick2
  }, [customCheckbox]);
}
Checkbox$2.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
Checkbox$2.displayName = "Checkbox";
Checkbox$2.inheritAttrs = false;
var FIX_LABEL = "__cascader_fix_label__";
function Column$1(_ref) {
  var _expandIconRef$value, _customSlots$value$ex, _customSlots$value, _loadingIconRef$value, _customSlots$value$lo, _customSlots$value2;
  var prefixCls = _ref.prefixCls, multiple = _ref.multiple, options = _ref.options, activeValue = _ref.activeValue, prevValuePath = _ref.prevValuePath, onToggleOpen = _ref.onToggleOpen, onSelect = _ref.onSelect, onActive = _ref.onActive, checkedSet = _ref.checkedSet, halfCheckedSet = _ref.halfCheckedSet, loadingKeys = _ref.loadingKeys, isSelectable = _ref.isSelectable;
  var menuPrefixCls = "".concat(prefixCls, "-menu");
  var menuItemPrefixCls = "".concat(prefixCls, "-menu-item");
  var _useInjectCascader = useInjectCascader(), fieldNames = _useInjectCascader.fieldNames, changeOnSelect = _useInjectCascader.changeOnSelect, expandTrigger = _useInjectCascader.expandTrigger, expandIconRef = _useInjectCascader.expandIcon, loadingIconRef = _useInjectCascader.loadingIcon, dropdownMenuColumnStyle = _useInjectCascader.dropdownMenuColumnStyle, customSlots = _useInjectCascader.customSlots;
  var expandIcon = (_expandIconRef$value = expandIconRef.value) !== null && _expandIconRef$value !== void 0 ? _expandIconRef$value : (_customSlots$value$ex = (_customSlots$value = customSlots.value).expandIcon) === null || _customSlots$value$ex === void 0 ? void 0 : _customSlots$value$ex.call(_customSlots$value);
  var loadingIcon = (_loadingIconRef$value = loadingIconRef.value) !== null && _loadingIconRef$value !== void 0 ? _loadingIconRef$value : (_customSlots$value$lo = (_customSlots$value2 = customSlots.value).loadingIcon) === null || _customSlots$value$lo === void 0 ? void 0 : _customSlots$value$lo.call(_customSlots$value2);
  var hoverOpen = expandTrigger.value === "hover";
  return createVNode("ul", {
    "class": menuPrefixCls,
    "role": "menu"
  }, [options.map(function(option) {
    var _option$FIX_LABEL, _ref2;
    var disabled = option.disabled;
    var searchOptions = option[SEARCH_MARK];
    var label = (_option$FIX_LABEL = option[FIX_LABEL]) !== null && _option$FIX_LABEL !== void 0 ? _option$FIX_LABEL : option[fieldNames.value.label];
    var value = option[fieldNames.value.value];
    var isMergedLeaf = isLeaf(option, fieldNames.value);
    var fullPath = searchOptions ? searchOptions.map(function(opt) {
      return opt[fieldNames.value.value];
    }) : [].concat(_toConsumableArray(prevValuePath), [value]);
    var fullPathKey = toPathKey(fullPath);
    var isLoading = loadingKeys.includes(fullPathKey);
    var checked = checkedSet.has(fullPathKey);
    var halfChecked = halfCheckedSet.has(fullPathKey);
    var triggerOpenPath = function triggerOpenPath2() {
      if (!disabled && (!hoverOpen || !isMergedLeaf)) {
        onActive(fullPath);
      }
    };
    var triggerSelect = function triggerSelect2() {
      if (isSelectable(option)) {
        onSelect(fullPath, isMergedLeaf);
      }
    };
    var title;
    if (typeof option.title === "string") {
      title = option.title;
    } else if (typeof label === "string") {
      title = label;
    }
    return createVNode("li", {
      "key": fullPathKey,
      "class": [menuItemPrefixCls, (_ref2 = {}, _defineProperty$U(_ref2, "".concat(menuItemPrefixCls, "-expand"), !isMergedLeaf), _defineProperty$U(_ref2, "".concat(menuItemPrefixCls, "-active"), activeValue === value), _defineProperty$U(_ref2, "".concat(menuItemPrefixCls, "-disabled"), disabled), _defineProperty$U(_ref2, "".concat(menuItemPrefixCls, "-loading"), isLoading), _ref2)],
      "style": dropdownMenuColumnStyle.value,
      "role": "menuitemcheckbox",
      "title": title,
      "aria-checked": checked,
      "data-path-key": fullPathKey,
      "onClick": function onClick2() {
        triggerOpenPath();
        if (!multiple || isMergedLeaf) {
          triggerSelect();
        }
      },
      "onDblclick": function onDblclick() {
        if (changeOnSelect.value) {
          onToggleOpen(false);
        }
      },
      "onMouseenter": function onMouseenter2() {
        if (hoverOpen) {
          triggerOpenPath();
        }
      },
      "onMousedown": function onMousedown2(e2) {
        e2.preventDefault();
      }
    }, [multiple && createVNode(Checkbox$2, {
      "prefixCls": "".concat(prefixCls, "-checkbox"),
      "checked": checked,
      "halfChecked": halfChecked,
      "disabled": disabled,
      "onClick": function onClick2(e2) {
        e2.stopPropagation();
        triggerSelect();
      }
    }, null), createVNode("div", {
      "class": "".concat(menuItemPrefixCls, "-content")
    }, [label]), !isLoading && expandIcon && !isMergedLeaf && createVNode("div", {
      "class": "".concat(menuItemPrefixCls, "-expand-icon")
    }, [expandIcon]), isLoading && loadingIcon && createVNode("div", {
      "class": "".concat(menuItemPrefixCls, "-loading-icon")
    }, [loadingIcon])]);
  })]);
}
Column$1.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
Column$1.displayName = "Column";
Column$1.inheritAttrs = false;
const OptionList$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  setup: function setup92(_props, context2) {
    var attrs = context2.attrs, slots = context2.slots;
    var baseProps3 = useBaseProps();
    var containerRef = ref();
    var rtl2 = computed(function() {
      return baseProps3.direction === "rtl";
    });
    var _useInjectCascader = useInjectCascader(), options = _useInjectCascader.options, values = _useInjectCascader.values, halfValues = _useInjectCascader.halfValues, fieldNames = _useInjectCascader.fieldNames, changeOnSelect = _useInjectCascader.changeOnSelect, onSelect = _useInjectCascader.onSelect, searchOptions = _useInjectCascader.searchOptions, dropdownPrefixCls = _useInjectCascader.dropdownPrefixCls, loadData = _useInjectCascader.loadData, expandTrigger = _useInjectCascader.expandTrigger, customSlots = _useInjectCascader.customSlots;
    var mergedPrefixCls = computed(function() {
      return dropdownPrefixCls.value || baseProps3.prefixCls;
    });
    var loadingKeys = shallowRef([]);
    var internalLoadData = function internalLoadData2(valueCells) {
      if (!loadData.value || baseProps3.searchValue) {
        return;
      }
      var optionList = toPathOptions(valueCells, options.value, fieldNames.value);
      var rawOptions = optionList.map(function(_ref) {
        var option = _ref.option;
        return option;
      });
      var lastOption = rawOptions[rawOptions.length - 1];
      if (lastOption && !isLeaf(lastOption, fieldNames.value)) {
        var pathKey = toPathKey(valueCells);
        loadingKeys.value = [].concat(_toConsumableArray(loadingKeys.value), [pathKey]);
        loadData.value(rawOptions);
      }
    };
    watchEffect(function() {
      if (loadingKeys.value.length) {
        loadingKeys.value.forEach(function(loadingKey) {
          var valueStrCells = toPathValueStr(loadingKey);
          var optionList = toPathOptions(valueStrCells, options.value, fieldNames.value, true).map(function(_ref2) {
            var option = _ref2.option;
            return option;
          });
          var lastOption = optionList[optionList.length - 1];
          if (!lastOption || lastOption[fieldNames.value.children] || isLeaf(lastOption, fieldNames.value)) {
            loadingKeys.value = loadingKeys.value.filter(function(key2) {
              return key2 !== loadingKey;
            });
          }
        });
      }
    });
    var checkedSet = computed(function() {
      return new Set(toPathKeys(values.value));
    });
    var halfCheckedSet = computed(function() {
      return new Set(toPathKeys(halfValues.value));
    });
    var _useActive = useActive(), _useActive2 = _slicedToArray$2(_useActive, 2), activeValueCells = _useActive2[0], setActiveValueCells = _useActive2[1];
    var onPathOpen = function onPathOpen2(nextValueCells) {
      setActiveValueCells(nextValueCells);
      internalLoadData(nextValueCells);
    };
    var isSelectable = function isSelectable2(option) {
      var disabled = option.disabled;
      var isMergedLeaf = isLeaf(option, fieldNames.value);
      return !disabled && (isMergedLeaf || changeOnSelect.value || baseProps3.multiple);
    };
    var onPathSelect = function onPathSelect2(valuePath, leaf) {
      var fromKeyboard = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      onSelect(valuePath);
      if (!baseProps3.multiple && (leaf || changeOnSelect.value && (expandTrigger.value === "hover" || fromKeyboard))) {
        baseProps3.toggleOpen(false);
      }
    };
    var mergedOptions = computed(function() {
      if (baseProps3.searchValue) {
        return searchOptions.value;
      }
      return options.value;
    });
    var optionColumns = computed(function() {
      var optionList = [{
        options: mergedOptions.value
      }];
      var currentList = mergedOptions.value;
      var _loop = function _loop2(i3) {
        var activeValueCell = activeValueCells.value[i3];
        var currentOption = currentList.find(function(option) {
          return option[fieldNames.value.value] === activeValueCell;
        });
        var subOptions = currentOption === null || currentOption === void 0 ? void 0 : currentOption[fieldNames.value.children];
        if (!(subOptions !== null && subOptions !== void 0 && subOptions.length)) {
          return "break";
        }
        currentList = subOptions;
        optionList.push({
          options: subOptions
        });
      };
      for (var i2 = 0; i2 < activeValueCells.value.length; i2 += 1) {
        var _ret = _loop(i2);
        if (_ret === "break")
          break;
      }
      return optionList;
    });
    var onKeyboardSelect = function onKeyboardSelect2(selectValueCells, option) {
      if (isSelectable(option)) {
        onPathSelect(selectValueCells, isLeaf(option, fieldNames.value), true);
      }
    };
    useKeyboard(context2, mergedOptions, fieldNames, activeValueCells, onPathOpen, onKeyboardSelect);
    var onListMouseDown = function onListMouseDown2(event2) {
      event2.preventDefault();
    };
    onMounted(function() {
      watch(activeValueCells, function(cells) {
        for (var i2 = 0; i2 < cells.length; i2 += 1) {
          var _containerRef$value;
          var cellPath = cells.slice(0, i2 + 1);
          var cellKeyPath = toPathKey(cellPath);
          var ele = (_containerRef$value = containerRef.value) === null || _containerRef$value === void 0 ? void 0 : _containerRef$value.querySelector('li[data-path-key="'.concat(cellKeyPath.replace(/\\{0,2}"/g, '\\"'), '"]'));
          if (ele) {
            scrollIntoParentView(ele);
          }
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    return function() {
      var _slots$notFoundConten, _customSlots$value$no, _customSlots$value, _optionColumns$value$, _optionColumns$value$2, _ref3, _ref4;
      var _baseProps$notFoundCo = baseProps3.notFoundContent, notFoundContent = _baseProps$notFoundCo === void 0 ? ((_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots)) || ((_customSlots$value$no = (_customSlots$value = customSlots.value).notFoundContent) === null || _customSlots$value$no === void 0 ? void 0 : _customSlots$value$no.call(_customSlots$value)) : _baseProps$notFoundCo, multiple = baseProps3.multiple, toggleOpen = baseProps3.toggleOpen;
      var isEmpty = !((_optionColumns$value$ = optionColumns.value[0]) !== null && _optionColumns$value$ !== void 0 && (_optionColumns$value$2 = _optionColumns$value$.options) !== null && _optionColumns$value$2 !== void 0 && _optionColumns$value$2.length);
      var emptyList = [(_ref3 = {}, _defineProperty$U(_ref3, fieldNames.value.value, "__EMPTY__"), _defineProperty$U(_ref3, FIX_LABEL, notFoundContent), _defineProperty$U(_ref3, "disabled", true), _ref3)];
      var columnProps = _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        multiple: !isEmpty && multiple,
        onSelect: onPathSelect,
        onActive: onPathOpen,
        onToggleOpen: toggleOpen,
        checkedSet: checkedSet.value,
        halfCheckedSet: halfCheckedSet.value,
        loadingKeys: loadingKeys.value,
        isSelectable
      });
      var mergedOptionColumns = isEmpty ? [{
        options: emptyList
      }] : optionColumns.value;
      var columnNodes = mergedOptionColumns.map(function(col, index2) {
        var prevValuePath = activeValueCells.value.slice(0, index2);
        var activeValue = activeValueCells.value[index2];
        return createVNode(Column$1, _objectSpread2$1(_objectSpread2$1({
          "key": index2
        }, columnProps), {}, {
          "prefixCls": mergedPrefixCls.value,
          "options": col.options,
          "prevValuePath": prevValuePath,
          "activeValue": activeValue
        }), null);
      });
      return createVNode("div", {
        "class": ["".concat(mergedPrefixCls.value, "-menus"), (_ref4 = {}, _defineProperty$U(_ref4, "".concat(mergedPrefixCls.value, "-menu-empty"), isEmpty), _defineProperty$U(_ref4, "".concat(mergedPrefixCls.value, "-rtl"), rtl2.value), _ref4)],
        "onMousedown": onListMouseDown,
        "ref": containerRef
      }, [columnNodes]);
    };
  }
});
function useMaxLevel(keyEntities) {
  var maxLevel = ref(0);
  var levelEntities = shallowRef();
  watchEffect(function() {
    var newLevelEntities = /* @__PURE__ */ new Map();
    var newMaxLevel = 0;
    var keyEntitiesValue = keyEntities.value || {};
    for (var key2 in keyEntitiesValue) {
      if (Object.prototype.hasOwnProperty.call(keyEntitiesValue, key2)) {
        var entity = keyEntitiesValue[key2];
        var level = entity.level;
        var levelSet = newLevelEntities.get(level);
        if (!levelSet) {
          levelSet = /* @__PURE__ */ new Set();
          newLevelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        newMaxLevel = Math.max(newMaxLevel, level);
      }
    }
    maxLevel.value = newMaxLevel;
    levelEntities.value = newLevelEntities;
  });
  return {
    maxLevel,
    levelEntities
  };
}
function baseCascaderProps() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseSelectPropsWithoutPrivate(), ["tokenSeparators", "mode", "showSearch"])), {}, {
    id: String,
    prefixCls: String,
    fieldNames: Object,
    children: Array,
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: SHOW_PARENT$1
    },
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    expandTrigger: String,
    options: Array,
    dropdownPrefixCls: String,
    loadData: Function,
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    popupClassName: String,
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    popupPlacement: String,
    placement: String,
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    expandIcon: PropTypes$1.any,
    loadingIcon: PropTypes$1.any
  });
}
function internalCascaderProps() {
  return _objectSpread2$1(_objectSpread2$1({}, baseCascaderProps()), {}, {
    onChange: Function,
    customSlots: Object
  });
}
function isMultipleValue(value) {
  return Array.isArray(value) && Array.isArray(value[0]);
}
function toRawValues(value) {
  if (!value) {
    return [];
  }
  if (isMultipleValue(value)) {
    return value;
  }
  return (value.length === 0 ? [] : [value]).map(function(val) {
    return Array.isArray(val) ? val : [val];
  });
}
const Cascader$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: false,
  props: initDefaultProps$1(internalCascaderProps(), {}),
  setup: function setup93(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var mergedId = useId(toRef(props3, "id"));
    var multiple = computed(function() {
      return !!props3.checkable;
    });
    var _useMergedState = useMergedState(props3.defaultValue, {
      value: computed(function() {
        return props3.value;
      }),
      postState: toRawValues
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), rawValues = _useMergedState2[0], setRawValues = _useMergedState2[1];
    var mergedFieldNames = computed(function() {
      return fillFieldNames$2(props3.fieldNames);
    });
    var mergedOptions = computed(function() {
      return props3.options || [];
    });
    var pathKeyEntities = useEntities(mergedOptions, mergedFieldNames);
    var getValueByKeyPath = function getValueByKeyPath2(pathKeys) {
      var keyPathEntities = pathKeyEntities.value;
      return pathKeys.map(function(pathKey) {
        var nodes = keyPathEntities[pathKey].nodes;
        return nodes.map(function(node) {
          return node[mergedFieldNames.value.value];
        });
      });
    };
    var _useMergedState3 = useMergedState("", {
      value: computed(function() {
        return props3.searchValue;
      }),
      postState: function postState(search) {
        return search || "";
      }
    }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), mergedSearchValue = _useMergedState4[0], setSearchValue = _useMergedState4[1];
    var onInternalSearch = function onInternalSearch2(searchText, info) {
      setSearchValue(searchText);
      if (info.source !== "blur" && props3.onSearch) {
        props3.onSearch(searchText);
      }
    };
    var _useSearchConfig = useSearchConfig(toRef(props3, "showSearch")), mergedShowSearch = _useSearchConfig.showSearch, mergedSearchConfig = _useSearchConfig.searchConfig;
    var searchOptions = useSearchOptions(mergedSearchValue, mergedOptions, mergedFieldNames, computed(function() {
      return props3.dropdownPrefixCls || props3.prefixCls;
    }), mergedSearchConfig, toRef(props3, "changeOnSelect"));
    var missingValuesInfo = useMissingValues(mergedOptions, mergedFieldNames, rawValues);
    var _ref2 = [ref([]), ref([]), ref([])], checkedValues = _ref2[0], halfCheckedValues = _ref2[1], missingCheckedValues = _ref2[2];
    var _useMaxLevel = useMaxLevel(pathKeyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
    watchEffect(function() {
      var _missingValuesInfo$va = _slicedToArray$2(missingValuesInfo.value, 2), existValues = _missingValuesInfo$va[0], missingValues = _missingValuesInfo$va[1];
      if (!multiple.value || !rawValues.value.length) {
        var _ref3 = [existValues, [], missingValues];
        checkedValues.value = _ref3[0];
        halfCheckedValues.value = _ref3[1];
        missingCheckedValues.value = _ref3[2];
        return;
      }
      var keyPathValues = toPathKeys(existValues);
      var keyPathEntities = pathKeyEntities.value;
      var _conductCheck = conductCheck(keyPathValues, true, keyPathEntities, maxLevel.value, levelEntities.value), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
      var _ref4 = [getValueByKeyPath(checkedKeys), getValueByKeyPath(halfCheckedKeys), missingValues];
      checkedValues.value = _ref4[0];
      halfCheckedValues.value = _ref4[1];
      missingCheckedValues.value = _ref4[2];
    });
    var deDuplicatedValues = computed(function() {
      var checkedKeys = toPathKeys(checkedValues.value);
      var deduplicateKeys = formatStrategyValues$1(checkedKeys, pathKeyEntities.value, props3.showCheckedStrategy);
      return [].concat(_toConsumableArray(missingCheckedValues.value), _toConsumableArray(getValueByKeyPath(deduplicateKeys)));
    });
    var displayValues = useDisplayValues(deDuplicatedValues, mergedOptions, mergedFieldNames, multiple, toRef(props3, "displayRender"));
    var triggerChange = function triggerChange2(nextValues) {
      setRawValues(nextValues);
      if (props3.onChange) {
        var nextRawValues = toRawValues(nextValues);
        var valueOptions = nextRawValues.map(function(valueCells) {
          return toPathOptions(valueCells, mergedOptions.value, mergedFieldNames.value).map(function(valueOpt) {
            return valueOpt.option;
          });
        });
        var triggerValues = multiple.value ? nextRawValues : nextRawValues[0];
        var triggerOptions = multiple.value ? valueOptions : valueOptions[0];
        props3.onChange(triggerValues, triggerOptions);
      }
    };
    var onInternalSelect = function onInternalSelect2(valuePath) {
      setSearchValue("");
      if (!multiple.value) {
        triggerChange(valuePath);
      } else {
        var pathKey = toPathKey(valuePath);
        var checkedPathKeys = toPathKeys(checkedValues.value);
        var halfCheckedPathKeys = toPathKeys(halfCheckedValues.value);
        var existInChecked = checkedPathKeys.includes(pathKey);
        var existInMissing = missingCheckedValues.value.some(function(valueCells) {
          return toPathKey(valueCells) === pathKey;
        });
        var nextCheckedValues = checkedValues.value;
        var nextMissingValues = missingCheckedValues.value;
        if (existInMissing && !existInChecked) {
          nextMissingValues = missingCheckedValues.value.filter(function(valueCells) {
            return toPathKey(valueCells) !== pathKey;
          });
        } else {
          var nextRawCheckedKeys = existInChecked ? checkedPathKeys.filter(function(key2) {
            return key2 !== pathKey;
          }) : [].concat(_toConsumableArray(checkedPathKeys), [pathKey]);
          var checkedKeys;
          if (existInChecked) {
            var _conductCheck2 = conductCheck(nextRawCheckedKeys, {
              checked: false,
              halfCheckedKeys: halfCheckedPathKeys
            }, pathKeyEntities.value, maxLevel.value, levelEntities.value);
            checkedKeys = _conductCheck2.checkedKeys;
          } else {
            var _conductCheck3 = conductCheck(nextRawCheckedKeys, true, pathKeyEntities.value, maxLevel.value, levelEntities.value);
            checkedKeys = _conductCheck3.checkedKeys;
          }
          var deDuplicatedKeys = formatStrategyValues$1(checkedKeys, pathKeyEntities.value, props3.showCheckedStrategy);
          nextCheckedValues = getValueByKeyPath(deDuplicatedKeys);
        }
        triggerChange([].concat(_toConsumableArray(nextMissingValues), _toConsumableArray(nextCheckedValues)));
      }
    };
    var onDisplayValuesChange = function onDisplayValuesChange2(_2, info) {
      if (info.type === "clear") {
        triggerChange([]);
        return;
      }
      var valueCells = info.values[0].valueCells;
      onInternalSelect(valueCells);
    };
    var mergedOpen = computed(function() {
      return props3.open !== void 0 ? props3.open : props3.popupVisible;
    });
    var mergedDropdownClassName = computed(function() {
      return props3.dropdownClassName || props3.popupClassName;
    });
    var mergedDropdownStyle = computed(function() {
      return props3.dropdownStyle || props3.popupStyle || {};
    });
    var mergedPlacement = computed(function() {
      return props3.placement || props3.popupPlacement;
    });
    var onInternalDropdownVisibleChange = function onInternalDropdownVisibleChange2(nextVisible) {
      var _props$onDropdownVisi, _props$onPopupVisible;
      (_props$onDropdownVisi = props3.onDropdownVisibleChange) === null || _props$onDropdownVisi === void 0 ? void 0 : _props$onDropdownVisi.call(props3, nextVisible);
      (_props$onPopupVisible = props3.onPopupVisibleChange) === null || _props$onPopupVisible === void 0 ? void 0 : _props$onPopupVisible.call(props3, nextVisible);
    };
    var _toRefs = toRefs(props3), changeOnSelect = _toRefs.changeOnSelect, checkable = _toRefs.checkable, dropdownPrefixCls = _toRefs.dropdownPrefixCls, loadData = _toRefs.loadData, expandTrigger = _toRefs.expandTrigger, expandIcon = _toRefs.expandIcon, loadingIcon = _toRefs.loadingIcon, dropdownMenuColumnStyle = _toRefs.dropdownMenuColumnStyle, customSlots = _toRefs.customSlots;
    useProvideCascader({
      options: mergedOptions,
      fieldNames: mergedFieldNames,
      values: checkedValues,
      halfValues: halfCheckedValues,
      changeOnSelect,
      onSelect: onInternalSelect,
      checkable,
      searchOptions,
      dropdownPrefixCls,
      loadData,
      expandTrigger,
      expandIcon,
      loadingIcon,
      dropdownMenuColumnStyle,
      customSlots
    });
    var selectRef = ref();
    expose({
      focus: function focus() {
        var _selectRef$value;
        (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
      },
      blur: function blur() {
        var _selectRef$value2;
        (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
      },
      scrollTo: function scrollTo2(arg) {
        var _selectRef$value3;
        (_selectRef$value3 = selectRef.value) === null || _selectRef$value3 === void 0 ? void 0 : _selectRef$value3.scrollTo(arg);
      }
    });
    var pickProps = computed(function() {
      return omit$2(props3, [
        "id",
        "prefixCls",
        "fieldNames",
        "defaultValue",
        "value",
        "changeOnSelect",
        "onChange",
        "displayRender",
        "checkable",
        "searchValue",
        "onSearch",
        "showSearch",
        "expandTrigger",
        "options",
        "dropdownPrefixCls",
        "loadData",
        "popupVisible",
        "open",
        "popupClassName",
        "dropdownClassName",
        "dropdownMenuColumnStyle",
        "popupPlacement",
        "placement",
        "onDropdownVisibleChange",
        "onPopupVisibleChange",
        "expandIcon",
        "loadingIcon",
        "customSlots",
        "showCheckedStrategy",
        "children"
      ]);
    });
    return function() {
      var emptyOptions = !(mergedSearchValue.value ? searchOptions.value : mergedOptions.value).length;
      var _props$dropdownMatchS = props3.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? false : _props$dropdownMatchS;
      var dropdownStyle = mergedSearchValue.value && mergedSearchConfig.value.matchInputWidth || emptyOptions ? {} : {
        minWidth: "auto"
      };
      return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
        "ref": selectRef,
        "id": mergedId,
        "prefixCls": props3.prefixCls,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth,
        "dropdownStyle": _objectSpread2$1(_objectSpread2$1({}, mergedDropdownStyle.value), dropdownStyle),
        "displayValues": displayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "mode": multiple.value ? "multiple" : void 0,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "showSearch": mergedShowSearch.value,
        "OptionList": OptionList$1,
        "emptyOptions": emptyOptions,
        "open": mergedOpen.value,
        "dropdownClassName": mergedDropdownClassName.value,
        "placement": mergedPlacement.value,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "getRawInputElement": function getRawInputElement() {
          var _slots$default;
          return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
        }
      }), slots);
    };
  }
});
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
const LeftOutlinedSvg = LeftOutlined$2;
function _objectSpread$y(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$y(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$y(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var LeftOutlined = function LeftOutlined2(props3, context2) {
  var p2 = _objectSpread$y({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$y({}, p2, {
    "icon": LeftOutlinedSvg
  }), null);
};
LeftOutlined.displayName = "LeftOutlined";
LeftOutlined.inheritAttrs = false;
const LeftOutlined$1 = LeftOutlined;
function arrayEach(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (iteratee(array4[index2], index2, array4) === false) {
      break;
    }
  }
  return array4;
}
function copyObject(source2, props3, object4, customizer) {
  var isNew = !object4;
  object4 || (object4 = {});
  var index2 = -1, length = props3.length;
  while (++index2 < length) {
    var key2 = props3[index2];
    var newValue = customizer ? customizer(object4[key2], source2[key2], key2, object4, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key2];
    }
    if (isNew) {
      baseAssignValue(object4, key2, newValue);
    } else {
      assignValue(object4, key2, newValue);
    }
  }
  return object4;
}
function baseAssign(object4, source2) {
  return object4 && copyObject(source2, keys(source2), object4);
}
function nativeKeysIn(object4) {
  var result = [];
  if (object4 != null) {
    for (var key2 in Object(object4)) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseKeysIn(object4) {
  if (!isObject$2(object4)) {
    return nativeKeysIn(object4);
  }
  var isProto = isPrototype(object4), result = [];
  for (var key2 in object4) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$1.call(object4, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
function keysIn(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
}
function baseAssignIn(object4, source2) {
  return object4 && copyObject(source2, keysIn(source2), object4);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root$2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  if (isDeep) {
    return buffer2.slice();
  }
  var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
  buffer2.copy(result);
  return result;
}
function copyArray(source2, array4) {
  var index2 = -1, length = source2.length;
  array4 || (array4 = Array(length));
  while (++index2 < length) {
    array4[index2] = source2[index2];
  }
  return array4;
}
function copySymbols(source2, object4) {
  return copyObject(source2, getSymbols$1(source2), object4);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
  var result = [];
  while (object4) {
    arrayPush(result, getSymbols$1(object4));
    object4 = getPrototype$1(object4);
  }
  return result;
};
const getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source2, object4) {
  return copyObject(source2, getSymbolsIn$1(source2), object4);
}
function getAllKeysIn(object4) {
  return baseGetAllKeys(object4, keysIn, getSymbolsIn$1);
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array4) {
  var length = array4.length, result = new array4.constructor(length);
  if (length && typeof array4[0] == "string" && hasOwnProperty.call(array4, "index")) {
    result.index = array4.index;
    result.input = array4.input;
  }
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp$1(regexp4) {
  var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
  result.lastIndex = regexp4.lastIndex;
  return result;
}
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object4, tag, isDeep) {
  var Ctor = object4.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object4);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object4);
    case dataViewTag$1:
      return cloneDataView(object4, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object4, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$2:
    case stringTag$1:
      return new Ctor(object4);
    case regexpTag$1:
      return cloneRegExp$1(object4);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object4);
  }
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object4() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object4.prototype = proto;
    var result = new object4();
    object4.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function initCloneObject(object4) {
  return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate$1(getPrototype$1(object4)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
const isMap$2 = isMap$1;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
const isSet$2 = isSet$1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag$1 = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag$1] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key2, object4, stack2) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object4 ? customizer(value, key2, object4, stack2) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$a(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$3(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object4) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object4 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value);
  if (stacked) {
    return stacked;
  }
  stack2.set(value, result);
  if (isSet$2(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
    });
  } else if (isMap$2(value)) {
    value.forEach(function(subValue, key3) {
      result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn : keys;
  var props3 = isArr ? void 0 : keysFunc(value);
  arrayEach(props3 || value, function(subValue, key3) {
    if (props3) {
      key3 = subValue;
      subValue = value[key3];
    }
    assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
  });
  return result;
}
var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key2 in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key2)) {
          target[key2] = source2[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args2, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args3, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args3);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e2) {
        return typeof e2 === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$6(template) {
  for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args2[_key - 1] = arguments[_key];
  }
  var i2 = 0;
  var len = args2.length;
  if (typeof template === "function") {
    return template.apply(null, args2);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i2 >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args2[i2++]);
        case "%d":
          return Number(args2[i2++]);
        case "%j":
          try {
            return JSON.stringify(args2[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total3 = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total3++;
    if (total3 === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source2) {
  if (option.first) {
    var _pending = new Promise(function(resolve2, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source2);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending["catch"](function(e2) {
      return e2;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total3 = 0;
  var results = [];
  var pending = new Promise(function(resolve2, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total3++;
      if (total3 === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source2);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve2(source2);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending["catch"](function(e2) {
    return e2;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$1(value, path2) {
  var v2 = value;
  for (var i2 = 0; i2 < path2.length; i2++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path2[i2]];
  }
  return v2;
}
function complementError(rule, source2) {
  return function(oe) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$1(source2, rule.fullFields);
    } else {
      fieldValue = source2[oe.field || rule.fullField];
    }
    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      fieldValue,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source2) {
  if (source2) {
    for (var s2 in source2) {
      if (source2.hasOwnProperty(s2)) {
        var value = source2[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source2, errors, options, type4) {
  if (rule.required && (!source2.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format$6(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source2, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format$6(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b2 = function b3(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path2;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e2) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type2(rule, value, source2, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source2, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$6(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$6(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source2, errors, options) {
  var len = typeof rule.len === "number";
  var min3 = typeof rule.min === "number";
  var max3 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key2 = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$6(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min3 && !max3 && val < rule.min) {
    errors.push(format$6(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max3 && !min3 && val > rule.max) {
    errors.push(format$6(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min3 && max3 && (val < rule.min || val > rule.max)) {
    errors.push(format$6(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source2, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format$6(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source2, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format$6(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format$6(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
      rules.pattern(rule, value, source2, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source2, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source2, errors, options);
      rules.range(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source2, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source2, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source2, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source2, errors, options, type4);
  callback(errors);
};
var type$2 = function type3(rule, value, callback, source2, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source2, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source2, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source2, errors, options);
  }
  callback(errors);
};
var validators$2 = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type$2,
  hex: type$2,
  email: type$2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone3() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name2) {
      var item = rules2[name2];
      _this.rules[name2] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source2 = source_;
    var options = o2;
    var callback = oc;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source2);
      }
      return Promise.resolve(source2);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add2(e2) {
        if (Array.isArray(e2)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e2);
        } else {
          errors.push(e2);
        }
      }
      for (var i2 = 0; i2 < results.length; i2++) {
        add2(results[i2]);
      }
      if (!errors.length) {
        callback(null, source2);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value = source2[z2];
      arr.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source2 === source_) {
            source2 = _extends({}, source2);
          }
          value = source2[z2] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value,
          source: source2,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data9, doIt) {
      var rule = data9.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data9.value);
      rule.field = data9.field;
      function addFullField(key2, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb(e2) {
        if (e2 === void 0) {
          e2 = [];
        }
        var errorList = Array.isArray(e2) ? e2 : [e2];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source2));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data9.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source2));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$6(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data9.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data9.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data9.rule.options) {
            data9.rule.options.messages = options.messages;
            data9.rule.options.error = options.error;
          }
          schema.validate(data9.value, data9.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data9.value, cb, data9.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data9.value, cb, data9.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb(error.message);
        }
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e2) {
          return cb(e2);
        });
      }
    }, function(results) {
      complete(results);
    }, source2);
  };
  _proto.getType = function getType2(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
      throw new Error(format$6("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators$2.required;
    }
    return validators$2[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register2(type4, validator2) {
  if (typeof validator2 !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators$2[type4] = validator2;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators$2;
function toArray$5(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function get$4(entity, path2) {
  var current2 = entity;
  for (var i2 = 0; i2 < path2.length; i2 += 1) {
    if (current2 === null || current2 === void 0) {
      return void 0;
    }
    current2 = current2[path2[i2]];
  }
  return current2;
}
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
  var clone3;
  if (!entity && typeof path2 === "number") {
    clone3 = [];
  } else if (Array.isArray(entity)) {
    clone3 = _toConsumableArray(entity);
  } else {
    clone3 = _objectSpread2$1({}, entity);
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone3[path2][restPath[0]];
  } else {
    clone3[path2] = internalSet(clone3[path2], restPath, value, removeIfUndefined);
  }
  return clone3;
}
function set$1(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value === void 0 && !get$4(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function getNamePath(path2) {
  return toArray$5(path2);
}
function getValue(store, namePath) {
  var value = get$4(store, namePath);
  return value;
}
function setValue(store, namePath, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = set$1(store, namePath, value, removeIfUndefined);
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath(path2, namePath);
  });
}
function isObject$1(obj) {
  return _typeof$3(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store, values) {
  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2$1({}, store);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach(function(key2) {
    var prevValue = newStore[key2];
    var value = values[key2];
    var recursive = isObject$1(prevValue) && isObject$1(value);
    newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;
  });
  return newStore;
}
function setValues(store) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current2, newStore) {
    return internalSetValues(current2, newStore);
  }, store);
}
function cloneByNamePathList(store, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value = getValue(store, namePath);
    newStore = setValue(newStore, namePath, value);
  });
  return newStore;
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i2) {
    return changedNamePath[i2] === nameUnit;
  });
}
var typeTemplate$1 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$1,
    method: typeTemplate$1,
    array: typeTemplate$1,
    object: typeTemplate$1,
    number: typeTemplate$1,
    date: typeTemplate$1,
    boolean: typeTemplate$1,
    integer: typeTemplate$1,
    float: typeTemplate$1,
    regexp: typeTemplate$1,
    email: typeTemplate$1,
    url: typeTemplate$1,
    hex: typeTemplate$1
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
var AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, function(str) {
    var key2 = str.slice(2, -1);
    return kv[key2];
  });
}
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
function _validateRule() {
  _validateRule = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee2(name2, value, rule, options, messageVariables) {
    var cloneRule, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
    return regenerator.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2$1({}, rule);
            delete cloneRule.ruleIndex;
            delete cloneRule.trigger;
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator2 = new AsyncValidator(_defineProperty$U({}, name2, [cloneRule]));
            messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
            validator2.messages(messages2);
            result = [];
            _context2.prev = 9;
            _context2.next = 12;
            return Promise.resolve(validator2.validate(_defineProperty$U({}, name2, value), _objectSpread2$1({}, options)));
          case 12:
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](9);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index2) {
                var message2 = _ref4.message;
                return isValidElement(message2) ? cloneVNode(message2, {
                  key: "error_".concat(index2)
                }) : message2;
              });
            } else {
              console.error(_context2.t0);
              result = [messages2.default()];
            }
          case 17:
            if (!(!result.length && subRuleField)) {
              _context2.next = 22;
              break;
            }
            _context2.next = 20;
            return Promise.all(value.map(function(subValue, i2) {
              return validateRule("".concat(name2, ".").concat(i2), subValue, subRuleField, options, messageVariables);
            }));
          case 20:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
              return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
            }, []));
          case 22:
            kv = _objectSpread2$1(_objectSpread2$1({}, rule), {}, {
              name: name2,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error) {
              if (typeof error === "string") {
                return replaceMessage(error, kv);
              }
              return error;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[9, 14]]);
  }));
  return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
  var name2 = namePath.join(".");
  var filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator;
    var cloneRule = _objectSpread2$1(_objectSpread2$1({}, currentRule), {}, {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = function(rule, val, callback) {
        var hasPromise = false;
        var wrappedCallback = function wrappedCallback2() {
          for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
            args2[_key] = arguments[_key];
          }
          Promise.resolve().then(function() {
            if (!hasPromise) {
              callback.apply(void 0, args2);
            }
          });
        };
        var promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        if (hasPromise) {
          promise.then(function() {
            callback();
          }).catch(function(err) {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(function(_ref, _ref2) {
    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
    var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  var summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(resolve2, reject) {
        var i2, rule, errors;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i2 = 0;
              case 1:
                if (!(i2 < filledRules.length)) {
                  _context.next = 12;
                  break;
                }
                rule = filledRules[i2];
                _context.next = 5;
                return validateRule(name2, value, rule, options, messageVariables);
              case 5:
                errors = _context.sent;
                if (!errors.length) {
                  _context.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context.abrupt("return");
              case 9:
                i2 += 1;
                _context.next = 1;
                break;
              case 12:
                resolve2([]);
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  } else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name2, value, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch(function(e2) {
    return e2;
  });
  return summaryPromise;
}
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee3(rulePromises) {
    return regenerator.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee4(rulePromises) {
    var count;
    return regenerator.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            count = 0;
            return _context4.abrupt("return", new Promise(function(resolve2) {
              rulePromises.forEach(function(promise) {
                promise.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve2([ruleError]);
                  }
                  count += 1;
                  if (count === rulePromises.length) {
                    resolve2([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _finishOnFirstFailed.apply(this, arguments);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object4, source2, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object4 == null) {
    return !length;
  }
  object4 = Object(object4);
  while (index2--) {
    var data9 = matchData[index2];
    if (noCustomizer && data9[2] ? data9[1] !== object4[data9[0]] : !(data9[0] in object4)) {
      return false;
    }
  }
  while (++index2 < length) {
    data9 = matchData[index2];
    var key2 = data9[0], objValue = object4[key2], srcValue = data9[1];
    if (noCustomizer && data9[2]) {
      if (objValue === void 0 && !(key2 in object4)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key2, object4, source2, stack2);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$2(value);
}
function getMatchData(object4) {
  var result = keys(object4), length = result.length;
  while (length--) {
    var key2 = result[length], value = object4[key2];
    result[length] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object4) {
    if (object4 == null) {
      return false;
    }
    return object4[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object4));
  };
}
function baseMatches(source2) {
  var matchData = getMatchData(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object4) {
    return object4 === source2 || baseIsMatch(object4, source2, matchData);
  };
}
function get$3(object4, path2, defaultValue) {
  var result = object4 == null ? void 0 : baseGet(object4, path2);
  return result === void 0 ? defaultValue : result;
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path2), srcValue);
  }
  return function(object4) {
    var objValue = get$3(object4, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object4, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function basePropertyDeep(path2) {
  return function(object4) {
    return baseGet(object4, path2);
  };
}
function property(path2) {
  return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$a(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key2) {
        return iteratee(iterable[key2], key2, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var nativeMax = Math.max;
function findIndex(array4, predicate, fromIndex) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax(length + index2, 0);
  }
  return baseFindIndex(array4, baseIteratee(predicate), index2);
}
var find = createFind(findIndex);
const find$1 = find;
var FormContextKey = Symbol("formContextKey");
var useProvideForm = function useProvideForm2(state) {
  provide(FormContextKey, state);
};
var useInjectForm = function useInjectForm2() {
  return inject(FormContextKey, {
    name: computed(function() {
      return void 0;
    }),
    labelAlign: computed(function() {
      return "right";
    }),
    vertical: computed(function() {
      return false;
    }),
    addField: function addField(_eventKey, _field) {
    },
    removeField: function removeField(_eventKey) {
    },
    model: computed(function() {
      return void 0;
    }),
    rules: computed(function() {
      return void 0;
    }),
    colon: computed(function() {
      return void 0;
    }),
    labelWrap: computed(function() {
      return void 0;
    }),
    labelCol: computed(function() {
      return void 0;
    }),
    requiredMark: computed(function() {
      return false;
    }),
    validateTrigger: computed(function() {
      return void 0;
    }),
    onValidate: function onValidate() {
    },
    validateMessages: computed(function() {
      return defaultValidateMessages;
    })
  });
};
var FormItemPrefixContextKey = Symbol("formItemPrefixContextKey");
var useProvideFormItemPrefix = function useProvideFormItemPrefix2(state) {
  provide(FormItemPrefixContextKey, state);
};
var useInjectFormItemPrefix = function useInjectFormItemPrefix2() {
  return inject(FormItemPrefixContextKey, {
    prefixCls: computed(function() {
      return "";
    })
  });
};
var FormItemLabel = function FormItemLabel2(props3, _ref) {
  var _props$label, _slots$label, _slots$tooltip, _classNames2;
  var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
  var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), prefixCls = _props$attrs.prefixCls, htmlFor = _props$attrs.htmlFor, labelCol = _props$attrs.labelCol, labelAlign = _props$attrs.labelAlign, colon = _props$attrs.colon, required4 = _props$attrs.required, requiredMark = _props$attrs.requiredMark;
  var _useLocaleReceiver = useLocaleReceiver("Form"), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), formLocale = _useLocaleReceiver2[0];
  var label = (_props$label = props3.label) !== null && _props$label !== void 0 ? _props$label : (_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots);
  if (!label)
    return null;
  var _useInjectForm = useInjectForm(), vertical = _useInjectForm.vertical, contextLabelAlign = _useInjectForm.labelAlign, contextLabelCol = _useInjectForm.labelCol, labelWrap = _useInjectForm.labelWrap, contextColon = _useInjectForm.colon;
  var mergedLabelCol = labelCol || (contextLabelCol === null || contextLabelCol === void 0 ? void 0 : contextLabelCol.value) || {};
  var mergedLabelAlign = labelAlign || (contextLabelAlign === null || contextLabelAlign === void 0 ? void 0 : contextLabelAlign.value);
  var labelClsBasic = "".concat(prefixCls, "-item-label");
  var labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && "".concat(labelClsBasic, "-left"), mergedLabelCol.class, _defineProperty$U({}, "".concat(labelClsBasic, "-wrap"), !!labelWrap.value));
  var labelChildren = label;
  var computedColon = colon === true || (contextColon === null || contextColon === void 0 ? void 0 : contextColon.value) !== false && colon !== false;
  var haveColon = computedColon && !vertical.value;
  if (haveColon && typeof label === "string" && label.trim() !== "") {
    labelChildren = label.replace(/[:|：]\s*$/, "");
  }
  labelChildren = createVNode(Fragment, null, [labelChildren, (_slots$tooltip = slots.tooltip) === null || _slots$tooltip === void 0 ? void 0 : _slots$tooltip.call(slots, {
    class: "".concat(prefixCls, "-item-tooltip")
  })]);
  if (requiredMark === "optional" && !required4) {
    var _formLocale$value, _defaultLocale$Form;
    labelChildren = createVNode(Fragment, null, [labelChildren, createVNode("span", {
      "class": "".concat(prefixCls, "-item-optional")
    }, [((_formLocale$value = formLocale.value) === null || _formLocale$value === void 0 ? void 0 : _formLocale$value.optional) || ((_defaultLocale$Form = defaultLocale.Form) === null || _defaultLocale$Form === void 0 ? void 0 : _defaultLocale$Form.optional)])]);
  }
  var labelClassName = classNames((_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-item-required"), required4), _defineProperty$U(_classNames2, "".concat(prefixCls, "-item-required-mark-optional"), requiredMark === "optional"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-item-no-colon"), !computedColon), _classNames2));
  return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedLabelCol), {}, {
    "class": labelColClassName
  }), {
    default: function _default9() {
      return [createVNode("label", {
        "for": htmlFor,
        "class": labelClassName,
        "title": typeof label === "string" ? label : "",
        "onClick": function onClick2(e2) {
          return emit("click", e2);
        }
      }, [labelChildren])];
    }
  });
};
FormItemLabel.displayName = "FormItemLabel";
FormItemLabel.inheritAttrs = false;
const FormItemLabel$1 = FormItemLabel;
const ErrorList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ErrorList",
  props: ["errors", "help", "onDomErrorVisibleChange", "helpStatus", "warnings"],
  setup: function setup94(props3) {
    var _useConfigInject = useConfigInject("", props3), rootPrefixCls = _useConfigInject.prefixCls;
    var _useInjectFormItemPre = useInjectFormItemPrefix(), prefixCls = _useInjectFormItemPre.prefixCls, status = _useInjectFormItemPre.status;
    var baseClassName = computed(function() {
      return "".concat(prefixCls.value, "-item-explain");
    });
    var visible = computed(function() {
      return !!(props3.errors && props3.errors.length);
    });
    var innerStatus = ref(status.value);
    watch([visible, status], function() {
      if (visible.value) {
        innerStatus.value = status.value;
      }
    });
    return function() {
      var _props$errors, _props$errors2;
      var colMItem = collapseMotion$1("".concat(rootPrefixCls.value, "-show-help-item"));
      var transitionGroupProps = getTransitionGroupProps("".concat(rootPrefixCls.value, "-show-help-item"), colMItem);
      transitionGroupProps.class = baseClassName.value;
      return (_props$errors = props3.errors) !== null && _props$errors !== void 0 && _props$errors.length ? createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps), {}, {
        "tag": "div"
      }), {
        default: function _default9() {
          return [(_props$errors2 = props3.errors) === null || _props$errors2 === void 0 ? void 0 : _props$errors2.map(function(error, index2) {
            return createVNode("div", {
              "key": index2,
              "role": "alert",
              "class": innerStatus.value ? "".concat(baseClassName.value, "-").concat(innerStatus.value) : ""
            }, [error]);
          })];
        }
      }) : null;
    };
  }
});
var iconMap = {
  success: CheckCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  error: CloseCircleFilled$1,
  validating: LoadingOutlined$1
};
var FormItemInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  slots: ["help", "extra", "errors"],
  inheritAttrs: false,
  props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status"],
  setup: function setup95(props3, _ref) {
    var slots = _ref.slots;
    var formContext = useInjectForm();
    var contextWrapperCol = formContext.wrapperCol;
    var subFormContext = _objectSpread2$1({}, formContext);
    delete subFormContext.labelCol;
    delete subFormContext.wrapperCol;
    useProvideForm(subFormContext);
    useProvideFormItemPrefix({
      prefixCls: computed(function() {
        return props3.prefixCls;
      }),
      status: computed(function() {
        return props3.status;
      })
    });
    return function() {
      var _slots$help, _slots$errors, _slots$extra;
      var prefixCls = props3.prefixCls, wrapperCol = props3.wrapperCol, _props$help = props3.help, help = _props$help === void 0 ? (_slots$help = slots.help) === null || _slots$help === void 0 ? void 0 : _slots$help.call(slots) : _props$help, _props$errors = props3.errors, errors = _props$errors === void 0 ? (_slots$errors = slots.errors) === null || _slots$errors === void 0 ? void 0 : _slots$errors.call(slots) : _props$errors, hasFeedback = props3.hasFeedback, status = props3.status, _props$extra = props3.extra, extra = _props$extra === void 0 ? (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots) : _props$extra;
      var baseClassName = "".concat(prefixCls, "-item");
      var mergedWrapperCol = wrapperCol || (contextWrapperCol === null || contextWrapperCol === void 0 ? void 0 : contextWrapperCol.value) || {};
      var className = classNames("".concat(baseClassName, "-control"), mergedWrapperCol.class);
      var IconNode = status && iconMap[status];
      return createVNode(Col$1, _objectSpread2$1(_objectSpread2$1({}, mergedWrapperCol), {}, {
        "class": className
      }), {
        default: function _default9() {
          var _slots$default;
          return createVNode(Fragment, null, [createVNode("div", {
            "class": "".concat(baseClassName, "-control-input")
          }, [createVNode("div", {
            "class": "".concat(baseClassName, "-control-input-content")
          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), hasFeedback && IconNode ? createVNode("span", {
            "class": "".concat(baseClassName, "-children-icon")
          }, [createVNode(IconNode, null, null)]) : null]), createVNode(ErrorList, {
            "errors": errors,
            "help": help,
            "class": "".concat(baseClassName, "-explain-connected")
          }, null), extra ? createVNode("div", {
            "class": "".concat(baseClassName, "-extra")
          }, [extra]) : null]);
        }
      });
    };
  }
});
const FormItemInput$1 = FormItemInput;
function useDebounce(value) {
  var cacheValue = shallowRef(value.value.slice());
  var timeout = null;
  watchEffect(function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      cacheValue.value = value.value;
    }, value.value.length ? 0 : 10);
  });
  return cacheValue;
}
tuple$1("success", "warning", "error", "validating", "");
function getPropByPath$1(obj, namePathList, strict) {
  var tempObj = obj;
  var keyArr = namePathList;
  var i2 = 0;
  try {
    for (var len = keyArr.length; i2 < len - 1; ++i2) {
      if (!tempObj && !strict)
        break;
      var key2 = keyArr[i2];
      if (key2 in tempObj) {
        tempObj = tempObj[key2];
      } else {
        if (strict) {
          throw Error("please transfer a valid name path to form item!");
        }
        break;
      }
    }
    if (strict && !tempObj) {
      throw Error("please transfer a valid name path to form item!");
    }
  } catch (error) {
    console.error("please transfer a valid name path to form item!");
  }
  return {
    o: tempObj,
    k: keyArr[i2],
    v: tempObj ? tempObj[keyArr[i2]] : void 0
  };
}
var formItemProps = function formItemProps2() {
  return {
    htmlFor: String,
    prefixCls: String,
    label: PropTypes$1.any,
    help: PropTypes$1.any,
    extra: PropTypes$1.any,
    labelCol: {
      type: Object
    },
    wrapperCol: {
      type: Object
    },
    hasFeedback: {
      type: Boolean,
      default: false
    },
    colon: {
      type: Boolean,
      default: void 0
    },
    labelAlign: PropTypes$1.oneOf(tuple$1("left", "right")),
    prop: {
      type: [String, Number, Array]
    },
    name: {
      type: [String, Number, Array]
    },
    rules: [Array, Object],
    autoLink: {
      type: Boolean,
      default: true
    },
    required: {
      type: Boolean,
      default: void 0
    },
    validateFirst: {
      type: Boolean,
      default: void 0
    },
    validateStatus: PropTypes$1.oneOf(tuple$1("", "success", "warning", "error", "validating")),
    validateTrigger: {
      type: [String, Array]
    },
    messageVariables: {
      type: Object
    },
    hidden: Boolean,
    noStyle: Boolean
  };
};
var indexGuid$1 = 0;
var defaultItemNamePrefixCls = "form_item";
const FormItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItem",
  inheritAttrs: false,
  __ANT_NEW_FORM_ITEM: true,
  props: formItemProps(),
  slots: ["help", "label", "extra"],
  setup: function setup96(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    warning$3(props3.prop === void 0);
    var eventKey = "form-item-".concat(++indexGuid$1);
    var _useConfigInject = useConfigInject("form", props3), prefixCls = _useConfigInject.prefixCls;
    var formContext = useInjectForm();
    var fieldName = computed(function() {
      return props3.name || props3.prop;
    });
    var errors = ref([]);
    var validateDisabled = ref(false);
    var inputRef = ref();
    var namePath = computed(function() {
      var val = fieldName.value;
      return getNamePath(val);
    });
    var fieldId = computed(function() {
      if (!namePath.value.length) {
        return void 0;
      } else {
        var formName = formContext.name.value;
        var mergedId = namePath.value.join("_");
        return formName ? "".concat(formName, "_").concat(mergedId) : "".concat(defaultItemNamePrefixCls, "_").concat(mergedId);
      }
    });
    var getNewFieldValue = function getNewFieldValue2() {
      var model = formContext.model.value;
      if (!model || !fieldName.value) {
        return;
      } else {
        return getPropByPath$1(model, namePath.value, true).v;
      }
    };
    var fieldValue = computed(function() {
      return getNewFieldValue();
    });
    var initialValue = ref(cloneDeep(fieldValue.value));
    var mergedValidateTrigger = computed(function() {
      var validateTrigger = props3.validateTrigger !== void 0 ? props3.validateTrigger : formContext.validateTrigger.value;
      validateTrigger = validateTrigger === void 0 ? "change" : validateTrigger;
      return toArray$5(validateTrigger);
    });
    var rulesRef = computed(function() {
      var formRules = formContext.rules.value;
      var selfRules = props3.rules;
      var requiredRule = props3.required !== void 0 ? {
        required: !!props3.required,
        trigger: mergedValidateTrigger.value
      } : [];
      var prop = getPropByPath$1(formRules, namePath.value);
      formRules = formRules ? prop.o[prop.k] || prop.v : [];
      var rules2 = [].concat(selfRules || formRules || []);
      if (find$1(rules2, function(rule) {
        return rule.required;
      })) {
        return rules2;
      } else {
        return rules2.concat(requiredRule);
      }
    });
    var isRequired2 = computed(function() {
      var rules2 = rulesRef.value;
      var isRequired3 = false;
      if (rules2 && rules2.length) {
        rules2.every(function(rule) {
          if (rule.required) {
            isRequired3 = true;
            return false;
          }
          return true;
        });
      }
      return isRequired3 || props3.required;
    });
    var validateState = ref();
    watchEffect(function() {
      validateState.value = props3.validateStatus;
    });
    var messageVariables = computed(function() {
      var variables = {};
      if (typeof props3.label === "string") {
        variables.label = props3.label;
      } else if (props3.name) {
        variables.label = String(name);
      }
      if (props3.messageVariables) {
        variables = _objectSpread2$1(_objectSpread2$1({}, variables), props3.messageVariables);
      }
      return variables;
    });
    var validateRules$1 = function validateRules$12(options) {
      if (namePath.value.length === 0) {
        return;
      }
      var _props$validateFirst = props3.validateFirst, validateFirst = _props$validateFirst === void 0 ? false : _props$validateFirst;
      var _ref2 = options || {}, triggerName = _ref2.triggerName;
      var filteredRules = rulesRef.value;
      if (triggerName) {
        filteredRules = filteredRules.filter(function(rule) {
          var trigger2 = rule.trigger;
          if (!trigger2 && !mergedValidateTrigger.value.length) {
            return true;
          }
          var triggerList = toArray$5(trigger2 || mergedValidateTrigger.value);
          return triggerList.includes(triggerName);
        });
      }
      if (!filteredRules.length) {
        return Promise.resolve();
      }
      var promise = validateRules(namePath.value, fieldValue.value, filteredRules, _objectSpread2$1({
        validateMessages: formContext.validateMessages.value
      }, options), validateFirst, messageVariables.value);
      validateState.value = "validating";
      errors.value = [];
      promise.catch(function(e2) {
        return e2;
      }).then(function() {
        var results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (validateState.value === "validating") {
          var res = results.filter(function(result) {
            return result && result.errors.length;
          });
          validateState.value = res.length ? "error" : "success";
          errors.value = res.map(function(r2) {
            return r2.errors;
          });
          formContext.onValidate(fieldName.value, !errors.value.length, errors.value.length ? toRaw(errors.value[0]) : null);
        }
      });
      return promise;
    };
    var _onFieldBlur = function onFieldBlur2() {
      validateRules$1({
        triggerName: "blur"
      });
    };
    var _onFieldChange = function onFieldChange2() {
      if (validateDisabled.value) {
        validateDisabled.value = false;
        return;
      }
      validateRules$1({
        triggerName: "change"
      });
    };
    var clearValidate2 = function clearValidate3() {
      validateState.value = props3.validateStatus;
      validateDisabled.value = false;
      errors.value = [];
    };
    var resetField = function resetField2() {
      validateState.value = props3.validateStatus;
      validateDisabled.value = true;
      errors.value = [];
      var model = formContext.model.value || {};
      var value = fieldValue.value;
      var prop = getPropByPath$1(model, namePath.value, true);
      if (Array.isArray(value)) {
        prop.o[prop.k] = [].concat(initialValue.value);
      } else {
        prop.o[prop.k] = initialValue.value;
      }
      nextTick(function() {
        validateDisabled.value = false;
      });
    };
    var htmlFor = computed(function() {
      return props3.htmlFor === void 0 ? fieldId.value : props3.htmlFor;
    });
    var onLabelClick = function onLabelClick2() {
      var id = htmlFor.value;
      if (!id || !inputRef.value) {
        return;
      }
      var control = inputRef.value.$el.querySelector('[id="'.concat(id, '"]'));
      if (control && control.focus) {
        control.focus();
      }
    };
    expose({
      onFieldBlur: _onFieldBlur,
      onFieldChange: _onFieldChange,
      clearValidate: clearValidate2,
      resetField
    });
    useProvideFormItemContext({
      id: fieldId,
      onFieldBlur: function onFieldBlur2() {
        if (props3.autoLink) {
          _onFieldBlur();
        }
      },
      onFieldChange: function onFieldChange2() {
        if (props3.autoLink) {
          _onFieldChange();
        }
      },
      clearValidate: clearValidate2
    }, computed(function() {
      return !!(props3.autoLink && formContext.model.value && fieldName.value);
    }));
    var registered = false;
    watch(fieldName, function(val) {
      if (val) {
        if (!registered) {
          registered = true;
          formContext.addField(eventKey, {
            fieldValue,
            fieldId,
            fieldName,
            resetField,
            clearValidate: clearValidate2,
            namePath,
            validateRules: validateRules$1,
            rules: rulesRef
          });
        }
      } else {
        registered = false;
        formContext.removeField(eventKey);
      }
    }, {
      immediate: true
    });
    onBeforeUnmount(function() {
      formContext.removeField(eventKey);
    });
    var debounceErrors = useDebounce(errors);
    var mergedValidateStatus = computed(function() {
      if (props3.validateStatus !== void 0) {
        return props3.validateStatus;
      } else if (debounceErrors.value.length) {
        return "error";
      }
      return validateState.value;
    });
    var itemClassName = computed(function() {
      var _ref3;
      return _ref3 = {}, _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item"), true), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-has-feedback"), mergedValidateStatus.value && props3.hasFeedback), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-has-success"), mergedValidateStatus.value === "success"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-has-warning"), mergedValidateStatus.value === "warning"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-has-error"), mergedValidateStatus.value === "error"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-is-validating"), mergedValidateStatus.value === "validating"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-item-hidden"), props3.hidden), _ref3;
    });
    return function() {
      var _slots$default, _props$help;
      if (props3.noStyle)
        return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var help = (_props$help = props3.help) !== null && _props$help !== void 0 ? _props$help : slots.help ? filterEmpty(slots.help()) : null;
      return createVNode(Row$3, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": [itemClassName.value, help !== void 0 && help !== null || debounceErrors.value.length ? "".concat(prefixCls.value, "-item-with-help") : "", attrs.class],
        "key": "row"
      }), {
        default: function _default9() {
          var _props$label, _slots$label, _props$extra, _slots$extra;
          return createVNode(Fragment, null, [createVNode(FormItemLabel$1, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
            "htmlFor": htmlFor.value,
            "required": isRequired2.value,
            "requiredMark": formContext.requiredMark.value,
            "prefixCls": prefixCls.value,
            "onClick": onLabelClick,
            "label": (_props$label = props3.label) !== null && _props$label !== void 0 ? _props$label : (_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots)
          }), null), createVNode(FormItemInput$1, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
            "errors": help !== void 0 && help !== null ? toArray$5(help) : debounceErrors.value,
            "prefixCls": prefixCls.value,
            "status": mergedValidateStatus.value,
            "ref": inputRef,
            "help": help,
            "extra": (_props$extra = props3.extra) !== null && _props$extra !== void 0 ? _props$extra : (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots)
          }), {
            default: slots.default
          })]);
        }
      });
    };
  }
});
function allPromiseFinish(promiseList) {
  var hasError = false;
  var count = promiseList.length;
  var results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise(function(resolve2, reject) {
    promiseList.forEach(function(promise, index2) {
      promise.catch(function(e2) {
        hasError = true;
        return e2;
      }).then(function(result) {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve2(results);
      });
    });
  });
}
function t(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r(t2, e2, n2, r2, i2, o2, l2, d2) {
  return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
}
var i = function(e2, i2) {
  var o2 = window, l2 = i2.scrollMode, d2 = i2.block, f2 = i2.inline, h2 = i2.boundary, u2 = i2.skipOverflowHiddenElements, s2 = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t(e2))
    throw new TypeError("Invalid target");
  for (var a2, c2, g2 = document.scrollingElement || document.documentElement, p2 = [], m2 = e2; t(m2) && s2(m2); ) {
    if ((m2 = null == (c2 = (a2 = m2).parentElement) ? a2.getRootNode().host || null : c2) === g2) {
      p2.push(m2);
      break;
    }
    null != m2 && m2 === document.body && n(m2) && !n(document.documentElement) || null != m2 && n(m2, u2) && p2.push(m2);
  }
  for (var w2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, v2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b2 = e2.getBoundingClientRect(), y2 = b2.height, E2 = b2.width, M2 = b2.top, V2 = b2.right, x2 = b2.bottom, I2 = b2.left, C = "start" === d2 || "nearest" === d2 ? M2 : "end" === d2 ? x2 : M2 + y2 / 2, R2 = "center" === f2 ? I2 + E2 / 2 : "end" === f2 ? V2 : I2, T2 = [], k2 = 0; k2 < p2.length; k2++) {
    var B2 = p2[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j2 = D2.left;
    if ("if-needed" === l2 && M2 >= 0 && I2 >= 0 && x2 <= v2 && V2 <= w2 && M2 >= Y2 && x2 <= S2 && I2 >= j2 && V2 <= L2)
      return T2;
    var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F2 = parseInt(N2.borderBottomWidth, 10), G = 0, J2 = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z2 - F2 : 0, Q = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X / B2.offsetWidth : 0, U = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
    if (g2 === B2)
      G = "start" === d2 ? C : "end" === d2 ? C - v2 : "nearest" === d2 ? r(H, H + v2, v2, z2, F2, H + C, H + C + y2, y2) : C - v2 / 2, J2 = "start" === f2 ? R2 : "center" === f2 ? R2 - w2 / 2 : "end" === f2 ? R2 - w2 : r(W, W + w2, w2, q2, A2, W + R2, W + R2 + E2, E2), G = Math.max(0, G + H), J2 = Math.max(0, J2 + W);
    else {
      G = "start" === d2 ? C - Y2 - z2 : "end" === d2 ? C - S2 + F2 + P2 : "nearest" === d2 ? r(Y2, S2, O2, z2, F2 + P2, C, C + y2, y2) : C - (Y2 + O2 / 2) + P2 / 2, J2 = "start" === f2 ? R2 - j2 - q2 : "center" === f2 ? R2 - (j2 + X / 2) + K / 2 : "end" === f2 ? R2 - L2 + A2 + K : r(j2, L2, X, q2, A2 + K, R2, R2 + E2, E2);
      var Z = B2.scrollLeft, $2 = B2.scrollTop;
      C += $2 - (G = Math.max(0, Math.min($2 + G / U, B2.scrollHeight - O2 / U + P2))), R2 += Z - (J2 = Math.max(0, Math.min(Z + J2 / Q, B2.scrollWidth - X / Q + K)));
    }
    T2.push({ el: B2, top: G, left: J2 });
  }
  return T2;
};
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i(target, computeOptions), computeOptions.behavior);
}
var nativeMin = Math.min;
function baseIntersection(arrays, iteratee, comparator2) {
  var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
  while (othIndex--) {
    var array4 = arrays[othIndex];
    if (othIndex && iteratee) {
      array4 = arrayMap(array4, baseUnary(iteratee));
    }
    maxLength = nativeMin(array4.length, maxLength);
    caches[othIndex] = !comparator2 && (iteratee || length >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : void 0;
  }
  array4 = arrays[0];
  var index2 = -1, seen2 = caches[0];
  outer:
    while (++index2 < length && result.length < maxLength) {
      var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator2 || value !== 0 ? value : 0;
      if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result, computed2, comparator2))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
            continue outer;
          }
        }
        if (seen2) {
          seen2.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});
const intersection$1 = intersection;
function last$1(array4) {
  var length = array4 == null ? 0 : array4.length;
  return length ? array4[length - 1] : void 0;
}
function parent(object4, path2) {
  return path2.length < 2 ? object4 : baseGet(object4, baseSlice(path2, 0, -1));
}
function baseUnset(object4, path2) {
  path2 = castPath(path2, object4);
  object4 = parent(object4, path2);
  return object4 == null || delete object4[toKey(last$1(path2))];
}
function customOmitClone(value) {
  return isPlainObject$1(value) ? void 0 : value;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object4, paths) {
  var result = {};
  if (object4 == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path2) {
    path2 = castPath(path2, object4);
    isDeep || (isDeep = path2.length > 1);
    return path2;
  });
  copyObject(object4, getAllKeysIn(object4), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
const omit$1 = omit;
function isRequired(rules2) {
  var isRequired2 = false;
  if (rules2 && rules2.length) {
    rules2.every(function(rule) {
      if (rule.required) {
        isRequired2 = true;
        return false;
      }
      return true;
    });
  }
  return isRequired2;
}
function toArray$4(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function getPropByPath(obj, path2, strict) {
  var tempObj = obj;
  path2 = path2.replace(/\[(\w+)\]/g, ".$1");
  path2 = path2.replace(/^\./, "");
  var keyArr = path2.split(".");
  var i2 = 0;
  for (var len = keyArr.length; i2 < len - 1; ++i2) {
    if (!tempObj && !strict)
      break;
    var key2 = keyArr[i2];
    if (key2 in tempObj) {
      tempObj = tempObj[key2];
    } else {
      if (strict) {
        throw new Error("please transfer a valid name path to validate!");
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i2],
    v: tempObj ? tempObj[keyArr[i2]] : null,
    isValid: tempObj && keyArr[i2] in tempObj
  };
}
function useForm(modelRef) {
  var rulesRef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ref({});
  var options = arguments.length > 2 ? arguments[2] : void 0;
  var initialModel = cloneDeep(unref(modelRef));
  var validateInfos = reactive({});
  var rulesKeys = shallowRef([]);
  var resetFields = function resetFields2(newValues) {
    _extends$1(unref(modelRef), _objectSpread2$1(_objectSpread2$1({}, cloneDeep(initialModel)), newValues));
    nextTick(function() {
      Object.keys(validateInfos).forEach(function(key2) {
        validateInfos[key2] = {
          autoLink: false,
          required: isRequired(unref(rulesRef)[key2])
        };
      });
    });
  };
  var filterRules = function filterRules2() {
    var rules2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var trigger2 = arguments.length > 1 ? arguments[1] : void 0;
    if (!trigger2.length) {
      return rules2;
    } else {
      return rules2.filter(function(rule) {
        var triggerList = toArray$4(rule.trigger || "change");
        return intersection$1(triggerList, trigger2).length;
      });
    }
  };
  var lastValidatePromise = null;
  var validateFields = function validateFields2(names2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var strict = arguments.length > 2 ? arguments[2] : void 0;
    var promiseList = [];
    var values = {};
    var _loop = function _loop2(i3) {
      var name2 = names2[i3];
      var prop = getPropByPath(unref(modelRef), name2, strict);
      if (!prop.isValid)
        return "continue";
      values[name2] = prop.v;
      var rules2 = filterRules(unref(rulesRef)[name2], toArray$4(option && option.trigger));
      if (rules2.length) {
        promiseList.push(validateField(name2, prop.v, rules2, option || {}).then(function() {
          return {
            name: name2,
            errors: [],
            warnings: []
          };
        }).catch(function(ruleErrors) {
          var mergedErrors = [];
          var mergedWarnings = [];
          ruleErrors.forEach(function(_ref) {
            var warningOnly = _ref.rule.warningOnly, errors = _ref.errors;
            if (warningOnly) {
              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
            } else {
              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: name2,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: name2,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    };
    for (var i2 = 0; i2 < names2.length; i2++) {
      var _ret = _loop(i2);
      if (_ret === "continue")
        continue;
    }
    var summaryPromise = allPromiseFinish(promiseList);
    lastValidatePromise = summaryPromise;
    var returnPromise = summaryPromise.then(function() {
      if (lastValidatePromise === summaryPromise) {
        return Promise.resolve(values);
      }
      return Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values,
        errorFields: errorList,
        outOfDate: lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e2) {
      return e2;
    });
    return returnPromise;
  };
  var validateField = function validateField2(name2, value, rules2) {
    var option = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var promise = validateRules([name2], value, rules2, _objectSpread2$1({
      validateMessages: defaultValidateMessages
    }, option), !!option.validateFirst);
    if (!validateInfos[name2]) {
      return promise.catch(function(e2) {
        return e2;
      });
    }
    validateInfos[name2].validateStatus = "validating";
    promise.catch(function(e2) {
      return e2;
    }).then(function() {
      var results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (validateInfos[name2].validateStatus === "validating") {
        var _options$onValidate;
        var res = results.filter(function(result) {
          return result && result.errors.length;
        });
        validateInfos[name2].validateStatus = res.length ? "error" : "success";
        validateInfos[name2].help = res.length ? res.map(function(r2) {
          return r2.errors;
        }) : null;
        options === null || options === void 0 ? void 0 : (_options$onValidate = options.onValidate) === null || _options$onValidate === void 0 ? void 0 : _options$onValidate.call(options, name2, !res.length, res.length ? toRaw(validateInfos[name2].help[0]) : null);
      }
    });
    return promise;
  };
  var validate = function validate2(names2, option) {
    var keys2 = [];
    var strict = true;
    if (!names2) {
      strict = false;
      keys2 = rulesKeys.value;
    } else if (Array.isArray(names2)) {
      keys2 = names2;
    } else {
      keys2 = [names2];
    }
    var promises = validateFields(keys2, option || {}, strict);
    promises.catch(function(e2) {
      return e2;
    });
    return promises;
  };
  var clearValidate2 = function clearValidate3(names2) {
    var keys2 = [];
    if (!names2) {
      keys2 = rulesKeys.value;
    } else if (Array.isArray(names2)) {
      keys2 = names2;
    } else {
      keys2 = [names2];
    }
    keys2.forEach(function(key2) {
      validateInfos[key2] && _extends$1(validateInfos[key2], {
        validateStatus: "",
        help: null
      });
    });
  };
  var mergeValidateInfo = function mergeValidateInfo2(items) {
    var info = {
      autoLink: false
    };
    var help = [];
    var infos = Array.isArray(items) ? items : [items];
    for (var i2 = 0; i2 < infos.length; i2++) {
      var arg = infos[i2];
      if ((arg === null || arg === void 0 ? void 0 : arg.validateStatus) === "error") {
        info.validateStatus = "error";
        arg.help && help.push(arg.help);
      }
      info.required = info.required || (arg === null || arg === void 0 ? void 0 : arg.required);
    }
    info.help = help;
    return info;
  };
  var oldModel = initialModel;
  var isFirstTime = true;
  var modelFn = function modelFn2(model) {
    var names2 = [];
    rulesKeys.value.forEach(function(key2) {
      var prop = getPropByPath(model, key2, false);
      var oldProp = getPropByPath(oldModel, key2, false);
      var isFirstValidation = isFirstTime && (options === null || options === void 0 ? void 0 : options.immediate) && prop.isValid;
      if (isFirstValidation || !isEqual$1(prop.v, oldProp.v)) {
        names2.push(key2);
      }
    });
    validate(names2, {
      trigger: "change"
    });
    isFirstTime = false;
    oldModel = cloneDeep(toRaw(model));
  };
  var debounceOptions = options === null || options === void 0 ? void 0 : options.debounce;
  var first = true;
  watch(rulesRef, function() {
    rulesKeys.value = rulesRef ? Object.keys(unref(rulesRef)) : [];
    if (!first && options && options.validateOnRuleChange) {
      validate();
    }
    first = false;
  }, {
    deep: true,
    immediate: true
  });
  watch(rulesKeys, function() {
    var newValidateInfos = {};
    rulesKeys.value.forEach(function(key3) {
      newValidateInfos[key3] = _extends$1({}, validateInfos[key3], {
        autoLink: false,
        required: isRequired(unref(rulesRef)[key3])
      });
      delete validateInfos[key3];
    });
    for (var key2 in validateInfos) {
      if (Object.prototype.hasOwnProperty.call(validateInfos, key2)) {
        delete validateInfos[key2];
      }
    }
    _extends$1(validateInfos, newValidateInfos);
  }, {
    immediate: true
  });
  watch(modelRef, debounceOptions && debounceOptions.wait ? debounce(modelFn, debounceOptions.wait, omit$1(debounceOptions, ["wait"])) : modelFn, {
    immediate: options && !!options.immediate,
    deep: true
  });
  return {
    modelRef,
    rulesRef,
    initialModel,
    validateInfos,
    resetFields,
    validate,
    validateField,
    mergeValidateInfo,
    clearValidate: clearValidate2
  };
}
var formProps = function formProps2() {
  return {
    layout: PropTypes$1.oneOf(tuple$1("horizontal", "inline", "vertical")),
    labelCol: {
      type: Object
    },
    wrapperCol: {
      type: Object
    },
    colon: {
      type: Boolean,
      default: void 0
    },
    labelAlign: PropTypes$1.oneOf(tuple$1("left", "right")),
    labelWrap: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    requiredMark: {
      type: [String, Boolean],
      default: void 0
    },
    hideRequiredMark: {
      type: Boolean,
      default: void 0
    },
    model: PropTypes$1.object,
    rules: {
      type: Object
    },
    validateMessages: {
      type: Object,
      default: void 0
    },
    validateOnRuleChange: {
      type: Boolean,
      default: void 0
    },
    scrollToFirstError: {
      type: [Boolean, Object]
    },
    onSubmit: Function,
    name: String,
    validateTrigger: {
      type: [String, Array]
    },
    size: {
      type: String
    },
    onValuesChange: {
      type: Function
    },
    onFieldsChange: {
      type: Function
    },
    onFinish: {
      type: Function
    },
    onFinishFailed: {
      type: Function
    },
    onValidate: {
      type: Function
    }
  };
};
function isEqualName(name1, name2) {
  return isEqual$1(toArray$5(name1), toArray$5(name2));
}
var Form = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AForm",
  inheritAttrs: false,
  props: initDefaultProps$1(formProps(), {
    layout: "horizontal",
    hideRequiredMark: false,
    colon: true
  }),
  Item: FormItem,
  useForm,
  setup: function setup97(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots, expose = _ref.expose, attrs = _ref.attrs;
    var size2 = useInjectSize(props3);
    var _useConfigInject = useConfigInject("form", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, contextForm = _useConfigInject.form;
    var requiredMark = computed(function() {
      return props3.requiredMark === "" || props3.requiredMark;
    });
    var mergedRequiredMark = computed(function() {
      var _contextForm$value;
      if (requiredMark.value !== void 0) {
        return requiredMark.value;
      }
      if (contextForm && ((_contextForm$value = contextForm.value) === null || _contextForm$value === void 0 ? void 0 : _contextForm$value.requiredMark) !== void 0) {
        return contextForm.value.requiredMark;
      }
      if (props3.hideRequiredMark) {
        return false;
      }
      return true;
    });
    var mergedColon = computed(function() {
      var _props$colon, _contextForm$value2;
      return (_props$colon = props3.colon) !== null && _props$colon !== void 0 ? _props$colon : (_contextForm$value2 = contextForm.value) === null || _contextForm$value2 === void 0 ? void 0 : _contextForm$value2.colon;
    });
    var _useInjectGlobalForm = useInjectGlobalForm(), globalValidateMessages = _useInjectGlobalForm.validateMessages;
    var validateMessages = computed(function() {
      return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages), globalValidateMessages.value), props3.validateMessages);
    });
    var formClassName = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(props3.layout), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-hide-required-mark"), mergedRequiredMark.value === false), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(size2.value), size2.value), _classNames));
    });
    var lastValidatePromise = ref();
    var fields = {};
    var addField = function addField2(eventKey, field) {
      fields[eventKey] = field;
    };
    var removeField = function removeField2(eventKey) {
      delete fields[eventKey];
    };
    var getFieldsByNameList = function getFieldsByNameList2(nameList) {
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? toArray$5(nameList).map(getNamePath) : [];
      if (!provideNameList) {
        return Object.values(fields);
      } else {
        return Object.values(fields).filter(function(field) {
          return namePathList.findIndex(function(namePath) {
            return isEqualName(namePath, field.fieldName.value);
          }) > -1;
        });
      }
    };
    var resetFields = function resetFields2(name2) {
      if (!props3.model) {
        warning$2(false, "Form", "model is required for resetFields to work.");
        return;
      }
      getFieldsByNameList(name2).forEach(function(field) {
        field.resetField();
      });
    };
    var clearValidate2 = function clearValidate3(name2) {
      getFieldsByNameList(name2).forEach(function(field) {
        field.clearValidate();
      });
    };
    var handleFinishFailed = function handleFinishFailed2(errorInfo) {
      var scrollToFirstError = props3.scrollToFirstError;
      emit("finishFailed", errorInfo);
      if (scrollToFirstError && errorInfo.errorFields.length) {
        var scrollToFieldOptions = {};
        if (_typeof$3(scrollToFirstError) === "object") {
          scrollToFieldOptions = scrollToFirstError;
        }
        scrollToField(errorInfo.errorFields[0].name, scrollToFieldOptions);
      }
    };
    var validate = function validate2() {
      return validateField.apply(void 0, arguments);
    };
    var scrollToField = function scrollToField2(name2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var fields2 = getFieldsByNameList(name2 ? [name2] : void 0);
      if (fields2.length) {
        var fieldId = fields2[0].fieldId.value;
        var node = fieldId ? document.getElementById(fieldId) : null;
        if (node) {
          scrollIntoView(node, _objectSpread2$1({
            scrollMode: "if-needed",
            block: "nearest"
          }, options));
        }
      }
    };
    var getFieldsValue = function getFieldsValue2() {
      var nameList = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (nameList === true) {
        var allNameList = [];
        Object.values(fields).forEach(function(_ref2) {
          var namePath = _ref2.namePath;
          allNameList.push(namePath.value);
        });
        return cloneByNamePathList(props3.model, allNameList);
      } else {
        return cloneByNamePathList(props3.model, nameList);
      }
    };
    var validateFields = function validateFields2(nameList, options) {
      warning$2(!(nameList instanceof Function), "Form", "validateFields/validateField/validate not support callback, please use promise instead");
      if (!props3.model) {
        warning$2(false, "Form", "model is required for validateFields to work.");
        return Promise.reject("Form `model` is required for validateFields to work.");
      }
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? toArray$5(nameList).map(getNamePath) : [];
      var promiseList = [];
      Object.values(fields).forEach(function(field) {
        var _field$rules;
        if (!provideNameList) {
          namePathList.push(field.namePath.value);
        }
        if (!((_field$rules = field.rules) !== null && _field$rules !== void 0 && _field$rules.value.length)) {
          return;
        }
        var fieldNamePath = field.namePath.value;
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
          var promise = field.validateRules(_objectSpread2$1({
            validateMessages: validateMessages.value
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var mergedErrors = [];
            var mergedWarnings = [];
            ruleErrors.forEach(function(_ref3) {
              var warningOnly = _ref3.rule.warningOnly, errors = _ref3.errors;
              if (warningOnly) {
                mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
              } else {
                mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      var summaryPromise = allPromiseFinish(promiseList);
      lastValidatePromise.value = summaryPromise;
      var returnPromise = summaryPromise.then(function() {
        if (lastValidatePromise.value === summaryPromise) {
          return Promise.resolve(getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch(function(results) {
        var errorList = results.filter(function(result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: lastValidatePromise.value !== summaryPromise
        });
      });
      returnPromise.catch(function(e2) {
        return e2;
      });
      return returnPromise;
    };
    var validateField = function validateField2() {
      return validateFields.apply(void 0, arguments);
    };
    var handleSubmit = function handleSubmit2(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      emit("submit", e2);
      if (props3.model) {
        var res = validateFields();
        res.then(function(values) {
          emit("finish", values);
        }).catch(function(errors) {
          handleFinishFailed(errors);
        });
      }
    };
    expose({
      resetFields,
      clearValidate: clearValidate2,
      validateFields,
      getFieldsValue,
      validate,
      scrollToField
    });
    useProvideForm({
      model: computed(function() {
        return props3.model;
      }),
      name: computed(function() {
        return props3.name;
      }),
      labelAlign: computed(function() {
        return props3.labelAlign;
      }),
      labelCol: computed(function() {
        return props3.labelCol;
      }),
      labelWrap: computed(function() {
        return props3.labelWrap;
      }),
      wrapperCol: computed(function() {
        return props3.wrapperCol;
      }),
      vertical: computed(function() {
        return props3.layout === "vertical";
      }),
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      validateTrigger: computed(function() {
        return props3.validateTrigger;
      }),
      rules: computed(function() {
        return props3.rules;
      }),
      addField,
      removeField,
      onValidate: function onValidate(name2, status, errors) {
        emit("validate", name2, status, errors);
      },
      validateMessages
    });
    watch(function() {
      return props3.rules;
    }, function() {
      if (props3.validateOnRuleChange) {
        validateFields();
      }
    });
    return function() {
      var _slots$default;
      return createVNode("form", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "onSubmit": handleSubmit,
        "class": [formClassName.value, attrs.class]
      }), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const Form$1 = Form;
Form$1.useInjectFormItemContext = useInjectFormItemContext;
Form$1.ItemRest = FormItemRest;
Form$1.install = function(app) {
  app.component(Form$1.name, Form$1);
  app.component(Form$1.Item.name, Form$1.Item);
  app.component(FormItemRest.name, FormItemRest);
  return app;
};
var _excluded$E = ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"];
function highlightKeyword(str, lowerKeyword, prefixCls) {
  var cells = str.toLowerCase().split(lowerKeyword).reduce(function(list, cur, index2) {
    return index2 === 0 ? [cur] : [].concat(_toConsumableArray(list), [lowerKeyword, cur]);
  }, []);
  var fillCells = [];
  var start = 0;
  cells.forEach(function(cell, index2) {
    var end = start + cell.length;
    var originWorld = str.slice(start, end);
    start = end;
    if (index2 % 2 === 1) {
      originWorld = createVNode("span", {
        "class": "".concat(prefixCls, "-menu-item-keyword"),
        "key": "seperator"
      }, [originWorld]);
    }
    fillCells.push(originWorld);
  });
  return fillCells;
}
var defaultSearchRender = function defaultSearchRender2(_ref) {
  var inputValue = _ref.inputValue, path2 = _ref.path, prefixCls = _ref.prefixCls, fieldNames = _ref.fieldNames;
  var optionList = [];
  var lower2 = inputValue.toLowerCase();
  path2.forEach(function(node, index2) {
    if (index2 !== 0) {
      optionList.push(" / ");
    }
    var label = node[fieldNames.label];
    var type4 = _typeof$3(label);
    if (type4 === "string" || type4 === "number") {
      label = highlightKeyword(String(label), lower2, prefixCls);
    }
    optionList.push(label);
  });
  return optionList;
};
function cascaderProps() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(internalCascaderProps(), ["customSlots", "checkable", "options"])), {}, {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: PropTypes$1.any,
    options: Array,
    "onUpdate:value": Function
  });
}
var Cascader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: false,
  props: initDefaultProps$1(cascaderProps(), {
    bordered: true,
    choiceTransitionName: "",
    allowClear: true
  }),
  setup: function setup98(props3, _ref2) {
    var attrs = _ref2.attrs, expose = _ref2.expose, slots = _ref2.slots, emit = _ref2.emit;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("cascader", props3), cascaderPrefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, renderEmpty2 = _useConfigInject.renderEmpty, size2 = _useConfigInject.size;
    var prefixCls = computed(function() {
      return getPrefixCls2("select", props3.prefixCls);
    });
    var isRtl = computed(function() {
      return direction.value === "rtl";
    });
    var mergedShowSearch = computed(function() {
      if (!props3.showSearch) {
        return props3.showSearch;
      }
      var searchConfig = {
        render: defaultSearchRender
      };
      if (_typeof$3(props3.showSearch) === "object") {
        searchConfig = _objectSpread2$1(_objectSpread2$1({}, searchConfig), props3.showSearch);
      }
      return searchConfig;
    });
    var mergedDropdownClassName = computed(function() {
      return classNames(props3.dropdownClassName || props3.popupClassName, "".concat(cascaderPrefixCls.value, "-dropdown"), _defineProperty$U({}, "".concat(cascaderPrefixCls.value, "-dropdown-rtl"), isRtl.value));
    });
    var selectRef = ref();
    expose({
      focus: function focus() {
        var _selectRef$value;
        (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
      },
      blur: function blur() {
        var _selectRef$value2;
        (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
      }
    });
    var handleChange2 = function handleChange3() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      emit("update:value", args2[0]);
      emit.apply(void 0, ["change"].concat(args2));
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2() {
      for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args2[_key2] = arguments[_key2];
      }
      emit.apply(void 0, ["blur"].concat(args2));
      formItemContext.onFieldBlur();
    };
    var mergedShowArrow = computed(function() {
      return props3.showArrow !== void 0 ? props3.showArrow : props3.loading || !props3.multiple;
    });
    var placement = computed(function() {
      if (props3.placement !== void 0) {
        return props3.placement;
      }
      return direction.value === "rtl" ? "bottomRight" : "bottomLeft";
    });
    return function() {
      var _slots$notFoundConten, _slots$expandIcon, _ref3;
      var _props$notFoundConten = props3.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? (_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots) : _props$notFoundConten, _props$expandIcon = props3.expandIcon, expandIcon = _props$expandIcon === void 0 ? (_slots$expandIcon = slots.expandIcon) === null || _slots$expandIcon === void 0 ? void 0 : _slots$expandIcon.call(slots) : _props$expandIcon, multiple = props3.multiple, bordered = props3.bordered, allowClear = props3.allowClear, choiceTransitionName = props3.choiceTransitionName, transitionName2 = props3.transitionName, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = _objectWithoutProperties$2(props3, _excluded$E);
      var mergedNotFoundContent = notFoundContent || renderEmpty2.value("Cascader");
      var mergedExpandIcon = expandIcon;
      if (!expandIcon) {
        mergedExpandIcon = isRtl.value ? createVNode(LeftOutlined$1, null, null) : createVNode(RightOutlined$1, null, null);
      }
      var loadingIcon = createVNode("span", {
        "class": "".concat(prefixCls.value, "-menu-item-loading-icon")
      }, [createVNode(LoadingOutlined$1, {
        "spin": true
      }, null)]);
      var _getIcons = getIcons(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        multiple,
        prefixCls: prefixCls.value,
        showArrow: mergedShowArrow.value
      }), slots), suffixIcon = _getIcons.suffixIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
      return createVNode(Cascader$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "id": id,
        "prefixCls": prefixCls.value,
        "class": [cascaderPrefixCls.value, (_ref3 = {}, _defineProperty$U(_ref3, "".concat(prefixCls.value, "-lg"), size2.value === "large"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-sm"), size2.value === "small"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-rtl"), isRtl.value), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-borderless"), !bordered), _ref3), attrs.class],
        "direction": direction.value,
        "placement": placement.value,
        "notFoundContent": mergedNotFoundContent,
        "allowClear": allowClear,
        "showSearch": mergedShowSearch.value,
        "expandIcon": mergedExpandIcon,
        "inputIcon": suffixIcon,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "loadingIcon": loadingIcon,
        "checkable": !!multiple,
        "dropdownClassName": mergedDropdownClassName.value,
        "dropdownPrefixCls": cascaderPrefixCls.value,
        "choiceTransitionName": getTransitionName$2(rootPrefixCls.value, "", choiceTransitionName),
        "transitionName": getTransitionName$2(rootPrefixCls.value, getTransitionDirection(placement.value), transitionName2),
        "getPopupContainer": getPopupContainer.value,
        "customSlots": _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
          checkable: function checkable() {
            return createVNode("span", {
              "class": "".concat(cascaderPrefixCls.value, "-checkbox-inner")
            }, null);
          }
        }),
        "tagRender": props3.tagRender || slots.tagRender,
        "displayRender": props3.displayRender || slots.displayRender,
        "maxTagPlaceholder": props3.maxTagPlaceholder || slots.maxTagPlaceholder,
        "showArrow": props3.showArrow,
        "onChange": handleChange2,
        "onBlur": handleBlur,
        "ref": selectRef
      }), slots);
    };
  }
});
const index$i = withInstall(Cascader);
var abstractCheckboxGroupProps = function abstractCheckboxGroupProps2() {
  return {
    name: String,
    prefixCls: String,
    options: {
      type: Array,
      default: function _default9() {
        return [];
      }
    },
    disabled: Boolean,
    id: String
  };
};
var checkboxGroupProps = function checkboxGroupProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxGroupProps()), {}, {
    defaultValue: {
      type: Array
    },
    value: {
      type: Array
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    }
  });
};
var abstractCheckboxProps = function abstractCheckboxProps2() {
  return {
    prefixCls: String,
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    isGroup: {
      type: Boolean,
      default: void 0
    },
    value: PropTypes$1.any,
    name: String,
    id: String,
    indeterminate: {
      type: Boolean,
      default: void 0
    },
    type: {
      type: String,
      default: "checkbox"
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    "onUpdate:checked": Function,
    onClick: Function,
    skipGroup: {
      type: Boolean,
      default: false
    }
  };
};
var checkboxProps = function checkboxProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractCheckboxProps()), {}, {
    indeterminate: {
      type: Boolean,
      default: false
    }
  });
};
var CheckboxGroupContextKey = Symbol("CheckboxGroupContext");
var _excluded$D = ["indeterminate", "skipGroup", "id"], _excluded2$5 = ["onMouseenter", "onMouseleave", "onInput", "class", "style"];
const Checkbox$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: false,
  __ANT_CHECKBOX: true,
  props: checkboxProps(),
  setup: function setup99(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("checkbox", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var checkboxGroup = inject(CheckboxGroupContextKey, void 0);
    var uniId = Symbol("checkboxUniId");
    watchEffect(function() {
      if (!props3.skipGroup && checkboxGroup) {
        checkboxGroup.registerValue(uniId, props3.value);
      }
    });
    onBeforeUnmount(function() {
      if (checkboxGroup) {
        checkboxGroup.cancelValue(uniId);
      }
    });
    onMounted(function() {
      warning$2(props3.checked !== void 0 || checkboxGroup || props3.value === void 0, "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    var handleChange2 = function handleChange3(event2) {
      var targetChecked = event2.target.checked;
      emit("update:checked", targetChecked);
      emit("change", event2);
    };
    var checkboxRef = ref();
    var focus = function focus2() {
      var _checkboxRef$value;
      (_checkboxRef$value = checkboxRef.value) === null || _checkboxRef$value === void 0 ? void 0 : _checkboxRef$value.focus();
    };
    var blur = function blur2() {
      var _checkboxRef$value2;
      (_checkboxRef$value2 = checkboxRef.value) === null || _checkboxRef$value2 === void 0 ? void 0 : _checkboxRef$value2.blur();
    };
    expose({
      focus,
      blur
    });
    return function() {
      var _slots$default, _classNames;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var indeterminate = props3.indeterminate, skipGroup = props3.skipGroup, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = _objectWithoutProperties$2(props3, _excluded$D);
      var onMouseenter2 = attrs.onMouseenter, onMouseleave2 = attrs.onMouseleave;
      attrs.onInput;
      var className = attrs.class, style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded2$5);
      var checkboxProps3 = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        id,
        prefixCls: prefixCls.value
      }, restAttrs);
      if (checkboxGroup && !skipGroup) {
        checkboxProps3.onChange = function() {
          for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
            args2[_key] = arguments[_key];
          }
          emit.apply(void 0, ["change"].concat(args2));
          checkboxGroup.toggleOption({
            label: children,
            value: props3.value
          });
        };
        checkboxProps3.name = checkboxGroup.name.value;
        checkboxProps3.checked = checkboxGroup.mergedValue.value.indexOf(props3.value) !== -1;
        checkboxProps3.disabled = props3.disabled || checkboxGroup.disabled.value;
        checkboxProps3.indeterminate = indeterminate;
      } else {
        checkboxProps3.onChange = handleChange2;
      }
      var classString = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper"), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper-checked"), checkboxProps3.checked), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrapper-disabled"), checkboxProps3.disabled), _classNames), className);
      var checkboxClass = classNames(_defineProperty$U({}, "".concat(prefixCls.value, "-indeterminate"), indeterminate));
      return createVNode("label", {
        "class": classString,
        "style": style2,
        "onMouseenter": onMouseenter2,
        "onMouseleave": onMouseleave2
      }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, checkboxProps3), {}, {
        "class": checkboxClass,
        "ref": checkboxRef
      }), null), children.length ? createVNode("span", null, [children]) : null]);
    };
  }
});
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (!it) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray$2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F2 = function F3() {
      };
      return {
        s: F2,
        n: function n2() {
          if (i2 >= o2.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o2[i2++]
          };
        },
        e: function e2(_e) {
          throw _e;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s2() {
      it = it.call(o2);
    },
    n: function n2() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e2(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f2() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
const CheckboxGroup$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  props: checkboxGroupProps(),
  setup: function setup100(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("checkbox", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var mergedValue = ref((props3.value === void 0 ? props3.defaultValue : props3.value) || []);
    watch(function() {
      return props3.value;
    }, function() {
      mergedValue.value = props3.value || [];
    });
    var options = computed(function() {
      return props3.options.map(function(option) {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    var triggerUpdate = ref(Symbol());
    var registeredValuesMap = ref(/* @__PURE__ */ new Map());
    var cancelValue = function cancelValue2(id) {
      registeredValuesMap.value.delete(id);
      triggerUpdate.value = Symbol();
    };
    var registerValue = function registerValue2(id, value) {
      registeredValuesMap.value.set(id, value);
      triggerUpdate.value = Symbol();
    };
    var registeredValues = ref(/* @__PURE__ */ new Map());
    watch(triggerUpdate, function() {
      var valuseMap = /* @__PURE__ */ new Map();
      var _iterator = _createForOfIteratorHelper(registeredValuesMap.value.values()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var value = _step.value;
          valuseMap.set(value, true);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      registeredValues.value = valuseMap;
    });
    var toggleOption = function toggleOption2(option) {
      var optionIndex = mergedValue.value.indexOf(option.value);
      var value = _toConsumableArray(mergedValue.value);
      if (optionIndex === -1) {
        value.push(option.value);
      } else {
        value.splice(optionIndex, 1);
      }
      if (props3.value === void 0) {
        mergedValue.value = value;
      }
      var val = value.filter(function(val2) {
        return registeredValues.value.has(val2);
      }).sort(function(a2, b2) {
        var indexA = options.value.findIndex(function(opt) {
          return opt.value === a2;
        });
        var indexB = options.value.findIndex(function(opt) {
          return opt.value === b2;
        });
        return indexA - indexB;
      });
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    provide(CheckboxGroupContextKey, {
      cancelValue,
      registerValue,
      toggleOption,
      mergedValue,
      name: computed(function() {
        return props3.name;
      }),
      disabled: computed(function() {
        return props3.disabled;
      })
    });
    expose({
      mergedValue
    });
    return function() {
      var _slots$default;
      var _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var children = null;
      var groupPrefixCls = "".concat(prefixCls.value, "-group");
      if (options.value && options.value.length > 0) {
        children = options.value.map(function(option) {
          var _slots$label;
          return createVNode(Checkbox$1, {
            "prefixCls": prefixCls.value,
            "key": option.value.toString(),
            "disabled": "disabled" in option ? option.disabled : props3.disabled,
            "indeterminate": option.indeterminate,
            "value": option.value,
            "checked": mergedValue.value.indexOf(option.value) !== -1,
            "onChange": option.onChange,
            "class": "".concat(groupPrefixCls, "-item")
          }, {
            default: function _default9() {
              return [option.label === void 0 ? (_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots, option) : option.label];
            }
          });
        });
      }
      return createVNode("div", {
        "class": [groupPrefixCls, _defineProperty$U({}, "".concat(groupPrefixCls, "-rtl"), direction.value === "rtl")],
        "id": id
      }, [children || ((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))]);
    };
  }
});
Checkbox$1.Group = CheckboxGroup$1;
Checkbox$1.install = function(app) {
  app.component(Checkbox$1.name, Checkbox$1);
  app.component(CheckboxGroup$1.name, CheckboxGroup$1);
  return app;
};
var commentProps = function commentProps2() {
  return {
    actions: Array,
    author: PropTypes$1.any,
    avatar: PropTypes$1.any,
    content: PropTypes$1.any,
    prefixCls: String,
    datetime: PropTypes$1.any
  };
};
var Comment = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AComment",
  props: commentProps(),
  slots: ["actions", "author", "avatar", "content", "datetime"],
  setup: function setup101(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("comment", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var renderNested = function renderNested2(prefixCls2, children) {
      return createVNode("div", {
        "class": "".concat(prefixCls2, "-nested")
      }, [children]);
    };
    var getAction = function getAction2(actions) {
      if (!actions || !actions.length) {
        return null;
      }
      var actionList = actions.map(function(action, index2) {
        return createVNode("li", {
          "key": "action-".concat(index2)
        }, [action]);
      });
      return actionList;
    };
    return function() {
      var _props$actions, _slots$actions, _props$author, _slots$author, _props$avatar, _slots$avatar, _props$content, _slots$content, _props$datetime, _slots$datetime, _slots$default;
      var pre = prefixCls.value;
      var actions = (_props$actions = props3.actions) !== null && _props$actions !== void 0 ? _props$actions : (_slots$actions = slots.actions) === null || _slots$actions === void 0 ? void 0 : _slots$actions.call(slots);
      var author = (_props$author = props3.author) !== null && _props$author !== void 0 ? _props$author : (_slots$author = slots.author) === null || _slots$author === void 0 ? void 0 : _slots$author.call(slots);
      var avatar = (_props$avatar = props3.avatar) !== null && _props$avatar !== void 0 ? _props$avatar : (_slots$avatar = slots.avatar) === null || _slots$avatar === void 0 ? void 0 : _slots$avatar.call(slots);
      var content = (_props$content = props3.content) !== null && _props$content !== void 0 ? _props$content : (_slots$content = slots.content) === null || _slots$content === void 0 ? void 0 : _slots$content.call(slots);
      var datetime = (_props$datetime = props3.datetime) !== null && _props$datetime !== void 0 ? _props$datetime : (_slots$datetime = slots.datetime) === null || _slots$datetime === void 0 ? void 0 : _slots$datetime.call(slots);
      var avatarDom = createVNode("div", {
        "class": "".concat(pre, "-avatar")
      }, [typeof avatar === "string" ? createVNode("img", {
        "src": avatar,
        "alt": "comment-avatar"
      }, null) : avatar]);
      var actionDom = actions ? createVNode("ul", {
        "class": "".concat(pre, "-actions")
      }, [getAction(Array.isArray(actions) ? actions : [actions])]) : null;
      var authorContent = createVNode("div", {
        "class": "".concat(pre, "-content-author")
      }, [author && createVNode("span", {
        "class": "".concat(pre, "-content-author-name")
      }, [author]), datetime && createVNode("span", {
        "class": "".concat(pre, "-content-author-time")
      }, [datetime])]);
      var contentDom = createVNode("div", {
        "class": "".concat(pre, "-content")
      }, [authorContent, createVNode("div", {
        "class": "".concat(pre, "-content-detail")
      }, [content]), actionDom]);
      var comment = createVNode("div", {
        "class": "".concat(pre, "-inner")
      }, [avatarDom, contentDom]);
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      return createVNode("div", {
        "class": [pre, _defineProperty$U({}, "".concat(pre, "-rtl"), direction.value === "rtl")]
      }, [comment, children && children.length ? renderNested(pre, children) : null]);
    };
  }
});
const index$h = withInstall(Comment);
var PickerButton = function PickerButton2(props3, _ref) {
  var attrs = _ref.attrs, slots = _ref.slots;
  return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({
    "size": "small",
    "type": "primary"
  }, props3), attrs), slots);
};
const PickerButton$1 = PickerButton;
var checkableTagProps = function checkableTagProps2() {
  return {
    prefixCls: String,
    checked: {
      type: Boolean,
      default: void 0
    },
    onChange: {
      type: Function
    },
    onClick: {
      type: Function
    },
    "onUpdate:checked": Function
  };
};
var CheckableTag = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckableTag",
  props: checkableTagProps(),
  setup: function setup102(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var _useConfigInject = useConfigInject("tag", props3), prefixCls = _useConfigInject.prefixCls;
    var handleClick2 = function handleClick3(e2) {
      var checked = props3.checked;
      emit("update:checked", !checked);
      emit("change", !checked);
      emit("click", e2);
    };
    var cls = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-checkable"), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-checkable-checked"), props3.checked), _classNames));
    });
    return function() {
      var _slots$default;
      return createVNode("span", {
        "class": cls.value,
        "onClick": handleClick2
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const CheckableTag$1 = CheckableTag;
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
var PresetStatusColorRegex = new RegExp("^(".concat(PresetStatusColorTypes.join("|"), ")$"));
var tagProps = function tagProps2() {
  return {
    prefixCls: String,
    color: {
      type: String
    },
    closable: {
      type: Boolean,
      default: false
    },
    closeIcon: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    onClose: {
      type: Function
    },
    "onUpdate:visible": Function,
    icon: PropTypes$1.any
  };
};
var Tag = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATag",
  props: tagProps(),
  slots: ["closeIcon", "icon"],
  setup: function setup103(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("tag", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var visible = ref(true);
    watchEffect(function() {
      if (props3.visible !== void 0) {
        visible.value = props3.visible;
      }
    });
    var handleCloseClick = function handleCloseClick2(e2) {
      e2.stopPropagation();
      emit("update:visible", false);
      emit("close", e2);
      if (e2.defaultPrevented) {
        return;
      }
      if (props3.visible === void 0) {
        visible.value = false;
      }
    };
    var isPresetColor2 = computed(function() {
      var color = props3.color;
      if (!color) {
        return false;
      }
      return PresetColorRegex.test(color) || PresetStatusColorRegex.test(color);
    });
    var tagClassName = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(props3.color), isPresetColor2.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-has-color"), props3.color && !isPresetColor2.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-hidden"), !visible.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
    });
    return function() {
      var _slots$icon, _slots$closeIcon, _slots$default;
      var _props$icon = props3.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots) : _props$icon, color = props3.color, _props$closeIcon = props3.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : _props$closeIcon, _props$closable = props3.closable, closable = _props$closable === void 0 ? false : _props$closable;
      var renderCloseIcon = function renderCloseIcon2() {
        if (closable) {
          return closeIcon ? createVNode("span", {
            "class": "".concat(prefixCls.value, "-close-icon"),
            "onClick": handleCloseClick
          }, [closeIcon]) : createVNode(CloseOutlined$1, {
            "class": "".concat(prefixCls.value, "-close-icon"),
            "onClick": handleCloseClick
          }, null);
        }
        return null;
      };
      var tagStyle = {
        backgroundColor: color && !isPresetColor2.value ? color : void 0
      };
      var iconNode = icon || null;
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var kids = iconNode ? createVNode(Fragment, null, [iconNode, createVNode("span", null, [children])]) : children;
      var isNeedWave = "onClick" in attrs;
      var tagNode = createVNode("span", {
        "class": tagClassName.value,
        "style": tagStyle
      }, [kids, renderCloseIcon()]);
      return isNeedWave ? createVNode(Wave, null, {
        default: function _default9() {
          return [tagNode];
        }
      }) : tagNode;
    };
  }
});
Tag.CheckableTag = CheckableTag$1;
Tag.install = function(app) {
  app.component(Tag.name, Tag);
  app.component(CheckableTag$1.name, CheckableTag$1);
  return app;
};
const Tag$1 = Tag;
function PickerTag(props3, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  return createVNode(Tag$1, _objectSpread2$1(_objectSpread2$1({
    "color": "blue"
  }, props3), attrs), slots);
}
var CalendarOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
const CalendarOutlinedSvg = CalendarOutlined$2;
function _objectSpread$x(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$x(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$x(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CalendarOutlined = function CalendarOutlined2(props3, context2) {
  var p2 = _objectSpread$x({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$x({}, p2, {
    "icon": CalendarOutlinedSvg
  }), null);
};
CalendarOutlined.displayName = "CalendarOutlined";
CalendarOutlined.inheritAttrs = false;
const CalendarOutlined$1 = CalendarOutlined;
var ClockCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
const ClockCircleOutlinedSvg = ClockCircleOutlined$2;
function _objectSpread$w(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$w(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$w(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ClockCircleOutlined = function ClockCircleOutlined2(props3, context2) {
  var p2 = _objectSpread$w({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$w({}, p2, {
    "icon": ClockCircleOutlinedSvg
  }), null);
};
ClockCircleOutlined.displayName = "ClockCircleOutlined";
ClockCircleOutlined.inheritAttrs = false;
const ClockCircleOutlined$1 = ClockCircleOutlined;
function getPlaceholder(picker, locale2, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.yearPlaceholder;
  }
  if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
    return locale2.lang.quarterPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.monthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.weekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.placeholder;
  }
  return locale2.lang.placeholder;
}
function getRangePlaceholder(picker, locale2, customizePlaceholder) {
  if (customizePlaceholder !== void 0) {
    return customizePlaceholder;
  }
  if (picker === "year" && locale2.lang.yearPlaceholder) {
    return locale2.lang.rangeYearPlaceholder;
  }
  if (picker === "month" && locale2.lang.monthPlaceholder) {
    return locale2.lang.rangeMonthPlaceholder;
  }
  if (picker === "week" && locale2.lang.weekPlaceholder) {
    return locale2.lang.rangeWeekPlaceholder;
  }
  if (picker === "time" && locale2.timePickerLocale.placeholder) {
    return locale2.timePickerLocale.rangePlaceholder;
  }
  return locale2.lang.rangePlaceholder;
}
function commonProps() {
  return {
    id: String,
    dropdownClassName: String,
    dropdownAlign: {
      type: Object
    },
    popupStyle: {
      type: Object
    },
    transitionName: String,
    placeholder: String,
    allowClear: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    tabindex: Number,
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    inputReadOnly: {
      type: Boolean,
      default: void 0
    },
    getPopupContainer: {
      type: Function
    },
    panelRender: {
      type: Function
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    },
    onOk: {
      type: Function
    },
    onOpenChange: {
      type: Function
    },
    "onUpdate:open": {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onMousedown: {
      type: Function
    },
    onMouseup: {
      type: Function
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onContextmenu: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    role: String,
    name: String,
    autocomplete: String,
    direction: {
      type: String
    },
    showToday: {
      type: Boolean,
      default: void 0
    },
    showTime: {
      type: [Boolean, Object],
      default: void 0
    },
    locale: {
      type: Object
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    dateRender: {
      type: Function
    },
    disabledDate: {
      type: Function
    },
    mode: {
      type: String
    },
    picker: {
      type: String
    },
    valueFormat: String,
    disabledHours: Function,
    disabledMinutes: Function,
    disabledSeconds: Function
  };
}
function datePickerProps() {
  return {
    defaultPickerValue: {
      type: [String, Object]
    },
    defaultValue: {
      type: [String, Object]
    },
    value: {
      type: [String, Object]
    },
    disabledTime: {
      type: Function
    },
    format: {
      type: [String, Function, Array]
    },
    renderExtraFooter: {
      type: Function
    },
    showNow: {
      type: Boolean,
      default: void 0
    },
    monthCellRender: {
      type: Function
    },
    monthCellContentRender: {
      type: Function
    }
  };
}
function rangePickerProps() {
  return {
    allowEmpty: {
      type: Array
    },
    dateRender: {
      type: Function
    },
    defaultPickerValue: {
      type: Array
    },
    defaultValue: {
      type: Array
    },
    value: {
      type: Array
    },
    disabledTime: {
      type: Function
    },
    disabled: {
      type: [Boolean, Array]
    },
    format: String,
    renderExtraFooter: {
      type: Function
    },
    separator: {
      type: String
    },
    ranges: {
      type: Object
    },
    placeholder: Array,
    mode: {
      type: Array
    },
    onChange: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    },
    onCalendarChange: {
      type: Function
    },
    onPanelChange: {
      type: Function
    },
    onOk: {
      type: Function
    }
  };
}
var _excluded$C = ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"];
function generateSinglePicker(generateConfig2, extraProps) {
  function getPicker(picker, displayName) {
    var comProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), datePickerProps()), extraProps);
    return defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: displayName,
      inheritAttrs: false,
      props: comProps,
      slots: [
        "suffixIcon",
        "prevIcon",
        "nextIcon",
        "superPrevIcon",
        "superNextIcon",
        "dateRender",
        "renderExtraFooter",
        "monthCellRender"
      ],
      setup: function setup219(_props, _ref) {
        var slots = _ref.slots, expose = _ref.expose, attrs = _ref.attrs, emit = _ref.emit;
        var props3 = _props;
        var formItemContext = useInjectFormItemContext();
        devWarning(!(props3.monthCellContentRender || slots.monthCellContentRender), "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.');
        devWarning(!attrs.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
        var _useConfigInject = useConfigInject("picker", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, size2 = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
        var pickerRef = ref();
        expose({
          focus: function focus() {
            var _pickerRef$value;
            (_pickerRef$value = pickerRef.value) === null || _pickerRef$value === void 0 ? void 0 : _pickerRef$value.focus();
          },
          blur: function blur() {
            var _pickerRef$value2;
            (_pickerRef$value2 = pickerRef.value) === null || _pickerRef$value2 === void 0 ? void 0 : _pickerRef$value2.blur();
          }
        });
        var maybeToString = function maybeToString2(date4) {
          return props3.valueFormat ? generateConfig2.toString(date4, props3.valueFormat) : date4;
        };
        var onChange3 = function onChange4(date4, dateString) {
          var value2 = maybeToString(date4);
          emit("update:value", value2);
          emit("change", value2, dateString);
          formItemContext.onFieldChange();
        };
        var onOpenChange = function onOpenChange2(open2) {
          emit("update:open", open2);
          emit("openChange", open2);
        };
        var onFocus2 = function onFocus3(e2) {
          emit("focus", e2);
        };
        var onBlur2 = function onBlur3(e2) {
          emit("blur", e2);
          formItemContext.onFieldBlur();
        };
        var onPanelChange = function onPanelChange2(date4, mode) {
          var value2 = maybeToString(date4);
          emit("panelChange", value2, mode);
        };
        var onOk = function onOk2(date4) {
          var value2 = maybeToString(date4);
          emit("ok", value2);
        };
        var _useLocaleReceiver = useLocaleReceiver("DatePicker", enUS), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), contextLocale = _useLocaleReceiver2[0];
        var value = computed(function() {
          if (props3.value) {
            return props3.valueFormat ? generateConfig2.toDate(props3.value, props3.valueFormat) : props3.value;
          }
          return props3.value === "" ? void 0 : props3.value;
        });
        var defaultValue = computed(function() {
          if (props3.defaultValue) {
            return props3.valueFormat ? generateConfig2.toDate(props3.defaultValue, props3.valueFormat) : props3.defaultValue;
          }
          return props3.defaultValue === "" ? void 0 : props3.defaultValue;
        });
        var defaultPickerValue = computed(function() {
          if (props3.defaultPickerValue) {
            return props3.valueFormat ? generateConfig2.toDate(props3.defaultPickerValue, props3.valueFormat) : props3.defaultPickerValue;
          }
          return props3.defaultPickerValue === "" ? void 0 : props3.defaultPickerValue;
        });
        return function() {
          var _slots$suffixIcon, _slots$clearIcon, _classNames, _slots$prevIcon, _slots$nextIcon, _slots$superPrevIcon, _slots$superNextIcon;
          var locale2 = _objectSpread2$1(_objectSpread2$1({}, contextLocale.value), props3.locale);
          var p2 = _objectSpread2$1(_objectSpread2$1({}, props3), attrs);
          var _p$bordered = p2.bordered, bordered = _p$bordered === void 0 ? true : _p$bordered, placeholder = p2.placeholder, _p$suffixIcon = p2.suffixIcon, suffixIcon = _p$suffixIcon === void 0 ? (_slots$suffixIcon = slots.suffixIcon) === null || _slots$suffixIcon === void 0 ? void 0 : _slots$suffixIcon.call(slots) : _p$suffixIcon, _p$showToday = p2.showToday, showToday = _p$showToday === void 0 ? true : _p$showToday, transitionName2 = p2.transitionName, _p$allowClear = p2.allowClear, allowClear = _p$allowClear === void 0 ? true : _p$allowClear, _p$dateRender = p2.dateRender, dateRender = _p$dateRender === void 0 ? slots.dateRender : _p$dateRender, _p$renderExtraFooter = p2.renderExtraFooter, renderExtraFooter = _p$renderExtraFooter === void 0 ? slots.renderExtraFooter : _p$renderExtraFooter, _p$monthCellRender = p2.monthCellRender, monthCellRender = _p$monthCellRender === void 0 ? slots.monthCellRender || props3.monthCellContentRender || slots.monthCellContentRender : _p$monthCellRender, _p$clearIcon = p2.clearIcon, clearIcon = _p$clearIcon === void 0 ? (_slots$clearIcon = slots.clearIcon) === null || _slots$clearIcon === void 0 ? void 0 : _slots$clearIcon.call(slots) : _p$clearIcon, _p$id = p2.id, id = _p$id === void 0 ? formItemContext.id.value : _p$id, restProps = _objectWithoutProperties$2(p2, _excluded$C);
          var showTime = p2.showTime === "" ? true : p2.showTime;
          var format5 = p2.format;
          var additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          var mergedPicker = picker || p2.picker || "date";
          additionalOverrideProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, additionalOverrideProps), showTime ? getTimeProps(_objectSpread2$1({
            format: format5,
            picker: mergedPicker
          }, _typeof$3(showTime) === "object" ? showTime : {})) : {}), mergedPicker === "time" ? getTimeProps(_objectSpread2$1(_objectSpread2$1({
            format: format5
          }, restProps), {}, {
            picker: mergedPicker
          })) : {});
          var pre = prefixCls.value;
          return createVNode(Picker$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
            "monthCellRender": monthCellRender,
            "dateRender": dateRender,
            "renderExtraFooter": renderExtraFooter,
            "ref": pickerRef,
            "placeholder": getPlaceholder(mergedPicker, locale2, placeholder),
            "suffixIcon": suffixIcon || (mergedPicker === "time" ? createVNode(ClockCircleOutlined$1, null, null) : createVNode(CalendarOutlined$1, null, null)),
            "clearIcon": clearIcon || createVNode(CloseCircleFilled$1, null, null),
            "allowClear": allowClear,
            "transitionName": transitionName2 || "".concat(rootPrefixCls.value, "-slide-up")
          }, restProps), additionalOverrideProps), {}, {
            "id": id,
            "picker": mergedPicker,
            "value": value.value,
            "defaultValue": defaultValue.value,
            "defaultPickerValue": defaultPickerValue.value,
            "showToday": showToday,
            "locale": locale2.lang,
            "class": classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-").concat(size2.value), size2.value), _defineProperty$U(_classNames, "".concat(pre, "-borderless"), !bordered), _classNames), attrs.class),
            "prefixCls": pre,
            "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
            "generateConfig": generateConfig2,
            "prevIcon": ((_slots$prevIcon = slots.prevIcon) === null || _slots$prevIcon === void 0 ? void 0 : _slots$prevIcon.call(slots)) || createVNode("span", {
              "class": "".concat(pre, "-prev-icon")
            }, null),
            "nextIcon": ((_slots$nextIcon = slots.nextIcon) === null || _slots$nextIcon === void 0 ? void 0 : _slots$nextIcon.call(slots)) || createVNode("span", {
              "class": "".concat(pre, "-next-icon")
            }, null),
            "superPrevIcon": ((_slots$superPrevIcon = slots.superPrevIcon) === null || _slots$superPrevIcon === void 0 ? void 0 : _slots$superPrevIcon.call(slots)) || createVNode("span", {
              "class": "".concat(pre, "-super-prev-icon")
            }, null),
            "superNextIcon": ((_slots$superNextIcon = slots.superNextIcon) === null || _slots$superNextIcon === void 0 ? void 0 : _slots$superNextIcon.call(slots)) || createVNode("span", {
              "class": "".concat(pre, "-super-next-icon")
            }, null),
            "components": Components,
            "direction": direction.value,
            "onChange": onChange3,
            "onOpenChange": onOpenChange,
            "onFocus": onFocus2,
            "onBlur": onBlur2,
            "onPanelChange": onPanelChange,
            "onOk": onOk
          }), null);
        };
      }
    });
  }
  var DatePicker2 = getPicker(void 0, "ADatePicker");
  var WeekPicker2 = getPicker("week", "AWeekPicker");
  var MonthPicker2 = getPicker("month", "AMonthPicker");
  var YearPicker2 = getPicker("year", "AYearPicker");
  var TimePicker2 = getPicker("time", "TimePicker");
  var QuarterPicker2 = getPicker("quarter", "AQuarterPicker");
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2
  };
}
var SwapRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
const SwapRightOutlinedSvg = SwapRightOutlined$2;
function _objectSpread$v(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$v(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$v(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var SwapRightOutlined = function SwapRightOutlined2(props3, context2) {
  var p2 = _objectSpread$v({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$v({}, p2, {
    "icon": SwapRightOutlinedSvg
  }), null);
};
SwapRightOutlined.displayName = "SwapRightOutlined";
SwapRightOutlined.inheritAttrs = false;
const SwapRightOutlined$1 = SwapRightOutlined;
var _excluded$B = ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"];
function generateRangePicker(generateConfig2, extraProps) {
  var RangePicker2 = defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: false,
    props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), rangePickerProps()), extraProps),
    slots: [
      "suffixIcon",
      "prevIcon",
      "nextIcon",
      "superPrevIcon",
      "superNextIcon",
      "dateRender",
      "renderExtraFooter"
    ],
    setup: function setup219(_props, _ref) {
      var expose = _ref.expose, slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
      var props3 = _props;
      var formItemContext = useInjectFormItemContext();
      devWarning(!attrs.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.');
      var _useConfigInject = useConfigInject("picker", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, size2 = _useConfigInject.size, rootPrefixCls = _useConfigInject.rootPrefixCls;
      var pickerRef = ref();
      expose({
        focus: function focus() {
          var _pickerRef$value;
          (_pickerRef$value = pickerRef.value) === null || _pickerRef$value === void 0 ? void 0 : _pickerRef$value.focus();
        },
        blur: function blur() {
          var _pickerRef$value2;
          (_pickerRef$value2 = pickerRef.value) === null || _pickerRef$value2 === void 0 ? void 0 : _pickerRef$value2.blur();
        }
      });
      var maybeToStrings = function maybeToStrings2(dates) {
        return props3.valueFormat ? generateConfig2.toString(dates, props3.valueFormat) : dates;
      };
      var onChange3 = function onChange4(dates, dateStrings) {
        var values = maybeToStrings(dates);
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      var onOpenChange = function onOpenChange2(open2) {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      var onFocus2 = function onFocus3(e2) {
        emit("focus", e2);
      };
      var onBlur2 = function onBlur3(e2) {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      var onPanelChange = function onPanelChange2(dates, modes) {
        var values = maybeToStrings(dates);
        emit("panelChange", values, modes);
      };
      var onOk = function onOk2(dates) {
        var value2 = maybeToStrings(dates);
        emit("ok", value2);
      };
      var onCalendarChange = function onCalendarChange2(dates, dateStrings, info) {
        var values = maybeToStrings(dates);
        emit("calendarChange", values, dateStrings, info);
      };
      var _useLocaleReceiver = useLocaleReceiver("DatePicker", enUS), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), contextLocale = _useLocaleReceiver2[0];
      var value = computed(function() {
        if (props3.value) {
          return props3.valueFormat ? generateConfig2.toDate(props3.value, props3.valueFormat) : props3.value;
        }
        return props3.value;
      });
      var defaultValue = computed(function() {
        if (props3.defaultValue) {
          return props3.valueFormat ? generateConfig2.toDate(props3.defaultValue, props3.valueFormat) : props3.defaultValue;
        }
        return props3.defaultValue;
      });
      var defaultPickerValue = computed(function() {
        if (props3.defaultPickerValue) {
          return props3.valueFormat ? generateConfig2.toDate(props3.defaultPickerValue, props3.valueFormat) : props3.defaultPickerValue;
        }
        return props3.defaultPickerValue;
      });
      return function() {
        var _slots$suffixIcon, _slots$separator, _slots$clearIcon, _classNames, _slots$prevIcon, _slots$nextIcon, _slots$superPrevIcon, _slots$superNextIcon;
        var locale2 = _objectSpread2$1(_objectSpread2$1({}, contextLocale.value), props3.locale);
        var p2 = _objectSpread2$1(_objectSpread2$1({}, props3), attrs);
        p2.prefixCls;
        var _p$bordered = p2.bordered, bordered = _p$bordered === void 0 ? true : _p$bordered, placeholder = p2.placeholder, _p$suffixIcon = p2.suffixIcon, suffixIcon = _p$suffixIcon === void 0 ? (_slots$suffixIcon = slots.suffixIcon) === null || _slots$suffixIcon === void 0 ? void 0 : _slots$suffixIcon.call(slots) : _p$suffixIcon, _p$picker = p2.picker, picker = _p$picker === void 0 ? "date" : _p$picker, transitionName2 = p2.transitionName, _p$allowClear = p2.allowClear, allowClear = _p$allowClear === void 0 ? true : _p$allowClear, _p$dateRender = p2.dateRender, dateRender = _p$dateRender === void 0 ? slots.dateRender : _p$dateRender, _p$renderExtraFooter = p2.renderExtraFooter, renderExtraFooter = _p$renderExtraFooter === void 0 ? slots.renderExtraFooter : _p$renderExtraFooter, _p$separator = p2.separator, separator = _p$separator === void 0 ? (_slots$separator = slots.separator) === null || _slots$separator === void 0 ? void 0 : _slots$separator.call(slots) : _p$separator, _p$clearIcon = p2.clearIcon, clearIcon = _p$clearIcon === void 0 ? (_slots$clearIcon = slots.clearIcon) === null || _slots$clearIcon === void 0 ? void 0 : _slots$clearIcon.call(slots) : _p$clearIcon, _p$id = p2.id, id = _p$id === void 0 ? formItemContext.id.value : _p$id, restProps = _objectWithoutProperties$2(p2, _excluded$B);
        delete restProps["onUpdate:value"];
        delete restProps["onUpdate:open"];
        var format5 = p2.format, showTime = p2.showTime;
        var additionalOverrideProps = {};
        additionalOverrideProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, additionalOverrideProps), showTime ? getTimeProps(_objectSpread2$1({
          format: format5,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(_objectSpread2$1(_objectSpread2$1({
          format: format5
        }, omit$2(restProps, ["disabledTime"])), {}, {
          picker
        })) : {});
        var pre = prefixCls.value;
        return createVNode(VCRangePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "dateRender": dateRender,
          "renderExtraFooter": renderExtraFooter,
          "separator": separator || createVNode("span", {
            "aria-label": "to",
            "class": "".concat(pre, "-separator")
          }, [createVNode(SwapRightOutlined$1, null, null)]),
          "ref": pickerRef,
          "placeholder": getRangePlaceholder(picker, locale2, placeholder),
          "suffixIcon": suffixIcon || (picker === "time" ? createVNode(ClockCircleOutlined$1, null, null) : createVNode(CalendarOutlined$1, null, null)),
          "clearIcon": clearIcon || createVNode(CloseCircleFilled$1, null, null),
          "allowClear": allowClear,
          "transitionName": transitionName2 || "".concat(rootPrefixCls.value, "-slide-up")
        }, restProps), additionalOverrideProps), {}, {
          "id": id,
          "value": value.value,
          "defaultValue": defaultValue.value,
          "defaultPickerValue": defaultPickerValue.value,
          "picker": picker,
          "class": classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-").concat(size2.value), size2.value), _defineProperty$U(_classNames, "".concat(pre, "-borderless"), !bordered), _classNames), attrs.class),
          "locale": locale2.lang,
          "prefixCls": pre,
          "getPopupContainer": attrs.getCalendarContainer || getPopupContainer.value,
          "generateConfig": generateConfig2,
          "prevIcon": ((_slots$prevIcon = slots.prevIcon) === null || _slots$prevIcon === void 0 ? void 0 : _slots$prevIcon.call(slots)) || createVNode("span", {
            "class": "".concat(pre, "-prev-icon")
          }, null),
          "nextIcon": ((_slots$nextIcon = slots.nextIcon) === null || _slots$nextIcon === void 0 ? void 0 : _slots$nextIcon.call(slots)) || createVNode("span", {
            "class": "".concat(pre, "-next-icon")
          }, null),
          "superPrevIcon": ((_slots$superPrevIcon = slots.superPrevIcon) === null || _slots$superPrevIcon === void 0 ? void 0 : _slots$superPrevIcon.call(slots)) || createVNode("span", {
            "class": "".concat(pre, "-super-prev-icon")
          }, null),
          "superNextIcon": ((_slots$superNextIcon = slots.superNextIcon) === null || _slots$superNextIcon === void 0 ? void 0 : _slots$superNextIcon.call(slots)) || createVNode("span", {
            "class": "".concat(pre, "-super-next-icon")
          }, null),
          "components": Components,
          "direction": direction.value,
          "onChange": onChange3,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus2,
          "onBlur": onBlur2,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), null);
      };
    }
  });
  return RangePicker2;
}
var Components = {
  button: PickerButton$1,
  rangeItem: PickerTag
};
function toArray$3(list) {
  if (!list) {
    return [];
  }
  return Array.isArray(list) ? list : [list];
}
function getTimeProps(props3) {
  var format5 = props3.format, picker = props3.picker, showHour = props3.showHour, showMinute = props3.showMinute, showSecond = props3.showSecond, use12Hours = props3.use12Hours;
  var firstFormat = toArray$3(format5)[0];
  var showTimeObj = _objectSpread2$1({}, props3);
  if (firstFormat && typeof firstFormat === "string") {
    if (!firstFormat.includes("s") && showSecond === void 0) {
      showTimeObj.showSecond = false;
    }
    if (!firstFormat.includes("m") && showMinute === void 0) {
      showTimeObj.showMinute = false;
    }
    if (!firstFormat.includes("H") && !firstFormat.includes("h") && showHour === void 0) {
      showTimeObj.showHour = false;
    }
    if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
      showTimeObj.use12Hours = true;
    }
  }
  if (picker === "time") {
    return showTimeObj;
  }
  if (typeof firstFormat === "function") {
    delete showTimeObj.format;
  }
  return {
    showTime: showTimeObj
  };
}
function generatePicker(generateConfig2, extraProps) {
  var _generateSinglePicker = generateSinglePicker(generateConfig2, extraProps), DatePicker2 = _generateSinglePicker.DatePicker, WeekPicker2 = _generateSinglePicker.WeekPicker, MonthPicker2 = _generateSinglePicker.MonthPicker, YearPicker2 = _generateSinglePicker.YearPicker, TimePicker2 = _generateSinglePicker.TimePicker, QuarterPicker2 = _generateSinglePicker.QuarterPicker;
  var RangePicker2 = generateRangePicker(generateConfig2, extraProps);
  return {
    DatePicker: DatePicker2,
    WeekPicker: WeekPicker2,
    MonthPicker: MonthPicker2,
    YearPicker: YearPicker2,
    TimePicker: TimePicker2,
    QuarterPicker: QuarterPicker2,
    RangePicker: RangePicker2
  };
}
var _generatePicker = generatePicker(dayjsGenerateConfig), DatePicker$2 = _generatePicker.DatePicker, WeekPicker = _generatePicker.WeekPicker, MonthPicker = _generatePicker.MonthPicker, YearPicker = _generatePicker.YearPicker, TimePicker$3 = _generatePicker.TimePicker, QuarterPicker = _generatePicker.QuarterPicker, RangePicker$1 = _generatePicker.RangePicker;
const DatePicker$3 = _extends$1(DatePicker$2, {
  WeekPicker,
  MonthPicker,
  YearPicker,
  RangePicker: RangePicker$1,
  TimePicker: TimePicker$3,
  QuarterPicker,
  install: function install2(app) {
    app.component(DatePicker$2.name, DatePicker$2);
    app.component(RangePicker$1.name, RangePicker$1);
    app.component(MonthPicker.name, MonthPicker);
    app.component(WeekPicker.name, WeekPicker);
    app.component(QuarterPicker.name, QuarterPicker);
    return app;
  }
});
function notEmpty(val) {
  return val !== void 0 && val !== null;
}
var Cell$1 = function Cell(props3) {
  var itemPrefixCls = props3.itemPrefixCls, component = props3.component, span = props3.span, labelStyle = props3.labelStyle, contentStyle = props3.contentStyle, bordered = props3.bordered, label = props3.label, content = props3.content, colon = props3.colon;
  var Component = component;
  if (bordered) {
    var _ref;
    return createVNode(Component, {
      "class": [(_ref = {}, _defineProperty$U(_ref, "".concat(itemPrefixCls, "-item-label"), notEmpty(label)), _defineProperty$U(_ref, "".concat(itemPrefixCls, "-item-content"), notEmpty(content)), _ref)],
      "colSpan": span
    }, {
      default: function _default9() {
        return [notEmpty(label) && createVNode("span", {
          "style": labelStyle
        }, [label]), notEmpty(content) && createVNode("span", {
          "style": contentStyle
        }, [content])];
      }
    });
  }
  return createVNode(Component, {
    "class": ["".concat(itemPrefixCls, "-item")],
    "colSpan": span
  }, {
    default: function _default9() {
      return [createVNode("div", {
        "class": "".concat(itemPrefixCls, "-item-container")
      }, [label && createVNode("span", {
        "class": ["".concat(itemPrefixCls, "-item-label"), _defineProperty$U({}, "".concat(itemPrefixCls, "-item-no-colon"), !colon)],
        "style": labelStyle
      }, [label]), content && createVNode("span", {
        "class": "".concat(itemPrefixCls, "-item-content"),
        "style": contentStyle
      }, [content])])];
    }
  });
};
const Cell$2 = Cell$1;
var Row = function Row2(props3) {
  var renderCells = function renderCells2(items, _ref, _ref2) {
    var colon = _ref.colon, prefixCls2 = _ref.prefixCls, bordered2 = _ref.bordered;
    var component = _ref2.component, type4 = _ref2.type, showLabel = _ref2.showLabel, showContent = _ref2.showContent, rootLabelStyle = _ref2.labelStyle, rootContentStyle = _ref2.contentStyle;
    return items.map(function(item, index3) {
      var _item$children, _item$children$label;
      var itemProps = item.props || {};
      var _itemProps$prefixCls = itemProps.prefixCls, itemPrefixCls = _itemProps$prefixCls === void 0 ? prefixCls2 : _itemProps$prefixCls, _itemProps$span = itemProps.span, span = _itemProps$span === void 0 ? 1 : _itemProps$span, _itemProps$labelStyle = itemProps.labelStyle, labelStyle2 = _itemProps$labelStyle === void 0 ? itemProps["label-style"] : _itemProps$labelStyle, _itemProps$contentSty = itemProps.contentStyle, contentStyle2 = _itemProps$contentSty === void 0 ? itemProps["content-style"] : _itemProps$contentSty, _itemProps$label = itemProps.label, label = _itemProps$label === void 0 ? (_item$children = item.children) === null || _item$children === void 0 ? void 0 : (_item$children$label = _item$children.label) === null || _item$children$label === void 0 ? void 0 : _item$children$label.call(_item$children) : _itemProps$label;
      var children = getSlot(item);
      var className = getClass(item);
      var style2 = getStyle(item);
      var key2 = item.key;
      if (typeof component === "string") {
        return createVNode(Cell$2, {
          "key": "".concat(type4, "-").concat(String(key2) || index3),
          "class": className,
          "style": style2,
          "labelStyle": _objectSpread2$1(_objectSpread2$1({}, rootLabelStyle), labelStyle2),
          "contentStyle": _objectSpread2$1(_objectSpread2$1({}, rootContentStyle), contentStyle2),
          "span": span,
          "colon": colon,
          "component": component,
          "itemPrefixCls": itemPrefixCls,
          "bordered": bordered2,
          "label": showLabel ? label : null,
          "content": showContent ? children : null
        }, null);
      }
      return [createVNode(Cell$2, {
        "key": "label-".concat(String(key2) || index3),
        "class": className,
        "style": _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, rootLabelStyle), style2), labelStyle2),
        "span": 1,
        "colon": colon,
        "component": component[0],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "label": label
      }, null), createVNode(Cell$2, {
        "key": "content-".concat(String(key2) || index3),
        "class": className,
        "style": _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, rootContentStyle), style2), contentStyle2),
        "span": span * 2 - 1,
        "component": component[1],
        "itemPrefixCls": itemPrefixCls,
        "bordered": bordered2,
        "content": children
      }, null)];
    });
  };
  var prefixCls = props3.prefixCls, vertical = props3.vertical, row = props3.row, index2 = props3.index, bordered = props3.bordered;
  var _inject = inject(descriptionsContext, {
    labelStyle: ref({}),
    contentStyle: ref({})
  }), labelStyle = _inject.labelStyle, contentStyle = _inject.contentStyle;
  if (vertical) {
    return createVNode(Fragment, null, [createVNode("tr", {
      "key": "label-".concat(index2),
      "class": "".concat(prefixCls, "-row")
    }, [renderCells(row, props3, {
      component: "th",
      type: "label",
      showLabel: true,
      labelStyle: labelStyle.value,
      contentStyle: contentStyle.value
    })]), createVNode("tr", {
      "key": "content-".concat(index2),
      "class": "".concat(prefixCls, "-row")
    }, [renderCells(row, props3, {
      component: "td",
      type: "content",
      showContent: true,
      labelStyle: labelStyle.value,
      contentStyle: contentStyle.value
    })])]);
  }
  return createVNode("tr", {
    "key": index2,
    "class": "".concat(prefixCls, "-row")
  }, [renderCells(row, props3, {
    component: bordered ? ["th", "td"] : "td",
    type: "item",
    showLabel: true,
    showContent: true,
    labelStyle: labelStyle.value,
    contentStyle: contentStyle.value
  })]);
};
const Row$1 = Row;
({
  prefixCls: String,
  label: PropTypes$1.any,
  span: Number
});
var descriptionsItemProp = function descriptionsItemProp2() {
  return {
    prefixCls: String,
    label: PropTypes$1.any,
    labelStyle: {
      type: Object,
      default: void 0
    },
    contentStyle: {
      type: Object,
      default: void 0
    },
    span: {
      type: Number,
      default: 1
    }
  };
};
var DescriptionsItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptionsItem",
  props: descriptionsItemProp(),
  slots: ["label"],
  setup: function setup104(_2, _ref) {
    var slots = _ref.slots;
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
var DEFAULT_COLUMN_MAP = {
  xxxl: 3,
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
function getColumn(column2, screens2) {
  if (typeof column2 === "number") {
    return column2;
  }
  if (_typeof$3(column2) === "object") {
    for (var i2 = 0; i2 < responsiveArray.length; i2++) {
      var breakpoint = responsiveArray[i2];
      if (screens2[breakpoint] && column2[breakpoint] !== void 0) {
        return column2[breakpoint] || DEFAULT_COLUMN_MAP[breakpoint];
      }
    }
  }
  return 3;
}
function getFilledItem(node, span, rowRestCol) {
  var clone3 = node;
  if (span === void 0 || span > rowRestCol) {
    clone3 = cloneElement(node, {
      span: rowRestCol
    });
    warning$2(span === void 0, "Descriptions", "Sum of column `span` in a line not match `column` of Descriptions.");
  }
  return clone3;
}
function getRows(children, column2) {
  var childNodes = flattenChildren(children);
  var rows = [];
  var tmpRow = [];
  var rowRestCol = column2;
  childNodes.forEach(function(node, index2) {
    var _node$props;
    var span = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.span;
    var mergedSpan = span || 1;
    if (index2 === childNodes.length - 1) {
      tmpRow.push(getFilledItem(node, span, rowRestCol));
      rows.push(tmpRow);
      return;
    }
    if (mergedSpan < rowRestCol) {
      rowRestCol -= mergedSpan;
      tmpRow.push(node);
    } else {
      tmpRow.push(getFilledItem(node, mergedSpan, rowRestCol));
      rows.push(tmpRow);
      rowRestCol = column2;
      tmpRow = [];
    }
  });
  return rows;
}
var descriptionsProps = function descriptionsProps2() {
  return {
    prefixCls: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    size: {
      type: String,
      default: "default"
    },
    title: PropTypes$1.any,
    extra: PropTypes$1.any,
    column: {
      type: [Number, Object],
      default: function _default9() {
        return DEFAULT_COLUMN_MAP;
      }
    },
    layout: String,
    colon: {
      type: Boolean,
      default: void 0
    },
    labelStyle: {
      type: Object,
      default: void 0
    },
    contentStyle: {
      type: Object,
      default: void 0
    }
  };
};
var descriptionsContext = Symbol("descriptionsContext");
var Descriptions = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptions",
  props: descriptionsProps(),
  slots: ["title", "extra"],
  Item: DescriptionsItem,
  setup: function setup105(props3, _ref2) {
    var slots = _ref2.slots;
    var _useConfigInject = useConfigInject("descriptions", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var token2;
    var screens2 = ref({});
    onBeforeMount(function() {
      token2 = ResponsiveObserve.subscribe(function(screen) {
        if (_typeof$3(props3.column) !== "object") {
          return;
        }
        screens2.value = screen;
      });
    });
    onBeforeUnmount(function() {
      ResponsiveObserve.unsubscribe(token2);
    });
    provide(descriptionsContext, {
      labelStyle: toRef(props3, "labelStyle"),
      contentStyle: toRef(props3, "contentStyle")
    });
    var mergeColumn = computed(function() {
      return getColumn(props3.column, screens2.value);
    });
    return function() {
      var _slots$title, _slots$extra, _slots$default2, _ref3;
      var size2 = props3.size, _props$bordered = props3.bordered, bordered = _props$bordered === void 0 ? false : _props$bordered, _props$layout = props3.layout, layout = _props$layout === void 0 ? "horizontal" : _props$layout, _props$colon = props3.colon, colon = _props$colon === void 0 ? true : _props$colon, _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots) : _props$title, _props$extra = props3.extra, extra = _props$extra === void 0 ? (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots) : _props$extra;
      var children = (_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots);
      var rows = getRows(children, mergeColumn.value);
      return createVNode("div", {
        "class": [prefixCls.value, (_ref3 = {}, _defineProperty$U(_ref3, "".concat(prefixCls.value, "-").concat(size2), size2 !== "default"), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-bordered"), !!bordered), _defineProperty$U(_ref3, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref3)]
      }, [(title || extra) && createVNode("div", {
        "class": "".concat(prefixCls.value, "-header")
      }, [title && createVNode("div", {
        "class": "".concat(prefixCls.value, "-title")
      }, [title]), extra && createVNode("div", {
        "class": "".concat(prefixCls.value, "-extra")
      }, [extra])]), createVNode("div", {
        "class": "".concat(prefixCls.value, "-view")
      }, [createVNode("table", null, [createVNode("tbody", null, [rows.map(function(row, index2) {
        return createVNode(Row$1, {
          "key": index2,
          "index": index2,
          "colon": colon,
          "prefixCls": prefixCls.value,
          "vertical": layout === "vertical",
          "bordered": bordered,
          "row": row
        }, null);
      })])])])]);
    };
  }
});
Descriptions.install = function(app) {
  app.component(Descriptions.name, Descriptions);
  app.component(Descriptions.Item.name, Descriptions.Item);
  return app;
};
const Descriptions$1 = Descriptions;
var dividerProps = function dividerProps2() {
  return {
    prefixCls: String,
    type: {
      type: String,
      default: "horizontal"
    },
    dashed: {
      type: Boolean,
      default: false
    },
    orientation: {
      type: String,
      default: "center"
    },
    plain: {
      type: Boolean,
      default: false
    },
    orientationMargin: [String, Number]
  };
};
var Divider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADivider",
  props: dividerProps(),
  setup: function setup106(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("divider", props3), prefixClsRef = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var hasCustomMarginLeft = computed(function() {
      return props3.orientation === "left" && props3.orientationMargin != null;
    });
    var hasCustomMarginRight = computed(function() {
      return props3.orientation === "right" && props3.orientationMargin != null;
    });
    var classString = computed(function() {
      var _ref2;
      var type4 = props3.type, dashed = props3.dashed, plain = props3.plain;
      var prefixCls = prefixClsRef.value;
      return _ref2 = {}, _defineProperty$U(_ref2, prefixCls, true), _defineProperty$U(_ref2, "".concat(prefixCls, "-").concat(type4), true), _defineProperty$U(_ref2, "".concat(prefixCls, "-dashed"), !!dashed), _defineProperty$U(_ref2, "".concat(prefixCls, "-plain"), !!plain), _defineProperty$U(_ref2, "".concat(prefixCls, "-rtl"), direction.value === "rtl"), _defineProperty$U(_ref2, "".concat(prefixCls, "-no-default-orientation-margin-left"), hasCustomMarginLeft.value), _defineProperty$U(_ref2, "".concat(prefixCls, "-no-default-orientation-margin-right"), hasCustomMarginRight.value), _ref2;
    });
    var innerStyle = computed(function() {
      var marginValue = typeof props3.orientationMargin === "number" ? "".concat(props3.orientationMargin, "px") : props3.orientationMargin;
      return _objectSpread2$1(_objectSpread2$1({}, hasCustomMarginLeft.value && {
        marginLeft: marginValue
      }), hasCustomMarginRight.value && {
        marginRight: marginValue
      });
    });
    var orientationPrefix = computed(function() {
      return props3.orientation.length > 0 ? "-" + props3.orientation : props3.orientation;
    });
    return function() {
      var _slots$default;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      return createVNode("div", {
        "class": [classString.value, children.length ? "".concat(prefixClsRef.value, "-with-text ").concat(prefixClsRef.value, "-with-text").concat(orientationPrefix.value) : ""],
        "role": "separator"
      }, [children.length ? createVNode("span", {
        "class": "".concat(prefixClsRef.value, "-inner-text"),
        "style": innerStyle.value
      }, [children]) : null]);
    };
  }
});
const index$g = withInstall(Divider);
Dropdown$1.Button = DropdownButton;
Dropdown$1.install = function(app) {
  app.component(Dropdown$1.name, Dropdown$1);
  app.component(DropdownButton.name, DropdownButton);
  return app;
};
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  var match2 = str.match(/^(.*)px$/);
  var value = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
  return Number.isNaN(value) ? getScrollBarSize() : value;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  var _getComputedStyle2 = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle2.width, height = _getComputedStyle2.height;
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}
var props = function props2() {
  return {
    prefixCls: String,
    width: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    height: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    style: {
      type: Object,
      default: void 0
    },
    class: String,
    placement: {
      type: String
    },
    wrapperClassName: String,
    level: {
      type: [String, Array]
    },
    levelMove: {
      type: [Number, Function, Array]
    },
    duration: String,
    ease: String,
    showMask: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    afterVisibleChange: Function,
    keyboard: {
      type: Boolean,
      default: void 0
    },
    contentWrapperStyle: {
      type: Object,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    }
  };
};
var drawerProps$1 = function drawerProps() {
  return _objectSpread2$1(_objectSpread2$1({}, props()), {}, {
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.func, PropTypes$1.object, PropTypes$1.looseBool])
  });
};
var drawerChildProps = function drawerChildProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, props()), {}, {
    getContainer: Function,
    getOpenCount: Function,
    scrollLocker: PropTypes$1.any,
    switchScrollingEffect: Function
  });
};
function dataToArray(vars) {
  if (Array.isArray(vars)) {
    return vars;
  }
  return [vars];
}
var transitionEndObject = {
  transition: "transitionend",
  WebkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd otransitionend"
};
var transitionStr = Object.keys(transitionEndObject).filter(function(key2) {
  if (typeof document === "undefined") {
    return false;
  }
  var html2 = document.getElementsByTagName("html")[0];
  return key2 in (html2 ? html2.style : {});
})[0];
var transitionEndFun = transitionEndObject[transitionStr];
function addEventListener(target, eventType, callback, options) {
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    target.attachEvent("on".concat(eventType), callback);
  }
}
function removeEventListener(target, eventType, callback, options) {
  if (target.removeEventListener) {
    target.removeEventListener(eventType, callback, options);
  } else if (target.attachEvent) {
    target.detachEvent("on".concat(eventType), callback);
  }
}
function transformArguments(arg, cb) {
  var result = typeof arg === "function" ? arg(cb) : arg;
  if (Array.isArray(result)) {
    if (result.length === 2) {
      return result;
    }
    return [result[0], result[1]];
  }
  return [result];
}
var isNumeric2 = function isNumeric3(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
var windowIsUndefined = !(typeof window !== "undefined" && window.document && window.document.createElement);
var getTouchParentScroll = function getTouchParentScroll2(root2, currentTarget, differX, differY) {
  if (!currentTarget || currentTarget === document || currentTarget instanceof Document) {
    return false;
  }
  if (currentTarget === root2.parentNode) {
    return true;
  }
  var isY = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differY);
  var isX = Math.max(Math.abs(differX), Math.abs(differY)) === Math.abs(differX);
  var scrollY = currentTarget.scrollHeight - currentTarget.clientHeight;
  var scrollX = currentTarget.scrollWidth - currentTarget.clientWidth;
  var style2 = document.defaultView.getComputedStyle(currentTarget);
  var overflowY = style2.overflowY === "auto" || style2.overflowY === "scroll";
  var overflowX = style2.overflowX === "auto" || style2.overflowX === "scroll";
  var y2 = scrollY && overflowY;
  var x2 = scrollX && overflowX;
  if (isY && (!y2 || y2 && (currentTarget.scrollTop >= scrollY && differY < 0 || currentTarget.scrollTop <= 0 && differY > 0)) || isX && (!x2 || x2 && (currentTarget.scrollLeft >= scrollX && differX < 0 || currentTarget.scrollLeft <= 0 && differX > 0))) {
    return getTouchParentScroll2(root2, currentTarget.parentNode, differX, differY);
  }
  return false;
};
var _excluded$A = ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class"];
var currentDrawer = {};
var DrawerChild = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: drawerChildProps(),
  emits: ["close", "handleClick", "change"],
  setup: function setup107(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var state = reactive({
      startPos: {
        x: null,
        y: null
      }
    });
    var timeout;
    var contentWrapper = ref();
    var dom = ref();
    var maskDom = ref();
    var handlerDom = ref();
    var contentDom = ref();
    var levelDom = [];
    var drawerId = "drawer_id_".concat(Number((Date.now() + Math.random()).toString().replace(".", Math.round(Math.random() * 9).toString())).toString(16));
    var passive = !windowIsUndefined && supportsPassive$1 ? {
      passive: false
    } : false;
    onMounted(function() {
      nextTick(function() {
        var open2 = props3.open, getContainer4 = props3.getContainer, showMask = props3.showMask, autofocus = props3.autofocus;
        var container = getContainer4 === null || getContainer4 === void 0 ? void 0 : getContainer4();
        getLevelDom(props3);
        if (open2) {
          if (container && container.parentNode === document.body) {
            currentDrawer[drawerId] = open2;
          }
          openLevelTransition();
          nextTick(function() {
            if (autofocus) {
              domFocus();
            }
          });
          if (showMask) {
            var _props$scrollLocker;
            (_props$scrollLocker = props3.scrollLocker) === null || _props$scrollLocker === void 0 ? void 0 : _props$scrollLocker.lock();
          }
        }
      });
    });
    watch(function() {
      return props3.level;
    }, function() {
      getLevelDom(props3);
    }, {
      flush: "post"
    });
    watch(function() {
      return props3.open;
    }, function() {
      var open2 = props3.open, getContainer4 = props3.getContainer, scrollLocker = props3.scrollLocker, showMask = props3.showMask, autofocus = props3.autofocus;
      var container = getContainer4 === null || getContainer4 === void 0 ? void 0 : getContainer4();
      if (container && container.parentNode === document.body) {
        currentDrawer[drawerId] = !!open2;
      }
      openLevelTransition();
      if (open2) {
        if (autofocus) {
          domFocus();
        }
        if (showMask) {
          scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.lock();
        }
      } else {
        scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock();
      }
    }, {
      flush: "post"
    });
    onUnmounted(function() {
      var _props$scrollLocker2;
      var open2 = props3.open;
      delete currentDrawer[drawerId];
      if (open2) {
        setLevelTransform(false);
        document.body.style.touchAction = "";
      }
      (_props$scrollLocker2 = props3.scrollLocker) === null || _props$scrollLocker2 === void 0 ? void 0 : _props$scrollLocker2.unLock();
    });
    watch(function() {
      return props3.placement;
    }, function(val) {
      if (val) {
        contentDom.value = null;
      }
    });
    var domFocus = function domFocus2() {
      var _dom$value, _dom$value$focus;
      (_dom$value = dom.value) === null || _dom$value === void 0 ? void 0 : (_dom$value$focus = _dom$value.focus) === null || _dom$value$focus === void 0 ? void 0 : _dom$value$focus.call(_dom$value);
    };
    var removeStartHandler = function removeStartHandler2(e2) {
      if (e2.touches.length > 1) {
        return;
      }
      state.startPos = {
        x: e2.touches[0].clientX,
        y: e2.touches[0].clientY
      };
    };
    var removeMoveHandler = function removeMoveHandler2(e2) {
      if (e2.changedTouches.length > 1) {
        return;
      }
      var currentTarget = e2.currentTarget;
      var differX = e2.changedTouches[0].clientX - state.startPos.x;
      var differY = e2.changedTouches[0].clientY - state.startPos.y;
      if ((currentTarget === maskDom.value || currentTarget === handlerDom.value || currentTarget === contentDom.value && getTouchParentScroll(currentTarget, e2.target, differX, differY)) && e2.cancelable) {
        e2.preventDefault();
      }
    };
    var transitionEnd = function transitionEnd2(e2) {
      var dom2 = e2.target;
      removeEventListener(dom2, transitionEndFun, transitionEnd2);
      dom2.style.transition = "";
    };
    var onClose = function onClose2(e2) {
      emit("close", e2);
    };
    var onKeyDown = function onKeyDown2(e2) {
      if (e2.keyCode === KeyCode$1.ESC) {
        e2.stopPropagation();
        onClose(e2);
      }
    };
    var onWrapperTransitionEnd = function onWrapperTransitionEnd2(e2) {
      var open2 = props3.open, afterVisibleChange2 = props3.afterVisibleChange;
      if (e2.target === contentWrapper.value && e2.propertyName.match(/transform$/)) {
        dom.value.style.transition = "";
        if (!open2 && getCurrentDrawerSome()) {
          document.body.style.overflowX = "";
          if (maskDom.value) {
            maskDom.value.style.left = "";
            maskDom.value.style.width = "";
          }
        }
        if (afterVisibleChange2) {
          afterVisibleChange2(!!open2);
        }
      }
    };
    var horizontalBoolAndPlacementName = computed(function() {
      var placement = props3.placement;
      var isHorizontal = placement === "left" || placement === "right";
      var placementName = "translate".concat(isHorizontal ? "X" : "Y");
      return {
        isHorizontal,
        placementName
      };
    });
    var openLevelTransition = function openLevelTransition2() {
      var open2 = props3.open, width = props3.width, height = props3.height;
      var _horizontalBoolAndPla = horizontalBoolAndPlacementName.value, isHorizontal = _horizontalBoolAndPla.isHorizontal, placementName = _horizontalBoolAndPla.placementName;
      var contentValue = contentDom.value ? contentDom.value.getBoundingClientRect()[isHorizontal ? "width" : "height"] : 0;
      var value = (isHorizontal ? width : height) || contentValue;
      setLevelAndScrolling(open2, placementName, value);
    };
    var setLevelTransform = function setLevelTransform2(open2, placementName, value, right) {
      var placement = props3.placement, levelMove = props3.levelMove, duration = props3.duration, ease = props3.ease, showMask = props3.showMask;
      levelDom.forEach(function(dom2) {
        dom2.style.transition = "transform ".concat(duration, " ").concat(ease);
        addEventListener(dom2, transitionEndFun, transitionEnd);
        var levelValue = open2 ? value : 0;
        if (levelMove) {
          var $levelMove = transformArguments(levelMove, {
            target: dom2,
            open: open2
          });
          levelValue = open2 ? $levelMove[0] : $levelMove[1] || 0;
        }
        var $value = typeof levelValue === "number" ? "".concat(levelValue, "px") : levelValue;
        var placementPos = placement === "left" || placement === "top" ? $value : "-".concat($value);
        placementPos = showMask && placement === "right" && right ? "calc(".concat(placementPos, " + ").concat(right, "px)") : placementPos;
        dom2.style.transform = levelValue ? "".concat(placementName, "(").concat(placementPos, ")") : "";
      });
    };
    var setLevelAndScrolling = function setLevelAndScrolling2(open2, placementName, value) {
      if (!windowIsUndefined) {
        var right = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth ? getScrollBarSize(true) : 0;
        setLevelTransform(open2, placementName, value, right);
        toggleScrollingToDrawerAndBody(right);
      }
      emit("change", open2);
    };
    var toggleScrollingToDrawerAndBody = function toggleScrollingToDrawerAndBody2(right) {
      var getContainer4 = props3.getContainer, showMask = props3.showMask, open2 = props3.open;
      var container = getContainer4 === null || getContainer4 === void 0 ? void 0 : getContainer4();
      if (container && container.parentNode === document.body && showMask) {
        var eventArray = ["touchstart"];
        var domArray = [document.body, maskDom.value, handlerDom.value, contentDom.value];
        if (open2 && document.body.style.overflow !== "hidden") {
          if (right) {
            addScrollingEffect(right);
          }
          document.body.style.touchAction = "none";
          domArray.forEach(function(item, i2) {
            if (!item) {
              return;
            }
            addEventListener(item, eventArray[i2] || "touchmove", i2 ? removeMoveHandler : removeStartHandler, passive);
          });
        } else if (getCurrentDrawerSome()) {
          document.body.style.touchAction = "";
          if (right) {
            remScrollingEffect(right);
          }
          domArray.forEach(function(item, i2) {
            if (!item) {
              return;
            }
            removeEventListener(item, eventArray[i2] || "touchmove", i2 ? removeMoveHandler : removeStartHandler, passive);
          });
        }
      }
    };
    var addScrollingEffect = function addScrollingEffect2(right) {
      var placement = props3.placement, duration = props3.duration, ease = props3.ease;
      var widthTransition = "width ".concat(duration, " ").concat(ease);
      var transformTransition = "transform ".concat(duration, " ").concat(ease);
      dom.value.style.transition = "none";
      switch (placement) {
        case "right":
          dom.value.style.transform = "translateX(-".concat(right, "px)");
          break;
        case "top":
        case "bottom":
          dom.value.style.width = "calc(100% - ".concat(right, "px)");
          dom.value.style.transform = "translateZ(0)";
          break;
      }
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        if (dom.value) {
          dom.value.style.transition = "".concat(transformTransition, ",").concat(widthTransition);
          dom.value.style.width = "";
          dom.value.style.transform = "";
        }
      });
    };
    var remScrollingEffect = function remScrollingEffect2(right) {
      var placement = props3.placement, duration = props3.duration, ease = props3.ease;
      dom.value.style.transition = "none";
      var heightTransition;
      var widthTransition = "width ".concat(duration, " ").concat(ease);
      var transformTransition = "transform ".concat(duration, " ").concat(ease);
      switch (placement) {
        case "left": {
          dom.value.style.width = "100%";
          widthTransition = "width 0s ".concat(ease, " ").concat(duration);
          break;
        }
        case "right": {
          dom.value.style.transform = "translateX(".concat(right, "px)");
          dom.value.style.width = "100%";
          widthTransition = "width 0s ".concat(ease, " ").concat(duration);
          if (maskDom.value) {
            maskDom.value.style.left = "-".concat(right, "px");
            maskDom.value.style.width = "calc(100% + ".concat(right, "px)");
          }
          break;
        }
        case "top":
        case "bottom": {
          dom.value.style.width = "calc(100% + ".concat(right, "px)");
          dom.value.style.height = "100%";
          dom.value.style.transform = "translateZ(0)";
          heightTransition = "height 0s ".concat(ease, " ").concat(duration);
          break;
        }
      }
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        if (dom.value) {
          dom.value.style.transition = "".concat(transformTransition, ",").concat(heightTransition ? "".concat(heightTransition, ",") : "").concat(widthTransition);
          dom.value.style.transform = "";
          dom.value.style.width = "";
          dom.value.style.height = "";
        }
      });
    };
    var getCurrentDrawerSome = function getCurrentDrawerSome2() {
      return !Object.keys(currentDrawer).some(function(key2) {
        return currentDrawer[key2];
      });
    };
    var getLevelDom = function getLevelDom2(_ref2) {
      var level = _ref2.level, getContainer4 = _ref2.getContainer;
      if (windowIsUndefined) {
        return;
      }
      var container = getContainer4 === null || getContainer4 === void 0 ? void 0 : getContainer4();
      var parent2 = container ? container.parentNode : null;
      levelDom = [];
      if (level === "all") {
        var children = parent2 ? Array.prototype.slice.call(parent2.children) : [];
        children.forEach(function(child) {
          if (child.nodeName !== "SCRIPT" && child.nodeName !== "STYLE" && child.nodeName !== "LINK" && child !== container) {
            levelDom.push(child);
          }
        });
      } else if (level) {
        dataToArray(level).forEach(function(key2) {
          document.querySelectorAll(key2).forEach(function(item) {
            levelDom.push(item);
          });
        });
      }
    };
    var onHandleClick = function onHandleClick2(e2) {
      emit("handleClick", e2);
    };
    var canOpen = ref(false);
    watch(dom, function() {
      nextTick(function() {
        canOpen.value = true;
      });
    });
    return function() {
      var _classnames, _slots$default, _slots$handler;
      var width = props3.width, height = props3.height, $open = props3.open, prefixCls = props3.prefixCls, placement = props3.placement;
      props3.level;
      props3.levelMove;
      props3.ease;
      props3.duration;
      props3.getContainer;
      props3.onChange;
      props3.afterVisibleChange;
      var showMask = props3.showMask, maskClosable = props3.maskClosable, maskStyle = props3.maskStyle, keyboard = props3.keyboard;
      props3.getOpenCount;
      props3.scrollLocker;
      var contentWrapperStyle = props3.contentWrapperStyle, style2 = props3.style, className = props3.class, otherProps = _objectWithoutProperties$2(props3, _excluded$A);
      var open2 = $open && canOpen.value;
      var wrapperClassName = classNames(prefixCls, (_classnames = {}, _defineProperty$U(_classnames, "".concat(prefixCls, "-").concat(placement), true), _defineProperty$U(_classnames, "".concat(prefixCls, "-open"), open2), _defineProperty$U(_classnames, className, !!className), _defineProperty$U(_classnames, "no-mask", !showMask), _classnames));
      var placementName = horizontalBoolAndPlacementName.value.placementName;
      var placementPos = placement === "left" || placement === "top" ? "-100%" : "100%";
      var transform2 = open2 ? "" : "".concat(placementName, "(").concat(placementPos, ")");
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, omit$2(otherProps, ["switchScrollingEffect", "autofocus"])), {}, {
        "tabindex": -1,
        "class": wrapperClassName,
        "style": style2,
        "ref": dom,
        "onKeydown": open2 && keyboard ? onKeyDown : void 0,
        "onTransitionend": onWrapperTransitionEnd
      }), [showMask && createVNode("div", {
        "class": "".concat(prefixCls, "-mask"),
        "onClick": maskClosable ? onClose : void 0,
        "style": maskStyle,
        "ref": maskDom
      }, null), createVNode("div", {
        "class": "".concat(prefixCls, "-content-wrapper"),
        "style": _objectSpread2$1({
          transform: transform2,
          msTransform: transform2,
          width: isNumeric2(width) ? "".concat(width, "px") : width,
          height: isNumeric2(height) ? "".concat(height, "px") : height
        }, contentWrapperStyle),
        "ref": contentWrapper
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-content"),
        "ref": contentDom
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), slots.handler ? createVNode("div", {
        "onClick": onHandleClick,
        "ref": handlerDom
      }, [(_slots$handler = slots.handler) === null || _slots$handler === void 0 ? void 0 : _slots$handler.call(slots)]) : null])]);
    };
  }
});
const Child = DrawerChild;
function setStyle(style2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$element = options.element, element = _options$element === void 0 ? document.body : _options$element;
  var oldStyle = {};
  var styleKeys = Object.keys(style2);
  styleKeys.forEach(function(key2) {
    oldStyle[key2] = element.style[key2];
  });
  styleKeys.forEach(function(key2) {
    element.style[key2] = style2[key2];
  });
  return oldStyle;
}
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var cacheStyle$1 = {};
const switchScrollingEffect = function(close3) {
  if (!isBodyOverflowing() && !close3) {
    return;
  }
  var scrollingEffectClassName2 = "ant-scrolling-effect";
  var scrollingEffectClassNameReg2 = new RegExp("".concat(scrollingEffectClassName2), "g");
  var bodyClassName = document.body.className;
  if (close3) {
    if (!scrollingEffectClassNameReg2.test(bodyClassName))
      return;
    setStyle(cacheStyle$1);
    cacheStyle$1 = {};
    document.body.className = bodyClassName.replace(scrollingEffectClassNameReg2, "").trim();
    return;
  }
  var scrollBarSize = getScrollBarSize();
  if (scrollBarSize) {
    cacheStyle$1 = setStyle({
      position: "relative",
      width: "calc(100% - ".concat(scrollBarSize, "px)")
    });
    if (!scrollingEffectClassNameReg2.test(bodyClassName)) {
      var addClassName = "".concat(bodyClassName, " ").concat(scrollingEffectClassName2);
      document.body.className = addClassName.trim();
    }
  }
};
var locks = [];
var scrollingEffectClassName = "ant-scrolling-effect";
var scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), "g");
var uuid$2 = 0;
var cacheStyle = /* @__PURE__ */ new Map();
var ScrollLocker = /* @__PURE__ */ _createClass(function ScrollLocker2(_options) {
  var _this = this;
  _classCallCheck(this, ScrollLocker2);
  _defineProperty$U(this, "getContainer", function() {
    var _this$options;
    return (_this$options = _this.options) === null || _this$options === void 0 ? void 0 : _this$options.container;
  });
  _defineProperty$U(this, "reLock", function(options) {
    var findLock = locks.find(function(_ref) {
      var target = _ref.target;
      return target === _this.lockTarget;
    });
    if (findLock) {
      _this.unLock();
    }
    _this.options = options;
    if (findLock) {
      findLock.options = options;
      _this.lock();
    }
  });
  _defineProperty$U(this, "lock", function() {
    var _this$options3;
    if (locks.some(function(_ref2) {
      var target = _ref2.target;
      return target === _this.lockTarget;
    })) {
      return;
    }
    if (locks.some(function(_ref3) {
      var _this$options2;
      var options = _ref3.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options2 = _this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.container);
    })) {
      locks = [].concat(_toConsumableArray(locks), [{
        target: _this.lockTarget,
        options: _this.options
      }]);
      return;
    }
    var scrollBarSize = 0;
    var container = ((_this$options3 = _this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.container) || document.body;
    if (container === document.body && window.innerWidth - document.documentElement.clientWidth > 0 || container.scrollHeight > container.clientHeight) {
      scrollBarSize = getScrollBarSize();
    }
    var containerClassName = container.className;
    if (locks.filter(function(_ref4) {
      var _this$options4;
      var options = _ref4.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options4 = _this.options) === null || _this$options4 === void 0 ? void 0 : _this$options4.container);
    }).length === 0) {
      cacheStyle.set(container, setStyle({
        width: scrollBarSize !== 0 ? "calc(100% - ".concat(scrollBarSize, "px)") : void 0,
        overflow: "hidden",
        overflowX: "hidden",
        overflowY: "hidden"
      }, {
        element: container
      }));
    }
    if (!scrollingEffectClassNameReg.test(containerClassName)) {
      var addClassName = "".concat(containerClassName, " ").concat(scrollingEffectClassName);
      container.className = addClassName.trim();
    }
    locks = [].concat(_toConsumableArray(locks), [{
      target: _this.lockTarget,
      options: _this.options
    }]);
  });
  _defineProperty$U(this, "unLock", function() {
    var _this$options5;
    var findLock = locks.find(function(_ref5) {
      var target = _ref5.target;
      return target === _this.lockTarget;
    });
    locks = locks.filter(function(_ref6) {
      var target = _ref6.target;
      return target !== _this.lockTarget;
    });
    if (!findLock || locks.some(function(_ref7) {
      var _findLock$options;
      var options = _ref7.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_findLock$options = findLock.options) === null || _findLock$options === void 0 ? void 0 : _findLock$options.container);
    })) {
      return;
    }
    var container = ((_this$options5 = _this.options) === null || _this$options5 === void 0 ? void 0 : _this$options5.container) || document.body;
    var containerClassName = container.className;
    if (!scrollingEffectClassNameReg.test(containerClassName))
      return;
    setStyle(cacheStyle.get(container), {
      element: container
    });
    cacheStyle.delete(container);
    container.className = container.className.replace(scrollingEffectClassNameReg, "").trim();
  });
  this.lockTarget = uuid$2++;
  this.options = _options;
});
var openCount = 0;
var supportDom = canUseDom();
var cacheOverflow = {};
var getParent2 = function getParent3(getContainer4) {
  if (!supportDom) {
    return null;
  }
  if (getContainer4) {
    if (typeof getContainer4 === "string") {
      return document.querySelectorAll(getContainer4)[0];
    }
    if (typeof getContainer4 === "function") {
      return getContainer4();
    }
    if (_typeof$3(getContainer4) === "object" && getContainer4 instanceof window.HTMLElement) {
      return getContainer4;
    }
  }
  return document.body;
};
const Portal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: false,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup108(props3, _ref) {
    var slots = _ref.slots;
    var container = ref();
    var componentRef = ref();
    var rafId = ref();
    var scrollLocker = new ScrollLocker({
      container: getParent2(props3.getContainer)
    });
    var removeCurrentContainer = function removeCurrentContainer2() {
      var _container$value, _container$value$pare;
      (_container$value = container.value) === null || _container$value === void 0 ? void 0 : (_container$value$pare = _container$value.parentNode) === null || _container$value$pare === void 0 ? void 0 : _container$value$pare.removeChild(container.value);
    };
    var attachToParent = function attachToParent2() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (force || container.value && !container.value.parentNode) {
        var parent2 = getParent2(props3.getContainer);
        if (parent2) {
          parent2.appendChild(container.value);
          return true;
        }
        return false;
      }
      return true;
    };
    var getContainer4 = function getContainer5() {
      if (!supportDom) {
        return null;
      }
      if (!container.value) {
        container.value = document.createElement("div");
        attachToParent(true);
      }
      setWrapperClassName();
      return container.value;
    };
    var setWrapperClassName = function setWrapperClassName2() {
      var wrapperClassName = props3.wrapperClassName;
      if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
        container.value.className = wrapperClassName;
      }
    };
    onUpdated(function() {
      setWrapperClassName();
      attachToParent();
    });
    var switchScrolling = function switchScrolling2() {
      if (openCount === 1 && !Object.keys(cacheOverflow).length) {
        switchScrollingEffect();
        cacheOverflow = setStyle({
          overflow: "hidden",
          overflowX: "hidden",
          overflowY: "hidden"
        });
      } else if (!openCount) {
        setStyle(cacheOverflow);
        cacheOverflow = {};
        switchScrollingEffect(true);
      }
    };
    var instance = getCurrentInstance();
    onMounted(function() {
      var init = false;
      watch([function() {
        return props3.visible;
      }, function() {
        return props3.getContainer;
      }], function(_ref2, _ref3) {
        var _ref4 = _slicedToArray$2(_ref2, 2), visible = _ref4[0], getContainer5 = _ref4[1];
        var _ref5 = _slicedToArray$2(_ref3, 2), prevVisible = _ref5[0], prevGetContainer = _ref5[1];
        if (supportDom && getParent2(props3.getContainer) === document.body) {
          if (visible && !prevVisible) {
            openCount += 1;
          } else if (init) {
            openCount -= 1;
          }
        }
        if (init) {
          var getContainerIsFunc = typeof getContainer5 === "function" && typeof prevGetContainer === "function";
          if (getContainerIsFunc ? getContainer5.toString() !== prevGetContainer.toString() : getContainer5 !== prevGetContainer) {
            removeCurrentContainer();
          }
          if (visible && visible !== prevVisible && supportDom && getParent2(getContainer5) !== scrollLocker.getContainer()) {
            scrollLocker.reLock({
              container: getParent2(getContainer5)
            });
          }
        }
        init = true;
      }, {
        immediate: true,
        flush: "post"
      });
      nextTick(function() {
        if (!attachToParent()) {
          rafId.value = wrapperRaf(function() {
            instance.update();
          });
        }
      });
    });
    onBeforeUnmount(function() {
      var visible = props3.visible, getContainer5 = props3.getContainer;
      if (supportDom && getParent2(getContainer5) === document.body) {
        openCount = visible && openCount ? openCount - 1 : openCount;
      }
      removeCurrentContainer();
      wrapperRaf.cancel(rafId.value);
    });
    return function() {
      var forceRender = props3.forceRender, visible = props3.visible;
      var portal = null;
      var childProps = {
        getOpenCount: function getOpenCount2() {
          return openCount;
        },
        getContainer: getContainer4,
        switchScrollingEffect: switchScrolling,
        scrollLocker
      };
      if (forceRender || visible || componentRef.value) {
        portal = createVNode(Portal$1, {
          "getContainer": getContainer4,
          "ref": componentRef
        }, {
          default: function _default9() {
            var _slots$default;
            return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, childProps);
          }
        });
      }
      return portal;
    };
  }
});
var _excluded$z = ["afterVisibleChange", "getContainer", "wrapperClassName", "forceRender"], _excluded2$4 = ["visible", "afterClose"];
var DrawerWrapper = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: initDefaultProps$1(drawerProps$1(), {
    prefixCls: "drawer",
    placement: "left",
    getContainer: "body",
    level: "all",
    duration: ".3s",
    ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    afterVisibleChange: function afterVisibleChange() {
    },
    showMask: true,
    maskClosable: true,
    maskStyle: {},
    wrapperClassName: "",
    keyboard: true,
    forceRender: false,
    autofocus: true
  }),
  emits: ["handleClick", "close"],
  slots: ["handler"],
  setup: function setup109(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var dom = ref(null);
    var onHandleClick = function onHandleClick2(e2) {
      emit("handleClick", e2);
    };
    var onClose = function onClose2(e2) {
      emit("close", e2);
    };
    return function() {
      props3.afterVisibleChange;
      var getContainer4 = props3.getContainer, wrapperClassName = props3.wrapperClassName, forceRender = props3.forceRender, otherProps = _objectWithoutProperties$2(props3, _excluded$z);
      var portal = null;
      if (!getContainer4) {
        return createVNode("div", {
          "class": wrapperClassName,
          "ref": dom
        }, [createVNode(Child, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
          "open": props3.open,
          "getContainer": function getContainer5() {
            return dom.value;
          },
          "onClose": onClose,
          "onHandleClick": onHandleClick
        }), slots)]);
      }
      var $forceRender = !!slots.handler || forceRender;
      if ($forceRender || props3.open || dom.value) {
        portal = createVNode(Portal, {
          "visible": props3.open,
          "forceRender": $forceRender,
          "getContainer": getContainer4,
          "wrapperClassName": wrapperClassName
        }, {
          default: function _default9(_ref2) {
            var visible = _ref2.visible, afterClose = _ref2.afterClose, rest = _objectWithoutProperties$2(_ref2, _excluded2$4);
            return createVNode(Child, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              "ref": dom
            }, otherProps), rest), {}, {
              "open": visible !== void 0 ? visible : props3.open,
              "afterVisibleChange": afterClose !== void 0 ? afterClose : props3.afterVisibleChange,
              "onClose": onClose,
              "onHandleClick": onHandleClick
            }), slots);
          }
        });
      }
      return portal;
    };
  }
});
const Drawer$1 = DrawerWrapper;
var _excluded$y = ["width", "height", "visible", "placement", "mask", "wrapClassName", "class"];
var PlacementTypes = tuple$1("top", "right", "bottom", "left");
tuple$1("default", "large");
var defaultPushState = {
  distance: 180
};
var drawerProps2 = function drawerProps3() {
  return {
    autofocus: {
      type: Boolean,
      default: void 0
    },
    closable: {
      type: Boolean,
      default: void 0
    },
    closeIcon: PropTypes$1.any,
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: PropTypes$1.any,
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    wrapStyle: {
      type: Object,
      default: void 0
    },
    style: {
      type: Object,
      default: void 0
    },
    class: PropTypes$1.any,
    wrapClassName: String,
    size: {
      type: String
    },
    drawerStyle: {
      type: Object,
      default: void 0
    },
    headerStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    contentWrapperStyle: {
      type: Object,
      default: void 0
    },
    title: PropTypes$1.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    width: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    height: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    zIndex: Number,
    prefixCls: String,
    push: PropTypes$1.oneOfType([PropTypes$1.looseBool, {
      type: Object
    }]),
    placement: PropTypes$1.oneOf(PlacementTypes),
    keyboard: {
      type: Boolean,
      default: void 0
    },
    extra: PropTypes$1.any,
    footer: PropTypes$1.any,
    footerStyle: {
      type: Object,
      default: void 0
    },
    level: PropTypes$1.any,
    levelMove: {
      type: [Number, Array, Function]
    },
    handle: PropTypes$1.any,
    afterVisibleChange: Function,
    onAfterVisibleChange: Function,
    "onUpdate:visible": Function,
    onClose: Function
  };
};
var Drawer = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADrawer",
  inheritAttrs: false,
  props: initDefaultProps$1(drawerProps2(), {
    closable: true,
    placement: "right",
    maskClosable: true,
    mask: true,
    level: null,
    keyboard: true,
    push: defaultPushState
  }),
  slots: ["closeIcon", "title", "extra", "footer", "handle"],
  setup: function setup110(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots, attrs = _ref.attrs;
    var sPush = ref(false);
    var destroyClose = ref(false);
    var vcDrawer = ref(null);
    var parentDrawerOpts = inject("parentDrawerOpts", null);
    var _useConfigInject = useConfigInject("drawer", props3), prefixCls = _useConfigInject.prefixCls;
    devWarning(!props3.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead");
    devWarning(props3.wrapStyle === void 0, "Drawer", "`wrapStyle` prop is deprecated, please use `style` instead");
    devWarning(props3.wrapClassName === void 0, "Drawer", "`wrapClassName` prop is deprecated, please use `class` instead");
    var setPush = function setPush2() {
      sPush.value = true;
    };
    var setPull = function setPull2() {
      sPush.value = false;
      nextTick(function() {
        domFocus();
      });
    };
    provide("parentDrawerOpts", {
      setPush,
      setPull
    });
    onMounted(function() {
      var visible = props3.visible;
      if (visible && parentDrawerOpts) {
        parentDrawerOpts.setPush();
      }
    });
    onUnmounted(function() {
      if (parentDrawerOpts) {
        parentDrawerOpts.setPull();
      }
    });
    watch(function() {
      return props3.visible;
    }, function(visible) {
      if (parentDrawerOpts) {
        if (visible) {
          parentDrawerOpts.setPush();
        } else {
          parentDrawerOpts.setPull();
        }
      }
    }, {
      flush: "post"
    });
    var domFocus = function domFocus2() {
      var _vcDrawer$value, _vcDrawer$value$domFo;
      (_vcDrawer$value = vcDrawer.value) === null || _vcDrawer$value === void 0 ? void 0 : (_vcDrawer$value$domFo = _vcDrawer$value.domFocus) === null || _vcDrawer$value$domFo === void 0 ? void 0 : _vcDrawer$value$domFo.call(_vcDrawer$value);
    };
    var close3 = function close4(e2) {
      emit("update:visible", false);
      emit("close", e2);
    };
    var afterVisibleChange2 = function afterVisibleChange3(visible) {
      var _props$afterVisibleCh;
      (_props$afterVisibleCh = props3.afterVisibleChange) === null || _props$afterVisibleCh === void 0 ? void 0 : _props$afterVisibleCh.call(props3, visible);
      emit("afterVisibleChange", visible);
    };
    var destroyOnClose = computed(function() {
      return props3.destroyOnClose && !props3.visible;
    });
    var onDestroyTransitionEnd = function onDestroyTransitionEnd2() {
      var isDestroyOnClose = destroyOnClose.value;
      if (!isDestroyOnClose) {
        return;
      }
      if (!props3.visible) {
        destroyClose.value = true;
      }
    };
    var pushTransform = computed(function() {
      var push2 = props3.push, placement = props3.placement;
      var distance;
      if (typeof push2 === "boolean") {
        distance = push2 ? defaultPushState.distance : 0;
      } else {
        distance = push2.distance;
      }
      distance = parseFloat(String(distance || 0));
      if (placement === "left" || placement === "right") {
        return "translateX(".concat(placement === "left" ? distance : -distance, "px)");
      }
      if (placement === "top" || placement === "bottom") {
        return "translateY(".concat(placement === "top" ? distance : -distance, "px)");
      }
      return null;
    });
    var offsetStyle = computed(function() {
      var visible = props3.visible, mask = props3.mask, placement = props3.placement, _props$size = props3.size, size2 = _props$size === void 0 ? "default" : _props$size, width = props3.width, height = props3.height;
      if (!visible && !mask) {
        return {};
      }
      var val = {};
      if (placement === "left" || placement === "right") {
        var defaultWidth = size2 === "large" ? 736 : 378;
        val.width = typeof width === "undefined" ? defaultWidth : width;
        val.width = typeof val.width === "string" ? val.width : "".concat(val.width, "px");
      } else {
        var defaultHeight = size2 === "large" ? 736 : 378;
        val.height = typeof height === "undefined" ? defaultHeight : height;
        val.height = typeof val.height === "string" ? val.height : "".concat(val.height, "px");
      }
      return val;
    });
    var drawerStyle = computed(function() {
      var zIndex = props3.zIndex, wrapStyle = props3.wrapStyle, mask = props3.mask, style2 = props3.style;
      var val = mask ? {} : offsetStyle.value;
      return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        zIndex,
        transform: sPush.value ? pushTransform.value : void 0
      }, val), wrapStyle), style2);
    });
    var renderHeader = function renderHeader2(prefixCls2) {
      var closable = props3.closable, headerStyle = props3.headerStyle;
      var extra = getPropsSlot(slots, props3, "extra");
      var title = getPropsSlot(slots, props3, "title");
      if (!title && !closable) {
        return null;
      }
      return createVNode("div", {
        "class": classNames("".concat(prefixCls2, "-header"), _defineProperty$U({}, "".concat(prefixCls2, "-header-close-only"), closable && !title && !extra)),
        "style": headerStyle
      }, [createVNode("div", {
        "class": "".concat(prefixCls2, "-header-title")
      }, [renderCloseIcon(prefixCls2), title && createVNode("div", {
        "class": "".concat(prefixCls2, "-title")
      }, [title])]), extra && createVNode("div", {
        "class": "".concat(prefixCls2, "-extra")
      }, [extra])]);
    };
    var renderCloseIcon = function renderCloseIcon2(prefixCls2) {
      var _slots$closeIcon;
      var closable = props3.closable;
      var $closeIcon = slots.closeIcon ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : props3.closeIcon;
      return closable && createVNode("button", {
        "key": "closer",
        "onClick": close3,
        "aria-label": "Close",
        "class": "".concat(prefixCls2, "-close")
      }, [$closeIcon === void 0 ? createVNode(CloseOutlined$1, null, null) : $closeIcon]);
    };
    var renderBody = function renderBody2(prefixCls2) {
      var _slots$default;
      if (destroyClose.value && !props3.visible) {
        return null;
      }
      destroyClose.value = false;
      var bodyStyle = props3.bodyStyle, drawerStyle2 = props3.drawerStyle;
      var containerStyle = {};
      var isDestroyOnClose = destroyOnClose.value;
      if (isDestroyOnClose) {
        containerStyle.opacity = 0;
        containerStyle.transition = "opacity .3s";
      }
      return createVNode("div", {
        "class": "".concat(prefixCls2, "-wrapper-body"),
        "style": _objectSpread2$1(_objectSpread2$1({}, containerStyle), drawerStyle2),
        "onTransitionend": onDestroyTransitionEnd
      }, [renderHeader(prefixCls2), createVNode("div", {
        "key": "body",
        "class": "".concat(prefixCls2, "-body"),
        "style": bodyStyle
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), renderFooter(prefixCls2)]);
    };
    var renderFooter = function renderFooter2(prefixCls2) {
      var footer = getPropsSlot(slots, props3, "footer");
      if (!footer) {
        return null;
      }
      var footerClassName = "".concat(prefixCls2, "-footer");
      return createVNode("div", {
        "class": footerClassName,
        "style": props3.footerStyle
      }, [footer]);
    };
    return function() {
      var _classnames2;
      props3.width;
      props3.height;
      var visible = props3.visible, placement = props3.placement, mask = props3.mask, wrapClassName = props3.wrapClassName, className = props3.class, rest = _objectWithoutProperties$2(props3, _excluded$y);
      var val = mask ? offsetStyle.value : {};
      var haveMask = mask ? "" : "no-mask";
      var vcDrawerProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$2(rest, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "wrapStyle", "onAfterVisibleChange", "onClose", "onUpdate:visible"])), val), {}, {
        onClose: close3,
        afterVisibleChange: afterVisibleChange2,
        handler: false,
        prefixCls: prefixCls.value,
        open: visible,
        showMask: mask,
        placement,
        class: classNames((_classnames2 = {}, _defineProperty$U(_classnames2, className, className), _defineProperty$U(_classnames2, wrapClassName, !!wrapClassName), _defineProperty$U(_classnames2, haveMask, !!haveMask), _classnames2)),
        style: drawerStyle.value,
        ref: vcDrawer
      });
      return createVNode(Drawer$1, vcDrawerProps, {
        handler: props3.handle ? function() {
          return props3.handle;
        } : slots.handle,
        default: function _default9() {
          return renderBody(prefixCls.value);
        }
      });
    };
  }
});
const index$f = withInstall(Drawer);
var inputProps = function inputProps2() {
  return {
    id: String,
    prefixCls: String,
    inputPrefixCls: String,
    defaultValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    value: {
      type: [String, Number, Symbol],
      default: void 0
    },
    placeholder: {
      type: [String, Number]
    },
    autocomplete: String,
    type: {
      type: String,
      default: "text"
    },
    name: String,
    size: {
      type: String
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    readonly: {
      type: Boolean,
      default: void 0
    },
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    prefix: PropTypes$1.any,
    suffix: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    lazy: {
      type: Boolean,
      default: true
    },
    maxlength: Number,
    loading: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    showCount: {
      type: [Boolean, Object]
    },
    htmlSize: Number,
    onPressEnter: Function,
    onKeydown: Function,
    onKeyup: Function,
    onFocus: Function,
    onBlur: Function,
    onChange: Function,
    onInput: Function,
    "onUpdate:value": Function,
    valueModifiers: Object,
    hidden: Boolean
  };
};
const inputProps$1 = inputProps;
var textAreaProps = function textAreaProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {}, {
    rows: Number,
    autosize: {
      type: [Boolean, Object],
      default: void 0
    },
    autoSize: {
      type: [Boolean, Object],
      default: void 0
    },
    onResize: {
      type: Function
    },
    onCompositionstart: Function,
    onCompositionend: Function,
    valueModifiers: Object
  });
};
function getInputClassName(prefixCls, bordered, size2, disabled, direction) {
  var _classNames;
  return classNames(prefixCls, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-sm"), size2 === "small"), _defineProperty$U(_classNames, "".concat(prefixCls, "-lg"), size2 === "large"), _defineProperty$U(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _classNames));
}
var isValid2 = function isValid3(value) {
  return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
};
function hasPrefixSuffix(propsAndSlots) {
  return isValid2(propsAndSlots.prefix) || isValid2(propsAndSlots.suffix) || isValid2(propsAndSlots.allowClear);
}
function hasAddon(propsAndSlots) {
  return isValid2(propsAndSlots.addonBefore) || isValid2(propsAndSlots.addonAfter);
}
var ClearableInputType = ["text", "input"];
const ClearableLabeledInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    inputType: PropTypes$1.oneOf(tuple$1("text", "input")),
    value: PropTypes$1.any,
    defaultValue: PropTypes$1.any,
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: PropTypes$1.any,
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: PropTypes$1.any,
    prefix: PropTypes$1.any,
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: true
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean
  },
  setup: function setup111(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var containerRef = ref();
    var onInputMouseUp = function onInputMouseUp2(e2) {
      var _containerRef$value;
      if ((_containerRef$value = containerRef.value) !== null && _containerRef$value !== void 0 && _containerRef$value.contains(e2.target)) {
        var triggerFocus2 = props3.triggerFocus;
        triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
      }
    };
    var renderClearIcon = function renderClearIcon2(prefixCls) {
      var _classNames;
      var allowClear = props3.allowClear, value = props3.value, disabled = props3.disabled, readonly2 = props3.readonly, handleReset = props3.handleReset, _props$suffix = props3.suffix, suffix = _props$suffix === void 0 ? slots.suffix : _props$suffix;
      if (!allowClear) {
        return null;
      }
      var needClear = !disabled && !readonly2 && value;
      var className = "".concat(prefixCls, "-clear-icon");
      return createVNode(CloseCircleFilled$1, {
        "onClick": handleReset,
        "onMousedown": function onMousedown2(e2) {
          return e2.preventDefault();
        },
        "class": classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(className, "-hidden"), !needClear), _defineProperty$U(_classNames, "".concat(className, "-has-suffix"), !!suffix), _classNames), className),
        "role": "button"
      }, null);
    };
    var renderSuffix = function renderSuffix2(prefixCls) {
      var _slots$suffix;
      var _props$suffix2 = props3.suffix, suffix = _props$suffix2 === void 0 ? (_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots) : _props$suffix2, allowClear = props3.allowClear;
      if (suffix || allowClear) {
        return createVNode("span", {
          "class": "".concat(prefixCls, "-suffix")
        }, [renderClearIcon(prefixCls), suffix]);
      }
      return null;
    };
    var renderLabeledIcon = function renderLabeledIcon2(prefixCls, element) {
      var _slots$prefix, _slots$suffix2, _classNames2;
      var focused = props3.focused, value = props3.value, _props$prefix = props3.prefix, prefix = _props$prefix === void 0 ? (_slots$prefix = slots.prefix) === null || _slots$prefix === void 0 ? void 0 : _slots$prefix.call(slots) : _props$prefix, size2 = props3.size, _props$suffix3 = props3.suffix, suffix = _props$suffix3 === void 0 ? (_slots$suffix2 = slots.suffix) === null || _slots$suffix2 === void 0 ? void 0 : _slots$suffix2.call(slots) : _props$suffix3, disabled = props3.disabled, allowClear = props3.allowClear, direction = props3.direction, readonly2 = props3.readonly, bordered = props3.bordered, hidden = props3.hidden, _props$addonAfter = props3.addonAfter, addonAfter = _props$addonAfter === void 0 ? slots.addonAfter : _props$addonAfter, _props$addonBefore = props3.addonBefore, addonBefore = _props$addonBefore === void 0 ? slots.addonBefore : _props$addonBefore;
      var suffixNode = renderSuffix(prefixCls);
      if (!hasPrefixSuffix({
        prefix,
        suffix,
        allowClear
      })) {
        return cloneElement(element, {
          value
        });
      }
      var prefixNode = prefix ? createVNode("span", {
        "class": "".concat(prefixCls, "-prefix")
      }, [prefix]) : null;
      var affixWrapperCls = classNames("".concat(prefixCls, "-affix-wrapper"), (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-focused"), focused), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-disabled"), disabled), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), size2 === "small"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), size2 === "large"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-input-with-clear-btn"), suffix && allowClear && value), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-readonly"), readonly2), _defineProperty$U(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$U(_classNames2, "".concat(attrs.class), !hasAddon({
        addonAfter,
        addonBefore
      }) && attrs.class), _classNames2));
      return createVNode("span", {
        "ref": containerRef,
        "class": affixWrapperCls,
        "style": attrs.style,
        "onMouseup": onInputMouseUp,
        "hidden": hidden
      }, [prefixNode, cloneElement(element, {
        style: null,
        value,
        class: getInputClassName(prefixCls, bordered, size2, disabled)
      }), suffixNode]);
    };
    var renderInputWithLabel = function renderInputWithLabel2(prefixCls, labeledElement) {
      var _slots$addonBefore, _slots$addonAfter, _classNames4;
      var _props$addonBefore2 = props3.addonBefore, addonBefore = _props$addonBefore2 === void 0 ? (_slots$addonBefore = slots.addonBefore) === null || _slots$addonBefore === void 0 ? void 0 : _slots$addonBefore.call(slots) : _props$addonBefore2, _props$addonAfter2 = props3.addonAfter, addonAfter = _props$addonAfter2 === void 0 ? (_slots$addonAfter = slots.addonAfter) === null || _slots$addonAfter === void 0 ? void 0 : _slots$addonAfter.call(slots) : _props$addonAfter2, size2 = props3.size, direction = props3.direction, hidden = props3.hidden;
      if (!hasAddon({
        addonBefore,
        addonAfter
      })) {
        return labeledElement;
      }
      var wrapperClassName = "".concat(prefixCls, "-group");
      var addonClassName = "".concat(wrapperClassName, "-addon");
      var addonBeforeNode = addonBefore ? createVNode("span", {
        "class": addonClassName
      }, [addonBefore]) : null;
      var addonAfterNode = addonAfter ? createVNode("span", {
        "class": addonClassName
      }, [addonAfter]) : null;
      var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperClassName, _defineProperty$U({}, "".concat(wrapperClassName, "-rtl"), direction === "rtl"));
      var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), (_classNames4 = {}, _defineProperty$U(_classNames4, "".concat(prefixCls, "-group-wrapper-sm"), size2 === "small"), _defineProperty$U(_classNames4, "".concat(prefixCls, "-group-wrapper-lg"), size2 === "large"), _defineProperty$U(_classNames4, "".concat(prefixCls, "-group-wrapper-rtl"), direction === "rtl"), _classNames4), attrs.class);
      return createVNode("span", {
        "class": mergedGroupClassName,
        "style": attrs.style,
        "hidden": hidden
      }, [createVNode("span", {
        "class": mergedWrapperClassName
      }, [addonBeforeNode, cloneElement(labeledElement, {
        style: null
      }), addonAfterNode])]);
    };
    var renderTextAreaWithClearIcon = function renderTextAreaWithClearIcon2(prefixCls, element) {
      var _classNames5;
      var value = props3.value, allowClear = props3.allowClear, direction = props3.direction, bordered = props3.bordered, hidden = props3.hidden, _props$addonAfter3 = props3.addonAfter, addonAfter = _props$addonAfter3 === void 0 ? slots.addonAfter : _props$addonAfter3, _props$addonBefore3 = props3.addonBefore, addonBefore = _props$addonBefore3 === void 0 ? slots.addonBefore : _props$addonBefore3;
      if (!allowClear) {
        return cloneElement(element, {
          value
        });
      }
      var affixWrapperCls = classNames("".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"), (_classNames5 = {}, _defineProperty$U(_classNames5, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$U(_classNames5, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$U(_classNames5, "".concat(attrs.class), !hasAddon({
        addonAfter,
        addonBefore
      }) && attrs.class), _classNames5));
      return createVNode("span", {
        "class": affixWrapperCls,
        "style": attrs.style,
        "hidden": hidden
      }, [cloneElement(element, {
        style: null,
        value
      }), renderClearIcon(prefixCls)]);
    };
    return function() {
      var _slots$element;
      var prefixCls = props3.prefixCls, inputType = props3.inputType, _props$element = props3.element, element = _props$element === void 0 ? (_slots$element = slots.element) === null || _slots$element === void 0 ? void 0 : _slots$element.call(slots) : _props$element;
      if (inputType === ClearableInputType[0]) {
        return renderTextAreaWithClearIcon(prefixCls, element);
      }
      return renderInputWithLabel(prefixCls, renderLabeledIcon(prefixCls, element));
    };
  }
});
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
function resolveOnChange(target, e2, onChange3, targetValue) {
  if (!onChange3) {
    return;
  }
  var event2 = e2;
  if (e2.type === "click") {
    Object.defineProperty(event2, "target", {
      writable: true
    });
    Object.defineProperty(event2, "currentTarget", {
      writable: true
    });
    var currentTarget = target.cloneNode(true);
    event2.target = currentTarget;
    event2.currentTarget = currentTarget;
    currentTarget.value = "";
    onChange3(event2);
    return;
  }
  if (targetValue !== void 0) {
    Object.defineProperty(event2, "target", {
      writable: true
    });
    Object.defineProperty(event2, "currentTarget", {
      writable: true
    });
    event2.target = target;
    event2.currentTarget = target;
    target.value = targetValue;
    onChange3(event2);
    return;
  }
  onChange3(event2);
}
function triggerFocus(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
const Input$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: false,
  props: inputProps$1(),
  setup: function setup112(props3, _ref2) {
    var slots = _ref2.slots, attrs = _ref2.attrs, expose = _ref2.expose, emit = _ref2.emit;
    var inputRef = ref();
    var clearableInputRef = ref();
    var removePasswordTimeout;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("input", props3), direction = _useConfigInject.direction, prefixCls = _useConfigInject.prefixCls, size2 = _useConfigInject.size, autocomplete = _useConfigInject.autocomplete;
    var stateValue = ref(props3.value === void 0 ? props3.defaultValue : props3.value);
    var focused = ref(false);
    watch(function() {
      return props3.value;
    }, function() {
      stateValue.value = props3.value;
    });
    watch(function() {
      return props3.disabled;
    }, function() {
      if (props3.value !== void 0) {
        stateValue.value = props3.value;
      }
      if (props3.disabled) {
        focused.value = false;
      }
    });
    var clearPasswordValueAttribute = function clearPasswordValueAttribute2() {
      removePasswordTimeout = setTimeout(function() {
        var _inputRef$value;
        if (((_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.getAttribute("type")) === "password" && inputRef.value.hasAttribute("value")) {
          inputRef.value.removeAttribute("value");
        }
      });
    };
    var focus = function focus2(option) {
      triggerFocus(inputRef.value, option);
    };
    var blur = function blur2() {
      var _inputRef$value2;
      (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.blur();
    };
    var setSelectionRange = function setSelectionRange2(start, end, direction2) {
      var _inputRef$value3;
      (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.setSelectionRange(start, end, direction2);
    };
    var select = function select2() {
      var _inputRef$value4;
      (_inputRef$value4 = inputRef.value) === null || _inputRef$value4 === void 0 ? void 0 : _inputRef$value4.select();
    };
    expose({
      focus,
      blur,
      input: inputRef,
      stateValue,
      setSelectionRange,
      select
    });
    var onFocus2 = function onFocus3(e2) {
      var onFocus4 = props3.onFocus;
      focused.value = true;
      onFocus4 === null || onFocus4 === void 0 ? void 0 : onFocus4(e2);
      nextTick(function() {
        clearPasswordValueAttribute();
      });
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props3.onBlur;
      focused.value = false;
      onBlur4 === null || onBlur4 === void 0 ? void 0 : onBlur4(e2);
      formItemContext.onFieldBlur();
      nextTick(function() {
        clearPasswordValueAttribute();
      });
    };
    var triggerChange = function triggerChange2(e2) {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    var instance = getCurrentInstance();
    var setValue2 = function setValue3(value, callback) {
      if (stateValue.value === value) {
        return;
      }
      if (props3.value === void 0) {
        stateValue.value = value;
      } else {
        nextTick(function() {
          if (inputRef.value.value !== stateValue.value) {
            instance.update();
          }
        });
      }
      nextTick(function() {
        callback && callback();
      });
    };
    var handleReset = function handleReset2(e2) {
      resolveOnChange(inputRef.value, e2, triggerChange);
      setValue2("", function() {
        focus();
      });
    };
    var handleChange2 = function handleChange3(e2) {
      var _e$target = e2.target, value = _e$target.value, composing = _e$target.composing;
      if ((e2.isComposing || composing) && props3.lazy || stateValue.value === value)
        return;
      var newVal = e2.target.value;
      resolveOnChange(inputRef.value, e2, triggerChange);
      setValue2(newVal, function() {
        clearPasswordValueAttribute();
      });
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    onMounted(function() {
      clearPasswordValueAttribute();
    });
    onBeforeUnmount(function() {
      clearTimeout(removePasswordTimeout);
    });
    var renderInput = function renderInput2() {
      var _otherProps$id;
      var _props$addonBefore = props3.addonBefore, addonBefore = _props$addonBefore === void 0 ? slots.addonBefore : _props$addonBefore, _props$addonAfter = props3.addonAfter, addonAfter = _props$addonAfter === void 0 ? slots.addonAfter : _props$addonAfter, disabled = props3.disabled, _props$bordered = props3.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, _props$valueModifiers = props3.valueModifiers, valueModifiers = _props$valueModifiers === void 0 ? {} : _props$valueModifiers, htmlSize = props3.htmlSize;
      var otherProps = omit$2(props3, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers"
      ]);
      var inputProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, otherProps), attrs), {}, {
        autocomplete: autocomplete.value,
        onChange: handleChange2,
        onInput: handleChange2,
        onFocus: onFocus2,
        onBlur: onBlur2,
        onKeydown: handleKeyDown2,
        class: classNames(getInputClassName(prefixCls.value, bordered, size2.value, disabled, direction.value), _defineProperty$U({}, attrs.class, attrs.class && !addonBefore && !addonAfter)),
        ref: inputRef,
        key: "ant-input",
        size: htmlSize,
        id: (_otherProps$id = otherProps.id) !== null && _otherProps$id !== void 0 ? _otherProps$id : formItemContext.id.value
      });
      if (valueModifiers.lazy) {
        delete inputProps3.onInput;
      }
      if (!inputProps3.autofocus) {
        delete inputProps3.autofocus;
      }
      var inputNode = createVNode("input", omit$2(inputProps3, ["size"]), null);
      return withDirectives(inputNode, [[antInputDirective]]);
    };
    var renderShowCountSuffix = function renderShowCountSuffix2() {
      var _slots$suffix;
      var value = stateValue.value;
      var maxlength = props3.maxlength, _props$suffix = props3.suffix, suffix = _props$suffix === void 0 ? (_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots) : _props$suffix, showCount = props3.showCount;
      var hasMaxLength = Number(maxlength) > 0;
      if (suffix || showCount) {
        var valueLength = _toConsumableArray(fixControlledValue(value)).length;
        var dataCount = null;
        if (_typeof$3(showCount) === "object") {
          dataCount = showCount.formatter({
            count: valueLength,
            maxlength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxlength) : "");
        }
        return createVNode(Fragment, null, [!!showCount && createVNode("span", {
          "class": classNames("".concat(prefixCls.value, "-show-count-suffix"), _defineProperty$U({}, "".concat(prefixCls.value, "-show-count-has-suffix"), !!suffix))
        }, [dataCount]), suffix]);
      }
      return null;
    };
    return function() {
      var inputProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props3), {}, {
        prefixCls: prefixCls.value,
        inputType: "input",
        value: fixControlledValue(stateValue.value),
        handleReset,
        focused: focused.value && !props3.disabled
      });
      return createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, omit$2(inputProps3, ["element", "valueModifiers", "suffix", "showCount"])), {}, {
        "ref": clearableInputRef
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        element: renderInput,
        suffix: renderShowCountSuffix
      }));
    };
  }
});
const Group$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    }
  },
  setup: function setup113(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("input-group", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var cls = computed(function() {
      var _ref2;
      var pre = prefixCls.value;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(pre), true), _defineProperty$U(_ref2, "".concat(pre, "-lg"), props3.size === "large"), _defineProperty$U(_ref2, "".concat(pre, "-sm"), props3.size === "small"), _defineProperty$U(_ref2, "".concat(pre, "-compact"), props3.compact), _defineProperty$U(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _slots$default;
      return createVNode("span", {
        "class": cls.value,
        "onMouseenter": props3.onMouseenter,
        "onMouseleave": props3.onMouseleave,
        "onFocus": props3.onFocus,
        "onBlur": props3.onBlur
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
var applePhone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /\bAndroid(?:.+)SD4930UR\b/i;
var amazonTablet = /\bAndroid(?:.+)(?:KF[A-Z]{2,4})\b/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackberry = /BlackBerry/i;
var otherBlackberry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
function match(regex, userAgent) {
  return regex.test(userAgent);
}
function isMobile(userAgent) {
  var ua = userAgent || (typeof navigator !== "undefined" ? navigator.userAgent : "");
  var tmp = ua.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    var _tmp = tmp;
    var _tmp2 = _slicedToArray$2(_tmp, 1);
    ua = _tmp2[0];
  }
  tmp = ua.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    var _tmp3 = tmp;
    var _tmp4 = _slicedToArray$2(_tmp3, 1);
    ua = _tmp4[0];
  }
  var result = {
    apple: {
      phone: match(applePhone, ua) && !match(windowsPhone, ua),
      ipod: match(appleIpod, ua),
      tablet: !match(applePhone, ua) && match(appleTablet, ua) && !match(windowsPhone, ua),
      device: (match(applePhone, ua) || match(appleIpod, ua) || match(appleTablet, ua)) && !match(windowsPhone, ua)
    },
    amazon: {
      phone: match(amazonPhone, ua),
      tablet: !match(amazonPhone, ua) && match(amazonTablet, ua),
      device: match(amazonPhone, ua) || match(amazonTablet, ua)
    },
    android: {
      phone: !match(windowsPhone, ua) && match(amazonPhone, ua) || !match(windowsPhone, ua) && match(androidPhone, ua),
      tablet: !match(windowsPhone, ua) && !match(amazonPhone, ua) && !match(androidPhone, ua) && (match(amazonTablet, ua) || match(androidTablet, ua)),
      device: !match(windowsPhone, ua) && (match(amazonPhone, ua) || match(amazonTablet, ua) || match(androidPhone, ua) || match(androidTablet, ua)) || match(/\bokhttp\b/i, ua)
    },
    windows: {
      phone: match(windowsPhone, ua),
      tablet: match(windowsTablet, ua),
      device: match(windowsPhone, ua) || match(windowsTablet, ua)
    },
    other: {
      blackberry: match(otherBlackberry, ua),
      blackberry10: match(otherBlackberry10, ua),
      opera: match(otherOpera, ua),
      firefox: match(otherFirefox, ua),
      chrome: match(otherChrome, ua),
      device: match(otherBlackberry, ua) || match(otherBlackberry10, ua) || match(otherOpera, ua) || match(otherFirefox, ua) || match(otherChrome, ua)
    },
    any: null,
    phone: null,
    tablet: null
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var defaultResult = _objectSpread2$1(_objectSpread2$1({}, isMobile()), {}, {
  isMobile
});
const isMobile$1 = defaultResult;
var _excluded$x = ["disabled", "loading", "addonAfter", "suffix"];
const Search$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
    inputPrefixCls: String,
    enterButton: PropTypes$1.any,
    onSearch: {
      type: Function
    }
  }),
  setup: function setup114(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit;
    var inputRef = ref();
    var focus = function focus2() {
      var _inputRef$value;
      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();
    };
    var blur = function blur2() {
      var _inputRef$value2;
      (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.blur();
    };
    expose({
      focus,
      blur
    });
    var onChange3 = function onChange4(e2) {
      emit("update:value", e2.target.value);
      if (e2 && e2.target && e2.type === "click") {
        emit("search", e2.target.value, e2);
      }
      emit("change", e2);
    };
    var onMousedown2 = function onMousedown3(e2) {
      var _inputRef$value3;
      if (document.activeElement === ((_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.input)) {
        e2.preventDefault();
      }
    };
    var onSearch = function onSearch2(e2) {
      var _inputRef$value4;
      emit("search", (_inputRef$value4 = inputRef.value) === null || _inputRef$value4 === void 0 ? void 0 : _inputRef$value4.stateValue, e2);
      if (!isMobile$1.tablet) {
        inputRef.value.focus();
      }
    };
    var _useConfigInject = useConfigInject("input-search", props3), prefixCls = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls, direction = _useConfigInject.direction, size2 = _useConfigInject.size;
    var inputPrefixCls = computed(function() {
      return getPrefixCls2("input", props3.inputPrefixCls);
    });
    return function() {
      var _slots$addonAfter, _slots$suffix, _slots$enterButton, _slots$enterButton2, _classNames;
      var disabled = props3.disabled, loading = props3.loading, _props$addonAfter = props3.addonAfter, addonAfter = _props$addonAfter === void 0 ? (_slots$addonAfter = slots.addonAfter) === null || _slots$addonAfter === void 0 ? void 0 : _slots$addonAfter.call(slots) : _props$addonAfter, _props$suffix = props3.suffix, suffix = _props$suffix === void 0 ? (_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots) : _props$suffix, restProps = _objectWithoutProperties$2(props3, _excluded$x);
      var _props$enterButton = props3.enterButton, enterButton = _props$enterButton === void 0 ? (_slots$enterButton = (_slots$enterButton2 = slots.enterButton) === null || _slots$enterButton2 === void 0 ? void 0 : _slots$enterButton2.call(slots)) !== null && _slots$enterButton !== void 0 ? _slots$enterButton : false : _props$enterButton;
      enterButton = enterButton || enterButton === "";
      var searchIcon = typeof enterButton === "boolean" ? createVNode(SearchOutlined$1, null, null) : null;
      var btnClassName = "".concat(prefixCls.value, "-button");
      var enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
      var button;
      var isAntdButton = enterButtonAsElement.type && isPlainObject$1(enterButtonAsElement.type) && enterButtonAsElement.type.__ANT_BUTTON;
      if (isAntdButton || enterButtonAsElement.tagName === "button") {
        button = cloneElement(enterButtonAsElement, _objectSpread2$1({
          onMousedown: onMousedown2,
          onClick: onSearch,
          key: "enterButton"
        }, isAntdButton ? {
          class: btnClassName,
          size: size2.value
        } : {}), false);
      } else {
        var iconOnly = searchIcon && !enterButton;
        button = createVNode(Button$1, {
          "class": btnClassName,
          "type": enterButton ? "primary" : void 0,
          "size": size2.value,
          "disabled": disabled,
          "key": "enterButton",
          "onMousedown": onMousedown2,
          "onClick": onSearch,
          "loading": loading,
          "icon": iconOnly ? searchIcon : null
        }, {
          default: function _default9() {
            return [iconOnly ? null : searchIcon || enterButton];
          }
        });
      }
      if (addonAfter) {
        button = [button, addonAfter];
      }
      var cls = classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(size2.value), !!size2.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-with-button"), !!enterButton), _classNames), attrs.class);
      return createVNode(Input$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": inputRef
      }, omit$2(restProps, ["onUpdate:value", "onSearch", "enterButton"])), attrs), {}, {
        "onPressEnter": onSearch,
        "size": size2.value,
        "prefixCls": inputPrefixCls.value,
        "addonAfter": button,
        "suffix": suffix,
        "onChange": onChange3,
        "class": cls,
        "disabled": disabled
      }), slots);
    };
  }
});
var HIDDEN_TEXTAREA_STYLE = "\n min-height:0 !important;\n max-height:none !important;\n height:0 !important;\n visibility:hidden !important;\n overflow:hidden !important;\n position:absolute !important;\n z-index:-1000 !important;\n top:0 !important;\n right:0 !important\n";
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var nodeRef = node.getAttribute("id") || node.getAttribute("data-reactid") || node.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style2 = window.getComputedStyle(node);
  var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  var sizingStyle = SIZING_STYLE.map(function(name2) {
    return "".concat(name2, ":").concat(style2.getPropertyValue(name2));
  }).join(";");
  var nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache2 && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateNodeHeight(uiTextNode) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = Number.MIN_SAFE_INTEGER;
  var maxHeight = Number.MAX_SAFE_INTEGER;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  return {
    height: "".concat(height, "px"),
    minHeight: "".concat(minHeight, "px"),
    maxHeight: "".concat(maxHeight, "px"),
    overflowY,
    resize: "none"
  };
}
var RESIZE_STATUS_NONE = 0;
var RESIZE_STATUS_RESIZING = 1;
var RESIZE_STATUS_RESIZED = 2;
var ResizableTextArea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup: function setup115(props3, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var nextFrameActionId;
    var resizeFrameId;
    var textAreaRef = ref();
    var textareaStyles = ref({});
    var resizeStatus = ref(RESIZE_STATUS_NONE);
    onBeforeUnmount(function() {
      wrapperRaf.cancel(nextFrameActionId);
      wrapperRaf.cancel(resizeFrameId);
    });
    var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
      try {
        if (document.activeElement === textAreaRef.value) {
          var currentStart = textAreaRef.value.selectionStart;
          var currentEnd = textAreaRef.value.selectionEnd;
          textAreaRef.value.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e2) {
      }
    };
    var resizeTextarea = function resizeTextarea2() {
      var autoSize = props3.autoSize || props3.autosize;
      if (!autoSize || !textAreaRef.value) {
        return;
      }
      var minRows = autoSize.minRows, maxRows = autoSize.maxRows;
      textareaStyles.value = calculateNodeHeight(textAreaRef.value, false, minRows, maxRows);
      resizeStatus.value = RESIZE_STATUS_RESIZING;
      wrapperRaf.cancel(resizeFrameId);
      resizeFrameId = wrapperRaf(function() {
        resizeStatus.value = RESIZE_STATUS_RESIZED;
        resizeFrameId = wrapperRaf(function() {
          resizeStatus.value = RESIZE_STATUS_NONE;
          fixFirefoxAutoScroll();
        });
      });
    };
    var resizeOnNextFrame = function resizeOnNextFrame2() {
      wrapperRaf.cancel(nextFrameActionId);
      nextFrameActionId = wrapperRaf(resizeTextarea);
    };
    var handleResize = function handleResize2(size2) {
      if (resizeStatus.value !== RESIZE_STATUS_NONE) {
        return;
      }
      emit("resize", size2);
      var autoSize = props3.autoSize || props3.autosize;
      if (autoSize) {
        resizeOnNextFrame();
      }
    };
    warning$2(props3.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    var renderTextArea = function renderTextArea2() {
      var prefixCls = props3.prefixCls, autoSize = props3.autoSize, autosize = props3.autosize, disabled = props3.disabled;
      var otherProps = omit$2(props3, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "lazy", "maxlength", "valueModifiers"]);
      var cls = classNames(prefixCls, attrs.class, _defineProperty$U({}, "".concat(prefixCls, "-disabled"), disabled));
      var style2 = [attrs.style, textareaStyles.value, resizeStatus.value === RESIZE_STATUS_RESIZING ? {
        overflowX: "hidden",
        overflowY: "hidden"
      } : null];
      var textareaProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, otherProps), attrs), {}, {
        style: style2,
        class: cls
      });
      if (!textareaProps.autofocus) {
        delete textareaProps.autofocus;
      }
      if (textareaProps.rows === 0) {
        delete textareaProps.rows;
      }
      return createVNode(ResizeObserver$1, {
        "onResize": handleResize,
        "disabled": !(autoSize || autosize)
      }, {
        default: function _default9() {
          return [withDirectives(createVNode("textarea", _objectSpread2$1(_objectSpread2$1({}, textareaProps), {}, {
            "ref": textAreaRef
          }), null), [[antInputDirective]])];
        }
      });
    };
    watch(function() {
      return props3.value;
    }, function() {
      nextTick(function() {
        resizeTextarea();
      });
    });
    onMounted(function() {
      nextTick(function() {
        resizeTextarea();
      });
    });
    var instance = getCurrentInstance();
    expose({
      resizeTextarea,
      textArea: textAreaRef,
      instance
    });
    return function() {
      return renderTextArea();
    };
  }
});
const ResizableTextArea$1 = ResizableTextArea;
function fixEmojiLength(value, maxLength) {
  return _toConsumableArray(value || "").slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
const TextArea = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: false,
  props: textAreaProps(),
  setup: function setup116(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    var stateValue = ref(props3.value === void 0 ? props3.defaultValue : props3.value);
    var resizableTextArea = ref();
    var mergedValue = ref("");
    var _useConfigInject = useConfigInject("input", props3), prefixCls = _useConfigInject.prefixCls, size2 = _useConfigInject.size, direction = _useConfigInject.direction;
    var showCount = computed(function() {
      return props3.showCount === "" || props3.showCount || false;
    });
    var hasMaxLength = computed(function() {
      return Number(props3.maxlength) > 0;
    });
    var compositing = ref(false);
    var oldCompositionValueRef = ref();
    var oldSelectionStartRef = ref(0);
    var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
      compositing.value = true;
      oldCompositionValueRef.value = mergedValue.value;
      oldSelectionStartRef.value = e2.currentTarget.selectionStart;
      emit("compositionstart", e2);
    };
    var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
      compositing.value = false;
      var triggerValue = e2.currentTarget.value;
      if (hasMaxLength.value) {
        var _oldCompositionValueR;
        var isCursorInEnd = oldSelectionStartRef.value >= props3.maxlength + 1 || oldSelectionStartRef.value === ((_oldCompositionValueR = oldCompositionValueRef.value) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
        triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.value, triggerValue, props3.maxlength);
      }
      if (triggerValue !== mergedValue.value) {
        setValue2(triggerValue);
        resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      }
      emit("compositionend", e2);
    };
    var instance = getCurrentInstance();
    watch(function() {
      return props3.value;
    }, function() {
      if ("value" in instance.vnode.props || {}) {
        var _props$value;
        stateValue.value = (_props$value = props3.value) !== null && _props$value !== void 0 ? _props$value : "";
      }
    });
    var focus = function focus2(option) {
      var _resizableTextArea$va;
      triggerFocus((_resizableTextArea$va = resizableTextArea.value) === null || _resizableTextArea$va === void 0 ? void 0 : _resizableTextArea$va.textArea, option);
    };
    var blur = function blur2() {
      var _resizableTextArea$va2, _resizableTextArea$va3;
      (_resizableTextArea$va2 = resizableTextArea.value) === null || _resizableTextArea$va2 === void 0 ? void 0 : (_resizableTextArea$va3 = _resizableTextArea$va2.textArea) === null || _resizableTextArea$va3 === void 0 ? void 0 : _resizableTextArea$va3.blur();
    };
    var setValue2 = function setValue3(value, callback) {
      if (stateValue.value === value) {
        return;
      }
      if (props3.value === void 0) {
        stateValue.value = value;
      } else {
        nextTick(function() {
          if (resizableTextArea.value.textArea.value !== mergedValue.value) {
            var _resizableTextArea$va4, _resizableTextArea$va5, _resizableTextArea$va6;
            (_resizableTextArea$va4 = resizableTextArea.value) === null || _resizableTextArea$va4 === void 0 ? void 0 : (_resizableTextArea$va5 = (_resizableTextArea$va6 = _resizableTextArea$va4.instance).update) === null || _resizableTextArea$va5 === void 0 ? void 0 : _resizableTextArea$va5.call(_resizableTextArea$va6);
          }
        });
      }
      nextTick(function() {
        callback && callback();
      });
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === 13) {
        emit("pressEnter", e2);
      }
      emit("keydown", e2);
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props3.onBlur;
      onBlur4 === null || onBlur4 === void 0 ? void 0 : onBlur4(e2);
      formItemContext.onFieldBlur();
    };
    var triggerChange = function triggerChange2(e2) {
      emit("update:value", e2.target.value);
      emit("change", e2);
      emit("input", e2);
      formItemContext.onFieldChange();
    };
    var handleReset = function handleReset2(e2) {
      resolveOnChange(resizableTextArea.value.textArea, e2, triggerChange);
      setValue2("", function() {
        focus();
      });
    };
    var handleChange2 = function handleChange3(e2) {
      var composing = e2.target.composing;
      var triggerValue = e2.target.value;
      compositing.value = !!(e2.isComposing || composing);
      if (compositing.value && props3.lazy || stateValue.value === triggerValue)
        return;
      if (hasMaxLength.value) {
        var target = e2.target;
        var isCursorInEnd = target.selectionStart >= props3.maxlength + 1 || target.selectionStart === triggerValue.length || !target.selectionStart;
        triggerValue = setTriggerValue(isCursorInEnd, mergedValue.value, triggerValue, props3.maxlength);
      }
      resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
      setValue2(triggerValue);
    };
    var renderTextArea = function renderTextArea2() {
      var _class, _props$valueModifiers, _resizeProps$id;
      var style2 = attrs.style, customClass = attrs.class;
      var _props$bordered = props3.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered;
      var resizeProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["allowClear"])), attrs), {}, {
        style: showCount.value ? {} : style2,
        class: (_class = {}, _defineProperty$U(_class, "".concat(prefixCls.value, "-borderless"), !bordered), _defineProperty$U(_class, "".concat(customClass), customClass && !showCount.value), _defineProperty$U(_class, "".concat(prefixCls.value, "-sm"), size2.value === "small"), _defineProperty$U(_class, "".concat(prefixCls.value, "-lg"), size2.value === "large"), _class),
        showCount: null,
        prefixCls: prefixCls.value,
        onInput: handleChange2,
        onChange: handleChange2,
        onBlur: onBlur2,
        onKeydown: handleKeyDown2,
        onCompositionstart: onInternalCompositionStart,
        onCompositionend: onInternalCompositionEnd
      });
      if ((_props$valueModifiers = props3.valueModifiers) !== null && _props$valueModifiers !== void 0 && _props$valueModifiers.lazy) {
        delete resizeProps.onInput;
      }
      return createVNode(ResizableTextArea$1, _objectSpread2$1(_objectSpread2$1({}, resizeProps), {}, {
        "id": (_resizeProps$id = resizeProps.id) !== null && _resizeProps$id !== void 0 ? _resizeProps$id : formItemContext.id.value,
        "ref": resizableTextArea,
        "maxlength": props3.maxlength
      }), null);
    };
    expose({
      focus,
      blur,
      resizableTextArea
    });
    watchEffect(function() {
      var val = fixControlledValue(stateValue.value);
      if (!compositing.value && hasMaxLength.value && (props3.value === null || props3.value === void 0)) {
        val = fixEmojiLength(val, props3.maxlength);
      }
      mergedValue.value = val;
    });
    return function() {
      var maxlength = props3.maxlength, _props$bordered2 = props3.bordered, bordered = _props$bordered2 === void 0 ? true : _props$bordered2, hidden = props3.hidden;
      var style2 = attrs.style, customClass = attrs.class;
      var inputProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        prefixCls: prefixCls.value,
        inputType: "text",
        handleReset,
        direction: direction.value,
        bordered,
        style: showCount.value ? void 0 : style2
      });
      var textareaNode = createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, inputProps3), {}, {
        "value": mergedValue.value
      }), {
        element: renderTextArea
      });
      if (showCount.value) {
        var valueLength = _toConsumableArray(mergedValue.value).length;
        var dataCount = "";
        if (_typeof$3(showCount.value) === "object") {
          dataCount = showCount.value.formatter({
            count: valueLength,
            maxlength
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength.value ? " / ".concat(maxlength) : "");
        }
        textareaNode = createVNode("div", {
          "hidden": hidden,
          "class": classNames("".concat(prefixCls.value, "-textarea"), _defineProperty$U({}, "".concat(prefixCls.value, "-textarea-rtl"), direction.value === "rtl"), "".concat(prefixCls.value, "-textarea-show-count"), customClass),
          "style": style2,
          "data-count": _typeof$3(dataCount) !== "object" ? dataCount : void 0
        }, [textareaNode]);
      }
      return textareaNode;
    };
  }
});
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
const EyeOutlinedSvg = EyeOutlined$2;
function _objectSpread$u(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$u(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$u(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeOutlined = function EyeOutlined2(props3, context2) {
  var p2 = _objectSpread$u({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$u({}, p2, {
    "icon": EyeOutlinedSvg
  }), null);
};
EyeOutlined.displayName = "EyeOutlined";
EyeOutlined.inheritAttrs = false;
const EyeOutlined$1 = EyeOutlined;
var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
function _objectSpread$t(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$t(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$t(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props3, context2) {
  var p2 = _objectSpread$t({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$t({}, p2, {
    "icon": EyeInvisibleOutlinedSvg
  }), null);
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
EyeInvisibleOutlined.inheritAttrs = false;
const EyeInvisibleOutlined$1 = EyeInvisibleOutlined;
var _excluded$w = ["size", "visibilityToggle"];
var ActionMap = {
  click: "onClick",
  hover: "onMouseover"
};
var defaultIconRender = function defaultIconRender2(visible) {
  return visible ? createVNode(EyeOutlined$1, null, null) : createVNode(EyeInvisibleOutlined$1, null, null);
};
const Password = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, inputProps$1()), {}, {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: true
    },
    iconRender: Function
  }),
  setup: function setup117(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var visible = ref(false);
    var onVisibleChange = function onVisibleChange2() {
      var disabled = props3.disabled;
      if (disabled) {
        return;
      }
      visible.value = !visible.value;
    };
    var inputRef = ref();
    var focus = function focus2() {
      var _inputRef$value;
      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();
    };
    var blur = function blur2() {
      var _inputRef$value2;
      (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.blur();
    };
    expose({
      focus,
      blur
    });
    var getIcon2 = function getIcon3(prefixCls2) {
      var _iconProps;
      var action = props3.action, _props$iconRender = props3.iconRender, iconRender = _props$iconRender === void 0 ? slots.iconRender || defaultIconRender : _props$iconRender;
      var iconTrigger = ActionMap[action] || "";
      var icon = iconRender(visible.value);
      var iconProps = (_iconProps = {}, _defineProperty$U(_iconProps, iconTrigger, onVisibleChange), _defineProperty$U(_iconProps, "class", "".concat(prefixCls2, "-icon")), _defineProperty$U(_iconProps, "key", "passwordIcon"), _defineProperty$U(_iconProps, "onMousedown", function onMousedown2(e2) {
        e2.preventDefault();
      }), _defineProperty$U(_iconProps, "onMouseup", function onMouseup(e2) {
        e2.preventDefault();
      }), _iconProps);
      return cloneElement(isValidElement(icon) ? icon : createVNode("span", null, [icon]), iconProps);
    };
    var _useConfigInject = useConfigInject("input-password", props3), prefixCls = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var inputPrefixCls = computed(function() {
      return getPrefixCls2("input", props3.inputPrefixCls);
    });
    var renderPassword = function renderPassword2() {
      var size2 = props3.size, visibilityToggle = props3.visibilityToggle, restProps = _objectWithoutProperties$2(props3, _excluded$w);
      var suffixIcon = visibilityToggle && getIcon2(prefixCls.value);
      var inputClassName = classNames(prefixCls.value, attrs.class, _defineProperty$U({}, "".concat(prefixCls.value, "-").concat(size2), !!size2));
      var omittedProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(restProps, ["suffix", "iconRender", "action"])), attrs), {}, {
        type: visible.value ? "text" : "password",
        class: inputClassName,
        prefixCls: inputPrefixCls.value,
        suffix: suffixIcon
      });
      if (size2) {
        omittedProps.size = size2;
      }
      return createVNode(Input$1, _objectSpread2$1({
        "ref": inputRef
      }, omittedProps), slots);
    };
    return function() {
      return renderPassword();
    };
  }
});
Input$1.Group = Group$2;
Input$1.Search = Search$2;
Input$1.TextArea = TextArea;
Input$1.Password = Password;
Input$1.install = function(app) {
  app.component(Input$1.name, Input$1);
  app.component(Input$1.Group.name, Input$1.Group);
  app.component(Input$1.Search.name, Input$1.Search);
  app.component(Input$1.TextArea.name, Input$1.TextArea);
  app.component(Input$1.Password.name, Input$1.Password);
  return app;
};
var numberTag = "[object Number]";
function isNumber$2(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
function getClientSize() {
  var width = document.documentElement.clientWidth;
  var height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getOffset(node) {
  var box = node.getBoundingClientRect();
  var docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
function dialogPropTypes() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: PropTypes$1.shape({
      x: Number,
      y: Number
    }).loose,
    title: PropTypes$1.any,
    footer: PropTypes$1.any,
    transitionName: String,
    maskTransitionName: String,
    animation: PropTypes$1.any,
    maskAnimation: PropTypes$1.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: PropTypes$1.any,
    maskProps: PropTypes$1.any,
    wrapProps: PropTypes$1.any,
    getContainer: PropTypes$1.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: PropTypes$1.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function getMotionName(prefixCls, transitionName2, animationName) {
  var motionName = transitionName2;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
var uuid$1 = -1;
function getUUID() {
  uuid$1 += 1;
  return uuid$1;
}
function getScroll$1(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function offset$1(el) {
  var rect = el.getBoundingClientRect();
  var pos2 = {
    left: rect.left,
    top: rect.top
  };
  var doc2 = el.ownerDocument;
  var w2 = doc2.defaultView || doc2.parentWindow;
  pos2.left += getScroll$1(w2);
  pos2.top += getScroll$1(w2, true);
  return pos2;
}
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
const Content$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Content",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup: function setup118(props3, _ref) {
    var expose = _ref.expose, slots = _ref.slots, attrs = _ref.attrs;
    var sentinelStartRef = ref();
    var sentinelEndRef = ref();
    var dialogRef = ref();
    expose({
      focus: function focus() {
        var _sentinelStartRef$val;
        (_sentinelStartRef$val = sentinelStartRef.value) === null || _sentinelStartRef$val === void 0 ? void 0 : _sentinelStartRef$val.focus();
      },
      changeActive: function changeActive(next2) {
        var _document = document, activeElement = _document.activeElement;
        if (next2 && activeElement === sentinelEndRef.value) {
          sentinelStartRef.value.focus();
        } else if (!next2 && activeElement === sentinelStartRef.value) {
          sentinelEndRef.value.focus();
        }
      }
    });
    var transformOrigin = ref();
    var contentStyleRef = computed(function() {
      var width = props3.width, height = props3.height;
      var contentStyle = {};
      if (width !== void 0) {
        contentStyle.width = typeof width === "number" ? "".concat(width, "px") : width;
      }
      if (height !== void 0) {
        contentStyle.height = typeof height === "number" ? "".concat(height, "px") : height;
      }
      if (transformOrigin.value) {
        contentStyle.transformOrigin = transformOrigin.value;
      }
      return contentStyle;
    });
    var onPrepare = function onPrepare2() {
      nextTick(function() {
        if (dialogRef.value) {
          var elementOffset = offset$1(dialogRef.value);
          transformOrigin.value = props3.mousePosition ? "".concat(props3.mousePosition.x - elementOffset.left, "px ").concat(props3.mousePosition.y - elementOffset.top, "px") : "";
        }
      });
    };
    var onVisibleChanged = function onVisibleChanged2(visible) {
      props3.onVisibleChanged(visible);
    };
    return function() {
      var _slots$footer, _slots$title, _slots$closeIcon, _slots$default;
      var prefixCls = props3.prefixCls, _props$footer = props3.footer, footer = _props$footer === void 0 ? (_slots$footer = slots.footer) === null || _slots$footer === void 0 ? void 0 : _slots$footer.call(slots) : _props$footer, _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots) : _props$title, ariaId = props3.ariaId, closable = props3.closable, _props$closeIcon = props3.closeIcon, closeIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : _props$closeIcon, onClose = props3.onClose, bodyStyle = props3.bodyStyle, bodyProps = props3.bodyProps, onMousedown2 = props3.onMousedown, onMouseup = props3.onMouseup, visible = props3.visible, _props$modalRender = props3.modalRender, modalRender = _props$modalRender === void 0 ? slots.modalRender : _props$modalRender, destroyOnClose = props3.destroyOnClose, motionName = props3.motionName;
      var footerNode;
      if (footer) {
        footerNode = createVNode("div", {
          "class": "".concat(prefixCls, "-footer")
        }, [footer]);
      }
      var headerNode;
      if (title) {
        headerNode = createVNode("div", {
          "class": "".concat(prefixCls, "-header")
        }, [createVNode("div", {
          "class": "".concat(prefixCls, "-title"),
          "id": ariaId
        }, [title])]);
      }
      var closer;
      if (closable) {
        closer = createVNode("button", {
          "type": "button",
          "onClick": onClose,
          "aria-label": "Close",
          "class": "".concat(prefixCls, "-close")
        }, [closeIcon || createVNode("span", {
          "class": "".concat(prefixCls, "-close-x")
        }, null)]);
      }
      var content = createVNode("div", {
        "class": "".concat(prefixCls, "-content")
      }, [closer, headerNode, createVNode("div", _objectSpread2$1({
        "class": "".concat(prefixCls, "-body"),
        "style": bodyStyle
      }, bodyProps), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), footerNode]);
      var transitionProps = getTransitionProps(motionName);
      return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps), {}, {
        "onBeforeEnter": onPrepare,
        "onAfterEnter": function onAfterEnter() {
          return onVisibleChanged(true);
        },
        "onAfterLeave": function onAfterLeave() {
          return onVisibleChanged(false);
        }
      }), {
        default: function _default9() {
          return [visible || !destroyOnClose ? withDirectives(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
            "ref": dialogRef,
            "key": "dialog-element",
            "role": "document",
            "style": [contentStyleRef.value, attrs.style],
            "class": [prefixCls, attrs.class],
            "onMousedown": onMousedown2,
            "onMouseup": onMouseup
          }), [createVNode("div", {
            "tabindex": 0,
            "ref": sentinelStartRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null), modalRender ? modalRender({
            originVNode: content
          }) : content, createVNode("div", {
            "tabindex": 0,
            "ref": sentinelEndRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null)]), [[vShow, visible]]) : null];
        }
      });
    };
  }
});
function _objectDestructuringEmpty(obj) {
  if (obj == null)
    throw new TypeError("Cannot destructure " + obj);
}
const Mask = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Mask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup: function setup119(props3, _ref) {
    _objectDestructuringEmpty(_ref);
    return function() {
      var prefixCls = props3.prefixCls, visible = props3.visible, maskProps = props3.maskProps, motionName = props3.motionName;
      var transitionProps = getTransitionProps(motionName);
      return createVNode(Transition, transitionProps, {
        default: function _default9() {
          return [withDirectives(createVNode("div", _objectSpread2$1({
            "class": "".concat(prefixCls, "-mask")
          }, maskProps), null), [[vShow, visible]])];
        }
      });
    };
  }
});
const Dialog = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Dialog",
  inheritAttrs: false,
  props: initDefaultProps$1(_objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: true,
    visible: false,
    keyboard: true,
    closable: true,
    maskClosable: true,
    destroyOnClose: false,
    prefixCls: "rc-dialog",
    getOpenCount: function getOpenCount() {
      return null;
    },
    focusTriggerAfterClose: true
  }),
  setup: function setup120(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var lastOutSideActiveElementRef = ref();
    var wrapperRef = ref();
    var contentRef = ref();
    var animatedVisible = ref(props3.visible);
    var ariaIdRef = ref("vcDialogTitle".concat(getUUID()));
    var onDialogVisibleChanged = function onDialogVisibleChanged2(newVisible) {
      if (newVisible) {
        if (!contains(wrapperRef.value, document.activeElement)) {
          var _contentRef$value;
          lastOutSideActiveElementRef.value = document.activeElement;
          (_contentRef$value = contentRef.value) === null || _contentRef$value === void 0 ? void 0 : _contentRef$value.focus();
        }
      } else {
        var preAnimatedVisible = animatedVisible.value;
        animatedVisible.value = false;
        if (props3.mask && lastOutSideActiveElementRef.value && props3.focusTriggerAfterClose) {
          try {
            lastOutSideActiveElementRef.value.focus({
              preventScroll: true
            });
          } catch (e2) {
          }
          lastOutSideActiveElementRef.value = null;
        }
        if (preAnimatedVisible) {
          var _props$afterClose;
          (_props$afterClose = props3.afterClose) === null || _props$afterClose === void 0 ? void 0 : _props$afterClose.call(props3);
        }
      }
    };
    var onInternalClose = function onInternalClose2(e2) {
      var _props$onClose;
      (_props$onClose = props3.onClose) === null || _props$onClose === void 0 ? void 0 : _props$onClose.call(props3, e2);
    };
    var contentClickRef = ref(false);
    var contentTimeoutRef = ref();
    var onContentMouseDown = function onContentMouseDown2() {
      clearTimeout(contentTimeoutRef.value);
      contentClickRef.value = true;
    };
    var onContentMouseUp = function onContentMouseUp2() {
      contentTimeoutRef.value = setTimeout(function() {
        contentClickRef.value = false;
      });
    };
    var onWrapperClick = function onWrapperClick2(e2) {
      if (!props3.maskClosable)
        return null;
      if (contentClickRef.value) {
        contentClickRef.value = false;
      } else if (wrapperRef.value === e2.target) {
        onInternalClose(e2);
      }
    };
    var onWrapperKeyDown = function onWrapperKeyDown2(e2) {
      if (props3.keyboard && e2.keyCode === KeyCode$1.ESC) {
        e2.stopPropagation();
        onInternalClose(e2);
        return;
      }
      if (props3.visible) {
        if (e2.keyCode === KeyCode$1.TAB) {
          contentRef.value.changeActive(!e2.shiftKey);
        }
      }
    };
    watch(function() {
      return props3.visible;
    }, function() {
      if (props3.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    onBeforeUnmount(function() {
      var _props$scrollLocker;
      clearTimeout(contentTimeoutRef.value);
      (_props$scrollLocker = props3.scrollLocker) === null || _props$scrollLocker === void 0 ? void 0 : _props$scrollLocker.unLock();
    });
    watchEffect(function() {
      var _props$scrollLocker2;
      (_props$scrollLocker2 = props3.scrollLocker) === null || _props$scrollLocker2 === void 0 ? void 0 : _props$scrollLocker2.unLock();
      if (animatedVisible.value) {
        var _props$scrollLocker3;
        (_props$scrollLocker3 = props3.scrollLocker) === null || _props$scrollLocker3 === void 0 ? void 0 : _props$scrollLocker3.lock();
      }
    });
    return function() {
      var prefixCls = props3.prefixCls, mask = props3.mask, visible = props3.visible, maskTransitionName = props3.maskTransitionName, maskAnimation = props3.maskAnimation, zIndex = props3.zIndex, wrapClassName = props3.wrapClassName, rootClassName = props3.rootClassName, wrapStyle = props3.wrapStyle, closable = props3.closable, maskProps = props3.maskProps, maskStyle = props3.maskStyle, transitionName2 = props3.transitionName, animation = props3.animation, wrapProps = props3.wrapProps, _props$title = props3.title, title = _props$title === void 0 ? slots.title : _props$title;
      var style2 = attrs.style, className = attrs.class;
      return createVNode("div", _objectSpread2$1({
        "class": ["".concat(prefixCls, "-root"), rootClassName]
      }, pickAttrs(props3, {
        data: true
      })), [createVNode(Mask, {
        "prefixCls": prefixCls,
        "visible": mask && visible,
        "motionName": getMotionName(prefixCls, maskTransitionName, maskAnimation),
        "style": _objectSpread2$1({
          zIndex
        }, maskStyle),
        "maskProps": maskProps
      }, null), createVNode("div", _objectSpread2$1({
        "tabIndex": -1,
        "onKeydown": onWrapperKeyDown,
        "class": classNames("".concat(prefixCls, "-wrap"), wrapClassName),
        "ref": wrapperRef,
        "onClick": onWrapperClick,
        "role": "dialog",
        "aria-labelledby": title ? ariaIdRef.value : null,
        "style": _objectSpread2$1(_objectSpread2$1({
          zIndex
        }, wrapStyle), {}, {
          display: !animatedVisible.value ? "none" : null
        })
      }, wrapProps), [createVNode(Content$1, _objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["scrollLocker"])), {}, {
        "style": style2,
        "class": className,
        "onMousedown": onContentMouseDown,
        "onMouseup": onContentMouseUp,
        "ref": contentRef,
        "closable": closable,
        "ariaId": ariaIdRef.value,
        "prefixCls": prefixCls,
        "visible": visible,
        "onClose": onInternalClose,
        "onVisibleChanged": onDialogVisibleChanged,
        "motionName": getMotionName(prefixCls, transitionName2, animation)
      }), slots)])]);
    };
  }
});
var IDialogPropTypes = dialogPropTypes();
var DialogWrap = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: false,
  props: initDefaultProps$1(IDialogPropTypes, {
    visible: false
  }),
  setup: function setup121(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var animatedVisible = ref(props3.visible);
    useProvidePortal({}, {
      inTriggerContext: false
    });
    watch(function() {
      return props3.visible;
    }, function() {
      if (props3.visible) {
        animatedVisible.value = true;
      }
    }, {
      flush: "post"
    });
    return function() {
      var visible = props3.visible, getContainer4 = props3.getContainer, forceRender = props3.forceRender, _props$destroyOnClose = props3.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props3.afterClose;
      var dialogProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        ref: "_component",
        key: "dialog"
      });
      if (getContainer4 === false) {
        return createVNode(Dialog, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
          "getOpenCount": function getOpenCount2() {
            return 2;
          }
        }), slots);
      }
      if (!forceRender && destroyOnClose && !animatedVisible.value) {
        return null;
      }
      return createVNode(Portal, {
        "visible": visible,
        "forceRender": forceRender,
        "getContainer": getContainer4
      }, {
        default: function _default9(childProps) {
          dialogProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, dialogProps), childProps), {}, {
            afterClose: function afterClose() {
              _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
              animatedVisible.value = false;
            }
          });
          return createVNode(Dialog, dialogProps, slots);
        }
      });
    };
  }
});
const DialogWrap$1 = DialogWrap;
function useFrameSetState(initial) {
  var frame = ref(null);
  var state = reactive(_objectSpread2$1({}, initial));
  var queue2 = ref([]);
  var setFrameState = function setFrameState2(newState) {
    if (frame.value === null) {
      queue2.value = [];
      frame.value = wrapperRaf(function() {
        var memoState;
        queue2.value.forEach(function(queueState) {
          memoState = _objectSpread2$1(_objectSpread2$1({}, memoState), queueState);
        });
        _extends$1(state, memoState);
        frame.value = null;
      });
    }
    queue2.value.push(newState);
  };
  onMounted(function() {
    frame.value && wrapperRaf.cancel(frame.value);
  });
  return [state, setFrameState];
}
function fixPoint(key2, start, width, clientWidth) {
  var startAddWidth = start + width;
  var offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return _defineProperty$U({}, key2, offsetStart);
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return _defineProperty$U({}, key2, -offsetStart);
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return _defineProperty$U({}, key2, start < 0 ? offsetStart : -offsetStart);
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left, top) {
  var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
  var fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = _objectSpread2$1(_objectSpread2$1({}, fixPoint("x", left, width, clientWidth)), fixPoint("y", top, height, clientHeight));
  }
  return fixPos;
}
var previewGroupContext = Symbol("previewGroupContext");
var context = {
  provide: function provide$1(val) {
    provide(previewGroupContext, val);
  },
  inject: function inject$1() {
    return inject(previewGroupContext, {
      isPreviewGroup: ref(false),
      previewUrls: computed(function() {
        return /* @__PURE__ */ new Map();
      }),
      setPreviewUrls: function setPreviewUrls() {
      },
      current: ref(null),
      setCurrent: function setCurrent() {
      },
      setShowPreview: function setShowPreview() {
      },
      setMousePosition: function setMousePosition() {
      },
      registerImage: null,
      rootClassName: ""
    });
  }
};
var Group$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: false,
  props: {
    previewPrefixCls: String,
    preview: {
      type: [Boolean, Object],
      default: true
    },
    icons: {
      type: Object,
      default: function _default3() {
        return {};
      }
    }
  },
  setup: function setup122(props3, _ref) {
    var slots = _ref.slots;
    var preview = computed(function() {
      var defaultValues = {
        visible: void 0,
        onVisibleChange: function onVisibleChange() {
        },
        getContainer: void 0,
        current: 0
      };
      return _typeof$3(props3.preview) === "object" ? mergeDefaultValue(props3.preview, defaultValues) : defaultValues;
    });
    var previewUrls = reactive(/* @__PURE__ */ new Map());
    var current2 = ref();
    var previewVisible = computed(function() {
      return preview.value.visible;
    });
    var getPreviewContainer = computed(function() {
      return preview.value.getContainer;
    });
    var onPreviewVisibleChange = function onPreviewVisibleChange2(val, preval) {
      var _preview$value$onVisi, _preview$value;
      (_preview$value$onVisi = (_preview$value = preview.value).onVisibleChange) === null || _preview$value$onVisi === void 0 ? void 0 : _preview$value$onVisi.call(_preview$value, val, preval);
    };
    var _useMergedState = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview = _useMergedState2[1];
    var mousePosition2 = ref(null);
    var isControlled = computed(function() {
      return previewVisible.value !== void 0;
    });
    var previewUrlsKeys = computed(function() {
      return Array.from(previewUrls.keys());
    });
    var currentControlledKey = computed(function() {
      return previewUrlsKeys.value[preview.value.current];
    });
    var canPreviewUrls = computed(function() {
      return new Map(Array.from(previewUrls).filter(function(_ref2) {
        var _ref3 = _slicedToArray$2(_ref2, 2), canPreview = _ref3[1].canPreview;
        return !!canPreview;
      }).map(function(_ref4) {
        var _ref5 = _slicedToArray$2(_ref4, 2), id = _ref5[0], url2 = _ref5[1].url;
        return [id, url2];
      }));
    });
    var setPreviewUrls = function setPreviewUrls2(id, url2) {
      var canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      previewUrls.set(id, {
        url: url2,
        canPreview
      });
    };
    var setCurrent = function setCurrent2(val) {
      current2.value = val;
    };
    var setMousePosition = function setMousePosition2(val) {
      mousePosition2.value = val;
    };
    var registerImage = function registerImage2(id, url2) {
      var canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var unRegister = function unRegister2() {
        previewUrls.delete(id);
      };
      previewUrls.set(id, {
        url: url2,
        canPreview
      });
      return unRegister;
    };
    var onPreviewClose = function onPreviewClose2(e2) {
      e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
      setShowPreview(false);
      setMousePosition(null);
    };
    watch(currentControlledKey, function(val) {
      setCurrent(val);
    }, {
      immediate: true,
      flush: "post"
    });
    watchEffect(function() {
      if (isShowPreview.value && isControlled.value) {
        setCurrent(currentControlledKey.value);
      }
    }, {
      flush: "post"
    });
    context.provide({
      isPreviewGroup: ref(true),
      previewUrls: canPreviewUrls,
      setPreviewUrls,
      current: current2,
      setCurrent,
      setShowPreview,
      setMousePosition,
      registerImage
    });
    return function() {
      var dialogProps = _extends$1({}, (_objectDestructuringEmpty(preview.value), preview.value));
      return createVNode(Fragment, null, [slots.default && slots.default(), createVNode(Preview$1, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
        "ria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": props3.previewPrefixCls,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition2.value,
        "src": canPreviewUrls.value.get(current2.value),
        "icons": props3.icons,
        "getContainer": getPreviewContainer.value
      }), null)]);
    };
  }
});
const PreviewGroup$1 = Group$1;
var initialPosition = {
  x: 0,
  y: 0
};
var previewProps = _objectSpread2$1(_objectSpread2$1({}, dialogPropTypes()), {}, {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: function _default4() {
      return {};
    }
  }
});
var Preview = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: false,
  props: previewProps,
  emits: ["close", "afterClose"],
  setup: function setup123(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs;
    var _reactive = reactive(props3.icons), rotateLeft = _reactive.rotateLeft, rotateRight = _reactive.rotateRight, zoomIn = _reactive.zoomIn, zoomOut = _reactive.zoomOut, close3 = _reactive.close, left = _reactive.left, right = _reactive.right;
    var scale = ref(1);
    var rotate = ref(0);
    var _useFrameSetState = useFrameSetState(initialPosition), _useFrameSetState2 = _slicedToArray$2(_useFrameSetState, 2), position = _useFrameSetState2[0], setPosition = _useFrameSetState2[1];
    var onClose = function onClose2() {
      return emit("close");
    };
    var imgRef = ref();
    var originPositionRef = reactive({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    });
    var isMoving = ref(false);
    var groupContext = context.inject();
    var previewUrls = groupContext.previewUrls, current2 = groupContext.current, isPreviewGroup = groupContext.isPreviewGroup, setCurrent = groupContext.setCurrent;
    var previewGroupCount = computed(function() {
      return previewUrls.value.size;
    });
    var previewUrlsKeys = computed(function() {
      return Array.from(previewUrls.value.keys());
    });
    var currentPreviewIndex = computed(function() {
      return previewUrlsKeys.value.indexOf(current2.value);
    });
    var combinationSrc = computed(function() {
      return isPreviewGroup.value ? previewUrls.value.get(current2.value) : props3.src;
    });
    var showLeftOrRightSwitches = computed(function() {
      return isPreviewGroup.value && previewGroupCount.value > 1;
    });
    var lastWheelZoomDirection = ref({
      wheelDirection: 0
    });
    var onAfterClose = function onAfterClose2() {
      scale.value = 1;
      rotate.value = 0;
      setPosition(initialPosition);
      emit("afterClose");
    };
    var onZoomIn = function onZoomIn2() {
      scale.value++;
      setPosition(initialPosition);
    };
    var onZoomOut = function onZoomOut2() {
      if (scale.value > 1) {
        scale.value--;
      }
      setPosition(initialPosition);
    };
    var onRotateRight = function onRotateRight2() {
      rotate.value += 90;
    };
    var onRotateLeft = function onRotateLeft2() {
      rotate.value -= 90;
    };
    var onSwitchLeft = function onSwitchLeft2(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      if (currentPreviewIndex.value > 0) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
      }
    };
    var onSwitchRight = function onSwitchRight2(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      if (currentPreviewIndex.value < previewGroupCount.value - 1) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
      }
    };
    var wrapClassName = classNames(_defineProperty$U({}, "".concat(props3.prefixCls, "-moving"), isMoving.value));
    var toolClassName = "".concat(props3.prefixCls, "-operations-operation");
    var iconClassName = "".concat(props3.prefixCls, "-operations-icon");
    var tools = [{
      icon: close3,
      onClick: onClose,
      type: "close"
    }, {
      icon: zoomIn,
      onClick: onZoomIn,
      type: "zoomIn"
    }, {
      icon: zoomOut,
      onClick: onZoomOut,
      type: "zoomOut",
      disabled: computed(function() {
        return scale.value === 1;
      })
    }, {
      icon: rotateRight,
      onClick: onRotateRight,
      type: "rotateRight"
    }, {
      icon: rotateLeft,
      onClick: onRotateLeft,
      type: "rotateLeft"
    }];
    var onMouseUp2 = function onMouseUp3() {
      if (props3.visible && isMoving.value) {
        var width = imgRef.value.offsetWidth * scale.value;
        var height = imgRef.value.offsetHeight * scale.value;
        var _getOffset = getOffset(imgRef.value), _left = _getOffset.left, top = _getOffset.top;
        var isRotate = rotate.value % 180 !== 0;
        isMoving.value = false;
        var fixState = getFixScaleEleTransPosition(isRotate ? height : width, isRotate ? width : height, _left, top);
        if (fixState) {
          setPosition(_objectSpread2$1({}, fixState));
        }
      }
    };
    var onMouseDown2 = function onMouseDown3(event2) {
      if (event2.button !== 0)
        return;
      event2.preventDefault();
      event2.stopPropagation();
      originPositionRef.deltaX = event2.pageX - position.x;
      originPositionRef.deltaY = event2.pageY - position.y;
      originPositionRef.originX = position.x;
      originPositionRef.originY = position.y;
      isMoving.value = true;
    };
    var onMouseMove3 = function onMouseMove4(event2) {
      if (props3.visible && isMoving.value) {
        setPosition({
          x: event2.pageX - originPositionRef.deltaX,
          y: event2.pageY - originPositionRef.deltaY
        });
      }
    };
    var onWheelMove = function onWheelMove2(event2) {
      if (!props3.visible)
        return;
      event2.preventDefault();
      var wheelDirection = event2.deltaY;
      lastWheelZoomDirection.value = {
        wheelDirection
      };
    };
    var onKeyDown = function onKeyDown2(event2) {
      if (!props3.visible || !showLeftOrRightSwitches.value)
        return;
      event2.preventDefault();
      if (event2.keyCode === KeyCode$1.LEFT) {
        if (currentPreviewIndex.value > 0) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value - 1]);
        }
      } else if (event2.keyCode === KeyCode$1.RIGHT) {
        if (currentPreviewIndex.value < previewGroupCount.value - 1) {
          setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
        }
      }
    };
    var onDoubleClick = function onDoubleClick2() {
      if (props3.visible) {
        if (scale.value !== 1) {
          scale.value = 1;
        }
        if (position.x !== initialPosition.x || position.y !== initialPosition.y) {
          setPosition(initialPosition);
        }
      }
    };
    var removeListeners = function removeListeners2() {
    };
    onMounted(function() {
      watch([function() {
        return props3.visible;
      }, isMoving], function() {
        removeListeners();
        var onTopMouseUpListener;
        var onTopMouseMoveListener;
        var onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp2, false);
        var onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove3, false);
        var onScrollWheelListener = addEventListenerWrap(window, "wheel", onWheelMove, {
          passive: false
        });
        var onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown, false);
        try {
          if (window.top !== window.self) {
            onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp2, false);
            onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove3, false);
          }
        } catch (error) {
        }
        removeListeners = function removeListeners2() {
          onMouseUpListener.remove();
          onMouseMoveListener.remove();
          onScrollWheelListener.remove();
          onKeyDownListener.remove();
          if (onTopMouseUpListener)
            onTopMouseUpListener.remove();
          if (onTopMouseMoveListener)
            onTopMouseMoveListener.remove();
        };
      }, {
        flush: "post",
        immediate: true
      });
      watch([lastWheelZoomDirection], function() {
        var wheelDirection = lastWheelZoomDirection.value.wheelDirection;
        if (wheelDirection > 0) {
          onZoomOut();
        } else if (wheelDirection < 0) {
          onZoomIn();
        }
      });
    });
    onUnmounted(function() {
      removeListeners();
    });
    return function() {
      var visible = props3.visible, prefixCls = props3.prefixCls, rootClassName = props3.rootClassName;
      return createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "transitionName": "zoom",
        "maskTransitionName": "fade",
        "closable": false,
        "keyboard": true,
        "prefixCls": prefixCls,
        "onClose": onClose,
        "afterClose": onAfterClose,
        "visible": visible,
        "wrapClassName": wrapClassName,
        "rootClassName": rootClassName,
        "getContainer": props3.getContainer
      }), {
        default: function _default9() {
          return [createVNode("ul", {
            "class": "".concat(props3.prefixCls, "-operations")
          }, [tools.map(function(_ref2) {
            var IconType = _ref2.icon, onClick2 = _ref2.onClick, type4 = _ref2.type, disabled = _ref2.disabled;
            return createVNode("li", {
              "class": classNames(toolClassName, _defineProperty$U({}, "".concat(props3.prefixCls, "-operations-operation-disabled"), disabled && (disabled === null || disabled === void 0 ? void 0 : disabled.value))),
              "onClick": onClick2,
              "key": type4
            }, [cloneVNode(IconType, {
              class: iconClassName
            })]);
          })]), createVNode("div", {
            "class": "".concat(props3.prefixCls, "-img-wrapper"),
            "style": {
              transform: "translate3d(".concat(position.x, "px, ").concat(position.y, "px, 0)")
            }
          }, [createVNode("img", {
            "onMousedown": onMouseDown2,
            "onDblclick": onDoubleClick,
            "ref": imgRef,
            "class": "".concat(props3.prefixCls, "-img"),
            "src": combinationSrc.value,
            "alt": props3.alt,
            "style": {
              transform: "scale3d(".concat(scale.value, ", ").concat(scale.value, ", 1) rotate(").concat(rotate.value, "deg)")
            }
          }, null)]), showLeftOrRightSwitches.value && createVNode("div", {
            "class": classNames("".concat(props3.prefixCls, "-switch-left"), _defineProperty$U({}, "".concat(props3.prefixCls, "-switch-left-disabled"), currentPreviewIndex.value <= 0)),
            "onClick": onSwitchLeft
          }, [left]), showLeftOrRightSwitches.value && createVNode("div", {
            "class": classNames("".concat(props3.prefixCls, "-switch-right"), _defineProperty$U({}, "".concat(props3.prefixCls, "-switch-right-disabled"), currentPreviewIndex.value >= previewGroupCount.value - 1)),
            "onClick": onSwitchRight
          }, [right])];
        }
      });
    };
  }
});
const Preview$1 = Preview;
var _excluded$v = ["icons", "maskClassName", "src"];
var imageProps = function imageProps2() {
  return {
    src: String,
    wrapperClassName: String,
    wrapperStyle: {
      type: Object,
      default: void 0
    },
    rootClassName: String,
    prefixCls: String,
    previewPrefixCls: String,
    previewMask: {
      type: [Boolean, Function],
      default: void 0
    },
    placeholder: PropTypes$1.any,
    fallback: String,
    preview: {
      type: [Boolean, Object],
      default: true
    },
    onClick: {
      type: Function
    },
    onError: {
      type: Function
    }
  };
};
var mergeDefaultValue = function mergeDefaultValue2(obj, defaultValues) {
  var res = _objectSpread2$1({}, obj);
  Object.keys(defaultValues).forEach(function(key2) {
    if (obj[key2] === void 0) {
      res[key2] = defaultValues[key2];
    }
  });
  return res;
};
var uuid = 0;
var ImageInternal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Image",
  inheritAttrs: false,
  props: imageProps(),
  emits: ["click", "error"],
  setup: function setup124(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var prefixCls = computed(function() {
      return props3.prefixCls;
    });
    var previewPrefixCls = computed(function() {
      return "".concat(prefixCls.value, "-preview");
    });
    var preview = computed(function() {
      var defaultValues = {
        visible: void 0,
        onVisibleChange: function onVisibleChange() {
        },
        getContainer: void 0
      };
      return _typeof$3(props3.preview) === "object" ? mergeDefaultValue(props3.preview, defaultValues) : defaultValues;
    });
    var isCustomPlaceholder = computed(function() {
      return props3.placeholder && props3.placeholder !== true || slots.placeholder;
    });
    var previewVisible = computed(function() {
      return preview.value.visible;
    });
    var getPreviewContainer = computed(function() {
      return preview.value.getContainer;
    });
    var isControlled = computed(function() {
      return previewVisible.value !== void 0;
    });
    var onPreviewVisibleChange = function onPreviewVisibleChange2(val, preval) {
      var _preview$value$onVisi, _preview$value;
      (_preview$value$onVisi = (_preview$value = preview.value).onVisibleChange) === null || _preview$value$onVisi === void 0 ? void 0 : _preview$value$onVisi.call(_preview$value, val, preval);
    };
    var _useMergedState = useMergedState(!!previewVisible.value, {
      value: previewVisible,
      onChange: onPreviewVisibleChange
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview = _useMergedState2[1];
    watch(isShowPreview, function(val, preVal) {
      onPreviewVisibleChange(val, preVal);
    });
    var status = ref(isCustomPlaceholder.value ? "loading" : "normal");
    watch(function() {
      return props3.src;
    }, function() {
      status.value = isCustomPlaceholder.value ? "loading" : "normal";
    });
    var mousePosition2 = ref(null);
    var isError2 = computed(function() {
      return status.value === "error";
    });
    var groupContext = context.inject();
    var isPreviewGroup = groupContext.isPreviewGroup, setCurrent = groupContext.setCurrent, setGroupShowPreview = groupContext.setShowPreview, setGroupMousePosition = groupContext.setMousePosition, registerImage = groupContext.registerImage;
    var currentId = ref(uuid++);
    var canPreview = computed(function() {
      return props3.preview && !isError2.value;
    });
    var onLoad = function onLoad2() {
      status.value = "normal";
    };
    var onError = function onError2(e2) {
      status.value = "error";
      emit("error", e2);
    };
    var onPreview = function onPreview2(e2) {
      if (!isControlled.value) {
        var _getOffset = getOffset(e2.target), left = _getOffset.left, top = _getOffset.top;
        if (isPreviewGroup.value) {
          setCurrent(currentId.value);
          setGroupMousePosition({
            x: left,
            y: top
          });
        } else {
          mousePosition2.value = {
            x: left,
            y: top
          };
        }
      }
      if (isPreviewGroup.value) {
        setGroupShowPreview(true);
      } else {
        setShowPreview(true);
      }
      emit("click", e2);
    };
    var onPreviewClose = function onPreviewClose2() {
      setShowPreview(false);
      if (!isControlled.value) {
        mousePosition2.value = null;
      }
    };
    var img = ref(null);
    watch(function() {
      return img;
    }, function() {
      if (status.value !== "loading")
        return;
      if (img.value.complete && (img.value.naturalWidth || img.value.naturalHeight)) {
        onLoad();
      }
    });
    var unRegister = function unRegister2() {
    };
    onMounted(function() {
      watch([function() {
        return props3.src;
      }, canPreview], function() {
        unRegister();
        if (!isPreviewGroup.value) {
          return function() {
          };
        }
        unRegister = registerImage(currentId.value, props3.src, canPreview.value);
        if (!canPreview.value) {
          unRegister();
        }
      }, {
        flush: "post",
        immediate: true
      });
    });
    onUnmounted(function() {
      unRegister();
    });
    var toSizePx = function toSizePx2(l2) {
      if (isNumber$2(l2))
        return l2 + "px";
      return l2;
    };
    return function() {
      var prefixCls2 = props3.prefixCls, wrapperClassName = props3.wrapperClassName, fallback = props3.fallback, imgSrc = props3.src, placeholder = props3.placeholder, wrapperStyle2 = props3.wrapperStyle, rootClassName = props3.rootClassName;
      var width = attrs.width, height = attrs.height, crossorigin = attrs.crossorigin, decoding = attrs.decoding, alt = attrs.alt, sizes = attrs.sizes, srcset = attrs.srcset, usemap = attrs.usemap, cls = attrs.class, style2 = attrs.style;
      var _preview$value2 = preview.value, icons2 = _preview$value2.icons, maskClassName = _preview$value2.maskClassName, previewSrc = _preview$value2.src, dialogProps = _objectWithoutProperties$2(_preview$value2, _excluded$v);
      var wrappperClass = classNames(prefixCls2, wrapperClassName, rootClassName, _defineProperty$U({}, "".concat(prefixCls2, "-error"), isError2.value));
      var mergedSrc = isError2.value && fallback ? fallback : previewSrc !== null && previewSrc !== void 0 ? previewSrc : imgSrc;
      var imgCommonProps = {
        crossorigin,
        decoding,
        alt,
        sizes,
        srcset,
        usemap,
        class: classNames("".concat(prefixCls2, "-img"), _defineProperty$U({}, "".concat(prefixCls2, "-img-placeholder"), placeholder === true), cls),
        style: _objectSpread2$1({
          height
        }, style2)
      };
      return createVNode(Fragment, null, [createVNode("div", {
        "class": wrappperClass,
        "onClick": canPreview.value ? onPreview : function(e2) {
          emit("click", e2);
        },
        "style": _objectSpread2$1({
          width: toSizePx(width),
          height: toSizePx(height)
        }, wrapperStyle2)
      }, [createVNode("img", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, imgCommonProps), isError2.value && fallback ? {
        src: fallback
      } : {
        onLoad,
        onError,
        src: imgSrc
      }), {}, {
        "ref": img
      }), null), status.value === "loading" && createVNode("div", {
        "aria-hidden": "true",
        "class": "".concat(prefixCls2, "-placeholder")
      }, [placeholder || slots.placeholder && slots.placeholder()]), slots.previewMask && canPreview.value && createVNode("div", {
        "class": ["".concat(prefixCls2, "-mask"), maskClassName]
      }, [slots.previewMask()])]), !isPreviewGroup.value && canPreview.value && createVNode(Preview$1, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
        "aria-hidden": !isShowPreview.value,
        "visible": isShowPreview.value,
        "prefixCls": previewPrefixCls.value,
        "onClose": onPreviewClose,
        "mousePosition": mousePosition2.value,
        "src": mergedSrc,
        "alt": alt,
        "getContainer": getPreviewContainer.value,
        "icons": icons2,
        "rootClassName": rootClassName
      }), null)]);
    };
  }
});
ImageInternal.PreviewGroup = PreviewGroup$1;
const Image$3 = ImageInternal;
var RotateLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { "tag": "path", "attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, "name": "rotate-left", "theme": "outlined" };
const RotateLeftOutlinedSvg = RotateLeftOutlined$2;
function _objectSpread$s(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$s(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$s(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RotateLeftOutlined = function RotateLeftOutlined2(props3, context2) {
  var p2 = _objectSpread$s({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$s({}, p2, {
    "icon": RotateLeftOutlinedSvg
  }), null);
};
RotateLeftOutlined.displayName = "RotateLeftOutlined";
RotateLeftOutlined.inheritAttrs = false;
const RotateLeftOutlined$1 = RotateLeftOutlined;
var RotateRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { "tag": "path", "attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, "name": "rotate-right", "theme": "outlined" };
const RotateRightOutlinedSvg = RotateRightOutlined$2;
function _objectSpread$r(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$r(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$r(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var RotateRightOutlined = function RotateRightOutlined2(props3, context2) {
  var p2 = _objectSpread$r({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$r({}, p2, {
    "icon": RotateRightOutlinedSvg
  }), null);
};
RotateRightOutlined.displayName = "RotateRightOutlined";
RotateRightOutlined.inheritAttrs = false;
const RotateRightOutlined$1 = RotateRightOutlined;
var ZoomInOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-in", "theme": "outlined" };
const ZoomInOutlinedSvg = ZoomInOutlined$2;
function _objectSpread$q(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$q(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$q(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ZoomInOutlined = function ZoomInOutlined2(props3, context2) {
  var p2 = _objectSpread$q({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$q({}, p2, {
    "icon": ZoomInOutlinedSvg
  }), null);
};
ZoomInOutlined.displayName = "ZoomInOutlined";
ZoomInOutlined.inheritAttrs = false;
const ZoomInOutlined$1 = ZoomInOutlined;
var ZoomOutOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-out", "theme": "outlined" };
const ZoomOutOutlinedSvg = ZoomOutOutlined$2;
function _objectSpread$p(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$p(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$p(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ZoomOutOutlined = function ZoomOutOutlined2(props3, context2) {
  var p2 = _objectSpread$p({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$p({}, p2, {
    "icon": ZoomOutOutlinedSvg
  }), null);
};
ZoomOutOutlined.displayName = "ZoomOutOutlined";
ZoomOutOutlined.inheritAttrs = false;
const ZoomOutOutlined$1 = ZoomOutOutlined;
var icons = {
  rotateLeft: createVNode(RotateLeftOutlined$1, null, null),
  rotateRight: createVNode(RotateRightOutlined$1, null, null),
  zoomIn: createVNode(ZoomInOutlined$1, null, null),
  zoomOut: createVNode(ZoomOutOutlined$1, null, null),
  close: createVNode(CloseOutlined$1, null, null),
  left: createVNode(LeftOutlined$1, null, null),
  right: createVNode(RightOutlined$1, null, null)
};
var InternalPreviewGroup = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: false,
  props: {
    previewPrefixCls: String
  },
  setup: function setup125(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var _useConfigInject = useConfigInject("image", props3), getPrefixCls2 = _useConfigInject.getPrefixCls;
    var prefixCls = computed(function() {
      return getPrefixCls2("image-preview", props3.previewPrefixCls);
    });
    return function() {
      return createVNode(PreviewGroup$1, _objectSpread2$1(_objectSpread2$1({}, _objectSpread2$1(_objectSpread2$1({}, attrs), props3)), {}, {
        "icons": icons,
        "previewPrefixCls": prefixCls.value
      }), slots);
    };
  }
});
const PreviewGroup = InternalPreviewGroup;
var Image$1 = defineComponent({
  name: "AImage",
  inheritAttrs: false,
  props: imageProps(),
  setup: function setup126(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("image", props3), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, configProvider = _useConfigInject.configProvider;
    var mergedPreview = computed(function() {
      var preview = props3.preview;
      if (preview === false) {
        return preview;
      }
      var _preview = _typeof$3(preview) === "object" ? preview : {};
      return _objectSpread2$1(_objectSpread2$1({
        icons
      }, _preview), {}, {
        transitionName: getTransitionName$2(rootPrefixCls.value, "zoom", _preview.transitionName),
        maskTransitionName: getTransitionName$2(rootPrefixCls.value, "fade", _preview.maskTransitionName)
      });
    });
    return function() {
      var _configProvider$local;
      var imageLocale = ((_configProvider$local = configProvider.locale) === null || _configProvider$local === void 0 ? void 0 : _configProvider$local.Image) || defaultLocale.Image;
      var defaultPreviewMask = function defaultPreviewMask2() {
        return createVNode("div", {
          "class": "".concat(prefixCls.value, "-mask-info")
        }, [createVNode(EyeOutlined$1, null, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview]);
      };
      var _props$previewMask = props3.previewMask, previewMask = _props$previewMask === void 0 ? slots.previewMask || defaultPreviewMask : _props$previewMask;
      return createVNode(Image$3, _objectSpread2$1(_objectSpread2$1({}, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props3), {}, {
        prefixCls: prefixCls.value
      })), {}, {
        "preview": mergedPreview.value
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        previewMask: typeof previewMask === "function" ? previewMask : null
      }));
    };
  }
});
Image$1.PreviewGroup = PreviewGroup;
Image$1.install = function(app) {
  app.component(Image$1.name, Image$1);
  app.component(Image$1.PreviewGroup.name, Image$1.PreviewGroup);
  return app;
};
const Image$2 = Image$1;
var UpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
const UpOutlinedSvg = UpOutlined$2;
function _objectSpread$o(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$o(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$o(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var UpOutlined = function UpOutlined2(props3, context2) {
  var p2 = _objectSpread$o({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$o({}, p2, {
    "icon": UpOutlinedSvg
  }), null);
};
UpOutlined.displayName = "UpOutlined";
UpOutlined.inheritAttrs = false;
const UpOutlined$1 = UpOutlined;
function supportBigInt() {
  return typeof BigInt === "function";
}
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return /^\s*-?\d+(\.\d+)?\s*$/.test(num) || /^\s*-?\d+\.\s*$/.test(num) || /^\s*-?\.\d+\s*$/.test(num);
}
var NumberDecimal = /* @__PURE__ */ function() {
  function NumberDecimal2(value) {
    _classCallCheck(this, NumberDecimal2);
    _defineProperty$U(this, "origin", "");
    if (!value && value !== 0 || !String(value).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  _createClass(NumberDecimal2, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal2(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add2(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString3() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal2;
}();
var BigIntDecimal = /* @__PURE__ */ function() {
  function BigIntDecimal2(value) {
    _classCallCheck(this, BigIntDecimal2);
    _defineProperty$U(this, "origin", "");
    if (!value && value !== 0 || !String(value).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    if (value === "-") {
      this.nan = true;
      return;
    }
    var mergedValue = value;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  _createClass(BigIntDecimal2, [{
    key: "getMark",
    value: function getMark2() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone3 = new BigIntDecimal2(this.toString());
      clone3.negative = !clone3.negative;
      return clone3;
    }
  }, {
    key: "add",
    value: function add2(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value);
      }
      var offset3 = new BigIntDecimal2(value);
      if (offset3.isInvalidate()) {
        return this;
      }
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -maxDecimalLength), ".").concat(hydrateValueStr.slice(-maxDecimalLength)));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString3() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal2;
}();
function getMiniDecimal(value) {
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}
function toFixed(numStr, separatorStr, precision) {
  if (numStr === "") {
    return "";
  }
  var _trimNumber4 = trimNumber(numStr), negativeStr = _trimNumber4.negativeStr, integerStr = _trimNumber4.integerStr, decimalStr = _trimNumber4.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
const StepHandler = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: {
      type: Function
    }
  },
  slots: ["upNode", "downNode"],
  setup: function setup127(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var stepTimeoutRef = ref();
    var onStepMouseDown = function onStepMouseDown2(e2, up) {
      e2.preventDefault();
      emit("step", up);
      function loopStep() {
        emit("step", up);
        stepTimeoutRef.value = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.value = setTimeout(loopStep, STEP_DELAY);
    };
    var onStopStep = function onStopStep2() {
      clearTimeout(stepTimeoutRef.value);
    };
    onBeforeUnmount(function() {
      onStopStep();
    });
    return function() {
      if (isMobile$2()) {
        return null;
      }
      var prefixCls = props3.prefixCls, upDisabled = props3.upDisabled, downDisabled = props3.downDisabled;
      var handlerClassName = "".concat(prefixCls, "-handler");
      var upClassName = classNames(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$U({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
      var downClassName = classNames(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$U({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
      var sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseup: onStopStep,
        onMouseleave: onStopStep
      };
      var upNode = slots.upNode, downNode = slots.downNode;
      return createVNode("div", {
        "class": "".concat(handlerClassName, "-wrap")
      }, [createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": function onMousedown2(e2) {
          onStepMouseDown(e2, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        "class": upClassName
      }), [(upNode === null || upNode === void 0 ? void 0 : upNode()) || createVNode("span", {
        "unselectable": "on",
        "class": "".concat(prefixCls, "-handler-up-inner")
      }, null)]), createVNode("span", _objectSpread2$1(_objectSpread2$1({}, sharedHandlerProps), {}, {
        "onMousedown": function onMousedown2(e2) {
          onStepMouseDown(e2, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        "class": downClassName
      }), [(downNode === null || downNode === void 0 ? void 0 : downNode()) || createVNode("span", {
        "unselectable": "on",
        "class": "".concat(prefixCls, "-handler-down-inner")
      }, null)])]);
    };
  }
});
function useCursor(inputRef, focused) {
  var selectionRef = ref(null);
  function recordCursor() {
    try {
      var _inputRef$value = inputRef.value, start = _inputRef$value.selectionStart, end = _inputRef$value.selectionEnd, value = _inputRef$value.value;
      var beforeTxt = value.substring(0, start);
      var afterTxt = value.substring(end);
      selectionRef.value = {
        start,
        end,
        value,
        beforeTxt,
        afterTxt
      };
    } catch (e2) {
    }
  }
  function restoreCursor() {
    if (inputRef.value && selectionRef.value && focused.value) {
      try {
        var value = inputRef.value.value;
        var _selectionRef$value = selectionRef.value, beforeTxt = _selectionRef$value.beforeTxt, afterTxt = _selectionRef$value.afterTxt, start = _selectionRef$value.start;
        var startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.value.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          var beforeLastChar = beforeTxt[start - 1];
          var newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        inputRef.value.setSelectionRange(startPos, startPos);
      } catch (e2) {
        warning$3(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
      }
    }
  }
  return [recordCursor, restoreCursor];
}
const useFrame = function() {
  var idRef = ref(0);
  var cleanUp = function cleanUp2() {
    wrapperRaf.cancel(idRef.value);
  };
  onBeforeUnmount(function() {
    cleanUp();
  });
  return function(callback) {
    cleanUp();
    idRef.value = wrapperRaf(function() {
      callback();
    });
  };
};
var _excluded$u = ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"];
var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = function getDecimalIfValidate2(value) {
  var decimal = getMiniDecimal(value);
  return decimal.isInvalidate() ? null : decimal;
};
var inputNumberProps$1 = function inputNumberProps() {
  return {
    stringMode: {
      type: Boolean
    },
    defaultValue: {
      type: [String, Number]
    },
    value: {
      type: [String, Number]
    },
    prefixCls: {
      type: String
    },
    min: {
      type: [String, Number]
    },
    max: {
      type: [String, Number]
    },
    step: {
      type: [String, Number],
      default: 1
    },
    tabindex: {
      type: Number
    },
    controls: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    disabled: {
      type: Boolean
    },
    autofocus: {
      type: Boolean
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    parser: {
      type: Function
    },
    formatter: {
      type: Function
    },
    precision: {
      type: Number
    },
    decimalSeparator: {
      type: String
    },
    onInput: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onPressEnter: {
      type: Function
    },
    onStep: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    }
  };
};
const VcInputNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, inputNumberProps$1()), {}, {
    lazy: Boolean
  }),
  slots: ["upHandler", "downHandler"],
  setup: function setup128(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var inputRef = ref();
    var focus = ref(false);
    var userTypingRef = ref(false);
    var compositionRef = ref(false);
    var decimalValue = ref(getMiniDecimal(props3.value));
    function setUncontrolledDecimalValue(newDecimal) {
      if (props3.value === void 0) {
        decimalValue.value = newDecimal;
      }
    }
    var getPrecision2 = function getPrecision3(numStr, userTyping) {
      if (userTyping) {
        return void 0;
      }
      if (props3.precision >= 0) {
        return props3.precision;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props3.step));
    };
    var mergedParser = function mergedParser2(num) {
      var numStr = String(num);
      if (props3.parser) {
        return props3.parser(numStr);
      }
      var parsedStr = numStr;
      if (props3.decimalSeparator) {
        parsedStr = parsedStr.replace(props3.decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    };
    var inputValue = ref("");
    var mergedFormatter = function mergedFormatter2(number4, userTyping) {
      if (props3.formatter) {
        return props3.formatter(number4, {
          userTyping,
          input: String(inputValue.value)
        });
      }
      var str = typeof number4 === "number" ? num2str(number4) : number4;
      if (!userTyping) {
        var mergedPrecision = getPrecision2(str, userTyping);
        if (validateNumber(str) && (props3.decimalSeparator || mergedPrecision >= 0)) {
          var separatorStr = props3.decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    };
    var initValue = function() {
      var initValue2 = props3.value;
      if (decimalValue.value.isInvalidate() && ["string", "number"].includes(_typeof$3(initValue2))) {
        return Number.isNaN(initValue2) ? "" : initValue2;
      }
      return mergedFormatter(decimalValue.value.toString(), false);
    }();
    inputValue.value = initValue;
    function setInputValue(newValue, userTyping) {
      inputValue.value = mergedFormatter(
        newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
        userTyping
      );
    }
    var maxDecimal = computed(function() {
      return getDecimalIfValidate(props3.max);
    });
    var minDecimal = computed(function() {
      return getDecimalIfValidate(props3.min);
    });
    var upDisabled = computed(function() {
      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return maxDecimal.value.lessEquals(decimalValue.value);
    });
    var downDisabled = computed(function() {
      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {
        return false;
      }
      return decimalValue.value.lessEquals(minDecimal.value);
    });
    var _useCursor = useCursor(inputRef, focus), _useCursor2 = _slicedToArray$2(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
    var getRangeValue = function getRangeValue2(target) {
      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {
        return maxDecimal.value;
      }
      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {
        return minDecimal.value;
      }
      return null;
    };
    var isInRange2 = function isInRange3(target) {
      return !getRangeValue(target);
    };
    var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
      var updateValue = newValue;
      var isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!props3.readonly && !props3.disabled && isRangeValidate) {
        var numStr = updateValue.toString();
        var mergedPrecision = getPrecision2(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
        }
        if (!updateValue.equals(decimalValue.value)) {
          var _props$onChange;
          setUncontrolledDecimalValue(updateValue);
          (_props$onChange = props3.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props3, updateValue.isEmpty() ? null : getDecimalValue(props3.stringMode, updateValue));
          if (props3.value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue.value;
    };
    var onNextPromise = useFrame();
    var collectInputValue = function collectInputValue2(inputStr) {
      var _props$onInput;
      recordCursor();
      inputValue.value = inputStr;
      if (!compositionRef.value) {
        var finalValue = mergedParser(inputStr);
        var finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      (_props$onInput = props3.onInput) === null || _props$onInput === void 0 ? void 0 : _props$onInput.call(props3, inputStr);
      onNextPromise(function() {
        var nextInputStr = inputStr;
        if (!props3.parser) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue2(nextInputStr);
        }
      });
    };
    var onCompositionStart2 = function onCompositionStart3() {
      compositionRef.value = true;
    };
    var onCompositionEnd2 = function onCompositionEnd3() {
      compositionRef.value = false;
      collectInputValue(inputRef.value.value);
    };
    var onInternalInput = function onInternalInput2(e2) {
      collectInputValue(e2.target.value);
    };
    var onInternalStep = function onInternalStep2(up) {
      var _props$onStep, _inputRef$value;
      if (up && upDisabled.value || !up && downDisabled.value) {
        return;
      }
      userTypingRef.value = false;
      var stepDecimal = getMiniDecimal(props3.step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());
      var updatedValue = triggerValueUpdate(target, false);
      (_props$onStep = props3.onStep) === null || _props$onStep === void 0 ? void 0 : _props$onStep.call(props3, getDecimalValue(props3.stringMode, updatedValue), {
        offset: props3.step,
        type: up ? "up" : "down"
      });
      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();
    };
    var flushInputValue = function flushInputValue2(userTyping) {
      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));
      var formatValue2 = parsedValue;
      if (!parsedValue.isNaN()) {
        formatValue2 = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue2 = decimalValue.value;
      }
      if (props3.value !== void 0) {
        setInputValue(decimalValue.value, false);
      } else if (!formatValue2.isNaN()) {
        setInputValue(formatValue2, false);
      }
    };
    var onKeyDown = function onKeyDown2(event2) {
      var which = event2.which;
      userTypingRef.value = true;
      if (which === KeyCode$1.ENTER) {
        var _props$onPressEnter;
        if (!compositionRef.value) {
          userTypingRef.value = false;
        }
        flushInputValue(false);
        (_props$onPressEnter = props3.onPressEnter) === null || _props$onPressEnter === void 0 ? void 0 : _props$onPressEnter.call(props3, event2);
      }
      if (props3.keyboard === false) {
        return;
      }
      if (!compositionRef.value && [KeyCode$1.UP, KeyCode$1.DOWN].includes(which)) {
        onInternalStep(KeyCode$1.UP === which);
        event2.preventDefault();
      }
    };
    var onKeyUp = function onKeyUp2() {
      userTypingRef.value = false;
    };
    var onBlur2 = function onBlur3(e2) {
      flushInputValue(false);
      focus.value = false;
      userTypingRef.value = false;
      emit("blur", e2);
    };
    watch(function() {
      return props3.precision;
    }, function() {
      if (!decimalValue.value.isInvalidate()) {
        setInputValue(decimalValue.value, false);
      }
    }, {
      flush: "post"
    });
    watch(function() {
      return props3.value;
    }, function() {
      var newValue = getMiniDecimal(props3.value);
      decimalValue.value = newValue;
      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props3.formatter) {
        setInputValue(newValue, userTypingRef.value);
      }
    }, {
      flush: "post"
    });
    watch(inputValue, function() {
      if (props3.formatter) {
        restoreCursor();
      }
    }, {
      flush: "post"
    });
    watch(function() {
      return props3.disabled;
    }, function(val) {
      if (val) {
        focus.value = false;
      }
    });
    expose({
      focus: function focus2() {
        var _inputRef$value2;
        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.focus();
      },
      blur: function blur() {
        var _inputRef$value3;
        (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.blur();
      }
    });
    return function() {
      var _classNames;
      var _attrs$props = _objectSpread2$1(_objectSpread2$1({}, attrs), props3), _attrs$props$prefixCl = _attrs$props.prefixCls, prefixCls = _attrs$props$prefixCl === void 0 ? "rc-input-number" : _attrs$props$prefixCl, min3 = _attrs$props.min, max3 = _attrs$props.max, _attrs$props$step = _attrs$props.step, step = _attrs$props$step === void 0 ? 1 : _attrs$props$step;
      _attrs$props.defaultValue;
      _attrs$props.value;
      var disabled = _attrs$props.disabled, readonly2 = _attrs$props.readonly;
      _attrs$props.keyboard;
      var _attrs$props$controls = _attrs$props.controls, controls = _attrs$props$controls === void 0 ? true : _attrs$props$controls, autofocus = _attrs$props.autofocus;
      _attrs$props.stringMode;
      _attrs$props.parser;
      _attrs$props.formatter;
      _attrs$props.precision;
      _attrs$props.decimalSeparator;
      _attrs$props.onChange;
      _attrs$props.onInput;
      _attrs$props.onPressEnter;
      _attrs$props.onStep;
      var lazy = _attrs$props.lazy, className = _attrs$props.class, style2 = _attrs$props.style, inputProps3 = _objectWithoutProperties$2(_attrs$props, _excluded$u);
      var upHandler = slots.upHandler, downHandler = slots.downHandler;
      var inputClassName = "".concat(prefixCls, "-input");
      var eventProps = {};
      if (lazy) {
        eventProps.onChange = onInternalInput;
      } else {
        eventProps.onInput = onInternalInput;
      }
      return createVNode("div", {
        "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-focused"), focus.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls, "-readonly"), readonly2), _defineProperty$U(_classNames, "".concat(prefixCls, "-not-a-number"), decimalValue.value.isNaN()), _defineProperty$U(_classNames, "".concat(prefixCls, "-out-of-range"), !decimalValue.value.isInvalidate() && !isInRange2(decimalValue.value)), _classNames)),
        "style": style2,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp
      }, [controls && createVNode(StepHandler, {
        "prefixCls": prefixCls,
        "upDisabled": upDisabled.value,
        "downDisabled": downDisabled.value,
        "onStep": onInternalStep
      }, {
        upNode: upHandler,
        downNode: downHandler
      }), createVNode("div", {
        "class": "".concat(inputClassName, "-wrap")
      }, [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "autofocus": autofocus,
        "autocomplete": "off",
        "role": "spinbutton",
        "aria-valuemin": min3,
        "aria-valuemax": max3,
        "aria-valuenow": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),
        "step": step
      }, inputProps3), {}, {
        "ref": inputRef,
        "class": inputClassName,
        "value": inputValue.value,
        "disabled": disabled,
        "readonly": readonly2,
        "onFocus": function onFocus2(e2) {
          focus.value = true;
          emit("focus", e2);
        }
      }, eventProps), {}, {
        "onBlur": onBlur2,
        "onCompositionstart": onCompositionStart2,
        "onCompositionend": onCompositionEnd2
      }), null)])]);
    };
  }
});
function isValidValue(val) {
  return val !== void 0 && val !== null;
}
var _excluded$t = ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"];
var baseProps$1 = inputNumberProps$1();
var inputNumberProps2 = function inputNumberProps3() {
  return _objectSpread2$1(_objectSpread2$1({}, baseProps$1), {}, {
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: true
    },
    placeholder: String,
    name: String,
    id: String,
    type: String,
    addonBefore: PropTypes$1.any,
    addonAfter: PropTypes$1.any,
    prefix: PropTypes$1.any,
    "onUpdate:value": baseProps$1.onChange,
    valueModifiers: Object
  });
};
var InputNumber = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: false,
  props: inputNumberProps2(),
  slots: ["addonBefore", "addonAfter", "prefix"],
  setup: function setup129(props3, _ref) {
    var emit = _ref.emit, expose = _ref.expose, attrs = _ref.attrs, slots = _ref.slots;
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("input-number", props3), prefixCls = _useConfigInject.prefixCls, size2 = _useConfigInject.size, direction = _useConfigInject.direction;
    var mergedValue = ref(props3.value === void 0 ? props3.defaultValue : props3.value);
    var focused = ref(false);
    watch(function() {
      return props3.value;
    }, function() {
      mergedValue.value = props3.value;
    });
    var inputNumberRef = ref(null);
    var focus = function focus2() {
      var _inputNumberRef$value;
      (_inputNumberRef$value = inputNumberRef.value) === null || _inputNumberRef$value === void 0 ? void 0 : _inputNumberRef$value.focus();
    };
    var blur = function blur2() {
      var _inputNumberRef$value2;
      (_inputNumberRef$value2 = inputNumberRef.value) === null || _inputNumberRef$value2 === void 0 ? void 0 : _inputNumberRef$value2.blur();
    };
    expose({
      focus,
      blur
    });
    var handleChange2 = function handleChange3(val) {
      if (props3.value === void 0) {
        mergedValue.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      focused.value = false;
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    var handleFocus = function handleFocus2(e2) {
      focused.value = true;
      emit("focus", e2);
    };
    return function() {
      var _slots$addonBefore, _slots$addonAfter, _slots$prefix, _classNames;
      var _attrs$props = _objectSpread2$1(_objectSpread2$1({}, attrs), props3), className = _attrs$props.class, bordered = _attrs$props.bordered, readonly2 = _attrs$props.readonly, style2 = _attrs$props.style, _attrs$props$addonBef = _attrs$props.addonBefore, addonBefore = _attrs$props$addonBef === void 0 ? (_slots$addonBefore = slots.addonBefore) === null || _slots$addonBefore === void 0 ? void 0 : _slots$addonBefore.call(slots) : _attrs$props$addonBef, _attrs$props$addonAft = _attrs$props.addonAfter, addonAfter = _attrs$props$addonAft === void 0 ? (_slots$addonAfter = slots.addonAfter) === null || _slots$addonAfter === void 0 ? void 0 : _slots$addonAfter.call(slots) : _attrs$props$addonAft, _attrs$props$prefix = _attrs$props.prefix, prefix = _attrs$props$prefix === void 0 ? (_slots$prefix = slots.prefix) === null || _slots$prefix === void 0 ? void 0 : _slots$prefix.call(slots) : _attrs$props$prefix, _attrs$props$valueMod = _attrs$props.valueModifiers, valueModifiers = _attrs$props$valueMod === void 0 ? {} : _attrs$props$valueMod, others = _objectWithoutProperties$2(_attrs$props, _excluded$t);
      var preCls = prefixCls.value;
      var mergeSize = size2.value;
      var inputNumberClass = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(preCls, "-lg"), mergeSize === "large"), _defineProperty$U(_classNames, "".concat(preCls, "-sm"), mergeSize === "small"), _defineProperty$U(_classNames, "".concat(preCls, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(preCls, "-readonly"), readonly2), _defineProperty$U(_classNames, "".concat(preCls, "-borderless"), !bordered), _classNames), className);
      var element = createVNode(VcInputNumber, _objectSpread2$1(_objectSpread2$1({}, omit$2(others, ["size", "defaultValue"])), {}, {
        "ref": inputNumberRef,
        "lazy": !!valueModifiers.lazy,
        "value": mergedValue.value,
        "class": inputNumberClass,
        "prefixCls": preCls,
        "readonly": readonly2,
        "onChange": handleChange2,
        "onBlur": handleBlur,
        "onFocus": handleFocus
      }), {
        upHandler: function upHandler() {
          return createVNode(UpOutlined$1, {
            "class": "".concat(preCls, "-handler-up-inner")
          }, null);
        },
        downHandler: function downHandler() {
          return createVNode(DownOutlined$1, {
            "class": "".concat(preCls, "-handler-down-inner")
          }, null);
        }
      });
      var hasAddon2 = isValidValue(addonBefore) || isValidValue(addonAfter);
      if (isValidValue(prefix)) {
        var _classNames2;
        var affixWrapperCls = classNames("".concat(preCls, "-affix-wrapper"), (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(preCls, "-affix-wrapper-focused"), focused.value), _defineProperty$U(_classNames2, "".concat(preCls, "-affix-wrapper-disabled"), props3.disabled), _defineProperty$U(_classNames2, "".concat(preCls, "-affix-wrapper-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames2, "".concat(preCls, "-affix-wrapper-readonly"), readonly2), _defineProperty$U(_classNames2, "".concat(preCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$U(_classNames2, "".concat(className), !hasAddon2 && className), _classNames2));
        element = createVNode("div", {
          "class": affixWrapperCls,
          "style": style2,
          "onMouseup": function onMouseup() {
            return inputNumberRef.value.focus();
          }
        }, [createVNode("span", {
          "class": "".concat(preCls, "-prefix")
        }, [prefix]), element]);
      }
      if (hasAddon2) {
        var _classNames4;
        var wrapperClassName = "".concat(preCls, "-group");
        var addonClassName = "".concat(wrapperClassName, "-addon");
        var addonBeforeNode = addonBefore ? createVNode("div", {
          "class": addonClassName
        }, [addonBefore]) : null;
        var addonAfterNode = addonAfter ? createVNode("div", {
          "class": addonClassName
        }, [addonAfter]) : null;
        var mergedWrapperClassName = classNames("".concat(preCls, "-wrapper"), wrapperClassName, _defineProperty$U({}, "".concat(wrapperClassName, "-rtl"), direction.value === "rtl"));
        var mergedGroupClassName = classNames("".concat(preCls, "-group-wrapper"), (_classNames4 = {}, _defineProperty$U(_classNames4, "".concat(preCls, "-group-wrapper-sm"), mergeSize === "small"), _defineProperty$U(_classNames4, "".concat(preCls, "-group-wrapper-lg"), mergeSize === "large"), _defineProperty$U(_classNames4, "".concat(preCls, "-group-wrapper-rtl"), direction.value === "rtl"), _classNames4), className);
        element = createVNode("div", {
          "class": mergedGroupClassName,
          "style": style2
        }, [createVNode("div", {
          "class": mergedWrapperClassName
        }, [addonBeforeNode, element, addonAfterNode])]);
      }
      return cloneElement(element, {
        style: style2
      });
    };
  }
});
const index$e = _extends$1(InputNumber, {
  install: function install3(app) {
    app.component(InputNumber.name, InputNumber);
    return app;
  }
});
var basicProps = function basicProps2() {
  return {
    prefixCls: String,
    hasSider: {
      type: Boolean,
      default: void 0
    },
    tagName: String
  };
};
function generator(_ref) {
  var suffixCls = _ref.suffixCls, tagName = _ref.tagName, name2 = _ref.name;
  return function(BasicComponent) {
    var Adapter = defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: name2,
      props: basicProps(),
      setup: function setup219(props3, _ref2) {
        var slots = _ref2.slots;
        var _useConfigInject = useConfigInject(suffixCls, props3), prefixCls = _useConfigInject.prefixCls;
        return function() {
          var basicComponentProps = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
            prefixCls: prefixCls.value,
            tagName
          });
          return createVNode(BasicComponent, basicComponentProps, slots);
        };
      }
    });
    return Adapter;
  };
}
var Basic = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: basicProps(),
  setup: function setup130(props3, _ref3) {
    var slots = _ref3.slots;
    return function() {
      return createVNode(props3.tagName, {
        class: props3.prefixCls
      }, slots);
    };
  }
});
var BasicLayout = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: basicProps(),
  setup: function setup131(props3, _ref4) {
    var slots = _ref4.slots;
    var _useConfigInject2 = useConfigInject("", props3), direction = _useConfigInject2.direction;
    var siders = ref([]);
    var siderHookProvider = {
      addSider: function addSider(id) {
        siders.value = [].concat(_toConsumableArray(siders.value), [id]);
      },
      removeSider: function removeSider(id) {
        siders.value = siders.value.filter(function(currentId) {
          return currentId !== id;
        });
      }
    };
    provide(SiderHookProviderKey, siderHookProvider);
    var divCls = computed(function() {
      var _ref5;
      var prefixCls = props3.prefixCls, hasSider = props3.hasSider;
      return _ref5 = {}, _defineProperty$U(_ref5, "".concat(prefixCls), true), _defineProperty$U(_ref5, "".concat(prefixCls, "-has-sider"), typeof hasSider === "boolean" ? hasSider : siders.value.length > 0), _defineProperty$U(_ref5, "".concat(prefixCls, "-rtl"), direction.value === "rtl"), _ref5;
    });
    return function() {
      var tagName = props3.tagName;
      return createVNode(tagName, {
        class: divCls.value
      }, slots);
    };
  }
});
var Layout = generator({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(BasicLayout);
var Header$2 = generator({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(Basic);
var Footer$2 = generator({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(Basic);
var Content = generator({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(Basic);
const Layout$1 = Layout;
var BarsOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
const BarsOutlinedSvg = BarsOutlined$2;
function _objectSpread$n(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$n(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$n(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var BarsOutlined = function BarsOutlined2(props3, context2) {
  var p2 = _objectSpread$n({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$n({}, p2, {
    "icon": BarsOutlinedSvg
  }), null);
};
BarsOutlined.displayName = "BarsOutlined";
BarsOutlined.inheritAttrs = false;
const BarsOutlined$1 = BarsOutlined;
var dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
};
var siderProps = function siderProps2() {
  return {
    prefixCls: String,
    collapsible: {
      type: Boolean,
      default: void 0
    },
    collapsed: {
      type: Boolean,
      default: void 0
    },
    defaultCollapsed: {
      type: Boolean,
      default: void 0
    },
    reverseArrow: {
      type: Boolean,
      default: void 0
    },
    zeroWidthTriggerStyle: {
      type: Object,
      default: void 0
    },
    trigger: PropTypes$1.any,
    width: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    collapsedWidth: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    breakpoint: PropTypes$1.oneOf(tuple$1("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
    theme: PropTypes$1.oneOf(tuple$1("light", "dark")).def("dark"),
    onBreakpoint: Function,
    onCollapse: Function
  };
};
var generateId = function() {
  var i2 = 0;
  return function() {
    var prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    i2 += 1;
    return "".concat(prefix).concat(i2);
  };
}();
const Sider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ALayoutSider",
  inheritAttrs: false,
  props: initDefaultProps$1(siderProps(), {
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup: function setup132(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots;
    var _useConfigInject = useConfigInject("layout-sider", props3), prefixCls = _useConfigInject.prefixCls;
    var siderHook = inject(SiderHookProviderKey, void 0);
    var collapsed = ref(!!(props3.collapsed !== void 0 ? props3.collapsed : props3.defaultCollapsed));
    var below = ref(false);
    watch(function() {
      return props3.collapsed;
    }, function() {
      collapsed.value = !!props3.collapsed;
    });
    provide(SiderCollapsedKey, collapsed);
    var handleSetCollapsed = function handleSetCollapsed2(value, type4) {
      if (props3.collapsed === void 0) {
        collapsed.value = value;
      }
      emit("update:collapsed", value);
      emit("collapse", value, type4);
    };
    var responsiveHandlerRef = ref(function(mql2) {
      below.value = mql2.matches;
      emit("breakpoint", mql2.matches);
      if (collapsed.value !== mql2.matches) {
        handleSetCollapsed(mql2.matches, "responsive");
      }
    });
    var mql;
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.value(mql2);
    }
    var uniqueId = generateId("ant-sider-");
    siderHook && siderHook.addSider(uniqueId);
    onMounted(function() {
      watch(function() {
        return props3.breakpoint;
      }, function() {
        try {
          var _mql;
          (_mql = mql) === null || _mql === void 0 ? void 0 : _mql.removeEventListener("change", responsiveHandler);
        } catch (error) {
          var _mql2;
          (_mql2 = mql) === null || _mql2 === void 0 ? void 0 : _mql2.removeListener(responsiveHandler);
        }
        if (typeof window !== "undefined") {
          var _window2 = window, matchMedia = _window2.matchMedia;
          if (matchMedia && props3.breakpoint && props3.breakpoint in dimensionMaxMap) {
            mql = matchMedia("(max-width: ".concat(dimensionMaxMap[props3.breakpoint], ")"));
            try {
              mql.addEventListener("change", responsiveHandler);
            } catch (error) {
              mql.addListener(responsiveHandler);
            }
            responsiveHandler(mql);
          }
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(function() {
      try {
        var _mql3;
        (_mql3 = mql) === null || _mql3 === void 0 ? void 0 : _mql3.removeEventListener("change", responsiveHandler);
      } catch (error) {
        var _mql4;
        (_mql4 = mql) === null || _mql4 === void 0 ? void 0 : _mql4.removeListener(responsiveHandler);
      }
      siderHook && siderHook.removeSider(uniqueId);
    });
    var toggle = function toggle2() {
      handleSetCollapsed(!collapsed.value, "clickTrigger");
    };
    return function() {
      var _slots$trigger, _classNames, _slots$default;
      var pre = prefixCls.value;
      var collapsedWidth = props3.collapsedWidth, width = props3.width, reverseArrow = props3.reverseArrow, zeroWidthTriggerStyle = props3.zeroWidthTriggerStyle, _props$trigger = props3.trigger, trigger2 = _props$trigger === void 0 ? (_slots$trigger = slots.trigger) === null || _slots$trigger === void 0 ? void 0 : _slots$trigger.call(slots) : _props$trigger, collapsible = props3.collapsible, theme2 = props3.theme;
      var rawWidth = collapsed.value ? collapsedWidth : width;
      var siderWidth = isNumeric$2(rawWidth) ? "".concat(rawWidth, "px") : String(rawWidth);
      var zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? createVNode("span", {
        "onClick": toggle,
        "class": classNames("".concat(pre, "-zero-width-trigger"), "".concat(pre, "-zero-width-trigger-").concat(reverseArrow ? "right" : "left")),
        "style": zeroWidthTriggerStyle
      }, [trigger2 || createVNode(BarsOutlined$1, null, null)]) : null;
      var iconObj = {
        expanded: reverseArrow ? createVNode(RightOutlined$1, null, null) : createVNode(LeftOutlined$1, null, null),
        collapsed: reverseArrow ? createVNode(LeftOutlined$1, null, null) : createVNode(RightOutlined$1, null, null)
      };
      var status = collapsed.value ? "collapsed" : "expanded";
      var defaultTrigger = iconObj[status];
      var triggerDom = trigger2 !== null ? zeroWidthTrigger || createVNode("div", {
        "class": "".concat(pre, "-trigger"),
        "onClick": toggle,
        "style": {
          width: siderWidth
        }
      }, [trigger2 || defaultTrigger]) : null;
      var divStyle = [attrs.style, {
        flex: "0 0 ".concat(siderWidth),
        maxWidth: siderWidth,
        minWidth: siderWidth,
        width: siderWidth
      }];
      var siderCls = classNames(pre, "".concat(pre, "-").concat(theme2), (_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-collapsed"), !!collapsed.value), _defineProperty$U(_classNames, "".concat(pre, "-has-trigger"), collapsible && trigger2 !== null && !zeroWidthTrigger), _defineProperty$U(_classNames, "".concat(pre, "-below"), !!below.value), _defineProperty$U(_classNames, "".concat(pre, "-zero-width"), parseFloat(siderWidth) === 0), _classNames), attrs.class);
      return createVNode("aside", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "class": siderCls,
        "style": divStyle
      }), [createVNode("div", {
        "class": "".concat(pre, "-children")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), collapsible || below.value && zeroWidthTrigger ? triggerDom : null]);
    };
  }
});
var LayoutHeader = Header$2;
var LayoutFooter = Footer$2;
var LayoutSider = Sider;
var LayoutContent = Content;
const index$d = _extends$1(Layout$1, {
  Header: Header$2,
  Footer: Footer$2,
  Content,
  Sider,
  install: function install4(app) {
    app.component(Layout$1.name, Layout$1);
    app.component(Header$2.name, Header$2);
    app.component(Footer$2.name, Footer$2);
    app.component(Sider.name, Sider);
    app.component(Content.name, Content);
    return app;
  }
});
var _excluded$s = ["class", "style"];
var spinProps = function spinProps2() {
  return {
    prefixCls: String,
    spinning: {
      type: Boolean,
      default: void 0
    },
    size: String,
    wrapperClassName: String,
    tip: PropTypes$1.any,
    delay: Number,
    indicator: PropTypes$1.any
  };
};
var defaultIndicator = null;
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
function setDefaultIndicator(Content2) {
  var Indicator = Content2.indicator;
  defaultIndicator = typeof Indicator === "function" ? Indicator : function() {
    return createVNode(Indicator, null, null);
  };
}
const Spin = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: false,
  props: initDefaultProps$1(spinProps(), {
    size: "default",
    spinning: true,
    wrapperClassName: ""
  }),
  setup: function setup133() {
    return {
      originalUpdateSpinning: null,
      configProvider: inject("configProvider", defaultConfigProvider)
    };
  },
  data: function data4() {
    var spinning = this.spinning, delay = this.delay;
    var shouldBeDelayed = shouldDelay(spinning, delay);
    return {
      sSpinning: spinning && !shouldBeDelayed
    };
  },
  created: function created3() {
    this.originalUpdateSpinning = this.updateSpinning;
    this.debouncifyUpdateSpinning(this.$props);
  },
  mounted: function mounted5() {
    this.updateSpinning();
  },
  updated: function updated3() {
    var _this = this;
    nextTick(function() {
      _this.debouncifyUpdateSpinning();
      _this.updateSpinning();
    });
  },
  beforeUnmount: function beforeUnmount5() {
    this.cancelExistingSpin();
  },
  methods: {
    debouncifyUpdateSpinning: function debouncifyUpdateSpinning(props3) {
      var _ref = props3 || this.$props, delay = _ref.delay;
      if (delay) {
        this.cancelExistingSpin();
        this.updateSpinning = debounce(this.originalUpdateSpinning, delay);
      }
    },
    updateSpinning: function updateSpinning() {
      var spinning = this.spinning, sSpinning = this.sSpinning;
      if (sSpinning !== spinning) {
        this.sSpinning = spinning;
      }
    },
    cancelExistingSpin: function cancelExistingSpin() {
      var updateSpinning2 = this.updateSpinning;
      if (updateSpinning2 && updateSpinning2.cancel) {
        updateSpinning2.cancel();
      }
    },
    renderIndicator: function renderIndicator(prefixCls) {
      var dotClassName = "".concat(prefixCls, "-dot");
      var indicator = getComponent(this, "indicator");
      if (indicator === null) {
        return null;
      }
      if (Array.isArray(indicator)) {
        indicator = indicator.length === 1 ? indicator[0] : indicator;
      }
      if (isVNode(indicator)) {
        return cloneVNode(indicator, {
          class: dotClassName
        });
      }
      if (defaultIndicator && isVNode(defaultIndicator())) {
        return cloneVNode(defaultIndicator(), {
          class: dotClassName
        });
      }
      return createVNode("span", {
        "class": "".concat(dotClassName, " ").concat(prefixCls, "-dot-spin")
      }, [createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null), createVNode("i", {
        "class": "".concat(prefixCls, "-dot-item")
      }, null)]);
    }
  },
  render: function render6() {
    var _this$$slots$tip, _this$$slots, _spinClassName;
    var _this$$props = this.$props, size2 = _this$$props.size, customizePrefixCls = _this$$props.prefixCls, _this$$props$tip = _this$$props.tip, tip = _this$$props$tip === void 0 ? (_this$$slots$tip = (_this$$slots = this.$slots).tip) === null || _this$$slots$tip === void 0 ? void 0 : _this$$slots$tip.call(_this$$slots) : _this$$props$tip, wrapperClassName = _this$$props.wrapperClassName;
    var _this$$attrs = this.$attrs, cls = _this$$attrs.class, style2 = _this$$attrs.style, divProps = _objectWithoutProperties$2(_this$$attrs, _excluded$s);
    var _this$configProvider = this.configProvider, getPrefixCls2 = _this$configProvider.getPrefixCls, direction = _this$configProvider.direction;
    var prefixCls = getPrefixCls2("spin", customizePrefixCls);
    var sSpinning = this.sSpinning;
    var spinClassName = (_spinClassName = {}, _defineProperty$U(_spinClassName, prefixCls, true), _defineProperty$U(_spinClassName, "".concat(prefixCls, "-sm"), size2 === "small"), _defineProperty$U(_spinClassName, "".concat(prefixCls, "-lg"), size2 === "large"), _defineProperty$U(_spinClassName, "".concat(prefixCls, "-spinning"), sSpinning), _defineProperty$U(_spinClassName, "".concat(prefixCls, "-show-text"), !!tip), _defineProperty$U(_spinClassName, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$U(_spinClassName, cls, !!cls), _spinClassName);
    var spinElement = createVNode("div", _objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
      "style": style2,
      "class": spinClassName
    }), [this.renderIndicator(prefixCls), tip ? createVNode("div", {
      "class": "".concat(prefixCls, "-text")
    }, [tip]) : null]);
    var children = getSlot(this);
    if (children && children.length) {
      var _containerClassName;
      var containerClassName = (_containerClassName = {}, _defineProperty$U(_containerClassName, "".concat(prefixCls, "-container"), true), _defineProperty$U(_containerClassName, "".concat(prefixCls, "-blur"), sSpinning), _containerClassName);
      return createVNode("div", {
        "class": ["".concat(prefixCls, "-nested-loading"), wrapperClassName]
      }, [sSpinning && createVNode("div", {
        "key": "loading"
      }, [spinElement]), createVNode("div", {
        "class": containerClassName,
        "key": "container"
      }, [children])]);
    }
    return spinElement;
  }
});
Spin.setDefaultIndicator = setDefaultIndicator;
Spin.install = function(app) {
  app.component(Spin.name, Spin);
  return app;
};
var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
function _objectSpread$m(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$m(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$m(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleLeftOutlined = function DoubleLeftOutlined2(props3, context2) {
  var p2 = _objectSpread$m({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$m({}, p2, {
    "icon": DoubleLeftOutlinedSvg
  }), null);
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
DoubleLeftOutlined.inheritAttrs = false;
const DoubleLeftOutlined$1 = DoubleLeftOutlined;
var DoubleRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
const DoubleRightOutlinedSvg = DoubleRightOutlined$2;
function _objectSpread$l(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$l(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$l(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DoubleRightOutlined = function DoubleRightOutlined2(props3, context2) {
  var p2 = _objectSpread$l({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$l({}, p2, {
    "icon": DoubleRightOutlinedSvg
  }), null);
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
DoubleRightOutlined.inheritAttrs = false;
const DoubleRightOutlined$1 = DoubleRightOutlined;
const MiniSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: false,
  props: selectProps(),
  Option: VcSelect.Option,
  setup: function setup134(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    return function() {
      var selelctProps = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        size: "small"
      }, attrs);
      return createVNode(VcSelect, selelctProps, slots);
    };
  }
});
const Pager = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: false,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: function _default5() {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup: function setup135(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs;
    var handleClick2 = function handleClick3() {
      emit("click", props3.page);
    };
    var handleKeyPress = function handleKeyPress2(event2) {
      emit("keypress", event2, handleClick2, props3.page);
    };
    return function() {
      var _classNames;
      var showTitle = props3.showTitle, page2 = props3.page, itemRender = props3.itemRender;
      var _cls = attrs.class, style2 = attrs.style;
      var prefixCls = "".concat(props3.rootPrefixCls, "-item");
      var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(props3.page), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-active"), props3.active), _defineProperty$U(_classNames, "".concat(prefixCls, "-disabled"), !props3.page), _classNames), _cls);
      return createVNode("li", {
        "onClick": handleClick2,
        "onKeypress": handleKeyPress,
        "title": showTitle ? String(page2) : null,
        "tabindex": "0",
        "class": cls,
        "style": style2
      }, [itemRender({
        page: page2,
        type: "page",
        originalElement: createVNode("a", {
          "rel": "nofollow"
        }, [page2])
      })]);
    };
  }
});
const KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
const Options = defineComponent({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: PropTypes$1.any,
    current: Number,
    pageSizeOptions: PropTypes$1.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: PropTypes$1.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: PropTypes$1.any
  },
  setup: function setup136(props3) {
    var goInputText = ref("");
    var validValue = computed(function() {
      return !goInputText.value || isNaN(goInputText.value) ? void 0 : Number(goInputText.value);
    });
    var defaultBuildOptionText = function defaultBuildOptionText2(opt) {
      return "".concat(opt.value, " ").concat(props3.locale.items_per_page);
    };
    var handleChange2 = function handleChange3(e2) {
      var _e$target = e2.target, value = _e$target.value, composing = _e$target.composing;
      if (e2.isComposing || composing || goInputText.value === value)
        return;
      goInputText.value = value;
    };
    var handleBlur = function handleBlur2(e2) {
      var goButton = props3.goButton, quickGo = props3.quickGo, rootPrefixCls = props3.rootPrefixCls;
      if (goButton || goInputText.value === "") {
        return;
      }
      if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        goInputText.value = "";
        return;
      } else {
        quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    var go = function go2(e2) {
      if (goInputText.value === "") {
        return;
      }
      if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
        props3.quickGo(validValue.value);
        goInputText.value = "";
      }
    };
    var pageSizeOptions = computed(function() {
      var pageSize2 = props3.pageSize, pageSizeOptions2 = props3.pageSizeOptions;
      if (pageSizeOptions2.some(function(option) {
        return option.toString() === pageSize2.toString();
      })) {
        return pageSizeOptions2;
      }
      return pageSizeOptions2.concat([pageSize2.toString()]).sort(function(a2, b2) {
        var numberA = isNaN(Number(a2)) ? 0 : Number(a2);
        var numberB = isNaN(Number(b2)) ? 0 : Number(b2);
        return numberA - numberB;
      });
    });
    return function() {
      var rootPrefixCls = props3.rootPrefixCls, locale2 = props3.locale, changeSize = props3.changeSize, quickGo = props3.quickGo, goButton = props3.goButton, Select2 = props3.selectComponentClass, selectPrefixCls = props3.selectPrefixCls, pageSize2 = props3.pageSize, disabled = props3.disabled;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      if (changeSize && Select2) {
        var buildOptionText = props3.buildOptionText || defaultBuildOptionText;
        var options = pageSizeOptions.value.map(function(opt, i2) {
          return createVNode(Select2.Option, {
            "key": i2,
            "value": opt
          }, {
            default: function _default9() {
              return [buildOptionText({
                value: opt
              })];
            }
          });
        });
        changeSelect = createVNode(Select2, {
          "disabled": disabled,
          "prefixCls": selectPrefixCls,
          "showSearch": false,
          "class": "".concat(prefixCls, "-size-changer"),
          "optionLabelProp": "children",
          "value": (pageSize2 || pageSizeOptions.value[0]).toString(),
          "onChange": function onChange3(value) {
            return changeSize(Number(value));
          },
          "getPopupContainer": function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          }
        }, {
          default: function _default9() {
            return [options];
          }
        });
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? createVNode("button", {
            "type": "button",
            "onClick": go,
            "onKeyup": go,
            "disabled": disabled,
            "class": "".concat(prefixCls, "-quick-jumper-button")
          }, [locale2.jump_to_confirm]) : createVNode("span", {
            "onClick": go,
            "onKeyup": go
          }, [goButton]);
        }
        goInput = createVNode("div", {
          "class": "".concat(prefixCls, "-quick-jumper")
        }, [locale2.jump_to, withDirectives(createVNode("input", {
          "disabled": disabled,
          "type": "text",
          "value": goInputText.value,
          "onInput": handleChange2,
          "onChange": handleChange2,
          "onKeyup": go,
          "onBlur": handleBlur
        }, null), [[antInputDirective]]), locale2.page, gotoButton]);
      }
      return createVNode("li", {
        "class": "".concat(prefixCls)
      }, [changeSelect, goInput]);
    };
  }
});
const Pagination$2 = {
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875"
};
var _excluded$r = ["class"];
function isInteger(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function defaultItemRender(_ref) {
  var originalElement = _ref.originalElement;
  return originalElement;
}
function calculatePage(p2, state, props3) {
  var pageSize2 = typeof p2 === "undefined" ? state.statePageSize : p2;
  return Math.floor((props3.total - 1) / pageSize2) + 1;
}
const VcPagination = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: PropTypes$1.string.def("rc-pagination"),
    selectPrefixCls: PropTypes$1.string.def("rc-select"),
    current: Number,
    defaultCurrent: PropTypes$1.number.def(1),
    total: PropTypes$1.number.def(0),
    pageSize: Number,
    defaultPageSize: PropTypes$1.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: false
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: false
    },
    selectComponentClass: PropTypes$1.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: true
    },
    showQuickJumper: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.object]).def(false),
    showTitle: {
      type: Boolean,
      default: true
    },
    pageSizeOptions: PropTypes$1.arrayOf(PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: PropTypes$1.object.def(Pagination$2),
    itemRender: PropTypes$1.func.def(defaultItemRender),
    prevIcon: PropTypes$1.any,
    nextIcon: PropTypes$1.any,
    jumpPrevIcon: PropTypes$1.any,
    jumpNextIcon: PropTypes$1.any,
    totalBoundaryShowSizeChanger: PropTypes$1.number.def(50)
  },
  data: function data5() {
    var props3 = this.$props;
    var current2 = firstNotUndefined([this.current, this.defaultCurrent]);
    var pageSize2 = firstNotUndefined([this.pageSize, this.defaultPageSize]);
    current2 = Math.min(current2, calculatePage(pageSize2, void 0, props3));
    return {
      stateCurrent: current2,
      stateCurrentInputValue: current2,
      statePageSize: pageSize2
    };
  },
  watch: {
    current: function current(val) {
      this.setState({
        stateCurrent: val,
        stateCurrentInputValue: val
      });
    },
    pageSize: function pageSize(val) {
      var newState = {};
      var current2 = this.stateCurrent;
      var newCurrent = calculatePage(val, this.$data, this.$props);
      current2 = current2 > newCurrent ? newCurrent : current2;
      if (!hasProp(this, "current")) {
        newState.stateCurrent = current2;
        newState.stateCurrentInputValue = current2;
      }
      newState.statePageSize = val;
      this.setState(newState);
    },
    stateCurrent: function stateCurrent(_val, oldValue) {
      var _this = this;
      this.$nextTick(function() {
        if (_this.$refs.paginationNode) {
          var lastCurrentNode = _this.$refs.paginationNode.querySelector(".".concat(_this.prefixCls, "-item-").concat(oldValue));
          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      });
    },
    total: function total() {
      var newState = {};
      var newCurrent = calculatePage(this.pageSize, this.$data, this.$props);
      if (hasProp(this, "current")) {
        var current2 = Math.min(this.current, newCurrent);
        newState.stateCurrent = current2;
        newState.stateCurrentInputValue = current2;
      } else {
        var _current = this.stateCurrent;
        if (_current === 0 && newCurrent > 0) {
          _current = 1;
        } else {
          _current = Math.min(this.stateCurrent, newCurrent);
        }
        newState.stateCurrent = _current;
      }
      this.setState(newState);
    }
  },
  methods: {
    getJumpPrevPage: function getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage: function getJumpNextPage() {
      return Math.min(calculatePage(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon: function getItemIcon(icon, label) {
      var prefixCls = this.$props.prefixCls;
      var iconNode = getComponent(this, icon, this.$props) || createVNode("button", {
        "type": "button",
        "aria-label": label,
        "class": "".concat(prefixCls, "-item-link")
      }, null);
      return iconNode;
    },
    getValidValue: function getValidValue(e2) {
      var inputValue = e2.target.value;
      var allPages = calculatePage(void 0, this.$data, this.$props);
      var stateCurrentInputValue = this.$data.stateCurrentInputValue;
      var value;
      if (inputValue === "") {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = stateCurrentInputValue;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }
      return value;
    },
    isValid: function isValid4(page2) {
      return isInteger(page2) && page2 !== this.stateCurrent;
    },
    shouldDisplayQuickJumper: function shouldDisplayQuickJumper() {
      var _this$$props = this.$props, showQuickJumper = _this$$props.showQuickJumper, pageSize2 = _this$$props.pageSize, total3 = _this$$props.total;
      if (total3 <= pageSize2) {
        return false;
      }
      return showQuickJumper;
    },
    handleKeyDown: function handleKeyDown(event2) {
      if (event2.keyCode === KEYCODE.ARROW_UP || event2.keyCode === KEYCODE.ARROW_DOWN) {
        event2.preventDefault();
      }
    },
    handleKeyUp: function handleKeyUp(e2) {
      if (e2.isComposing || e2.target.composing)
        return;
      var value = this.getValidValue(e2);
      var stateCurrentInputValue = this.stateCurrentInputValue;
      if (value !== stateCurrentInputValue) {
        this.setState({
          stateCurrentInputValue: value
        });
      }
      if (e2.keyCode === KEYCODE.ENTER) {
        this.handleChange(value);
      } else if (e2.keyCode === KEYCODE.ARROW_UP) {
        this.handleChange(value - 1);
      } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
        this.handleChange(value + 1);
      }
    },
    changePageSize: function changePageSize(size2) {
      var current2 = this.stateCurrent;
      var preCurrent = current2;
      var newCurrent = calculatePage(size2, this.$data, this.$props);
      current2 = current2 > newCurrent ? newCurrent : current2;
      if (newCurrent === 0) {
        current2 = this.stateCurrent;
      }
      if (typeof size2 === "number") {
        if (!hasProp(this, "pageSize")) {
          this.setState({
            statePageSize: size2
          });
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: current2,
            stateCurrentInputValue: current2
          });
        }
      }
      this.__emit("update:pageSize", size2);
      if (current2 !== preCurrent) {
        this.__emit("update:current", current2);
      }
      this.__emit("showSizeChange", current2, size2);
      this.__emit("change", current2, size2);
    },
    handleChange: function handleChange(p2) {
      var disabled = this.$props.disabled;
      var page2 = p2;
      if (this.isValid(page2) && !disabled) {
        var currentPage = calculatePage(void 0, this.$data, this.$props);
        if (page2 > currentPage) {
          page2 = currentPage;
        } else if (page2 < 1) {
          page2 = 1;
        }
        if (!hasProp(this, "current")) {
          this.setState({
            stateCurrent: page2,
            stateCurrentInputValue: page2
          });
        }
        this.__emit("update:current", page2);
        this.__emit("change", page2, this.statePageSize);
        return page2;
      }
      return this.stateCurrent;
    },
    prev: function prev() {
      if (this.hasPrev()) {
        this.handleChange(this.stateCurrent - 1);
      }
    },
    next: function next() {
      if (this.hasNext()) {
        this.handleChange(this.stateCurrent + 1);
      }
    },
    jumpPrev: function jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext: function jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev: function hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext: function hasNext() {
      return this.stateCurrent < calculatePage(void 0, this.$data, this.$props);
    },
    getShowSizeChanger: function getShowSizeChanger() {
      var _this$$props2 = this.$props, showSizeChanger = _this$$props2.showSizeChanger, total3 = _this$$props2.total, totalBoundaryShowSizeChanger = _this$$props2.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total3 > totalBoundaryShowSizeChanger;
    },
    runIfEnter: function runIfEnter(event2, callback) {
      if (event2.key === "Enter" || event2.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    },
    runIfEnterPrev: function runIfEnterPrev(event2) {
      this.runIfEnter(event2, this.prev);
    },
    runIfEnterNext: function runIfEnterNext(event2) {
      this.runIfEnter(event2, this.next);
    },
    runIfEnterJumpPrev: function runIfEnterJumpPrev(event2) {
      this.runIfEnter(event2, this.jumpPrev);
    },
    runIfEnterJumpNext: function runIfEnterJumpNext(event2) {
      this.runIfEnter(event2, this.jumpNext);
    },
    handleGoTO: function handleGoTO(event2) {
      if (event2.keyCode === KEYCODE.ENTER || event2.type === "click") {
        this.handleChange(this.stateCurrentInputValue);
      }
    },
    renderPrev: function renderPrev(prevPage) {
      var itemRender = this.$props.itemRender;
      var prevButton = itemRender({
        page: prevPage,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      });
      var disabled = !this.hasPrev();
      return isValidElement(prevButton) ? cloneElement(prevButton, disabled ? {
        disabled
      } : {}) : prevButton;
    },
    renderNext: function renderNext(nextPage) {
      var itemRender = this.$props.itemRender;
      var nextButton = itemRender({
        page: nextPage,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      });
      var disabled = !this.hasNext();
      return isValidElement(nextButton) ? cloneElement(nextButton, disabled ? {
        disabled
      } : {}) : nextButton;
    }
  },
  render: function render7() {
    var _classNames6;
    var _this$$props3 = this.$props, prefixCls = _this$$props3.prefixCls, disabled = _this$$props3.disabled, hideOnSinglePage = _this$$props3.hideOnSinglePage, total3 = _this$$props3.total, locale2 = _this$$props3.locale, showQuickJumper = _this$$props3.showQuickJumper, showLessItems = _this$$props3.showLessItems, showTitle = _this$$props3.showTitle, showTotal = _this$$props3.showTotal, simple = _this$$props3.simple, itemRender = _this$$props3.itemRender, showPrevNextJumpers = _this$$props3.showPrevNextJumpers, jumpPrevIcon = _this$$props3.jumpPrevIcon, jumpNextIcon = _this$$props3.jumpNextIcon, selectComponentClass = _this$$props3.selectComponentClass, selectPrefixCls = _this$$props3.selectPrefixCls, pageSizeOptions = _this$$props3.pageSizeOptions;
    var stateCurrent2 = this.stateCurrent, statePageSize = this.statePageSize;
    var _splitAttrs$extraAttr = splitAttrs(this.$attrs).extraAttrs, className = _splitAttrs$extraAttr.class, restAttrs = _objectWithoutProperties$2(_splitAttrs$extraAttr, _excluded$r);
    if (hideOnSinglePage === true && this.total <= statePageSize) {
      return null;
    }
    var allPages = calculatePage(void 0, this.$data, this.$props);
    var pagerList = [];
    var jumpPrev2 = null;
    var jumpNext2 = null;
    var firstPager = null;
    var lastPager = null;
    var gotoButton = null;
    var goButton = showQuickJumper && showQuickJumper.goButton;
    var pageBufferSize = showLessItems ? 1 : 2;
    var prevPage = stateCurrent2 - 1 > 0 ? stateCurrent2 - 1 : 0;
    var nextPage = stateCurrent2 + 1 < allPages ? stateCurrent2 + 1 : allPages;
    var hasPrev2 = this.hasPrev();
    var hasNext2 = this.hasNext();
    if (simple) {
      if (goButton) {
        if (typeof goButton === "boolean") {
          gotoButton = createVNode("button", {
            "type": "button",
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [locale2.jump_to_confirm]);
        } else {
          gotoButton = createVNode("span", {
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [goButton]);
        }
        gotoButton = createVNode("li", {
          "title": showTitle ? "".concat(locale2.jump_to).concat(stateCurrent2, "/").concat(allPages) : null,
          "class": "".concat(prefixCls, "-simple-pager")
        }, [gotoButton]);
      }
      return createVNode("ul", _objectSpread2$1({
        "class": classNames("".concat(prefixCls, " ").concat(prefixCls, "-simple"), _defineProperty$U({}, "".concat(prefixCls, "-disabled"), disabled), className)
      }, restAttrs), [createVNode("li", {
        "title": showTitle ? locale2.prev_page : null,
        "onClick": this.prev,
        "tabindex": hasPrev2 ? 0 : null,
        "onKeypress": this.runIfEnterPrev,
        "class": classNames("".concat(prefixCls, "-prev"), _defineProperty$U({}, "".concat(prefixCls, "-disabled"), !hasPrev2)),
        "aria-disabled": !hasPrev2
      }, [this.renderPrev(prevPage)]), createVNode("li", {
        "title": showTitle ? "".concat(stateCurrent2, "/").concat(allPages) : null,
        "class": "".concat(prefixCls, "-simple-pager")
      }, [withDirectives(createVNode("input", {
        "type": "text",
        "value": this.stateCurrentInputValue,
        "disabled": disabled,
        "onKeydown": this.handleKeyDown,
        "onKeyup": this.handleKeyUp,
        "onInput": this.handleKeyUp,
        "onChange": this.handleKeyUp,
        "size": "3"
      }, null), [[antInputDirective]]), createVNode("span", {
        "class": "".concat(prefixCls, "-slash")
      }, [createTextVNode("\uFF0F")]), allPages]), createVNode("li", {
        "title": showTitle ? locale2.next_page : null,
        "onClick": this.next,
        "tabindex": hasNext2 ? 0 : null,
        "onKeypress": this.runIfEnterNext,
        "class": classNames("".concat(prefixCls, "-next"), _defineProperty$U({}, "".concat(prefixCls, "-disabled"), !hasNext2)),
        "aria-disabled": !hasNext2
      }, [this.renderNext(nextPage)]), gotoButton]);
    }
    if (allPages <= 3 + pageBufferSize * 2) {
      var pagerProps = {
        locale: locale2,
        rootPrefixCls: prefixCls,
        showTitle,
        itemRender,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      if (!allPages) {
        pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": "noPager",
          "page": 1,
          "class": "".concat(prefixCls, "-item-disabled")
        }), null));
      }
      for (var i2 = 1; i2 <= allPages; i2 += 1) {
        var active = stateCurrent2 === i2;
        pagerList.push(createVNode(Pager, _objectSpread2$1(_objectSpread2$1({}, pagerProps), {}, {
          "key": i2,
          "page": i2,
          "active": active
        }), null));
      }
    } else {
      var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
      var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
      if (showPrevNextJumpers) {
        jumpPrev2 = createVNode("li", {
          "title": this.showTitle ? prevItemTitle : null,
          "key": "prev",
          "onClick": this.jumpPrev,
          "tabindex": "0",
          "onKeypress": this.runIfEnterJumpPrev,
          "class": classNames("".concat(prefixCls, "-jump-prev"), _defineProperty$U({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
        }, [itemRender({
          page: this.getJumpPrevPage(),
          type: "jump-prev",
          originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
        })]);
        jumpNext2 = createVNode("li", {
          "title": this.showTitle ? nextItemTitle : null,
          "key": "next",
          "tabindex": "0",
          "onClick": this.jumpNext,
          "onKeypress": this.runIfEnterJumpNext,
          "class": classNames("".concat(prefixCls, "-jump-next"), _defineProperty$U({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
        }, [itemRender({
          page: this.getJumpNextPage(),
          type: "jump-next",
          originalElement: this.getItemIcon("jumpNextIcon", "next page")
        })]);
      }
      lastPager = createVNode(Pager, {
        "locale": locale2,
        "last": true,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": allPages,
        "page": allPages,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      firstPager = createVNode(Pager, {
        "locale": locale2,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": 1,
        "page": 1,
        "active": false,
        "showTitle": showTitle,
        "itemRender": itemRender
      }, null);
      var left = Math.max(1, stateCurrent2 - pageBufferSize);
      var right = Math.min(stateCurrent2 + pageBufferSize, allPages);
      if (stateCurrent2 - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }
      if (allPages - stateCurrent2 <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }
      for (var _i = left; _i <= right; _i += 1) {
        var _active = stateCurrent2 === _i;
        pagerList.push(createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": _i,
          "page": _i,
          "active": _active,
          "showTitle": showTitle,
          "itemRender": itemRender
        }, null));
      }
      if (stateCurrent2 - 1 >= pageBufferSize * 2 && stateCurrent2 !== 1 + 2) {
        pagerList[0] = createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": left,
          "page": left,
          "class": "".concat(prefixCls, "-item-after-jump-prev"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.unshift(jumpPrev2);
      }
      if (allPages - stateCurrent2 >= pageBufferSize * 2 && stateCurrent2 !== allPages - 2) {
        pagerList[pagerList.length - 1] = createVNode(Pager, {
          "locale": locale2,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": right,
          "page": right,
          "class": "".concat(prefixCls, "-item-before-jump-next"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": itemRender
        }, null);
        pagerList.push(jumpNext2);
      }
      if (left !== 1) {
        pagerList.unshift(firstPager);
      }
      if (right !== allPages) {
        pagerList.push(lastPager);
      }
    }
    var totalText = null;
    if (showTotal) {
      totalText = createVNode("li", {
        "class": "".concat(prefixCls, "-total-text")
      }, [showTotal(total3, [total3 === 0 ? 0 : (stateCurrent2 - 1) * statePageSize + 1, stateCurrent2 * statePageSize > total3 ? total3 : stateCurrent2 * statePageSize])]);
    }
    var prevDisabled = !hasPrev2 || !allPages;
    var nextDisabled = !hasNext2 || !allPages;
    var buildOptionText = this.buildOptionText || this.$slots.buildOptionText;
    return createVNode("ul", _objectSpread2$1(_objectSpread2$1({
      "unselectable": "on",
      "ref": "paginationNode"
    }, restAttrs), {}, {
      "class": classNames((_classNames6 = {}, _defineProperty$U(_classNames6, "".concat(prefixCls), true), _defineProperty$U(_classNames6, "".concat(prefixCls, "-disabled"), disabled), _classNames6), className)
    }), [totalText, createVNode("li", {
      "title": showTitle ? locale2.prev_page : null,
      "onClick": this.prev,
      "tabindex": prevDisabled ? null : 0,
      "onKeypress": this.runIfEnterPrev,
      "class": classNames("".concat(prefixCls, "-prev"), _defineProperty$U({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
      "aria-disabled": prevDisabled
    }, [this.renderPrev(prevPage)]), pagerList, createVNode("li", {
      "title": showTitle ? locale2.next_page : null,
      "onClick": this.next,
      "tabindex": nextDisabled ? null : 0,
      "onKeypress": this.runIfEnterNext,
      "class": classNames("".concat(prefixCls, "-next"), _defineProperty$U({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
      "aria-disabled": nextDisabled
    }, [this.renderNext(nextPage)]), createVNode(Options, {
      "disabled": disabled,
      "locale": locale2,
      "rootPrefixCls": prefixCls,
      "selectComponentClass": selectComponentClass,
      "selectPrefixCls": selectPrefixCls,
      "changeSize": this.getShowSizeChanger() ? this.changePageSize : null,
      "current": stateCurrent2,
      "pageSize": statePageSize,
      "pageSizeOptions": pageSizeOptions,
      "buildOptionText": buildOptionText || null,
      "quickGo": this.shouldDisplayQuickJumper() ? this.handleChange : null,
      "goButton": goButton
    }, null)]);
  }
});
var _excluded$q = ["size", "itemRender", "buildOptionText", "selectComponentClass", "responsive"];
var paginationProps = function paginationProps2() {
  return {
    total: Number,
    defaultCurrent: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    current: Number,
    defaultPageSize: Number,
    pageSize: Number,
    hideOnSinglePage: {
      type: Boolean,
      default: void 0
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    pageSizeOptions: Array,
    buildOptionText: Function,
    showQuickJumper: {
      type: [Boolean, Object],
      default: void 0
    },
    showTotal: Function,
    size: String,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: Object,
    prefixCls: String,
    selectPrefixCls: String,
    totalBoundaryShowSizeChanger: Number,
    selectComponentClass: String,
    itemRender: Function,
    role: String,
    responsive: Boolean,
    showLessItems: {
      type: Boolean,
      default: void 0
    },
    onChange: Function,
    onShowSizeChange: Function,
    "onUpdate:current": Function,
    "onUpdate:pageSize": Function
  };
};
const Pagination$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: false,
  props: paginationProps(),
  setup: function setup137(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("pagination", props3), prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider, direction = _useConfigInject.direction;
    var selectPrefixCls = computed(function() {
      return configProvider.getPrefixCls("select", props3.selectPrefixCls);
    });
    var breakpoint = useBreakpoint();
    var _useLocaleReceiver = useLocaleReceiver("Pagination", enUS$1, toRef(props3, "locale")), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var getIconsProps = function getIconsProps2(pre) {
      var ellipsis = createVNode("span", {
        "class": "".concat(pre, "-item-ellipsis")
      }, [createTextVNode("\u2022\u2022\u2022")]);
      var prevIcon = createVNode("button", {
        "class": "".concat(pre, "-item-link"),
        "type": "button",
        "tabindex": -1
      }, [createVNode(LeftOutlined$1, null, null)]);
      var nextIcon = createVNode("button", {
        "class": "".concat(pre, "-item-link"),
        "type": "button",
        "tabindex": -1
      }, [createVNode(RightOutlined$1, null, null)]);
      var jumpPrevIcon = createVNode("a", {
        "rel": "nofollow",
        "class": "".concat(pre, "-item-link")
      }, [createVNode("div", {
        "class": "".concat(pre, "-item-container")
      }, [createVNode(DoubleLeftOutlined$1, {
        "class": "".concat(pre, "-item-link-icon")
      }, null), ellipsis])]);
      var jumpNextIcon = createVNode("a", {
        "rel": "nofollow",
        "class": "".concat(pre, "-item-link")
      }, [createVNode("div", {
        "class": "".concat(pre, "-item-container")
      }, [createVNode(DoubleRightOutlined$1, {
        "class": "".concat(pre, "-item-link-icon")
      }, null), ellipsis])]);
      if (direction.value === "rtl") {
        var _ref2 = [nextIcon, prevIcon];
        prevIcon = _ref2[0];
        nextIcon = _ref2[1];
        var _ref3 = [jumpNextIcon, jumpPrevIcon];
        jumpPrevIcon = _ref3[0];
        jumpNextIcon = _ref3[1];
      }
      return {
        prevIcon,
        nextIcon,
        jumpPrevIcon,
        jumpNextIcon
      };
    };
    return function() {
      var _breakpoint$value;
      var size2 = props3.size, _props$itemRender = props3.itemRender, itemRender = _props$itemRender === void 0 ? slots.itemRender : _props$itemRender, _props$buildOptionTex = props3.buildOptionText, buildOptionText = _props$buildOptionTex === void 0 ? slots.buildOptionText : _props$buildOptionTex, selectComponentClass = props3.selectComponentClass, responsive = props3.responsive, restProps = _objectWithoutProperties$2(props3, _excluded$q);
      var isSmall = size2 === "small" || !!((_breakpoint$value = breakpoint.value) !== null && _breakpoint$value !== void 0 && _breakpoint$value.xs && !size2 && responsive);
      var paginationProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), getIconsProps(prefixCls.value)), {}, {
        prefixCls: prefixCls.value,
        selectPrefixCls: selectPrefixCls.value,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : VcSelect),
        locale: locale2.value,
        buildOptionText
      }, attrs), {}, {
        class: classNames(_defineProperty$U({
          mini: isSmall
        }, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), attrs.class),
        itemRender
      });
      return createVNode(VcPagination, paginationProps3, null);
    };
  }
});
const Pagination = withInstall(Pagination$1);
var listItemMetaProps = function listItemMetaProps2() {
  return {
    avatar: PropTypes$1.any,
    description: PropTypes$1.any,
    prefixCls: String,
    title: PropTypes$1.any
  };
};
const ItemMeta = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItemMeta",
  props: listItemMetaProps(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: true,
  slots: ["avatar", "description", "title"],
  setup: function setup138(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("list", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _props$title, _slots$title, _props$description, _slots$description, _props$avatar, _slots$avatar;
      var classString = "".concat(prefixCls.value, "-item-meta");
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
      var description = (_props$description = props3.description) !== null && _props$description !== void 0 ? _props$description : (_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.call(slots);
      var avatar = (_props$avatar = props3.avatar) !== null && _props$avatar !== void 0 ? _props$avatar : (_slots$avatar = slots.avatar) === null || _slots$avatar === void 0 ? void 0 : _slots$avatar.call(slots);
      var content = createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-content")
      }, [title && createVNode("h4", {
        "class": "".concat(prefixCls.value, "-item-meta-title")
      }, [title]), description && createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-description")
      }, [description])]);
      return createVNode("div", {
        "class": classString
      }, [avatar && createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-meta-avatar")
      }, [avatar]), (title || description) && content]);
    };
  }
});
var ListContextKey = Symbol("ListContextKey");
var _excluded$p = ["class"];
var listItemProps$1 = function listItemProps() {
  return {
    prefixCls: String,
    extra: PropTypes$1.any,
    actions: PropTypes$1.array,
    grid: Object,
    colStyle: {
      type: Object,
      default: void 0
    }
  };
};
const Item2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AListItem",
  inheritAttrs: false,
  Meta: ItemMeta,
  props: listItemProps$1(),
  slots: ["actions", "extra"],
  setup: function setup139(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _inject = inject(ListContextKey, {
      grid: ref(),
      itemLayout: ref()
    }), itemLayout = _inject.itemLayout, grid = _inject.grid;
    var _useConfigInject = useConfigInject("list", props3), prefixCls = _useConfigInject.prefixCls;
    var isItemContainsTextNodeAndNotSingular = function isItemContainsTextNodeAndNotSingular2() {
      var _slots$default;
      var children = ((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)) || [];
      var result;
      children.forEach(function(element) {
        if (isStringElement(element) && !isEmptyElement(element)) {
          result = true;
        }
      });
      return result && children.length > 1;
    };
    var isFlexMode = function isFlexMode2() {
      var _props$extra, _slots$extra;
      var extra = (_props$extra = props3.extra) !== null && _props$extra !== void 0 ? _props$extra : (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots);
      if (itemLayout.value === "vertical") {
        return !!extra;
      }
      return !isItemContainsTextNodeAndNotSingular();
    };
    return function() {
      var _props$extra2, _slots$extra2, _slots$default2, _props$actions, _slots$actions;
      var className = attrs.class, restAttrs = _objectWithoutProperties$2(attrs, _excluded$p);
      var pre = prefixCls.value;
      var extra = (_props$extra2 = props3.extra) !== null && _props$extra2 !== void 0 ? _props$extra2 : (_slots$extra2 = slots.extra) === null || _slots$extra2 === void 0 ? void 0 : _slots$extra2.call(slots);
      var children = (_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots);
      var actions = (_props$actions = props3.actions) !== null && _props$actions !== void 0 ? _props$actions : flattenChildren((_slots$actions = slots.actions) === null || _slots$actions === void 0 ? void 0 : _slots$actions.call(slots));
      actions = actions && !Array.isArray(actions) ? [actions] : actions;
      var actionsContent = actions && actions.length > 0 && createVNode("ul", {
        "class": "".concat(pre, "-item-action"),
        "key": "actions"
      }, [actions.map(function(action, i2) {
        return createVNode("li", {
          "key": "".concat(pre, "-item-action-").concat(i2)
        }, [action, i2 !== actions.length - 1 && createVNode("em", {
          "class": "".concat(pre, "-item-action-split")
        }, null)]);
      })]);
      var Element3 = grid.value ? "div" : "li";
      var itemChildren = createVNode(Element3, _objectSpread2$1(_objectSpread2$1({}, restAttrs), {}, {
        "class": classNames("".concat(pre, "-item"), _defineProperty$U({}, "".concat(pre, "-item-no-flex"), !isFlexMode()), className)
      }), {
        default: function _default9() {
          return [itemLayout.value === "vertical" && extra ? [createVNode("div", {
            "class": "".concat(pre, "-item-main"),
            "key": "content"
          }, [children, actionsContent]), createVNode("div", {
            "class": "".concat(pre, "-item-extra"),
            "key": "extra"
          }, [extra])] : [children, actionsContent, cloneElement(extra, {
            key: "extra"
          })]];
        }
      });
      return grid.value ? createVNode(Col$1, {
        "flex": 1,
        "style": props3.colStyle
      }, {
        default: function _default9() {
          return [itemChildren];
        }
      }) : itemChildren;
    };
  }
});
var listProps = function listProps2() {
  return {
    bordered: {
      type: Boolean,
      default: void 0
    },
    dataSource: PropTypes$1.array,
    extra: PropTypes$1.any,
    grid: {
      type: Object,
      default: void 0
    },
    itemLayout: String,
    loading: {
      type: [Boolean, Object],
      default: void 0
    },
    loadMore: PropTypes$1.any,
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    prefixCls: String,
    rowKey: [String, Number, Function],
    renderItem: Function,
    size: String,
    split: {
      type: Boolean,
      default: void 0
    },
    header: PropTypes$1.any,
    footer: PropTypes$1.any,
    locale: {
      type: Object
    }
  };
};
var List$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AList",
  Item: Item2,
  props: initDefaultProps$1(listProps(), {
    dataSource: [],
    bordered: false,
    split: true,
    loading: false,
    pagination: false
  }),
  slots: ["extra", "loadMore", "renderItem", "header", "footer"],
  setup: function setup140(props3, _ref) {
    var _paginationObj$value$, _paginationObj$value$2;
    var slots = _ref.slots;
    provide(ListContextKey, {
      grid: toRef(props3, "grid"),
      itemLayout: toRef(props3, "itemLayout")
    });
    var defaultPaginationProps = {
      current: 1,
      total: 0
    };
    var _useConfigInject = useConfigInject("list", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, renderEmpty2 = _useConfigInject.renderEmpty;
    var paginationObj = computed(function() {
      return props3.pagination && _typeof$3(props3.pagination) === "object" ? props3.pagination : {};
    });
    var paginationCurrent = ref((_paginationObj$value$ = paginationObj.value.defaultCurrent) !== null && _paginationObj$value$ !== void 0 ? _paginationObj$value$ : 1);
    var paginationSize = ref((_paginationObj$value$2 = paginationObj.value.defaultPageSize) !== null && _paginationObj$value$2 !== void 0 ? _paginationObj$value$2 : 10);
    watch(paginationObj, function() {
      if ("current" in paginationObj.value) {
        paginationCurrent.value = paginationObj.value.current;
      }
      if ("pageSize" in paginationObj.value) {
        paginationSize.value = paginationObj.value.pageSize;
      }
    });
    var listItemsKeys = [];
    var triggerPaginationEvent = function triggerPaginationEvent2(eventName) {
      return function(page2, pageSize2) {
        paginationCurrent.value = page2;
        paginationSize.value = pageSize2;
        if (paginationObj.value[eventName]) {
          paginationObj.value[eventName](page2, pageSize2);
        }
      };
    };
    var onPaginationChange = triggerPaginationEvent("onChange");
    var onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
    var renderEmptyFunc = function renderEmptyFunc2(renderEmptyHandler) {
      var _props$locale;
      return createVNode("div", {
        "class": "".concat(prefixCls.value, "-empty-text")
      }, [((_props$locale = props3.locale) === null || _props$locale === void 0 ? void 0 : _props$locale.emptyText) || renderEmptyHandler("List")]);
    };
    var loadingProp = computed(function() {
      if (typeof props3.loading === "boolean") {
        return {
          spinning: props3.loading
        };
      } else {
        return props3.loading;
      }
    });
    var isLoading = computed(function() {
      return loadingProp.value && loadingProp.value.spinning;
    });
    var sizeCls = computed(function() {
      var size2 = "";
      switch (props3.size) {
        case "large":
          size2 = "lg";
          break;
        case "small":
          size2 = "sm";
          break;
      }
      return size2;
    });
    var classObj = computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value), true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-vertical"), props3.itemLayout === "vertical"), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-").concat(sizeCls.value), sizeCls.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-split"), props3.split), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-bordered"), props3.bordered), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-loading"), isLoading.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-grid"), !!props3.grid), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var paginationProps3 = computed(function() {
      var pp = _objectSpread2$1(_objectSpread2$1({}, defaultPaginationProps), {}, {
        total: props3.dataSource.length,
        current: paginationCurrent.value,
        pageSize: paginationSize.value
      }, props3.pagination || {});
      var largestPage = Math.ceil(pp.total / pp.pageSize);
      if (pp.current > largestPage) {
        pp.current = largestPage;
      }
      return pp;
    });
    var splitDataSource = computed(function() {
      var dd = _toConsumableArray(props3.dataSource);
      if (props3.pagination) {
        if (props3.dataSource.length > (paginationProps3.value.current - 1) * paginationProps3.value.pageSize) {
          dd = _toConsumableArray(props3.dataSource).splice((paginationProps3.value.current - 1) * paginationProps3.value.pageSize, paginationProps3.value.pageSize);
        }
      }
      return dd;
    });
    var screens2 = useBreakpoint();
    var currentBreakpoint = eagerComputed(function() {
      for (var i2 = 0; i2 < responsiveArray.length; i2 += 1) {
        var breakpoint = responsiveArray[i2];
        if (screens2.value[breakpoint]) {
          return breakpoint;
        }
      }
      return void 0;
    });
    var colStyle = computed(function() {
      if (!props3.grid) {
        return void 0;
      }
      var columnCount = currentBreakpoint.value && props3.grid[currentBreakpoint.value] ? props3.grid[currentBreakpoint.value] : props3.grid.column;
      if (columnCount) {
        return {
          width: "".concat(100 / columnCount, "%"),
          maxWidth: "".concat(100 / columnCount, "%")
        };
      }
      return void 0;
    });
    var renderInnerItem = function renderInnerItem2(item, index2) {
      var _props$renderItem;
      var renderItem = (_props$renderItem = props3.renderItem) !== null && _props$renderItem !== void 0 ? _props$renderItem : slots.renderItem;
      if (!renderItem)
        return null;
      var key2;
      var rowKeyType = _typeof$3(props3.rowKey);
      if (rowKeyType === "function") {
        key2 = props3.rowKey(item);
      } else if (rowKeyType === "string" || rowKeyType === "number") {
        key2 = item[props3.rowKey];
      } else {
        key2 = item.key;
      }
      if (!key2) {
        key2 = "list-item-".concat(index2);
      }
      listItemsKeys[index2] = key2;
      return renderItem({
        item,
        index: index2
      });
    };
    return function() {
      var _props$loadMore, _slots$loadMore, _props$footer, _slots$footer, _props$header, _slots$header, _slots$default;
      var loadMore = (_props$loadMore = props3.loadMore) !== null && _props$loadMore !== void 0 ? _props$loadMore : (_slots$loadMore = slots.loadMore) === null || _slots$loadMore === void 0 ? void 0 : _slots$loadMore.call(slots);
      var footer = (_props$footer = props3.footer) !== null && _props$footer !== void 0 ? _props$footer : (_slots$footer = slots.footer) === null || _slots$footer === void 0 ? void 0 : _slots$footer.call(slots);
      var header = (_props$header = props3.header) !== null && _props$header !== void 0 ? _props$header : (_slots$header = slots.header) === null || _slots$header === void 0 ? void 0 : _slots$header.call(slots);
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var isSomethingAfterLastItem = !!(loadMore || props3.pagination || footer);
      var classString = _objectSpread2$1(_objectSpread2$1({}, classObj.value), {}, _defineProperty$U({}, "".concat(prefixCls.value, "-something-after-last-item"), isSomethingAfterLastItem));
      var paginationContent = props3.pagination ? createVNode("div", {
        "class": "".concat(prefixCls.value, "-pagination")
      }, [createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, paginationProps3.value), {}, {
        "onChange": onPaginationChange,
        "onShowSizeChange": onPaginationShowSizeChange
      }), null)]) : null;
      var childrenContent = isLoading.value && createVNode("div", {
        "style": {
          minHeight: "53px"
        }
      }, null);
      if (splitDataSource.value.length > 0) {
        listItemsKeys.length = 0;
        var items = splitDataSource.value.map(function(item, index2) {
          return renderInnerItem(item, index2);
        });
        var childrenList = items.map(function(child, index2) {
          return createVNode("div", {
            "key": listItemsKeys[index2],
            "style": colStyle.value
          }, [child]);
        });
        childrenContent = props3.grid ? createVNode(Row$3, {
          "gutter": props3.grid.gutter
        }, {
          default: function _default9() {
            return [childrenList];
          }
        }) : createVNode("ul", {
          "class": "".concat(prefixCls.value, "-items")
        }, [items]);
      } else if (!children.length && !isLoading.value) {
        childrenContent = renderEmptyFunc(renderEmpty2.value);
      }
      var paginationPosition = paginationProps3.value.position || "bottom";
      return createVNode("div", {
        "class": classString
      }, [(paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && createVNode("div", {
        "class": "".concat(prefixCls.value, "-header")
      }, [header]), createVNode(Spin, loadingProp.value, {
        default: function _default9() {
          return [childrenContent, children];
        }
      }), footer && createVNode("div", {
        "class": "".concat(prefixCls.value, "-footer")
      }, [footer]), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent]);
    };
  }
});
List$1.install = function(app) {
  app.component(List$1.name, List$1);
  app.component(List$1.Item.name, List$1.Item);
  app.component(List$1.Item.Meta.name, List$1.Item.Meta);
  return app;
};
const List$2 = List$1;
function getBeforeSelectionText(input) {
  var selectionStart = input.selectionStart;
  return input.value.slice(0, selectionStart);
}
function getLastMeasureIndex(text) {
  var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var prefixList = Array.isArray(prefix) ? prefix : [prefix];
  return prefixList.reduce(function(lastMatch, prefixStr) {
    var lastIndex = text.lastIndexOf(prefixStr);
    if (lastIndex > lastMatch.location) {
      return {
        location: lastIndex,
        prefix: prefixStr
      };
    }
    return lastMatch;
  }, {
    location: -1,
    prefix: ""
  });
}
function lower(char) {
  return (char || "").toLowerCase();
}
function reduceText(text, targetText, split2) {
  var firstChar = text[0];
  if (!firstChar || firstChar === split2) {
    return text;
  }
  var restText = text;
  var targetTextLen = targetText.length;
  for (var i2 = 0; i2 < targetTextLen; i2 += 1) {
    if (lower(restText[i2]) !== lower(targetText[i2])) {
      restText = restText.slice(i2);
      break;
    } else if (i2 === targetTextLen - 1) {
      restText = restText.slice(targetTextLen);
    }
  }
  return restText;
}
function replaceWithMeasure(text, measureConfig) {
  var measureLocation = measureConfig.measureLocation, prefix = measureConfig.prefix, targetText = measureConfig.targetText, selectionStart = measureConfig.selectionStart, split2 = measureConfig.split;
  var beforeMeasureText = text.slice(0, measureLocation);
  if (beforeMeasureText[beforeMeasureText.length - split2.length] === split2) {
    beforeMeasureText = beforeMeasureText.slice(0, beforeMeasureText.length - split2.length);
  }
  if (beforeMeasureText) {
    beforeMeasureText = "".concat(beforeMeasureText).concat(split2);
  }
  var restText = reduceText(text.slice(selectionStart), targetText.slice(selectionStart - measureLocation - prefix.length), split2);
  if (restText.slice(0, split2.length) === split2) {
    restText = restText.slice(split2.length);
  }
  var connectedStartText = "".concat(beforeMeasureText).concat(prefix).concat(targetText).concat(split2);
  return {
    text: "".concat(connectedStartText).concat(restText),
    selectionLocation: connectedStartText.length
  };
}
function setInputSelection(input, location2) {
  input.setSelectionRange(location2, location2);
  input.blur();
  input.focus();
}
function validateSearch(text, props3) {
  var split2 = props3.split;
  return !split2 || text.indexOf(split2) === -1;
}
function filterOption(input, _ref) {
  var _ref$value = _ref.value, value = _ref$value === void 0 ? "" : _ref$value;
  var lowerCase = input.toLowerCase();
  return value.toLowerCase().indexOf(lowerCase) !== -1;
}
var MentionsContextKey = Symbol("MentionsContextKey");
const MentionsContextKey$1 = MentionsContextKey;
function noop$6() {
}
const DropdownMenu = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DropdownMenu",
  props: {
    prefixCls: String,
    options: {
      type: Array,
      default: function _default6() {
        return [];
      }
    }
  },
  slots: ["notFoundContent", "option"],
  setup: function setup141(props3, _ref) {
    var slots = _ref.slots;
    var _inject = inject(MentionsContextKey$1, {
      activeIndex: ref(),
      loading: ref(false)
    }), activeIndex = _inject.activeIndex, setActiveIndex = _inject.setActiveIndex, selectOption = _inject.selectOption, _inject$onFocus = _inject.onFocus, onFocus2 = _inject$onFocus === void 0 ? noop$6 : _inject$onFocus, loading = _inject.loading;
    var timeoutId;
    var onMousedown2 = function onMousedown3(e2) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(function() {
        onFocus2(e2);
      });
    };
    onBeforeUnmount(function() {
      clearTimeout(timeoutId);
    });
    return function() {
      var _slots$notFoundConten;
      var prefixCls = props3.prefixCls, options = props3.options;
      var activeOption = options[activeIndex.value] || {};
      return createVNode(Menu, {
        "prefixCls": "".concat(prefixCls, "-menu"),
        "activeKey": activeOption.value,
        "onSelect": function onSelect(_ref2) {
          var key2 = _ref2.key;
          var option = options.find(function(_ref3) {
            var value = _ref3.value;
            return value === key2;
          });
          selectOption(option);
        },
        "onMousedown": onMousedown2
      }, {
        default: function _default9() {
          return [!loading.value && options.map(function(option, index2) {
            var _slots$option, _slots$option2;
            var value = option.value, disabled = option.disabled, _option$label = option.label, label = _option$label === void 0 ? option.value : _option$label;
            return createVNode(MenuItem$1, {
              "key": value,
              "disabled": disabled,
              "onMouseenter": function onMouseenter2() {
                setActiveIndex(index2);
              }
            }, {
              default: function _default10() {
                return [(_slots$option = (_slots$option2 = slots.option) === null || _slots$option2 === void 0 ? void 0 : _slots$option2.call(slots, option)) !== null && _slots$option !== void 0 ? _slots$option : typeof label === "function" ? label({
                  value,
                  disabled
                }) : label];
              }
            });
          }), !loading.value && options.length === 0 ? createVNode(MenuItem$1, {
            "key": "notFoundContent",
            "disabled": true
          }, {
            default: function _default10() {
              return [(_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots)];
            }
          }) : null, loading.value && createVNode(MenuItem$1, {
            "key": "loading",
            "disabled": true
          }, {
            default: function _default10() {
              return [createVNode(Spin, {
                "size": "small"
              }, null)];
            }
          })];
        }
      });
    };
  }
});
var BUILT_IN_PLACEMENTS = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
const KeywordTrigger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "KeywordTrigger",
  props: {
    loading: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: function _default7() {
        return [];
      }
    },
    prefixCls: String,
    placement: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    getPopupContainer: Function,
    direction: String
  },
  slots: ["notFoundContent", "option"],
  setup: function setup142(props3, _ref) {
    var slots = _ref.slots;
    var getDropdownPrefix = function getDropdownPrefix2() {
      return "".concat(props3.prefixCls, "-dropdown");
    };
    var getDropdownElement = function getDropdownElement2() {
      var options = props3.options;
      return createVNode(DropdownMenu, {
        "prefixCls": getDropdownPrefix(),
        "options": options
      }, {
        notFoundContent: slots.notFoundContent,
        option: slots.option
      });
    };
    var popupPlacement = computed(function() {
      var placement = props3.placement, direction = props3.direction;
      var popupPlacement2 = "topRight";
      if (direction === "rtl") {
        popupPlacement2 = placement === "top" ? "topLeft" : "bottomLeft";
      } else {
        popupPlacement2 = placement === "top" ? "topRight" : "bottomRight";
      }
      return popupPlacement2;
    });
    return function() {
      var visible = props3.visible, transitionName2 = props3.transitionName, getPopupContainer = props3.getPopupContainer;
      return createVNode(Trigger, {
        "prefixCls": getDropdownPrefix(),
        "popupVisible": visible,
        "popup": getDropdownElement(),
        "popupPlacement": popupPlacement.value,
        "popupTransitionName": transitionName2,
        "builtinPlacements": BUILT_IN_PLACEMENTS,
        "getPopupContainer": getPopupContainer
      }, {
        default: slots.default
      });
    };
  }
});
var PlaceMent = tuple$1("top", "bottom");
var mentionsProps$1 = {
  autofocus: {
    type: Boolean,
    default: void 0
  },
  prefix: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.arrayOf(PropTypes$1.string)]),
  prefixCls: String,
  value: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  split: String,
  transitionName: String,
  placement: PropTypes$1.oneOf(PlaceMent),
  character: PropTypes$1.any,
  characterRender: Function,
  filterOption: {
    type: [Boolean, Function]
  },
  validateSearch: Function,
  getPopupContainer: {
    type: Function
  },
  options: {
    type: Array,
    default: function _default8() {
      return void 0;
    }
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  rows: [Number, String],
  direction: {
    type: String
  }
};
var vcMentionsProps = _objectSpread2$1({}, mentionsProps$1);
var defaultProps$1 = {
  prefix: "@",
  split: " ",
  rows: 1,
  validateSearch,
  filterOption: function filterOption$1() {
    return filterOption;
  }
};
initDefaultProps$1(vcMentionsProps, defaultProps$1);
var _excluded$o = ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"], _excluded2$3 = ["class", "style"];
function noop$5() {
}
const Mentions$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Mentions",
  inheritAttrs: false,
  props: initDefaultProps$1(vcMentionsProps, defaultProps$1),
  slots: ["notFoundContent", "option"],
  emits: ["change", "select", "search", "focus", "blur", "pressenter"],
  setup: function setup143(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var measure2 = ref(null);
    var textarea = ref(null);
    var focusId = ref();
    var state = reactive({
      value: props3.value || "",
      measuring: false,
      measureLocation: 0,
      measureText: null,
      measurePrefix: "",
      activeIndex: 0,
      isFocus: false
    });
    watchEffect(function() {
      state.value = props3.value;
    });
    var triggerChange = function triggerChange2(val) {
      emit("change", val);
    };
    var onChange3 = function onChange4(_ref2) {
      var _ref2$target = _ref2.target, value = _ref2$target.value, composing = _ref2$target.composing, isComposing = _ref2.isComposing;
      if (isComposing || composing)
        return;
      triggerChange(value);
    };
    var startMeasure = function startMeasure2(measureText, measurePrefix, measureLocation) {
      _extends$1(state, {
        measuring: true,
        measureText,
        measurePrefix,
        measureLocation,
        activeIndex: 0
      });
    };
    var stopMeasure = function stopMeasure2(callback) {
      _extends$1(state, {
        measuring: false,
        measureLocation: 0,
        measureText: null
      });
      callback === null || callback === void 0 ? void 0 : callback();
    };
    var onKeyDown = function onKeyDown2(event2) {
      var which = event2.which;
      if (!state.measuring) {
        return;
      }
      if (which === KeyCode$1.UP || which === KeyCode$1.DOWN) {
        var optionLen = options.value.length;
        var offset3 = which === KeyCode$1.UP ? -1 : 1;
        var newActiveIndex = (state.activeIndex + offset3 + optionLen) % optionLen;
        state.activeIndex = newActiveIndex;
        event2.preventDefault();
      } else if (which === KeyCode$1.ESC) {
        stopMeasure();
      } else if (which === KeyCode$1.ENTER) {
        event2.preventDefault();
        if (!options.value.length) {
          stopMeasure();
          return;
        }
        var option = options.value[state.activeIndex];
        selectOption(option);
      }
    };
    var onKeyUp = function onKeyUp2(event2) {
      var key2 = event2.key, which = event2.which;
      var prevMeasureText = state.measureText, measuring = state.measuring;
      var prefix = props3.prefix, validateSearch2 = props3.validateSearch;
      var target = event2.target;
      if (target.composing) {
        return;
      }
      var selectionStartText = getBeforeSelectionText(target);
      var _getLastMeasureIndex = getLastMeasureIndex(selectionStartText, prefix), measureIndex = _getLastMeasureIndex.location, measurePrefix = _getLastMeasureIndex.prefix;
      if ([KeyCode$1.ESC, KeyCode$1.UP, KeyCode$1.DOWN, KeyCode$1.ENTER].indexOf(which) !== -1) {
        return;
      }
      if (measureIndex !== -1) {
        var measureText = selectionStartText.slice(measureIndex + measurePrefix.length);
        var validateMeasure = validateSearch2(measureText, props3);
        var matchOption = !!getOptions2(measureText).length;
        if (validateMeasure) {
          if (key2 === measurePrefix || key2 === "Shift" || measuring || measureText !== prevMeasureText && matchOption) {
            startMeasure(measureText, measurePrefix, measureIndex);
          }
        } else if (measuring) {
          stopMeasure();
        }
        if (validateMeasure) {
          emit("search", measureText, measurePrefix);
        }
      } else if (measuring) {
        stopMeasure();
      }
    };
    var onPressEnter = function onPressEnter2(event2) {
      if (!state.measuring) {
        emit("pressenter", event2);
      }
    };
    var onInputFocus = function onInputFocus2(event2) {
      onFocus2(event2);
    };
    var onInputBlur = function onInputBlur2(event2) {
      onBlur2(event2);
    };
    var onFocus2 = function onFocus3(event2) {
      clearTimeout(focusId.value);
      var isFocus = state.isFocus;
      if (!isFocus && event2) {
        emit("focus", event2);
      }
      state.isFocus = true;
    };
    var onBlur2 = function onBlur3(event2) {
      focusId.value = setTimeout(function() {
        state.isFocus = false;
        stopMeasure();
        emit("blur", event2);
      }, 100);
    };
    var selectOption = function selectOption2(option) {
      var split2 = props3.split;
      var _option$value = option.value, mentionValue = _option$value === void 0 ? "" : _option$value;
      var _replaceWithMeasure = replaceWithMeasure(state.value, {
        measureLocation: state.measureLocation,
        targetText: mentionValue,
        prefix: state.measurePrefix,
        selectionStart: textarea.value.selectionStart,
        split: split2
      }), text = _replaceWithMeasure.text, selectionLocation = _replaceWithMeasure.selectionLocation;
      triggerChange(text);
      stopMeasure(function() {
        setInputSelection(textarea.value, selectionLocation);
      });
      emit("select", option, state.measurePrefix);
    };
    var setActiveIndex = function setActiveIndex2(activeIndex) {
      state.activeIndex = activeIndex;
    };
    var getOptions2 = function getOptions3(measureText) {
      var targetMeasureText = measureText || state.measureText || "";
      var filterOption2 = props3.filterOption;
      var list = props3.options.filter(function(option) {
        if (!!filterOption2 === false) {
          return true;
        }
        return filterOption2(targetMeasureText, option);
      });
      return list;
    };
    var options = computed(function() {
      return getOptions2();
    });
    var focus = function focus2() {
      textarea.value.focus();
    };
    var blur = function blur2() {
      textarea.value.blur();
    };
    expose({
      blur,
      focus
    });
    provide(MentionsContextKey$1, {
      activeIndex: toRef(state, "activeIndex"),
      setActiveIndex,
      selectOption,
      onFocus: onFocus2,
      onBlur: onBlur2,
      loading: toRef(props3, "loading")
    });
    onUpdated(function() {
      nextTick(function() {
        if (state.measuring) {
          measure2.value.scrollTop = textarea.value.scrollTop;
        }
      });
    });
    return function() {
      var measureLocation = state.measureLocation, measurePrefix = state.measurePrefix, measuring = state.measuring;
      var prefixCls = props3.prefixCls, placement = props3.placement, transitionName2 = props3.transitionName, getPopupContainer = props3.getPopupContainer, direction = props3.direction, restProps = _objectWithoutProperties$2(props3, _excluded$o);
      var className = attrs.class, style2 = attrs.style, otherAttrs = _objectWithoutProperties$2(attrs, _excluded2$3);
      var inputProps3 = omit$2(restProps, ["value", "prefix", "split", "validateSearch", "filterOption", "options", "loading"]);
      var textareaProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, inputProps3), otherAttrs), {}, {
        onChange: noop$5,
        onSelect: noop$5,
        value: state.value,
        onInput: onChange3,
        onBlur: onInputBlur,
        onKeydown: onKeyDown,
        onKeyup: onKeyUp,
        onFocus: onInputFocus,
        onPressenter: onPressEnter
      });
      return createVNode("div", {
        "class": classNames(prefixCls, className),
        "style": style2
      }, [withDirectives(createVNode("textarea", _objectSpread2$1({
        "ref": textarea
      }, textareaProps), null), [[antInputDirective]]), measuring && createVNode("div", {
        "ref": measure2,
        "class": "".concat(prefixCls, "-measure")
      }, [state.value.slice(0, measureLocation), createVNode(KeywordTrigger, {
        "prefixCls": prefixCls,
        "transitionName": transitionName2,
        "placement": placement,
        "options": measuring ? options.value : [],
        "visible": true,
        "direction": direction,
        "getPopupContainer": getPopupContainer
      }, {
        default: function _default9() {
          return [createVNode("span", null, [measurePrefix])];
        },
        notFoundContent: slots.notFoundContent,
        option: slots.option
      }), state.value.slice(measureLocation + measurePrefix.length)])]);
    };
  }
});
var optionProps = {
  value: String,
  disabled: Boolean,
  label: [String, Number, Function]
};
const Option$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Option",
  props: optionProps,
  render: function render8(_props, _ref) {
    var _slots$default;
    var slots = _ref.slots;
    return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
  }
});
var _excluded$n = ["disabled", "getPopupContainer", "rows", "id"], _excluded2$2 = ["class"];
var getMentions = function getMentions2() {
  var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _config$prefix = config.prefix, prefix = _config$prefix === void 0 ? "@" : _config$prefix, _config$split = config.split, split2 = _config$split === void 0 ? " " : _config$split;
  var prefixList = Array.isArray(prefix) ? prefix : [prefix];
  return value.split(split2).map(function() {
    var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var hitPrefix = null;
    prefixList.some(function(prefixStr) {
      var startStr = str.slice(0, prefixStr.length);
      if (startStr === prefixStr) {
        hitPrefix = prefixStr;
        return true;
      }
      return false;
    });
    if (hitPrefix !== null) {
      return {
        prefix: hitPrefix,
        value: str.slice(hitPrefix.length)
      };
    }
    return null;
  }).filter(function(entity) {
    return !!entity && !!entity.value;
  });
};
var mentionsProps = function mentionsProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, mentionsProps$1), {}, {
    loading: {
      type: Boolean,
      default: void 0
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onSelect: {
      type: Function
    },
    onChange: {
      type: Function
    },
    onPressenter: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    },
    notFoundContent: PropTypes$1.any,
    defaultValue: String,
    id: String
  });
};
var Mentions = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AMentions",
  inheritAttrs: false,
  props: mentionsProps(),
  slots: ["notFoundContent", "option"],
  setup: function setup144(props3, _ref) {
    var _ref2, _props$value;
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var _useConfigInject = useConfigInject("mentions", props3), prefixCls = _useConfigInject.prefixCls, renderEmpty2 = _useConfigInject.renderEmpty, direction = _useConfigInject.direction;
    var focused = ref(false);
    var vcMentions = ref(null);
    var value = ref((_ref2 = (_props$value = props3.value) !== null && _props$value !== void 0 ? _props$value : props3.defaultValue) !== null && _ref2 !== void 0 ? _ref2 : "");
    var formItemContext = useInjectFormItemContext();
    watch(function() {
      return props3.value;
    }, function(val) {
      value.value = val;
    });
    var handleFocus = function handleFocus2(e2) {
      focused.value = true;
      emit("focus", e2);
    };
    var handleBlur = function handleBlur2(e2) {
      focused.value = false;
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    var handleSelect = function handleSelect2() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      emit.apply(void 0, ["select"].concat(args2));
      focused.value = true;
    };
    var handleChange2 = function handleChange3(val) {
      if (props3.value === void 0) {
        value.value = val;
      }
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    var getNotFoundContent = function getNotFoundContent2() {
      var notFoundContent = props3.notFoundContent;
      if (notFoundContent !== void 0) {
        return notFoundContent;
      }
      if (slots.notFoundContent) {
        return slots.notFoundContent();
      }
      return renderEmpty2.value("Select");
    };
    var getOptions2 = function getOptions3() {
      var _slots$default;
      return flattenChildren(((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)) || []).map(function(item) {
        var _item$children, _item$children$defaul;
        return _objectSpread2$1(_objectSpread2$1({}, getOptionProps(item)), {}, {
          label: (_item$children = item.children) === null || _item$children === void 0 ? void 0 : (_item$children$defaul = _item$children.default) === null || _item$children$defaul === void 0 ? void 0 : _item$children$defaul.call(_item$children)
        });
      });
    };
    var focus = function focus2() {
      vcMentions.value.focus();
    };
    var blur = function blur2() {
      vcMentions.value.blur();
    };
    expose({
      focus,
      blur
    });
    return function() {
      var _classNames;
      var disabled = props3.disabled, getPopupContainer = props3.getPopupContainer, _props$rows = props3.rows, rows = _props$rows === void 0 ? 1 : _props$rows, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = _objectWithoutProperties$2(props3, _excluded$n);
      var className = attrs.class, otherAttrs = _objectWithoutProperties$2(attrs, _excluded2$2);
      var otherProps = omit$2(restProps, ["defaultValue", "onUpdate:value", "prefixCls"]);
      var mergedClassName = classNames(className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-focused"), focused.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
      var mentionsProps3 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        prefixCls: prefixCls.value
      }, otherProps), {}, {
        disabled,
        direction: direction.value,
        filterOption: props3.filterOption,
        getPopupContainer,
        options: props3.options || getOptions2(),
        class: mergedClassName
      }, otherAttrs), {}, {
        rows,
        onChange: handleChange2,
        onSelect: handleSelect,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ref: vcMentions,
        value: value.value,
        id
      });
      return createVNode(Mentions$1, mentionsProps3, {
        notFoundContent: getNotFoundContent,
        option: slots.option
      });
    };
  }
});
var MentionsOption = defineComponent(_objectSpread2$1(_objectSpread2$1({
  compatConfig: {
    MODE: 3
  }
}, Option$1), {}, {
  name: "AMentionsOption",
  props: optionProps
}));
const index$c = _extends$1(Mentions, {
  Option: MentionsOption,
  getMentions,
  install: function install5(app) {
    app.component(Mentions.name, Mentions);
    app.component(MentionsOption.name, MentionsOption);
    return app;
  }
});
var _excluded$m = ["prefixCls", "visible", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"];
var mousePosition = null;
var getClickPosition = function getClickPosition2(e2) {
  mousePosition = {
    x: e2.pageX,
    y: e2.pageY
  };
  setTimeout(function() {
    return mousePosition = null;
  }, 100);
};
if (canUseDocElement()) {
  addEventListenerWrap(document.documentElement, "click", getClickPosition, true);
}
var modalProps = function modalProps2() {
  return {
    prefixCls: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    confirmLoading: {
      type: Boolean,
      default: void 0
    },
    title: PropTypes$1.any,
    closable: {
      type: Boolean,
      default: void 0
    },
    closeIcon: PropTypes$1.any,
    onOk: Function,
    onCancel: Function,
    "onUpdate:visible": Function,
    onChange: Function,
    afterClose: Function,
    centered: {
      type: Boolean,
      default: void 0
    },
    width: [String, Number],
    footer: PropTypes$1.any,
    okText: PropTypes$1.any,
    okType: String,
    cancelText: PropTypes$1.any,
    icon: PropTypes$1.any,
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    okButtonProps: Object,
    cancelButtonProps: Object,
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    wrapClassName: String,
    maskTransitionName: String,
    transitionName: String,
    getContainer: {
      type: [String, Function, Boolean, Object],
      default: void 0
    },
    zIndex: Number,
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    keyboard: {
      type: Boolean,
      default: void 0
    },
    wrapProps: Object,
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    modalRender: Function
  };
};
var destroyFns = [];
const Modal = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AModal",
  inheritAttrs: false,
  props: initDefaultProps$1(modalProps(), {
    width: 520,
    transitionName: "zoom",
    maskTransitionName: "fade",
    confirmLoading: false,
    visible: false,
    okType: "primary"
  }),
  setup: function setup145(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots, attrs = _ref.attrs;
    var _useLocaleReceiver = useLocaleReceiver("Modal"), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var _useConfigInject = useConfigInject("modal", props3), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer;
    var handleCancel = function handleCancel2(e2) {
      emit("update:visible", false);
      emit("cancel", e2);
      emit("change", false);
    };
    var handleOk = function handleOk2(e2) {
      emit("ok", e2);
    };
    var renderFooter = function renderFooter2() {
      var _slots$okText, _slots$cancelText;
      var _props$okText = props3.okText, okText = _props$okText === void 0 ? (_slots$okText = slots.okText) === null || _slots$okText === void 0 ? void 0 : _slots$okText.call(slots) : _props$okText, okType = props3.okType, _props$cancelText = props3.cancelText, cancelText = _props$cancelText === void 0 ? (_slots$cancelText = slots.cancelText) === null || _slots$cancelText === void 0 ? void 0 : _slots$cancelText.call(slots) : _props$cancelText, confirmLoading = props3.confirmLoading;
      return createVNode(Fragment, null, [createVNode(Button$1, _objectSpread2$1({
        "onClick": handleCancel
      }, props3.cancelButtonProps), {
        default: function _default9() {
          return [cancelText || locale2.value.cancelText];
        }
      }), createVNode(Button$1, _objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(okType)), {}, {
        "loading": confirmLoading,
        "onClick": handleOk
      }, props3.okButtonProps), {
        default: function _default9() {
          return [okText || locale2.value.okText];
        }
      })]);
    };
    return function() {
      var _slots$closeIcon, _classNames;
      props3.prefixCls;
      var visible = props3.visible, wrapClassName = props3.wrapClassName, centered = props3.centered, getContainer4 = props3.getContainer, _props$closeIcon = props3.closeIcon, _closeIcon = _props$closeIcon === void 0 ? (_slots$closeIcon = slots.closeIcon) === null || _slots$closeIcon === void 0 ? void 0 : _slots$closeIcon.call(slots) : _props$closeIcon, _props$focusTriggerAf = props3.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, restProps = _objectWithoutProperties$2(props3, _excluded$m);
      var wrapClassNameExtended = classNames(wrapClassName, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-centered"), !!centered), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-wrap-rtl"), direction.value === "rtl"), _classNames));
      return createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
        "getContainer": getContainer4 || getPopupContainer.value,
        "prefixCls": prefixCls.value,
        "wrapClassName": wrapClassNameExtended,
        "visible": visible,
        "mousePosition": mousePosition,
        "onClose": handleCancel,
        "focusTriggerAfterClose": focusTriggerAfterClose,
        "transitionName": getTransitionName$2(rootPrefixCls.value, "zoom", props3.transitionName),
        "maskTransitionName": getTransitionName$2(rootPrefixCls.value, "fade", props3.maskTransitionName)
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        footer: slots.footer || renderFooter,
        closeIcon: function closeIcon() {
          return createVNode("span", {
            "class": "".concat(prefixCls.value, "-close-x")
          }, [_closeIcon || createVNode(CloseOutlined$1, {
            "class": "".concat(prefixCls.value, "-close-icon")
          }, null)]);
        }
      }));
    };
  }
});
var useDestroyed = function useDestroyed2() {
  var destroyed = ref(false);
  onBeforeUnmount(function() {
    destroyed.value = true;
  });
  return destroyed;
};
const useDestroyed$1 = useDestroyed;
var actionButtonProps = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: Object,
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function isThenable(thing) {
  return !!(thing && !!thing.then);
}
const ActionButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ActionButton",
  props: actionButtonProps,
  setup: function setup146(props3, _ref) {
    var slots = _ref.slots;
    var clickedRef = ref(false);
    var buttonRef = ref();
    var loading = ref(false);
    var timeoutId;
    var isDestroyed = useDestroyed$1();
    onMounted(function() {
      if (props3.autofocus) {
        timeoutId = setTimeout(function() {
          var _buttonRef$value$$el;
          return (_buttonRef$value$$el = buttonRef.value.$el) === null || _buttonRef$value$$el === void 0 ? void 0 : _buttonRef$value$$el.focus();
        });
      }
    });
    onBeforeUnmount(function() {
      clearTimeout(timeoutId);
    });
    var handlePromiseOnOk = function handlePromiseOnOk2(returnValueOfOnOk) {
      var close3 = props3.close;
      if (!isThenable(returnValueOfOnOk)) {
        return;
      }
      loading.value = true;
      returnValueOfOnOk.then(function() {
        if (!isDestroyed.value) {
          loading.value = false;
        }
        close3.apply(void 0, arguments);
        clickedRef.value = false;
      }, function(e2) {
        console.error(e2);
        if (!isDestroyed.value) {
          loading.value = false;
        }
        clickedRef.value = false;
      });
    };
    var onClick2 = function onClick3(e2) {
      var actionFn = props3.actionFn, _props$close = props3.close, close3 = _props$close === void 0 ? function() {
      } : _props$close;
      if (clickedRef.value) {
        return;
      }
      clickedRef.value = true;
      if (!actionFn) {
        close3();
        return;
      }
      var returnValueOfOnOk;
      if (props3.emitEvent) {
        returnValueOfOnOk = actionFn(e2);
        if (props3.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
          clickedRef.value = false;
          close3(e2);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(close3);
        clickedRef.value = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!returnValueOfOnOk) {
          close3();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return function() {
      var type4 = props3.type, prefixCls = props3.prefixCls, buttonProps3 = props3.buttonProps;
      return createVNode(Button$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(type4)), {}, {
        "onClick": onClick2,
        "loading": loading.value,
        "prefixCls": prefixCls
      }, buttonProps3), {}, {
        "ref": buttonRef
      }), slots);
    };
  }
});
function renderSomeContent(someContent) {
  if (typeof someContent === "function") {
    return someContent();
  }
  return someContent;
}
const ConfirmDialog = defineComponent({
  name: "ConfirmDialog",
  inheritAttrs: false,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName"],
  setup: function setup147(props3, _ref) {
    var attrs = _ref.attrs;
    var _useLocaleReceiver = useLocaleReceiver("Modal"), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    return function() {
      var icon = props3.icon, onCancel = props3.onCancel, onOk = props3.onOk, close3 = props3.close, _props$closable = props3.closable, closable = _props$closable === void 0 ? false : _props$closable, zIndex = props3.zIndex, afterClose = props3.afterClose, visible = props3.visible, keyboard = props3.keyboard, centered = props3.centered, getContainer4 = props3.getContainer, maskStyle = props3.maskStyle, okButtonProps = props3.okButtonProps, cancelButtonProps = props3.cancelButtonProps, _props$okCancel = props3.okCancel, okCancel = _props$okCancel === void 0 ? true : _props$okCancel, _props$width = props3.width, width = _props$width === void 0 ? 416 : _props$width, _props$mask = props3.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props3.maskClosable, maskClosable = _props$maskClosable === void 0 ? false : _props$maskClosable, type4 = props3.type, title = props3.title, content = props3.content, direction = props3.direction, closeIcon = props3.closeIcon, modalRender = props3.modalRender, focusTriggerAfterClose = props3.focusTriggerAfterClose, rootPrefixCls = props3.rootPrefixCls, bodyStyle = props3.bodyStyle, wrapClassName = props3.wrapClassName;
      var okType = props3.okType || "primary";
      var prefixCls = props3.prefixCls || "ant-modal";
      var contentPrefixCls = "".concat(prefixCls, "-confirm");
      var style2 = attrs.style || {};
      var okText = renderSomeContent(props3.okText) || (okCancel ? locale2.value.okText : locale2.value.justOkText);
      var cancelText = renderSomeContent(props3.cancelText) || locale2.value.cancelText;
      var autoFocusButton = props3.autoFocusButton === null ? false : props3.autoFocusButton || "ok";
      var classString = classNames(contentPrefixCls, "".concat(contentPrefixCls, "-").concat(type4), "".concat(prefixCls, "-").concat(type4), _defineProperty$U({}, "".concat(contentPrefixCls, "-rtl"), direction === "rtl"), attrs.class);
      var cancelButton = okCancel && createVNode(ActionButton, {
        "actionFn": onCancel,
        "close": close3,
        "autofocus": autoFocusButton === "cancel",
        "buttonProps": cancelButtonProps,
        "prefixCls": "".concat(rootPrefixCls, "-btn")
      }, {
        default: function _default9() {
          return [cancelText];
        }
      });
      return createVNode(Modal, {
        "prefixCls": prefixCls,
        "class": classString,
        "wrapClassName": classNames(_defineProperty$U({}, "".concat(contentPrefixCls, "-centered"), !!centered), wrapClassName),
        "onCancel": function onCancel2(e2) {
          return close3({
            triggerCancel: true
          }, e2);
        },
        "visible": visible,
        "title": "",
        "footer": "",
        "transitionName": getTransitionName$2(rootPrefixCls, "zoom", props3.transitionName),
        "maskTransitionName": getTransitionName$2(rootPrefixCls, "fade", props3.maskTransitionName),
        "mask": mask,
        "maskClosable": maskClosable,
        "maskStyle": maskStyle,
        "style": style2,
        "bodyStyle": bodyStyle,
        "width": width,
        "zIndex": zIndex,
        "afterClose": afterClose,
        "keyboard": keyboard,
        "centered": centered,
        "getContainer": getContainer4,
        "closable": closable,
        "closeIcon": closeIcon,
        "modalRender": modalRender,
        "focusTriggerAfterClose": focusTriggerAfterClose
      }, {
        default: function _default9() {
          return [createVNode("div", {
            "class": "".concat(contentPrefixCls, "-body-wrapper")
          }, [createVNode("div", {
            "class": "".concat(contentPrefixCls, "-body")
          }, [renderSomeContent(icon), title === void 0 ? null : createVNode("span", {
            "class": "".concat(contentPrefixCls, "-title")
          }, [renderSomeContent(title)]), createVNode("div", {
            "class": "".concat(contentPrefixCls, "-content")
          }, [renderSomeContent(content)])]), createVNode("div", {
            "class": "".concat(contentPrefixCls, "-btns")
          }, [cancelButton, createVNode(ActionButton, {
            "type": okType,
            "actionFn": onOk,
            "close": close3,
            "autofocus": autoFocusButton === "ok",
            "buttonProps": okButtonProps,
            "prefixCls": "".concat(rootPrefixCls, "-btn")
          }, {
            default: function _default10() {
              return [okText];
            }
          })])])];
        }
      });
    };
  }
});
var confirm = function confirm2(config) {
  var container = document.createDocumentFragment();
  var currentConfig = _objectSpread2$1(_objectSpread2$1({}, omit$2(config, ["parentContext", "appContext"])), {}, {
    close: close3,
    visible: true
  });
  var confirmDialogInstance = null;
  function destroy3() {
    if (confirmDialogInstance) {
      render$a(null, container);
      confirmDialogInstance.component.update();
      confirmDialogInstance = null;
    }
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    var triggerCancel = args2.some(function(param) {
      return param && param.triggerCancel;
    });
    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, args2);
    }
    for (var i2 = 0; i2 < destroyFns.length; i2++) {
      var fn = destroyFns[i2];
      if (fn === close3) {
        destroyFns.splice(i2, 1);
        break;
      }
    }
  }
  function close3() {
    var _this = this;
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }
    currentConfig = _objectSpread2$1(_objectSpread2$1({}, currentConfig), {}, {
      visible: false,
      afterClose: function afterClose() {
        if (typeof config.afterClose === "function") {
          config.afterClose();
        }
        destroy3.apply(_this, args2);
      }
    });
    update(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === "function") {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = _objectSpread2$1(_objectSpread2$1({}, currentConfig), configUpdate);
    }
    if (confirmDialogInstance) {
      _extends$1(confirmDialogInstance.component.props, currentConfig);
      confirmDialogInstance.component.update();
    }
  }
  var Wrapper = function Wrapper2(p2) {
    var global2 = globalConfigForApi;
    var rootPrefixCls = global2.prefixCls;
    var prefixCls = p2.prefixCls || "".concat(rootPrefixCls, "-modal");
    return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
      "notUpdateGlobalConfig": true,
      "prefixCls": rootPrefixCls
    }), {
      default: function _default9() {
        return [createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({}, p2), {}, {
          "rootPrefixCls": rootPrefixCls,
          "prefixCls": prefixCls
        }), null)];
      }
    });
  };
  function render14(props3) {
    var vm = createVNode(Wrapper, _objectSpread2$1({}, props3));
    vm.appContext = config.parentContext || config.appContext || vm.appContext;
    render$a(vm, container);
    return vm;
  }
  confirmDialogInstance = render14(currentConfig);
  destroyFns.push(close3);
  return {
    destroy: close3,
    update
  };
};
const confirm$1 = confirm;
function withWarn(props3) {
  return _objectSpread2$1(_objectSpread2$1({
    icon: function icon() {
      return createVNode(ExclamationCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props3), {}, {
    type: "warning"
  });
}
function withInfo(props3) {
  return _objectSpread2$1(_objectSpread2$1({
    icon: function icon() {
      return createVNode(InfoCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props3), {}, {
    type: "info"
  });
}
function withSuccess(props3) {
  return _objectSpread2$1(_objectSpread2$1({
    icon: function icon() {
      return createVNode(CheckCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props3), {}, {
    type: "success"
  });
}
function withError(props3) {
  return _objectSpread2$1(_objectSpread2$1({
    icon: function icon() {
      return createVNode(CloseCircleOutlined$1, null, null);
    },
    okCancel: false
  }, props3), {}, {
    type: "error"
  });
}
function withConfirm(props3) {
  return _objectSpread2$1(_objectSpread2$1({
    icon: function icon() {
      return createVNode(ExclamationCircleOutlined$1, null, null);
    },
    okCancel: true
  }, props3), {}, {
    type: "confirm"
  });
}
function modalWarn(props3) {
  return confirm$1(withWarn(props3));
}
Modal.info = function infoFn(props3) {
  return confirm$1(withInfo(props3));
};
Modal.success = function successFn(props3) {
  return confirm$1(withSuccess(props3));
};
Modal.error = function errorFn(props3) {
  return confirm$1(withError(props3));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props3) {
  return confirm$1(withConfirm(props3));
};
Modal.destroyAll = function destroyAllFn() {
  while (destroyFns.length) {
    var close3 = destroyFns.pop();
    if (close3) {
      close3();
    }
  }
};
Modal.install = function(app) {
  app.component(Modal.name, Modal);
  return app;
};
function padEnd(string3, length, chars) {
  string3 = toString$1(string3);
  length = toInteger(length);
  var strLength = length ? stringSize(string3) : 0;
  return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
}
var StatisticNumber = function StatisticNumber2(props3) {
  var value = props3.value, formatter = props3.formatter, precision = props3.precision, decimalSeparator = props3.decimalSeparator, _props$groupSeparator = props3.groupSeparator, groupSeparator = _props$groupSeparator === void 0 ? "" : _props$groupSeparator, prefixCls = props3.prefixCls;
  var valueNode;
  if (typeof formatter === "function") {
    valueNode = formatter({
      value
    });
  } else {
    var val = String(value);
    var cells = val.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!cells) {
      valueNode = val;
    } else {
      var negative = cells[1];
      var int = cells[2] || "0";
      var decimal = cells[4] || "";
      int = int.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
      if (typeof precision === "number") {
        decimal = padEnd(decimal, precision, "0").slice(0, precision);
      }
      if (decimal) {
        decimal = "".concat(decimalSeparator).concat(decimal);
      }
      valueNode = [createVNode("span", {
        "key": "int",
        "class": "".concat(prefixCls, "-content-value-int")
      }, [negative, int]), decimal && createVNode("span", {
        "key": "decimal",
        "class": "".concat(prefixCls, "-content-value-decimal")
      }, [decimal])];
    }
  }
  return createVNode("span", {
    "class": "".concat(prefixCls, "-content-value")
  }, [valueNode]);
};
StatisticNumber.displayName = "StatisticNumber";
const StatisticNumber$1 = StatisticNumber;
var skeletonTitleProps = function skeletonTitleProps2() {
  return {
    prefixCls: String,
    width: {
      type: [Number, String]
    }
  };
};
var SkeletonTitle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonTitle",
  props: skeletonTitleProps(),
  setup: function setup148(props3) {
    return function() {
      var prefixCls = props3.prefixCls, width = props3.width;
      var zWidth = typeof width === "number" ? "".concat(width, "px") : width;
      return createVNode("h3", {
        "class": prefixCls,
        "style": {
          width: zWidth
        }
      }, null);
    };
  }
});
const SkeletonTitle$1 = SkeletonTitle;
var skeletonParagraphProps = function skeletonParagraphProps2() {
  return {
    prefixCls: String,
    width: {
      type: [Number, String, Array]
    },
    rows: Number
  };
};
var SkeletonParagraph = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonParagraph",
  props: skeletonParagraphProps(),
  setup: function setup149(props3) {
    var getWidth3 = function getWidth4(index2) {
      var width = props3.width, _props$rows = props3.rows, rows = _props$rows === void 0 ? 2 : _props$rows;
      if (Array.isArray(width)) {
        return width[index2];
      }
      if (rows - 1 === index2) {
        return width;
      }
      return void 0;
    };
    return function() {
      var prefixCls = props3.prefixCls, rows = props3.rows;
      var rowList = _toConsumableArray(Array(rows)).map(function(_2, index2) {
        var width = getWidth3(index2);
        return createVNode("li", {
          "key": index2,
          "style": {
            width: typeof width === "number" ? "".concat(width, "px") : width
          }
        }, null);
      });
      return createVNode("ul", {
        "class": prefixCls
      }, [rowList]);
    };
  }
});
const Paragraph$2 = SkeletonParagraph;
var skeletonElementProps = function skeletonElementProps2() {
  return {
    prefixCls: String,
    size: [String, Number],
    shape: String,
    active: {
      type: Boolean,
      default: void 0
    }
  };
};
var Element$1 = function Element2(props3) {
  var _classNames, _classNames2;
  var prefixCls = props3.prefixCls, size2 = props3.size, shape = props3.shape;
  var sizeCls = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-lg"), size2 === "large"), _defineProperty$U(_classNames, "".concat(prefixCls, "-sm"), size2 === "small"), _classNames));
  var shapeCls = classNames((_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls, "-circle"), shape === "circle"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-square"), shape === "square"), _defineProperty$U(_classNames2, "".concat(prefixCls, "-round"), shape === "round"), _classNames2));
  var sizeStyle = typeof size2 === "number" ? {
    width: "".concat(size2, "px"),
    height: "".concat(size2, "px"),
    lineHeight: "".concat(size2, "px")
  } : {};
  return createVNode("span", {
    "class": classNames(prefixCls, sizeCls, shapeCls),
    "style": sizeStyle
  }, null);
};
Element$1.displayName = "SkeletonElement";
const Element$2 = Element$1;
var skeletonProps = function skeletonProps2() {
  return {
    active: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    avatar: {
      type: [Boolean, Object],
      default: void 0
    },
    title: {
      type: [Boolean, Object],
      default: void 0
    },
    paragraph: {
      type: [Boolean, Object],
      default: void 0
    },
    round: {
      type: Boolean,
      default: void 0
    }
  };
};
function getComponentProps(prop) {
  if (prop && _typeof$3(prop) === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  var basicProps3 = {};
  if (!hasAvatar || !hasTitle) {
    basicProps3.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps3.rows = 3;
  } else {
    basicProps3.rows = 2;
  }
  return basicProps3;
}
var Skeleton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeleton",
  props: initDefaultProps$1(skeletonProps(), {
    avatar: false,
    title: true,
    paragraph: true
  }),
  setup: function setup150(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("skeleton", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    return function() {
      var _slots$default;
      var loading = props3.loading, avatar = props3.avatar, title = props3.title, paragraph = props3.paragraph, active = props3.active, round = props3.round;
      var pre = prefixCls.value;
      if (loading || props3.loading === void 0) {
        var _classNames;
        var hasAvatar = !!avatar || avatar === "";
        var hasTitle = !!title || title === "";
        var hasParagraph = !!paragraph || paragraph === "";
        var avatarNode;
        if (hasAvatar) {
          var avatarProps4 = _objectSpread2$1(_objectSpread2$1({
            prefixCls: "".concat(pre, "-avatar")
          }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
          avatarNode = createVNode("div", {
            "class": "".concat(pre, "-header")
          }, [createVNode(Element$2, avatarProps4, null)]);
        }
        var contentNode;
        if (hasTitle || hasParagraph) {
          var $title;
          if (hasTitle) {
            var titleProps3 = _objectSpread2$1(_objectSpread2$1({
              prefixCls: "".concat(pre, "-title")
            }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
            $title = createVNode(SkeletonTitle$1, titleProps3, null);
          }
          var paragraphNode;
          if (hasParagraph) {
            var paragraphProps3 = _objectSpread2$1(_objectSpread2$1({
              prefixCls: "".concat(pre, "-paragraph")
            }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
            paragraphNode = createVNode(Paragraph$2, paragraphProps3, null);
          }
          contentNode = createVNode("div", {
            "class": "".concat(pre, "-content")
          }, [$title, paragraphNode]);
        }
        var cls = classNames(pre, (_classNames = {}, _defineProperty$U(_classNames, "".concat(pre, "-with-avatar"), hasAvatar), _defineProperty$U(_classNames, "".concat(pre, "-active"), active), _defineProperty$U(_classNames, "".concat(pre, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(pre, "-round"), round), _classNames));
        return createVNode("div", {
          "class": cls
        }, [avatarNode, contentNode]);
      }
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
const Skeleton$1 = Skeleton;
var statisticProps = function statisticProps2() {
  return {
    prefixCls: String,
    decimalSeparator: String,
    groupSeparator: String,
    format: String,
    value: {
      type: [String, Number, Object]
    },
    valueStyle: {
      type: Object,
      default: void 0
    },
    valueRender: PropTypes$1.any,
    formatter: PropTypes$1.any,
    precision: Number,
    prefix: PropTypes$1.any,
    suffix: PropTypes$1.any,
    title: PropTypes$1.any,
    loading: {
      type: Boolean,
      default: void 0
    }
  };
};
const Statistic = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AStatistic",
  props: initDefaultProps$1(statisticProps(), {
    decimalSeparator: ".",
    groupSeparator: ",",
    loading: false
  }),
  slots: ["title", "prefix", "suffix", "formatter"],
  setup: function setup151(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("statistic", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    return function() {
      var _props$title, _slots$title, _props$prefix, _slots$prefix, _props$suffix, _slots$suffix, _props$formatter;
      var _props$value = props3.value, value = _props$value === void 0 ? 0 : _props$value, valueStyle = props3.valueStyle, valueRender = props3.valueRender;
      var pre = prefixCls.value;
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
      var prefix = (_props$prefix = props3.prefix) !== null && _props$prefix !== void 0 ? _props$prefix : (_slots$prefix = slots.prefix) === null || _slots$prefix === void 0 ? void 0 : _slots$prefix.call(slots);
      var suffix = (_props$suffix = props3.suffix) !== null && _props$suffix !== void 0 ? _props$suffix : (_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots);
      var formatter = (_props$formatter = props3.formatter) !== null && _props$formatter !== void 0 ? _props$formatter : slots.formatter;
      var valueNode = createVNode(StatisticNumber$1, _objectSpread2$1({
        "data-for-update": Date.now()
      }, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        prefixCls: pre,
        value,
        formatter
      })), null);
      if (valueRender) {
        valueNode = valueRender(valueNode);
      }
      return createVNode("div", {
        "class": [pre, _defineProperty$U({}, "".concat(pre, "-rtl"), direction.value === "rtl")]
      }, [title && createVNode("div", {
        "class": "".concat(pre, "-title")
      }, [title]), createVNode(Skeleton$1, {
        "paragraph": false,
        "loading": props3.loading
      }, {
        default: function _default9() {
          return [createVNode("div", {
            "style": valueStyle,
            "class": "".concat(pre, "-content")
          }, [prefix && createVNode("span", {
            "class": "".concat(pre, "-content-prefix")
          }, [prefix]), valueNode, suffix && createVNode("span", {
            "class": "".concat(pre, "-content-suffix")
          }, [suffix])])];
        }
      })]);
    };
  }
});
var timeUnits = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
];
function formatTimeStr(duration, format5) {
  var leftDuration = duration;
  var escapeRegex = /\[[^\]]*]/g;
  var keepList = (format5.match(escapeRegex) || []).map(function(str) {
    return str.slice(1, -1);
  });
  var templateText = format5.replace(escapeRegex, "[]");
  var replacedText = timeUnits.reduce(function(current2, _ref) {
    var _ref2 = _slicedToArray$2(_ref, 2), name2 = _ref2[0], unit = _ref2[1];
    if (current2.indexOf(name2) !== -1) {
      var value = Math.floor(leftDuration / unit);
      leftDuration -= value * unit;
      return current2.replace(new RegExp("".concat(name2, "+"), "g"), function(match2) {
        var len = match2.length;
        return padStart(value.toString(), len, "0");
      });
    }
    return current2;
  }, templateText);
  var index2 = 0;
  return replacedText.replace(escapeRegex, function() {
    var match2 = keepList[index2];
    index2 += 1;
    return match2;
  });
}
function formatCountdown(value, config) {
  var _config$format = config.format, format5 = _config$format === void 0 ? "" : _config$format;
  var target = new Date(value).getTime();
  var current2 = Date.now();
  var diff2 = Math.max(target - current2, 0);
  return formatTimeStr(diff2, format5);
}
var REFRESH_INTERVAL = 1e3 / 30;
function getTime(value) {
  return new Date(value).getTime();
}
var countdownProps = function countdownProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, statisticProps()), {}, {
    value: [Number, String, Object],
    format: String,
    onFinish: Function,
    onChange: Function
  });
};
const Countdown = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AStatisticCountdown",
  props: initDefaultProps$1(countdownProps(), {
    format: "HH:mm:ss"
  }),
  setup: function setup152(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var countdownId = ref();
    var statistic = ref();
    var syncTimer = function syncTimer2() {
      var value = props3.value;
      var timestamp = getTime(value);
      if (timestamp >= Date.now()) {
        startTimer();
      } else {
        stopTimer();
      }
    };
    var startTimer = function startTimer2() {
      if (countdownId.value)
        return;
      var timestamp = getTime(props3.value);
      countdownId.value = setInterval(function() {
        statistic.value.$forceUpdate();
        if (timestamp > Date.now()) {
          emit("change", timestamp - Date.now());
        }
        syncTimer();
      }, REFRESH_INTERVAL);
    };
    var stopTimer = function stopTimer2() {
      var value = props3.value;
      if (countdownId.value) {
        clearInterval(countdownId.value);
        countdownId.value = void 0;
        var timestamp = getTime(value);
        if (timestamp < Date.now()) {
          emit("finish");
        }
      }
    };
    var formatCountdown$1 = function formatCountdown$12(_ref2) {
      var value = _ref2.value, config = _ref2.config;
      var format5 = props3.format;
      return formatCountdown(value, _objectSpread2$1(_objectSpread2$1({}, config), {}, {
        format: format5
      }));
    };
    var valueRenderHtml = function valueRenderHtml2(node) {
      return node;
    };
    onMounted(function() {
      syncTimer();
    });
    onUpdated(function() {
      syncTimer();
    });
    onBeforeUnmount(function() {
      stopTimer();
    });
    return function() {
      var value = props3.value;
      return createVNode(Statistic, _objectSpread2$1({
        "ref": statistic
      }, _objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["onFinish", "onChange"])), {}, {
        value,
        valueRender: valueRenderHtml,
        formatter: formatCountdown$1
      })), slots);
    };
  }
});
Statistic.Countdown = Countdown;
Statistic.install = function(app) {
  app.component(Statistic.name, Statistic);
  app.component(Statistic.Countdown.name, Statistic.Countdown);
  return app;
};
var StatisticCountdown = Statistic.Countdown;
var ArrowLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "arrow-left", "theme": "outlined" };
const ArrowLeftOutlinedSvg = ArrowLeftOutlined$2;
function _objectSpread$k(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$k(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$k(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ArrowLeftOutlined = function ArrowLeftOutlined2(props3, context2) {
  var p2 = _objectSpread$k({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$k({}, p2, {
    "icon": ArrowLeftOutlinedSvg
  }), null);
};
ArrowLeftOutlined.displayName = "ArrowLeftOutlined";
ArrowLeftOutlined.inheritAttrs = false;
const ArrowLeftOutlined$1 = ArrowLeftOutlined;
var ArrowRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" } }] }, "name": "arrow-right", "theme": "outlined" };
const ArrowRightOutlinedSvg = ArrowRightOutlined$2;
function _objectSpread$j(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$j(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$j(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var ArrowRightOutlined = function ArrowRightOutlined2(props3, context2) {
  var p2 = _objectSpread$j({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$j({}, p2, {
    "icon": ArrowRightOutlinedSvg
  }), null);
};
ArrowRightOutlined.displayName = "ArrowRightOutlined";
ArrowRightOutlined.inheritAttrs = false;
const ArrowRightOutlined$1 = ArrowRightOutlined;
var _excluded$l = ["noStyle", "disabled"];
var inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
var TransButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TransButton",
  inheritAttrs: false,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup: function setup153(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, attrs = _ref.attrs, expose = _ref.expose;
    var domRef = ref();
    var onKeyDown = function onKeyDown2(event2) {
      var keyCode = event2.keyCode;
      if (keyCode === KeyCode$1.ENTER) {
        event2.preventDefault();
      }
    };
    var onKeyUp = function onKeyUp2(event2) {
      var keyCode = event2.keyCode;
      if (keyCode === KeyCode$1.ENTER) {
        emit("click", event2);
      }
    };
    var onClick2 = function onClick3(e2) {
      emit("click", e2);
    };
    var focus = function focus2() {
      if (domRef.value) {
        domRef.value.focus();
      }
    };
    var blur = function blur2() {
      if (domRef.value) {
        domRef.value.blur();
      }
    };
    onMounted(function() {
      if (props3.autofocus) {
        focus();
      }
    });
    expose({
      focus,
      blur
    });
    return function() {
      var _slots$default;
      var noStyle = props3.noStyle, disabled = props3.disabled, restProps = _objectWithoutProperties$2(props3, _excluded$l);
      var mergedStyle = {};
      if (!noStyle) {
        mergedStyle = _objectSpread2$1({}, inlineStyle);
      }
      if (disabled) {
        mergedStyle.pointerEvents = "none";
      }
      return createVNode("div", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "role": "button",
        "tabindex": 0,
        "ref": domRef
      }, restProps), attrs), {}, {
        "onClick": onClick2,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp,
        "style": _objectSpread2$1(_objectSpread2$1({}, mergedStyle), attrs.style || {})
      }), [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const TransButton$1 = TransButton;
var pageHeaderProps = function pageHeaderProps2() {
  return {
    backIcon: PropTypes$1.any,
    prefixCls: String,
    title: PropTypes$1.any,
    subTitle: PropTypes$1.any,
    breadcrumb: PropTypes$1.object,
    tags: PropTypes$1.any,
    footer: PropTypes$1.any,
    extra: PropTypes$1.any,
    avatar: PropTypes$1.object,
    ghost: {
      type: Boolean,
      default: void 0
    },
    onBack: Function
  };
};
var PageHeader = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APageHeader",
  props: pageHeaderProps(),
  slots: ["backIcon", "avatar", "breadcrumb", "title", "subTitle", "tags", "extra", "footer"],
  setup: function setup154(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var _useConfigInject = useConfigInject("page-header", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, pageHeader = _useConfigInject.pageHeader;
    var compact3 = ref(false);
    var isDestroyed = useDestroyed$1();
    var onResize = function onResize2(_ref2) {
      var width = _ref2.width;
      if (!isDestroyed.value) {
        compact3.value = width < 768;
      }
    };
    var ghost = computed(function() {
      var _ref3, _props$ghost, _pageHeader$value;
      return (_ref3 = (_props$ghost = props3.ghost) !== null && _props$ghost !== void 0 ? _props$ghost : (_pageHeader$value = pageHeader.value) === null || _pageHeader$value === void 0 ? void 0 : _pageHeader$value.ghost) !== null && _ref3 !== void 0 ? _ref3 : true;
    });
    var getBackIcon = function getBackIcon2() {
      var _ref4, _props$backIcon, _slots$backIcon;
      return (_ref4 = (_props$backIcon = props3.backIcon) !== null && _props$backIcon !== void 0 ? _props$backIcon : (_slots$backIcon = slots.backIcon) === null || _slots$backIcon === void 0 ? void 0 : _slots$backIcon.call(slots)) !== null && _ref4 !== void 0 ? _ref4 : direction.value === "rtl" ? createVNode(ArrowRightOutlined$1, null, null) : createVNode(ArrowLeftOutlined$1, null, null);
    };
    var renderBack = function renderBack2(backIcon) {
      if (!backIcon || !props3.onBack) {
        return null;
      }
      return createVNode(LocaleReceiver, {
        "componentName": "PageHeader",
        "children": function children(_ref5) {
          var back = _ref5.back;
          return createVNode("div", {
            "class": "".concat(prefixCls.value, "-back")
          }, [createVNode(TransButton$1, {
            "onClick": function onClick2(e2) {
              emit("back", e2);
            },
            "class": "".concat(prefixCls.value, "-back-button"),
            "aria-label": back
          }, {
            default: function _default9() {
              return [backIcon];
            }
          })]);
        }
      }, null);
    };
    var renderBreadcrumb = function renderBreadcrumb2() {
      var _slots$breadcrumb;
      return props3.breadcrumb ? createVNode(Breadcrumb$1, props3.breadcrumb, null) : (_slots$breadcrumb = slots.breadcrumb) === null || _slots$breadcrumb === void 0 ? void 0 : _slots$breadcrumb.call(slots);
    };
    var renderTitle = function renderTitle2() {
      var _props$title, _slots$title, _props$subTitle, _slots$subTitle, _props$tags, _slots$tags, _props$extra, _slots$extra, _slots$avatar;
      var avatar = props3.avatar;
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
      var subTitle = (_props$subTitle = props3.subTitle) !== null && _props$subTitle !== void 0 ? _props$subTitle : (_slots$subTitle = slots.subTitle) === null || _slots$subTitle === void 0 ? void 0 : _slots$subTitle.call(slots);
      var tags = (_props$tags = props3.tags) !== null && _props$tags !== void 0 ? _props$tags : (_slots$tags = slots.tags) === null || _slots$tags === void 0 ? void 0 : _slots$tags.call(slots);
      var extra = (_props$extra = props3.extra) !== null && _props$extra !== void 0 ? _props$extra : (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots);
      var headingPrefixCls = "".concat(prefixCls.value, "-heading");
      var hasHeading = title || subTitle || tags || extra;
      if (!hasHeading) {
        return null;
      }
      var backIcon = getBackIcon();
      var backIconDom = renderBack(backIcon);
      var hasTitle = backIconDom || avatar || hasHeading;
      return createVNode("div", {
        "class": headingPrefixCls
      }, [hasTitle && createVNode("div", {
        "class": "".concat(headingPrefixCls, "-left")
      }, [backIconDom, avatar ? createVNode(Avatar$1, avatar, null) : (_slots$avatar = slots.avatar) === null || _slots$avatar === void 0 ? void 0 : _slots$avatar.call(slots), title && createVNode("span", {
        "class": "".concat(headingPrefixCls, "-title"),
        "title": typeof title === "string" ? title : void 0
      }, [title]), subTitle && createVNode("span", {
        "class": "".concat(headingPrefixCls, "-sub-title"),
        "title": typeof subTitle === "string" ? subTitle : void 0
      }, [subTitle]), tags && createVNode("span", {
        "class": "".concat(headingPrefixCls, "-tags")
      }, [tags])]), extra && createVNode("span", {
        "class": "".concat(headingPrefixCls, "-extra")
      }, [extra])]);
    };
    var renderFooter = function renderFooter2() {
      var _props$footer, _slots$footer;
      var footer = (_props$footer = props3.footer) !== null && _props$footer !== void 0 ? _props$footer : filterEmpty((_slots$footer = slots.footer) === null || _slots$footer === void 0 ? void 0 : _slots$footer.call(slots));
      return isEmptyContent(footer) ? null : createVNode("div", {
        "class": "".concat(prefixCls.value, "-footer")
      }, [footer]);
    };
    var renderChildren2 = function renderChildren3(children) {
      return createVNode("div", {
        "class": "".concat(prefixCls.value, "-content")
      }, [children]);
    };
    return function() {
      var _props$breadcrumb, _slots$default, _classNames;
      var hasBreadcrumb = ((_props$breadcrumb = props3.breadcrumb) === null || _props$breadcrumb === void 0 ? void 0 : _props$breadcrumb.routes) || slots.breadcrumb;
      var hasFooter = props3.footer || slots.footer;
      var children = flattenChildren((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var className = classNames(prefixCls.value, (_classNames = {
        "has-breadcrumb": hasBreadcrumb,
        "has-footer": hasFooter
      }, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-ghost"), ghost.value), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-compact"), compact3.value), _classNames));
      return createVNode(ResizeObserver$1, {
        "onResize": onResize
      }, {
        default: function _default9() {
          return [createVNode("div", {
            "class": className
          }, [renderBreadcrumb(), renderTitle(), children.length ? renderChildren2(children) : null, renderFooter()])];
        }
      });
    };
  }
});
const index$b = withInstall(PageHeader);
var _excluded$k = ["placement", "overlayClassName"];
var popconfirmProps = function popconfirmProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, abstractTooltipProps()), {}, {
    prefixCls: String,
    content: PropTypes$1.any,
    title: PropTypes$1.any,
    okType: {
      type: String,
      default: "primary"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    okText: PropTypes$1.any,
    cancelText: PropTypes$1.any,
    icon: PropTypes$1.any,
    okButtonProps: {
      type: Object,
      default: void 0
    },
    cancelButtonProps: {
      type: Object,
      default: void 0
    },
    showCancel: {
      type: Boolean,
      default: true
    },
    onConfirm: Function,
    onCancel: Function
  });
};
var Popconfirm = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "APopconfirm",
  props: initDefaultProps$1(popconfirmProps(), _objectSpread2$1(_objectSpread2$1({}, tooltipDefaultProps()), {}, {
    trigger: "click",
    transitionName: "zoom-big",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true,
    okType: "primary",
    disabled: false
  })),
  slots: ["title", "content", "okText", "icon", "cancelText", "cancelButton", "okButton"],
  emits: ["update:visible", "visibleChange"],
  setup: function setup155(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    onMounted(function() {
      devWarning(props3.defaultVisible === void 0, "Popconfirm", "'defaultVisible' is deprecated, please use 'v-model:visible'");
    });
    var tooltipRef = ref();
    expose({
      getPopupDomNode: function getPopupDomNode2() {
        var _tooltipRef$value, _tooltipRef$value$get;
        return (_tooltipRef$value = tooltipRef.value) === null || _tooltipRef$value === void 0 ? void 0 : (_tooltipRef$value$get = _tooltipRef$value.getPopupDomNode) === null || _tooltipRef$value$get === void 0 ? void 0 : _tooltipRef$value$get.call(_tooltipRef$value);
      }
    });
    var _useMergedState = useMergedState(false, {
      value: toRef(props3, "visible"),
      defaultValue: props3.defaultVisible
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), visible = _useMergedState2[0], setVisible = _useMergedState2[1];
    var settingVisible = function settingVisible2(value, e2) {
      if (props3.visible === void 0) {
        setVisible(value);
      }
      emit("update:visible", value);
      emit("visibleChange", value, e2);
    };
    var close3 = function close4(e2) {
      settingVisible(false, e2);
    };
    var onConfirm = function onConfirm2(e2) {
      var _props$onConfirm;
      return (_props$onConfirm = props3.onConfirm) === null || _props$onConfirm === void 0 ? void 0 : _props$onConfirm.call(props3, e2);
    };
    var onCancel = function onCancel2(e2) {
      var _props$onCancel;
      settingVisible(false, e2);
      (_props$onCancel = props3.onCancel) === null || _props$onCancel === void 0 ? void 0 : _props$onCancel.call(props3, e2);
    };
    var onKeyDown = function onKeyDown2(e2) {
      if (e2.keyCode === KeyCode$1.ESC && visible) {
        settingVisible(false, e2);
      }
    };
    var onVisibleChange = function onVisibleChange2(value) {
      var disabled = props3.disabled;
      if (disabled) {
        return;
      }
      settingVisible(value);
    };
    var _useConfigInject = useConfigInject("popconfirm", props3), prefixClsConfirm = _useConfigInject.prefixCls, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var rootPrefixCls = computed(function() {
      return getPrefixCls2();
    });
    var popoverPrefixCls = computed(function() {
      return getPrefixCls2("popover");
    });
    var btnPrefixCls = computed(function() {
      return getPrefixCls2("btn");
    });
    var _useLocaleReceiver = useLocaleReceiver("Popconfirm", defaultLocale.Popconfirm), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), popconfirmLocale = _useLocaleReceiver2[0];
    var renderOverlay = function renderOverlay2() {
      var _slots$title, _slots$cancel, _slots$okText, _slots$icon;
      var okButtonProps = props3.okButtonProps, cancelButtonProps = props3.cancelButtonProps, _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots) : _props$title, _props$cancelText = props3.cancelText, cancelText = _props$cancelText === void 0 ? (_slots$cancel = slots.cancel) === null || _slots$cancel === void 0 ? void 0 : _slots$cancel.call(slots) : _props$cancelText, _props$okText = props3.okText, okText = _props$okText === void 0 ? (_slots$okText = slots.okText) === null || _slots$okText === void 0 ? void 0 : _slots$okText.call(slots) : _props$okText, okType = props3.okType, _props$icon = props3.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots) : _props$icon, _props$showCancel = props3.showCancel, showCancel = _props$showCancel === void 0 ? true : _props$showCancel;
      var cancelButton = slots.cancelButton, okButton = slots.okButton;
      var cancelProps = _objectSpread2$1({
        onClick: onCancel,
        size: "small"
      }, cancelButtonProps);
      var okProps = _objectSpread2$1(_objectSpread2$1({
        onClick: onConfirm
      }, convertLegacyProps(okType)), {}, {
        size: "small"
      }, okButtonProps);
      return createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-inner-content")
      }, [createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-message")
      }, [icon || createVNode(ExclamationCircleFilled$1, null, null), createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-message-title")
      }, [title])]), createVNode("div", {
        "class": "".concat(popoverPrefixCls.value, "-buttons")
      }, [showCancel ? cancelButton ? cancelButton(cancelProps) : createVNode(Button$1, cancelProps, {
        default: function _default9() {
          return [cancelText || popconfirmLocale.value.cancelText];
        }
      }) : null, okButton ? okButton(okProps) : createVNode(ActionButton, {
        "buttonProps": _objectSpread2$1(_objectSpread2$1({
          size: "small"
        }, convertLegacyProps(okType)), okButtonProps),
        "actionFn": onConfirm,
        "close": close3,
        "prefixCls": btnPrefixCls.value,
        "quitOnNullishReturnValue": true,
        "emitEvent": true
      }, {
        default: function _default9() {
          return [okText || popconfirmLocale.value.okText];
        }
      })])]);
    };
    return function() {
      var _slots$default;
      var placement = props3.placement, overlayClassName = props3.overlayClassName, restProps = _objectWithoutProperties$2(props3, _excluded$k);
      var otherProps = omit$2(restProps, ["title", "content", "cancelText", "okText", "onUpdate:visible", "onConfirm", "onCancel"]);
      var overlayClassNames = classNames(prefixClsConfirm.value, overlayClassName);
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
        "prefixCls": popoverPrefixCls.value,
        "placement": placement,
        "onVisibleChange": onVisibleChange,
        "visible": visible.value,
        "overlayClassName": overlayClassNames,
        "transitionName": getTransitionName$2(rootPrefixCls.value, "zoom-big", props3.transitionName),
        "ref": tooltipRef
      }), {
        default: function _default9() {
          return [cloneVNodes(((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)) || [], {
            onKeydown: function onKeydown(e2) {
              onKeyDown(e2);
            }
          }, false)];
        },
        title: renderOverlay
      });
    };
  }
});
const index$a = withInstall(Popconfirm);
var progressStatuses = tuple$1("normal", "exception", "active", "success");
var ProgressType = tuple$1("line", "circle", "dashboard");
var ProgressSize = tuple$1("default", "small");
var progressProps = function progressProps2() {
  return {
    prefixCls: String,
    type: PropTypes$1.oneOf(ProgressType),
    percent: Number,
    format: {
      type: Function
    },
    status: PropTypes$1.oneOf(progressStatuses),
    showInfo: {
      type: Boolean,
      default: void 0
    },
    strokeWidth: Number,
    strokeLinecap: String,
    strokeColor: {
      type: [String, Object],
      default: void 0
    },
    trailColor: String,
    width: Number,
    success: {
      type: Object,
      default: function _default9() {
        return {};
      }
    },
    gapDegree: Number,
    gapPosition: String,
    size: PropTypes$1.oneOf(ProgressSize),
    steps: Number,
    successPercent: Number,
    title: String
  };
};
function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  var success = _ref.success, successPercent = _ref.successPercent;
  var percent = successPercent;
  if (success && "progress" in success) {
    devWarning(false, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead.");
    percent = success.progress;
  }
  if (success && "percent" in success) {
    percent = success.percent;
  }
  return percent;
}
var _excluded$j = ["from", "to", "direction"];
var lineProps = function lineProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, progressProps()), {}, {
    prefixCls: String,
    direction: {
      type: String
    }
  });
};
var sortGradient = function sortGradient2(gradients) {
  var tempArr = [];
  Object.keys(gradients).forEach(function(key2) {
    var formattedKey = parseFloat(key2.replace(/%/g, ""));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key2]
      });
    }
  });
  tempArr = tempArr.sort(function(a2, b2) {
    return a2.key - b2.key;
  });
  return tempArr.map(function(_ref) {
    var key2 = _ref.key, value = _ref.value;
    return "".concat(value, " ").concat(key2, "%");
  }).join(", ");
};
var handleGradient = function handleGradient2(strokeColor, directionConfig) {
  var _strokeColor$from = strokeColor.from, from = _strokeColor$from === void 0 ? presetPrimaryColors.blue : _strokeColor$from, _strokeColor$to = strokeColor.to, to = _strokeColor$to === void 0 ? presetPrimaryColors.blue : _strokeColor$to, _strokeColor$directio = strokeColor.direction, direction = _strokeColor$directio === void 0 ? directionConfig === "rtl" ? "to left" : "to right" : _strokeColor$directio, rest = _objectWithoutProperties$2(strokeColor, _excluded$j);
  if (Object.keys(rest).length !== 0) {
    var sortedGradients = sortGradient(rest);
    return {
      backgroundImage: "linear-gradient(".concat(direction, ", ").concat(sortedGradients, ")")
    };
  }
  return {
    backgroundImage: "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")")
  };
};
const Line = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Line",
  props: lineProps(),
  setup: function setup156(props3, _ref2) {
    var slots = _ref2.slots;
    var backgroundProps = computed(function() {
      var strokeColor = props3.strokeColor, direction = props3.direction;
      return strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, direction) : {
        background: strokeColor
      };
    });
    var trailStyle = computed(function() {
      return props3.trailColor ? {
        backgroundColor: props3.trailColor
      } : void 0;
    });
    var percentStyle = computed(function() {
      var percent = props3.percent, strokeWidth = props3.strokeWidth, strokeLinecap = props3.strokeLinecap, size2 = props3.size;
      return _objectSpread2$1({
        width: "".concat(validProgress(percent), "%"),
        height: "".concat(strokeWidth || (size2 === "small" ? 6 : 8), "px"),
        borderRadius: strokeLinecap === "square" ? 0 : ""
      }, backgroundProps.value);
    });
    var successPercent = computed(function() {
      return getSuccessPercent(props3);
    });
    var successPercentStyle = computed(function() {
      var strokeWidth = props3.strokeWidth, size2 = props3.size, strokeLinecap = props3.strokeLinecap, success = props3.success;
      return {
        width: "".concat(validProgress(successPercent.value), "%"),
        height: "".concat(strokeWidth || (size2 === "small" ? 6 : 8), "px"),
        borderRadius: strokeLinecap === "square" ? 0 : "",
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
    });
    return function() {
      var _slots$default;
      return createVNode(Fragment, null, [createVNode("div", {
        "class": "".concat(props3.prefixCls, "-outer")
      }, [createVNode("div", {
        "class": "".concat(props3.prefixCls, "-inner"),
        "style": trailStyle.value
      }, [createVNode("div", {
        "class": "".concat(props3.prefixCls, "-bg"),
        "style": percentStyle.value
      }, null), successPercent.value !== void 0 ? createVNode("div", {
        "class": "".concat(props3.prefixCls, "-success-bg"),
        "style": successPercentStyle.value
      }, null) : null])]), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
var defaultProps = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
};
var useTransitionDuration = function useTransitionDuration2(paths) {
  var prevTimeStamp = ref(null);
  onUpdated(function() {
    var now2 = Date.now();
    var updated4 = false;
    paths.value.forEach(function(val) {
      var path2 = (val === null || val === void 0 ? void 0 : val.$el) || val;
      if (!path2) {
        return;
      }
      updated4 = true;
      var pathStyle = path2.style;
      pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
      if (prevTimeStamp.value && now2 - prevTimeStamp.value < 100) {
        pathStyle.transitionDuration = "0s, 0s";
      }
    });
    if (updated4) {
      prevTimeStamp.value = Date.now();
    }
  });
  return paths;
};
var propTypes = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var _excluded$i = ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"];
var gradientSeed = 0;
function stripPercentToNumber(percent) {
  return +percent.replace("%", "");
}
function toArray$2(value) {
  return Array.isArray(value) ? value : [value];
}
function getPathStyles(offset3, percent, strokeColor, strokeWidth) {
  var gapDegree = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var gapPosition = arguments.length > 5 ? arguments[5] : void 0;
  var radius = 50 - strokeWidth / 2;
  var beginPositionX = 0;
  var beginPositionY = -radius;
  var endPositionX = 0;
  var endPositionY = -2 * radius;
  switch (gapPosition) {
    case "left":
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;
    case "right":
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;
    case "bottom":
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;
  }
  var pathString = "M 50,50 m ".concat(beginPositionX, ",").concat(beginPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(endPositionX, ",").concat(-endPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(-endPositionX, ",").concat(endPositionY);
  var len = Math.PI * 2 * radius;
  var pathStyle = {
    stroke: strokeColor,
    strokeDasharray: "".concat(percent / 100 * (len - gapDegree), "px ").concat(len, "px"),
    strokeDashoffset: "-".concat(gapDegree / 2 + offset3 / 100 * (len - gapDegree), "px"),
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
  };
  return {
    pathString,
    pathStyle
  };
}
const VCCircle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: initDefaultProps$1(propTypes, defaultProps),
  setup: function setup157(props3) {
    gradientSeed += 1;
    var gradientId = ref(gradientSeed);
    var percentList = computed(function() {
      return toArray$2(props3.percent);
    });
    var strokeColorList = computed(function() {
      return toArray$2(props3.strokeColor);
    });
    var _useRefs = useRefs$1(), _useRefs2 = _slicedToArray$2(_useRefs, 2), setRef2 = _useRefs2[0], paths = _useRefs2[1];
    useTransitionDuration(paths);
    var getStokeList = function getStokeList2() {
      var prefixCls = props3.prefixCls, strokeWidth = props3.strokeWidth, strokeLinecap = props3.strokeLinecap, gapDegree = props3.gapDegree, gapPosition = props3.gapPosition;
      var stackPtg = 0;
      return percentList.value.map(function(ptg, index2) {
        var color = strokeColorList.value[index2] || strokeColorList.value[strokeColorList.value.length - 1];
        var stroke = Object.prototype.toString.call(color) === "[object Object]" ? "url(#".concat(prefixCls, "-gradient-").concat(gradientId.value, ")") : "";
        var _getPathStyles = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition), pathString = _getPathStyles.pathString, pathStyle = _getPathStyles.pathStyle;
        stackPtg += ptg;
        var pathProps = {
          key: index2,
          d: pathString,
          stroke,
          "stroke-linecap": strokeLinecap,
          "stroke-width": strokeWidth,
          opacity: ptg === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: "".concat(prefixCls, "-circle-path"),
          style: pathStyle
        };
        return createVNode("path", _objectSpread2$1({
          "ref": setRef2(index2)
        }, pathProps), null);
      });
    };
    return function() {
      var prefixCls = props3.prefixCls, strokeWidth = props3.strokeWidth, trailWidth = props3.trailWidth, gapDegree = props3.gapDegree, gapPosition = props3.gapPosition, trailColor = props3.trailColor, strokeLinecap = props3.strokeLinecap;
      props3.strokeColor;
      var restProps = _objectWithoutProperties$2(props3, _excluded$i);
      var _getPathStyles2 = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition), pathString = _getPathStyles2.pathString, pathStyle = _getPathStyles2.pathStyle;
      delete restProps.percent;
      var gradient = strokeColorList.value.find(function(color) {
        return Object.prototype.toString.call(color) === "[object Object]";
      });
      var pathFirst = {
        d: pathString,
        stroke: trailColor,
        "stroke-linecap": strokeLinecap,
        "stroke-width": trailWidth || strokeWidth,
        "fill-opacity": "0",
        class: "".concat(prefixCls, "-circle-trail"),
        style: pathStyle
      };
      return createVNode("svg", _objectSpread2$1({
        "class": "".concat(prefixCls, "-circle"),
        "viewBox": "0 0 100 100"
      }, restProps), [gradient && createVNode("defs", null, [createVNode("linearGradient", {
        "id": "".concat(prefixCls, "-gradient-").concat(gradientId.value),
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [Object.keys(gradient).sort(function(a2, b2) {
        return stripPercentToNumber(a2) - stripPercentToNumber(b2);
      }).map(function(key2, index2) {
        return createVNode("stop", {
          "key": index2,
          "offset": key2,
          "stop-color": gradient[key2]
        }, null);
      })])]), createVNode("path", pathFirst, null), getStokeList().reverse()]);
    };
  }
});
function getPercentage(_ref) {
  var percent = _ref.percent, success = _ref.success, successPercent = _ref.successPercent;
  var realSuccessPercent = validProgress(getSuccessPercent({
    success,
    successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
}
function getStrokeColor(_ref2) {
  var _ref2$success = _ref2.success, success = _ref2$success === void 0 ? {} : _ref2$success, strokeColor = _ref2.strokeColor;
  var successColor = success.strokeColor;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
}
const Circle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Circle",
  inheritAttrs: false,
  props: progressProps(),
  setup: function setup158(props3, _ref3) {
    var slots = _ref3.slots;
    var gapDeg = computed(function() {
      if (props3.gapDegree || props3.gapDegree === 0) {
        return props3.gapDegree;
      }
      if (props3.type === "dashboard") {
        return 75;
      }
      return void 0;
    });
    var circleStyle = computed(function() {
      var circleSize = props3.width || 120;
      return {
        width: typeof circleSize === "number" ? "".concat(circleSize, "px") : circleSize,
        height: typeof circleSize === "number" ? "".concat(circleSize, "px") : circleSize,
        fontSize: "".concat(circleSize * 0.15 + 6, "px")
      };
    });
    var circleWidth = computed(function() {
      return props3.strokeWidth || 6;
    });
    var gapPos = computed(function() {
      return props3.gapPosition || props3.type === "dashboard" && "bottom" || "top";
    });
    var percent = computed(function() {
      return getPercentage(props3);
    });
    var isGradient = computed(function() {
      return Object.prototype.toString.call(props3.strokeColor) === "[object Object]";
    });
    var strokeColor = computed(function() {
      return getStrokeColor({
        success: props3.success,
        strokeColor: props3.strokeColor
      });
    });
    var wrapperClassName = computed(function() {
      var _ref4;
      return _ref4 = {}, _defineProperty$U(_ref4, "".concat(props3.prefixCls, "-inner"), true), _defineProperty$U(_ref4, "".concat(props3.prefixCls, "-circle-gradient"), isGradient.value), _ref4;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": wrapperClassName.value,
        "style": circleStyle.value
      }, [createVNode(VCCircle, {
        "percent": percent.value,
        "strokeWidth": circleWidth.value,
        "trailWidth": circleWidth.value,
        "strokeColor": strokeColor.value,
        "strokeLinecap": props3.strokeLinecap,
        "trailColor": props3.trailColor,
        "prefixCls": props3.prefixCls,
        "gapDegree": gapDeg.value,
        "gapPosition": gapPos.value
      }, null), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
var stepsProps$1 = function stepsProps() {
  return _objectSpread2$1(_objectSpread2$1({}, progressProps()), {}, {
    steps: Number,
    size: {
      type: String
    },
    strokeColor: String,
    trailColor: String
  });
};
const Steps$4 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: stepsProps$1(),
  setup: function setup159(props3, _ref) {
    var slots = _ref.slots;
    var current2 = computed(function() {
      return Math.round(props3.steps * ((props3.percent || 0) / 100));
    });
    var stepWidth = computed(function() {
      return props3.size === "small" ? 2 : 14;
    });
    var styledSteps = computed(function() {
      var steps = props3.steps, _props$strokeWidth = props3.strokeWidth, strokeWidth = _props$strokeWidth === void 0 ? 8 : _props$strokeWidth, strokeColor = props3.strokeColor, trailColor = props3.trailColor, prefixCls = props3.prefixCls;
      var temp = [];
      for (var i2 = 0; i2 < steps; i2 += 1) {
        var _cls;
        var cls = (_cls = {}, _defineProperty$U(_cls, "".concat(prefixCls, "-steps-item"), true), _defineProperty$U(_cls, "".concat(prefixCls, "-steps-item-active"), i2 <= current2.value - 1), _cls);
        temp.push(createVNode("div", {
          "key": i2,
          "class": cls,
          "style": {
            backgroundColor: i2 <= current2.value - 1 ? strokeColor : trailColor,
            width: "".concat(stepWidth.value, "px"),
            height: "".concat(strokeWidth, "px")
          }
        }, null));
      }
      return temp;
    });
    return function() {
      var _slots$default;
      return createVNode("div", {
        "class": "".concat(props3.prefixCls, "-steps-outer")
      }, [styledSteps.value, (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
const Progress$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  props: initDefaultProps$1(progressProps(), {
    type: "line",
    percent: 0,
    showInfo: true,
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: ["format"],
  setup: function setup160(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("progress", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    devWarning(props3.successPercent == void 0, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead.");
    var classString = computed(function() {
      var _ref2;
      var type4 = props3.type, showInfo = props3.showInfo, size2 = props3.size;
      var pre = prefixCls.value;
      return _ref2 = {}, _defineProperty$U(_ref2, pre, true), _defineProperty$U(_ref2, "".concat(pre, "-").concat(type4 === "dashboard" && "circle" || type4), true), _defineProperty$U(_ref2, "".concat(pre, "-show-info"), showInfo), _defineProperty$U(_ref2, "".concat(pre, "-").concat(size2), size2), _defineProperty$U(_ref2, "".concat(pre, "-rtl"), direction.value === "rtl"), _ref2;
    });
    var percentNumber = computed(function() {
      var _props$percent = props3.percent, percent = _props$percent === void 0 ? 0 : _props$percent;
      var successPercent = getSuccessPercent(props3);
      return parseInt(successPercent !== void 0 ? successPercent.toString() : percent.toString(), 10);
    });
    var progressStatus = computed(function() {
      var status = props3.status;
      if (progressStatuses.indexOf(status) < 0 && percentNumber.value >= 100) {
        return "success";
      }
      return status || "normal";
    });
    var renderProcessInfo = function renderProcessInfo2() {
      var showInfo = props3.showInfo, format5 = props3.format, type4 = props3.type, percent = props3.percent, title = props3.title;
      var successPercent = getSuccessPercent(props3);
      if (!showInfo)
        return null;
      var text;
      var textFormatter = format5 || (slots === null || slots === void 0 ? void 0 : slots.format) || function(val) {
        return "".concat(val, "%");
      };
      var isLineType = type4 === "line";
      if (format5 || slots !== null && slots !== void 0 && slots.format || progressStatus.value !== "exception" && progressStatus.value !== "success") {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus.value === "exception") {
        text = isLineType ? createVNode(CloseCircleFilled$1, null, null) : createVNode(CloseOutlined$1, null, null);
      } else if (progressStatus.value === "success") {
        text = isLineType ? createVNode(CheckCircleFilled$1, null, null) : createVNode(CheckOutlined$1, null, null);
      }
      return createVNode("span", {
        "class": "".concat(prefixCls.value, "-text"),
        "title": title === void 0 && typeof text === "string" ? text : void 0
      }, [text]);
    };
    return function() {
      var type4 = props3.type, steps = props3.steps, strokeColor = props3.strokeColor, title = props3.title;
      var progressInfo = renderProcessInfo();
      var progress;
      if (type4 === "line") {
        progress = steps ? createVNode(Steps$4, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
          "strokeColor": typeof strokeColor === "string" ? strokeColor : void 0,
          "prefixCls": prefixCls.value,
          "steps": steps
        }), {
          default: function _default9() {
            return [progressInfo];
          }
        }) : createVNode(Line, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
          "prefixCls": prefixCls.value
        }), {
          default: function _default9() {
            return [progressInfo];
          }
        });
      } else if (type4 === "circle" || type4 === "dashboard") {
        progress = createVNode(Circle, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
          "prefixCls": prefixCls.value
        }), {
          default: function _default9() {
            return [progressInfo];
          }
        });
      }
      var classNames2 = _objectSpread2$1(_objectSpread2$1({}, classString.value), {}, _defineProperty$U({}, "".concat(prefixCls.value, "-status-").concat(progressStatus.value), true));
      return createVNode("div", {
        "class": classNames2,
        "title": title
      }, [progress]);
    };
  }
});
const Progress = withInstall(Progress$1);
function getScroll(w2) {
  var ret = w2.pageXOffset;
  var method4 = "scrollLeft";
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getClientPosition(elem) {
  var x2;
  var y2;
  var doc2 = elem.ownerDocument;
  var body = doc2.body;
  var docElem = doc2 && doc2.documentElement;
  var box = elem.getBoundingClientRect();
  x2 = box.left;
  y2 = box.top;
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getOffsetLeft(el) {
  var pos2 = getClientPosition(el);
  var doc2 = el.ownerDocument;
  var w2 = doc2.defaultView || doc2.parentWindow;
  pos2.left += getScroll(w2);
  return pos2.left;
}
var StarFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, "name": "star", "theme": "filled" };
const StarFilledSvg = StarFilled$2;
function _objectSpread$i(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$i(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$i(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var StarFilled = function StarFilled2(props3, context2) {
  var p2 = _objectSpread$i({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$i({}, p2, {
    "icon": StarFilledSvg
  }), null);
};
StarFilled.displayName = "StarFilled";
StarFilled.inheritAttrs = false;
const StarFilled$1 = StarFilled;
var starProps = {
  value: Number,
  index: Number,
  prefixCls: String,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: PropTypes$1.any,
  characterRender: Function,
  focused: {
    type: Boolean,
    default: void 0
  },
  count: Number,
  onClick: Function,
  onHover: Function
};
const Star = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Star",
  inheritAttrs: false,
  props: starProps,
  emits: ["hover", "click"],
  setup: function setup161(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var onHover = function onHover2(e2) {
      var index2 = props3.index;
      emit("hover", e2, index2);
    };
    var onClick2 = function onClick3(e2) {
      var index2 = props3.index;
      emit("click", e2, index2);
    };
    var onKeyDown = function onKeyDown2(e2) {
      var index2 = props3.index;
      if (e2.keyCode === 13) {
        emit("click", e2, index2);
      }
    };
    var cls = computed(function() {
      var prefixCls = props3.prefixCls, index2 = props3.index, value = props3.value, allowHalf = props3.allowHalf, focused = props3.focused;
      var starValue = index2 + 1;
      var className = prefixCls;
      if (value === 0 && index2 === 0 && focused) {
        className += " ".concat(prefixCls, "-focused");
      } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
        className += " ".concat(prefixCls, "-half ").concat(prefixCls, "-active");
        if (focused) {
          className += " ".concat(prefixCls, "-focused");
        }
      } else {
        className += starValue <= value ? " ".concat(prefixCls, "-full") : " ".concat(prefixCls, "-zero");
        if (starValue === value && focused) {
          className += " ".concat(prefixCls, "-focused");
        }
      }
      return className;
    });
    return function() {
      var disabled = props3.disabled, prefixCls = props3.prefixCls, characterRender = props3.characterRender, index2 = props3.index, count = props3.count, value = props3.value;
      var character = getPropsSlot(slots, props3, "character");
      var star = createVNode("li", {
        "class": cls.value
      }, [createVNode("div", {
        "onClick": disabled ? null : onClick2,
        "onKeydown": disabled ? null : onKeyDown,
        "onMousemove": disabled ? null : onHover,
        "role": "radio",
        "aria-checked": value > index2 ? "true" : "false",
        "aria-posinset": index2 + 1,
        "aria-setsize": count,
        "tabindex": disabled ? -1 : 0
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-first")
      }, [character]), createVNode("div", {
        "class": "".concat(prefixCls, "-second")
      }, [character])])]);
      if (characterRender) {
        star = characterRender(star, props3);
      }
      return star;
    };
  }
});
var rateProps = function rateProps2() {
  return {
    prefixCls: String,
    count: Number,
    value: Number,
    allowHalf: {
      type: Boolean,
      default: void 0
    },
    allowClear: {
      type: Boolean,
      default: void 0
    },
    tooltips: Array,
    disabled: {
      type: Boolean,
      default: void 0
    },
    character: PropTypes$1.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    direction: String,
    id: String,
    onChange: Function,
    onHoverChange: Function,
    "onUpdate:value": Function,
    onFocus: Function,
    onBlur: Function,
    onKeydown: Function
  };
};
var Rate = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ARate",
  inheritAttrs: false,
  props: initDefaultProps$1(rateProps(), {
    value: 0,
    count: 5,
    allowHalf: false,
    allowClear: true,
    tabindex: 0,
    direction: "ltr"
  }),
  setup: function setup162(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var _useConfigInject = useConfigInject("rate", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var formItemContext = useInjectFormItemContext();
    var rateRef = ref();
    var _useRefs = useRefs$1(), _useRefs2 = _slicedToArray$2(_useRefs, 2), setRef2 = _useRefs2[0], starRefs = _useRefs2[1];
    var state = reactive({
      value: props3.value,
      focused: false,
      cleanedValue: null,
      hoverValue: void 0
    });
    watch(function() {
      return props3.value;
    }, function() {
      state.value = props3.value;
    });
    var getStarDOM = function getStarDOM2(index2) {
      return findDOMNode(starRefs.value.get(index2));
    };
    var getStarValue = function getStarValue2(index2, x2) {
      var reverse2 = direction.value === "rtl";
      var value = index2 + 1;
      if (props3.allowHalf) {
        var starEle = getStarDOM(index2);
        var leftDis = getOffsetLeft(starEle);
        var width = starEle.clientWidth;
        if (reverse2 && x2 - leftDis > width / 2) {
          value -= 0.5;
        } else if (!reverse2 && x2 - leftDis < width / 2) {
          value -= 0.5;
        }
      }
      return value;
    };
    var changeValue = function changeValue2(value) {
      if (props3.value === void 0) {
        state.value = value;
      }
      emit("update:value", value);
      emit("change", value);
      formItemContext.onFieldChange();
    };
    var onHover = function onHover2(e2, index2) {
      var hoverValue = getStarValue(index2, e2.pageX);
      if (hoverValue !== state.cleanedValue) {
        state.hoverValue = hoverValue;
        state.cleanedValue = null;
      }
      emit("hoverChange", hoverValue);
    };
    var onMouseLeave = function onMouseLeave2() {
      state.hoverValue = void 0;
      state.cleanedValue = null;
      emit("hoverChange", void 0);
    };
    var onClick2 = function onClick3(event2, index2) {
      var allowClear = props3.allowClear;
      var newValue = getStarValue(index2, event2.pageX);
      var isReset = false;
      if (allowClear) {
        isReset = newValue === state.value;
      }
      onMouseLeave();
      changeValue(isReset ? 0 : newValue);
      state.cleanedValue = isReset ? newValue : null;
    };
    var onFocus2 = function onFocus3(e2) {
      state.focused = true;
      emit("focus", e2);
    };
    var onBlur2 = function onBlur3(e2) {
      state.focused = false;
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    var onKeyDown = function onKeyDown2(event2) {
      var keyCode = event2.keyCode;
      var count = props3.count, allowHalf = props3.allowHalf;
      var reverse2 = direction.value === "rtl";
      if (keyCode === KeyCode$1.RIGHT && state.value < count && !reverse2) {
        if (allowHalf) {
          state.value += 0.5;
        } else {
          state.value += 1;
        }
        changeValue(state.value);
        event2.preventDefault();
      } else if (keyCode === KeyCode$1.LEFT && state.value > 0 && !reverse2) {
        if (allowHalf) {
          state.value -= 0.5;
        } else {
          state.value -= 1;
        }
        changeValue(state.value);
        event2.preventDefault();
      } else if (keyCode === KeyCode$1.RIGHT && state.value > 0 && reverse2) {
        if (allowHalf) {
          state.value -= 0.5;
        } else {
          state.value -= 1;
        }
        changeValue(state.value);
        event2.preventDefault();
      } else if (keyCode === KeyCode$1.LEFT && state.value < count && reverse2) {
        if (allowHalf) {
          state.value += 0.5;
        } else {
          state.value += 1;
        }
        changeValue(state.value);
        event2.preventDefault();
      }
      emit("keydown", event2);
    };
    var focus = function focus2() {
      if (!props3.disabled) {
        rateRef.value.focus();
      }
    };
    var blur = function blur2() {
      if (!props3.disabled) {
        rateRef.value.blur();
      }
    };
    expose({
      focus,
      blur
    });
    onMounted(function() {
      var autofocus = props3.autofocus, disabled = props3.disabled;
      if (autofocus && !disabled) {
        focus();
      }
    });
    var characterRender = function characterRender2(node, _ref2) {
      var index2 = _ref2.index;
      var tooltips = props3.tooltips;
      if (!tooltips)
        return node;
      return createVNode(Tooltip, {
        "title": tooltips[index2]
      }, {
        default: function _default9() {
          return [node];
        }
      });
    };
    var character = getPropsSlot(slots, props3, "character") || createVNode(StarFilled$1, null, null);
    return function() {
      var count = props3.count, allowHalf = props3.allowHalf, disabled = props3.disabled, tabindex = props3.tabindex, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var className = attrs.class, style2 = attrs.style;
      var stars = [];
      var disabledClass = disabled ? "".concat(prefixCls.value, "-disabled") : "";
      for (var index2 = 0; index2 < count; index2++) {
        stars.push(createVNode(Star, {
          "ref": setRef2(index2),
          "key": index2,
          "index": index2,
          "count": count,
          "disabled": disabled,
          "prefixCls": "".concat(prefixCls.value, "-star"),
          "allowHalf": allowHalf,
          "value": state.hoverValue === void 0 ? state.value : state.hoverValue,
          "onClick": onClick2,
          "onHover": onHover,
          "character": character,
          "characterRender": characterRender,
          "focused": state.focused
        }, null));
      }
      var rateClassName = classNames(prefixCls.value, disabledClass, className, _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
      return createVNode("ul", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "id": id,
        "class": rateClassName,
        "style": style2,
        "onMouseleave": disabled ? null : onMouseLeave,
        "tabindex": disabled ? -1 : tabindex,
        "onFocus": disabled ? null : onFocus2,
        "onBlur": disabled ? null : onBlur2,
        "onKeydown": disabled ? null : onKeyDown,
        "ref": rateRef,
        "role": "radiogroup"
      }), [stars]);
    };
  }
});
const index$9 = withInstall(Rate);
var WarningFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "warning", "theme": "filled" };
const WarningFilledSvg = WarningFilled$2;
function _objectSpread$h(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$h(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$h(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var WarningFilled = function WarningFilled2(props3, context2) {
  var p2 = _objectSpread$h({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$h({}, p2, {
    "icon": WarningFilledSvg
  }), null);
};
WarningFilled.displayName = "WarningFilled";
WarningFilled.inheritAttrs = false;
const WarningFilled$1 = WarningFilled;
var NoFound = function NoFound2() {
  return createVNode("svg", {
    "width": "252",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .387h251.772v251.772H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .012)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }, null), createVNode("path", {
    "d": "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    "fill": "#1890FF"
  }, null), createVNode("path", {
    "d": "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.275 222.1s2.773-1.11 6.102-3.884",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }, null), createVNode("path", {
    "d": "M110.846 74.481s1.79-.716 2.506.537",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.287 72.93s1.83 1.113 4.137.954",
    "stroke": "#5C2552",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    "stroke": "#DB836E",
    "stroke-width": "1.118",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M129.405 122.865s-5.272 7.403-9.422 10.768",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M119.306 107.329s.452 4.366-2.127 32.062",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "d": "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
  }, null), createVNode("path", {
    "d": "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    "fill": "#F4D19D"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }, null), createVNode("path", {
    "fill": "#CC9B6E",
    "d": "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }, null), createVNode("path", {
    "d": "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    "stroke": "#DB836E",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M88.979 89.48s7.776 5.384 16.6 2.842",
    "stroke": "#E4EBF7",
    "stroke-width": "1.101",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
const noFound = NoFound;
var ServerError = function ServerError2() {
  return createVNode("svg", {
    "width": "254",
    "height": "294"
  }, [createVNode("defs", null, [createVNode("path", {
    "d": "M0 .335h253.49v253.49H0z"
  }, null), createVNode("path", {
    "d": "M0 293.665h253.49V.401H0z"
  }, null)]), createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("g", {
    "transform": "translate(0 .067)"
  }, [createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "d": "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    "fill": "#E4EBF7",
    "mask": "url(#b)"
  }, null)]), createVNode("path", {
    "d": "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    "fill": "#FF603B"
  }, null), createVNode("path", {
    "d": "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    "fill": "#520038"
  }, null), createVNode("path", {
    "d": "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    "fill": "#552950"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }, null), createVNode("path", {
    "d": "M99.926 73.284s1.8-.72 2.52.54",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    "stroke": "#DB836E",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.326 71.724s1.84 1.12 4.16.96",
    "stroke": "#5C2552",
    "stroke-width": "1.117",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    "stroke": "#DB836E",
    "stroke-width": "1.063",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    "stroke": "#E4EBF7",
    "stroke-width": "1.136",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M96.973 219.373s2.882-1.153 6.34-4.034",
    "stroke": "#648BD8",
    "stroke-width": "1.032",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    "stroke": "#648BD8",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    "stroke": "#DB836E",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M109.278 112.533s3.38-3.613 7.575-4.662",
    "stroke": "#E4EBF7",
    "stroke-width": "1.085",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M107.375 123.006s9.697-2.745 11.445-.88",
    "stroke": "#E59788",
    "stroke-width": ".774",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    "stroke": "#BFCDDD",
    "stroke-width": "2",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    "fill": "#A3B4C6"
  }, null), createVNode("path", {
    "d": "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    "fill": "#A3B4C6"
  }, null), createVNode("mask", {
    "fill": "#fff"
  }, null), createVNode("path", {
    "fill": "#A3B4C6",
    "mask": "url(#d)",
    "d": "M154.098 190.096h70.513v-84.617h-70.513z"
  }, null), createVNode("path", {
    "d": "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    "stroke": "#7C90A5",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    "fill": "#FFF",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    "fill": "#BFCDDD",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M177.259 207.217v11.52M201.05 207.217v11.52",
    "stroke": "#A3B4C6",
    "stroke-width": "1.124",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    "fill": "#5BA02E",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    "fill": "#92C110",
    "mask": "url(#d)"
  }, null), createVNode("path", {
    "d": "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    "fill": "#F2D7AD",
    "mask": "url(#d)"
  }, null)])]);
};
const serverError = ServerError;
var Unauthorized = function Unauthorized2() {
  return createVNode("svg", {
    "width": "251",
    "height": "294"
  }, [createVNode("g", {
    "fill": "none",
    "fill-rule": "evenodd"
  }, [createVNode("path", {
    "d": "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    "fill": "#E4EBF7"
  }, null), createVNode("path", {
    "d": "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "d": "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    "stroke": "#FFF",
    "stroke-width": "2"
  }, null), createVNode("path", {
    "stroke": "#FFF",
    "stroke-width": "2",
    "d": "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }, null), createVNode("path", {
    "d": "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    "fill": "#A26EF4"
  }, null), createVNode("path", {
    "d": "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    "fill": "#5BA02E"
  }, null), createVNode("path", {
    "d": "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    "fill": "#92C110"
  }, null), createVNode("path", {
    "d": "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    "fill": "#F2D7AD"
  }, null), createVNode("path", {
    "d": "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M78.18 94.656s.911 7.41-4.914 13.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    "stroke": "#E4EBF7",
    "stroke-width": ".932",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    "fill": "#FFB594"
  }, null), createVNode("path", {
    "d": "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    "fill": "#5C2552"
  }, null), createVNode("path", {
    "d": "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "d": "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }, null), createVNode("path", {
    "d": "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    "fill": "#552950"
  }, null), createVNode("path", {
    "d": "M91.132 86.786s5.269 4.957 12.679 2.327",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    "fill": "#DB836E"
  }, null), createVNode("path", {
    "d": "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    "stroke": "#5C2552",
    "stroke-width": "1.526",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    "stroke": "#DB836E",
    "stroke-width": "1.145",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M66.508 86.763s-1.598 8.83-6.697 14.078",
    "stroke": "#E4EBF7",
    "stroke-width": "1.114",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M128.31 87.934s3.013 4.121 4.06 11.785",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M64.09 84.816s-6.03 9.912-13.607 9.903",
    "stroke": "#DB836E",
    "stroke-width": ".795",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    "fill": "#FFC6A0"
  }, null), createVNode("path", {
    "d": "M130.532 85.488s4.588 5.757 11.619 6.214",
    "stroke": "#DB836E",
    "stroke-width": ".75",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M121.708 105.73s-.393 8.564-1.34 13.612",
    "stroke": "#E4EBF7",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M115.784 161.512s-3.57-1.488-2.678-7.14",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    "fill": "#CBD1D1"
  }, null), createVNode("path", {
    "d": "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    "fill": "#2B0849"
  }, null), createVNode("path", {
    "d": "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    "fill": "#A4AABA"
  }, null), createVNode("path", {
    "d": "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    "fill": "#7BB2F9"
  }, null), createVNode("path", {
    "d": "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M108.459 220.905s2.759-1.104 6.07-3.863",
    "stroke": "#648BD8",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    "d": "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    "fill": "#FFF"
  }, null), createVNode("path", {
    "d": "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    "fill": "#192064"
  }, null), createVNode("path", {
    "d": "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    "stroke": "#648BD8",
    "stroke-width": "1.051",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])]);
};
const unauthorized = Unauthorized;
var IconMap = {
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  info: ExclamationCircleFilled$1,
  warning: WarningFilled$1
};
var ExceptionMap = {
  "404": noFound,
  "500": serverError,
  "403": unauthorized
};
var ExceptionStatus = Object.keys(ExceptionMap);
var resultProps = function resultProps2() {
  return {
    prefixCls: String,
    icon: PropTypes$1.any,
    status: {
      type: [Number, String],
      default: "info"
    },
    title: PropTypes$1.any,
    subTitle: PropTypes$1.any,
    extra: PropTypes$1.any
  };
};
var renderIcon = function renderIcon2(prefixCls, _ref) {
  var status = _ref.status, icon = _ref.icon;
  if (ExceptionStatus.includes("".concat(status))) {
    var SVGComponent = ExceptionMap[status];
    return createVNode("div", {
      "class": "".concat(prefixCls, "-icon ").concat(prefixCls, "-image")
    }, [createVNode(SVGComponent, null, null)]);
  }
  var IconComponent = IconMap[status];
  var iconNode = icon || createVNode(IconComponent, null, null);
  return createVNode("div", {
    "class": "".concat(prefixCls, "-icon")
  }, [iconNode]);
};
var renderExtra = function renderExtra2(prefixCls, extra) {
  return extra && createVNode("div", {
    "class": "".concat(prefixCls, "-extra")
  }, [extra]);
};
var Result = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AResult",
  props: resultProps(),
  slots: ["title", "subTitle", "icon", "extra"],
  setup: function setup163(props3, _ref2) {
    var slots = _ref2.slots;
    var _useConfigInject = useConfigInject("result", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var className = computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-").concat(props3.status), _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
    });
    return function() {
      var _props$title, _slots$title, _props$subTitle, _slots$subTitle, _props$icon, _slots$icon, _props$extra, _slots$extra;
      var title = (_props$title = props3.title) !== null && _props$title !== void 0 ? _props$title : (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots);
      var subTitle = (_props$subTitle = props3.subTitle) !== null && _props$subTitle !== void 0 ? _props$subTitle : (_slots$subTitle = slots.subTitle) === null || _slots$subTitle === void 0 ? void 0 : _slots$subTitle.call(slots);
      var icon = (_props$icon = props3.icon) !== null && _props$icon !== void 0 ? _props$icon : (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots);
      var extra = (_props$extra = props3.extra) !== null && _props$extra !== void 0 ? _props$extra : (_slots$extra = slots.extra) === null || _slots$extra === void 0 ? void 0 : _slots$extra.call(slots);
      var pre = prefixCls.value;
      return createVNode("div", {
        "class": className.value
      }, [renderIcon(pre, {
        status: props3.status,
        icon
      }), createVNode("div", {
        "class": "".concat(pre, "-title")
      }, [title]), subTitle && createVNode("div", {
        "class": "".concat(pre, "-subtitle")
      }, [subTitle]), renderExtra(pre, extra), slots.default && createVNode("div", {
        "class": "".concat(pre, "-content")
      }, [slots.default()])]);
    };
  }
});
Result.PRESENTED_IMAGE_403 = ExceptionMap[403];
Result.PRESENTED_IMAGE_404 = ExceptionMap[404];
Result.PRESENTED_IMAGE_500 = ExceptionMap[500];
Result.install = function(app) {
  app.component(Result.name, Result);
  return app;
};
const Result$1 = Result;
var skeletonButtonProps = function skeletonButtonProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, skeletonElementProps()), {}, {
    size: String,
    block: Boolean
  });
};
var SkeletonButton = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonButton",
  props: initDefaultProps$1(skeletonButtonProps(), {
    size: "default"
  }),
  setup: function setup164(props3) {
    var _useConfigInject = useConfigInject("skeleton", props3), prefixCls = _useConfigInject.prefixCls;
    var cls = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-element"), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-active"), props3.active), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-block"), props3.block), _classNames));
    });
    return function() {
      return createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        "prefixCls": "".concat(prefixCls.value, "-button")
      }), null)]);
    };
  }
});
const SkeletonButton$1 = SkeletonButton;
var SkeletonInput = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonInput",
  props: _objectSpread2$1(_objectSpread2$1({}, omit$2(skeletonElementProps(), ["shape"])), {}, {
    size: String
  }),
  setup: function setup165(props3) {
    var _useConfigInject = useConfigInject("skeleton", props3), prefixCls = _useConfigInject.prefixCls;
    var cls = computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-element"), _defineProperty$U({}, "".concat(prefixCls.value, "-active"), props3.active));
    });
    return function() {
      return createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        "prefixCls": "".concat(prefixCls.value, "-input")
      }), null)]);
    };
  }
});
const SkeletonInput$1 = SkeletonInput;
var path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
var SkeletonImage = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonImage",
  props: omit$2(skeletonElementProps(), ["size", "shape", "active"]),
  setup: function setup166(props3) {
    var _useConfigInject = useConfigInject("skeleton", props3), prefixCls = _useConfigInject.prefixCls;
    var cls = computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-element"));
    });
    return function() {
      return createVNode("div", {
        "class": cls.value
      }, [createVNode("div", {
        "class": "".concat(prefixCls.value, "-image")
      }, [createVNode("svg", {
        "viewBox": "0 0 1098 1024",
        "xmlns": "http://www.w3.org/2000/svg",
        "class": "".concat(prefixCls.value, "-image-svg")
      }, [createVNode("path", {
        "d": path,
        "class": "".concat(prefixCls.value, "-image-path")
      }, null)])])]);
    };
  }
});
const SkeletonImage$1 = SkeletonImage;
var avatarProps2 = function avatarProps3() {
  return _objectSpread2$1(_objectSpread2$1({}, skeletonElementProps()), {}, {
    shape: String
  });
};
var SkeletonAvatar = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonAvatar",
  props: initDefaultProps$1(avatarProps2(), {
    size: "default",
    shape: "circle"
  }),
  setup: function setup167(props3) {
    var _useConfigInject = useConfigInject("skeleton", props3), prefixCls = _useConfigInject.prefixCls;
    var cls = computed(function() {
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-element"), _defineProperty$U({}, "".concat(prefixCls.value, "-active"), props3.active));
    });
    return function() {
      return createVNode("div", {
        "class": cls.value
      }, [createVNode(Element$2, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        "prefixCls": "".concat(prefixCls.value, "-avatar")
      }), null)]);
    };
  }
});
const SkeletonAvatar$1 = SkeletonAvatar;
Skeleton$1.Button = SkeletonButton$1;
Skeleton$1.Avatar = SkeletonAvatar$1;
Skeleton$1.Input = SkeletonInput$1;
Skeleton$1.Image = SkeletonImage$1;
Skeleton$1.Title = SkeletonTitle$1;
Skeleton$1.install = function(app) {
  app.component(Skeleton$1.name, Skeleton$1);
  app.component(Skeleton$1.Button.name, SkeletonButton$1);
  app.component(Skeleton$1.Avatar.name, SkeletonAvatar$1);
  app.component(Skeleton$1.Input.name, SkeletonInput$1);
  app.component(Skeleton$1.Image.name, SkeletonImage$1);
  app.component(Skeleton$1.Title.name, SkeletonTitle$1);
  return app;
};
var Track2 = function Track3(_2, _ref) {
  var _ref2, _ref3;
  var attrs = _ref.attrs;
  var included = attrs.included, vertical = attrs.vertical, style2 = attrs.style, className = attrs.class;
  var length = attrs.length, offset3 = attrs.offset, reverse2 = attrs.reverse;
  if (length < 0) {
    reverse2 = !reverse2;
    length = Math.abs(length);
    offset3 = 100 - offset3;
  }
  var positonStyle = vertical ? (_ref2 = {}, _defineProperty$U(_ref2, reverse2 ? "top" : "bottom", "".concat(offset3, "%")), _defineProperty$U(_ref2, reverse2 ? "bottom" : "top", "auto"), _defineProperty$U(_ref2, "height", "".concat(length, "%")), _ref2) : (_ref3 = {}, _defineProperty$U(_ref3, reverse2 ? "right" : "left", "".concat(offset3, "%")), _defineProperty$U(_ref3, reverse2 ? "left" : "right", "auto"), _defineProperty$U(_ref3, "width", "".concat(length, "%")), _ref3);
  var elStyle = _objectSpread2$1(_objectSpread2$1({}, style2), positonStyle);
  return included ? createVNode("div", {
    "class": className,
    "style": elStyle
  }, null) : null;
};
Track2.inheritAttrs = false;
const Track$1 = Track2;
var calcPoints = function calcPoints2(_vertical, marks, dots, step, min3, max3) {
  warning$2(dots ? step > 0 : true, "Slider", "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
  var points = Object.keys(marks).map(parseFloat).sort(function(a2, b2) {
    return a2 - b2;
  });
  if (dots && step) {
    for (var i2 = min3; i2 <= max3; i2 += step) {
      if (points.indexOf(i2) === -1) {
        points.push(i2);
      }
    }
  }
  return points;
};
var Steps$2 = function Steps(_2, _ref) {
  var attrs = _ref.attrs;
  var prefixCls = attrs.prefixCls, vertical = attrs.vertical, reverse2 = attrs.reverse, marks = attrs.marks, dots = attrs.dots, step = attrs.step, included = attrs.included, lowerBound = attrs.lowerBound, upperBound = attrs.upperBound, max3 = attrs.max, min3 = attrs.min, dotStyle = attrs.dotStyle, activeDotStyle = attrs.activeDotStyle;
  var range3 = max3 - min3;
  var elements = calcPoints(vertical, marks, dots, step, min3, max3).map(function(point) {
    var _classNames;
    var offset3 = "".concat(Math.abs(point - min3) / range3 * 100, "%");
    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var style2 = vertical ? _objectSpread2$1(_objectSpread2$1({}, dotStyle), {}, _defineProperty$U({}, reverse2 ? "top" : "bottom", offset3)) : _objectSpread2$1(_objectSpread2$1({}, dotStyle), {}, _defineProperty$U({}, reverse2 ? "right" : "left", offset3));
    if (isActived) {
      style2 = _objectSpread2$1(_objectSpread2$1({}, style2), activeDotStyle);
    }
    var pointClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-dot"), true), _defineProperty$U(_classNames, "".concat(prefixCls, "-dot-active"), isActived), _defineProperty$U(_classNames, "".concat(prefixCls, "-dot-reverse"), reverse2), _classNames));
    return createVNode("span", {
      "class": pointClassName,
      "style": style2,
      "key": point
    }, null);
  });
  return createVNode("div", {
    "class": "".concat(prefixCls, "-step")
  }, [elements]);
};
Steps$2.inheritAttrs = false;
const Steps$3 = Steps$2;
var Marks = function Marks2(_2, _ref) {
  var attrs = _ref.attrs, slots = _ref.slots;
  var className = attrs.class, vertical = attrs.vertical, reverse2 = attrs.reverse, marks = attrs.marks, included = attrs.included, upperBound = attrs.upperBound, lowerBound = attrs.lowerBound, max3 = attrs.max, min3 = attrs.min, onClickLabel = attrs.onClickLabel;
  var marksKeys = Object.keys(marks);
  var customMark = slots.mark;
  var range3 = max3 - min3;
  var elements = marksKeys.map(parseFloat).sort(function(a2, b2) {
    return a2 - b2;
  }).map(function(point) {
    var _classNames;
    var markPoint = typeof marks[point] === "function" ? marks[point]() : marks[point];
    var markPointIsObject = _typeof$3(markPoint) === "object" && !isValidElement(markPoint);
    var markLabel = markPointIsObject ? markPoint.label : markPoint;
    if (!markLabel && markLabel !== 0) {
      return null;
    }
    if (customMark) {
      markLabel = customMark({
        point,
        label: markLabel
      });
    }
    var isActive = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var markClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(className, "-text"), true), _defineProperty$U(_classNames, "".concat(className, "-text-active"), isActive), _classNames));
    var bottomStyle = _defineProperty$U({
      marginBottom: "-50%"
    }, reverse2 ? "top" : "bottom", "".concat((point - min3) / range3 * 100, "%"));
    var leftStyle = _defineProperty$U({
      transform: "translateX(".concat(reverse2 ? "50%" : "-50%", ")"),
      msTransform: "translateX(".concat(reverse2 ? "50%" : "-50%", ")")
    }, reverse2 ? "right" : "left", "".concat((point - min3) / range3 * 100, "%"));
    var style2 = vertical ? bottomStyle : leftStyle;
    var markStyle = markPointIsObject ? _objectSpread2$1(_objectSpread2$1({}, style2), markPoint.style) : style2;
    var touchEvents = _defineProperty$U({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", function(e2) {
      return onClickLabel(e2, point);
    });
    return createVNode("span", _objectSpread2$1({
      "class": markClassName,
      "style": markStyle,
      "key": point,
      "onMousedown": function onMousedown2(e2) {
        return onClickLabel(e2, point);
      }
    }, touchEvents), [markLabel]);
  });
  return createVNode("div", {
    "class": className
  }, [elements]);
};
Marks.inheritAttrs = false;
const Marks$1 = Marks;
const VcHandle = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: false,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup: function setup168(props3, _ref) {
    var attrs = _ref.attrs, emit = _ref.emit, expose = _ref.expose;
    var clickFocused = ref(false);
    var handle = ref();
    var handleMouseUp = function handleMouseUp2() {
      if (document.activeElement === handle.value) {
        clickFocused.value = true;
      }
    };
    var handleBlur = function handleBlur2(e2) {
      clickFocused.value = false;
      emit("blur", e2);
    };
    var handleKeyDown2 = function handleKeyDown3() {
      clickFocused.value = false;
    };
    var focus = function focus2() {
      var _handle$value;
      (_handle$value = handle.value) === null || _handle$value === void 0 ? void 0 : _handle$value.focus();
    };
    var blur = function blur2() {
      var _handle$value2;
      (_handle$value2 = handle.value) === null || _handle$value2 === void 0 ? void 0 : _handle$value2.blur();
    };
    var clickFocus = function clickFocus2() {
      clickFocused.value = true;
      focus();
    };
    var handleMousedown = function handleMousedown2(e2) {
      e2.preventDefault();
      focus();
      emit("mousedown", e2);
    };
    expose({
      focus,
      blur,
      clickFocus,
      ref: handle
    });
    var onMouseUpListener = null;
    onMounted(function() {
      onMouseUpListener = addEventListenerWrap(document, "mouseup", handleMouseUp);
    });
    onBeforeUnmount(function() {
      var _onMouseUpListener;
      (_onMouseUpListener = onMouseUpListener) === null || _onMouseUpListener === void 0 ? void 0 : _onMouseUpListener.remove();
    });
    var positionStyle = computed(function() {
      var _ref2, _ref3;
      var vertical = props3.vertical, offset3 = props3.offset, reverse2 = props3.reverse;
      return vertical ? (_ref2 = {}, _defineProperty$U(_ref2, reverse2 ? "top" : "bottom", "".concat(offset3, "%")), _defineProperty$U(_ref2, reverse2 ? "bottom" : "top", "auto"), _defineProperty$U(_ref2, "transform", reverse2 ? null : "translateY(+50%)"), _ref2) : (_ref3 = {}, _defineProperty$U(_ref3, reverse2 ? "right" : "left", "".concat(offset3, "%")), _defineProperty$U(_ref3, reverse2 ? "left" : "right", "auto"), _defineProperty$U(_ref3, "transform", "translateX(".concat(reverse2 ? "+" : "-", "50%)")), _ref3);
    });
    return function() {
      var prefixCls = props3.prefixCls, disabled = props3.disabled, min3 = props3.min, max3 = props3.max, value = props3.value, tabindex = props3.tabindex, ariaLabel = props3.ariaLabel, ariaLabelledBy = props3.ariaLabelledBy, ariaValueTextFormatter = props3.ariaValueTextFormatter, onMouseenter2 = props3.onMouseenter, onMouseleave2 = props3.onMouseleave;
      var className = classNames(attrs.class, _defineProperty$U({}, "".concat(prefixCls, "-handle-click-focused"), clickFocused.value));
      var ariaProps = {
        "aria-valuemin": min3,
        "aria-valuemax": max3,
        "aria-valuenow": value,
        "aria-disabled": !!disabled
      };
      var elStyle = [attrs.style, positionStyle.value];
      var mergedTabIndex = tabindex || 0;
      if (disabled || tabindex === null) {
        mergedTabIndex = null;
      }
      var ariaValueText;
      if (ariaValueTextFormatter) {
        ariaValueText = ariaValueTextFormatter(value);
      }
      var handleProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        role: "slider",
        tabindex: mergedTabIndex
      }, ariaProps), {}, {
        class: className,
        onBlur: handleBlur,
        onKeydown: handleKeyDown2,
        onMousedown: handleMousedown,
        onMouseenter: onMouseenter2,
        onMouseleave: onMouseleave2,
        ref: handle,
        style: elStyle
      });
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, handleProps), {}, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-valuetext": ariaValueText
      }), null);
    };
  }
});
function isEventFromHandle(e2, handles) {
  try {
    return Object.keys(handles).some(function(key2) {
      return e2.target === handles[key2].ref;
    });
  } catch (error) {
    return false;
  }
}
function isValueOutOfRange(value, _ref) {
  var min3 = _ref.min, max3 = _ref.max;
  return value < min3 || value > max3;
}
function isNotTouchEvent(e2) {
  return e2.touches.length > 1 || e2.type.toLowerCase() === "touchend" && e2.touches.length > 0;
}
function getClosestPoint(val, _ref2) {
  var marks = _ref2.marks, step = _ref2.step, min3 = _ref2.min, max3 = _ref2.max;
  var points = Object.keys(marks).map(parseFloat);
  if (step !== null) {
    var baseNum = Math.pow(10, getPrecision(step));
    var maxSteps = Math.floor((max3 * baseNum - min3 * baseNum) / (step * baseNum));
    var steps = Math.min((val - min3) / step, maxSteps);
    var closestStep = Math.round(steps) * step + min3;
    points.push(closestStep);
  }
  var diffs = points.map(function(point) {
    return Math.abs(val - point);
  });
  return points[diffs.indexOf(Math.min.apply(Math, _toConsumableArray(diffs)))];
}
function getPrecision(step) {
  var stepString = step.toString();
  var precision = 0;
  if (stepString.indexOf(".") >= 0) {
    precision = stepString.length - stepString.indexOf(".") - 1;
  }
  return precision;
}
function getMousePosition(vertical, e2) {
  var zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e2.clientY : e2.pageX) / zoom;
}
function getTouchPosition(vertical, e2) {
  var zoom = 1;
  if (window.visualViewport) {
    zoom = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2);
  }
  return (vertical ? e2.touches[0].clientY : e2.touches[0].pageX) / zoom;
}
function getHandleCenterPosition(vertical, handle) {
  var coords = handle.getBoundingClientRect();
  return vertical ? coords.top + coords.height * 0.5 : window.pageXOffset + coords.left + coords.width * 0.5;
}
function ensureValueInRange(val, _ref3) {
  var max3 = _ref3.max, min3 = _ref3.min;
  if (val <= min3) {
    return min3;
  }
  if (val >= max3) {
    return max3;
  }
  return val;
}
function ensureValuePrecision(val, props3) {
  var step = props3.step;
  var closestPoint = isFinite(getClosestPoint(val, props3)) ? getClosestPoint(val, props3) : 0;
  return step === null ? closestPoint : parseFloat(closestPoint.toFixed(getPrecision(step)));
}
function pauseEvent(e2) {
  e2.stopPropagation();
  e2.preventDefault();
}
function calculateNextValue(func, value, props3) {
  var operations = {
    increase: function increase(a2, b2) {
      return a2 + b2;
    },
    decrease: function decrease(a2, b2) {
      return a2 - b2;
    }
  };
  var indexToGet = operations[func](Object.keys(props3.marks).indexOf(JSON.stringify(value)), 1);
  var keyToGet = Object.keys(props3.marks)[indexToGet];
  if (props3.step) {
    return operations[func](value, props3.step);
  }
  if (!!Object.keys(props3.marks).length && !!props3.marks[keyToGet]) {
    return props3.marks[keyToGet];
  }
  return value;
}
function getKeyboardValueMutator(e2, vertical, reverse2) {
  var increase = "increase";
  var decrease = "decrease";
  var method4 = increase;
  switch (e2.keyCode) {
    case KeyCode$1.UP:
      method4 = vertical && reverse2 ? decrease : increase;
      break;
    case KeyCode$1.RIGHT:
      method4 = !vertical && reverse2 ? decrease : increase;
      break;
    case KeyCode$1.DOWN:
      method4 = vertical && reverse2 ? increase : decrease;
      break;
    case KeyCode$1.LEFT:
      method4 = !vertical && reverse2 ? increase : decrease;
      break;
    case KeyCode$1.END:
      return function(_value, props3) {
        return props3.max;
      };
    case KeyCode$1.HOME:
      return function(_value, props3) {
        return props3.min;
      };
    case KeyCode$1.PAGE_UP:
      return function(value, props3) {
        return value + props3.step * 2;
      };
    case KeyCode$1.PAGE_DOWN:
      return function(value, props3) {
        return value - props3.step * 2;
      };
    default:
      return void 0;
  }
  return function(value, props3) {
    return calculateNextValue(method4, value, props3);
  };
}
var _excluded$h = ["index", "directives", "className", "style"];
function noop$4() {
}
function createSlider(Component) {
  var propTypes2 = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: PropTypes$1.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: PropTypes$1.object,
    maximumTrackStyle: PropTypes$1.object,
    handleStyle: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.arrayOf(PropTypes$1.object)]),
    trackStyle: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.arrayOf(PropTypes$1.object)]),
    railStyle: PropTypes$1.object,
    dotStyle: PropTypes$1.object,
    activeDotStyle: PropTypes$1.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [BaseMixin, Component],
    inheritAttrs: false,
    slots: ["mark"],
    props: initDefaultProps$1(propTypes2, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: true,
      disabled: false,
      dots: false,
      vertical: false,
      reverse: false,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data: function data9() {
      var step = this.step, max3 = this.max, min3 = this.min;
      var isPointDiffEven = isFinite(max3 - min3) ? (max3 - min3) % step === 0 : true;
      warning$2(step && Math.floor(step) === step ? isPointDiffEven : true, "Slider[max] - Slider[min] (".concat(max3 - min3, ") should be a multiple of Slider[step] (").concat(step, ")"));
      this.handlesRefs = {};
      return {};
    },
    mounted: function mounted6() {
      var _this = this;
      this.$nextTick(function() {
        _this.document = _this.sliderRef && _this.sliderRef.ownerDocument;
        var autofocus = _this.autofocus, disabled = _this.disabled;
        if (autofocus && !disabled) {
          _this.focus();
        }
      });
    },
    beforeUnmount: function beforeUnmount6() {
      var _this2 = this;
      this.$nextTick(function() {
        _this2.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle: function defaultHandle(_ref) {
        var index2 = _ref.index;
        _ref.directives;
        var className = _ref.className, style2 = _ref.style, restProps = _objectWithoutProperties$2(_ref, _excluded$h);
        delete restProps.dragging;
        if (restProps.value === null) {
          return null;
        }
        var handleProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          class: className,
          style: style2,
          key: index2
        });
        return createVNode(VcHandle, handleProps, null);
      },
      onDown: function onDown(e2, position) {
        var p2 = position;
        var _this$$props = this.$props, draggableTrack = _this$$props.draggableTrack, isVertical = _this$$props.vertical;
        var bounds = this.$data.bounds;
        var value = draggableTrack && this.positionGetValue ? this.positionGetValue(p2) || [] : [];
        var inPoint = isEventFromHandle(e2, this.handlesRefs);
        this.dragTrack = draggableTrack && bounds.length >= 2 && !inPoint && !value.map(function(n2, i2) {
          var v2 = !i2 ? n2 >= bounds[i2] : true;
          return i2 === value.length - 1 ? n2 <= bounds[i2] : v2;
        }).some(function(c2) {
          return !c2;
        });
        if (this.dragTrack) {
          this.dragOffset = p2;
          this.startBounds = _toConsumableArray(bounds);
        } else {
          if (!inPoint) {
            this.dragOffset = 0;
          } else {
            var handlePosition = getHandleCenterPosition(isVertical, e2.target);
            this.dragOffset = p2 - handlePosition;
            p2 = handlePosition;
          }
          this.onStart(p2);
        }
      },
      onMouseDown: function onMouseDown2(e2) {
        if (e2.button !== 0) {
          return;
        }
        this.removeDocumentEvents();
        var isVertical = this.$props.vertical;
        var position = getMousePosition(isVertical, e2);
        this.onDown(e2, position);
        this.addDocumentMouseEvents();
      },
      onTouchStart: function onTouchStart(e2) {
        if (isNotTouchEvent(e2))
          return;
        var isVertical = this.vertical;
        var position = getTouchPosition(isVertical, e2);
        this.onDown(e2, position);
        this.addDocumentTouchEvents();
        pauseEvent(e2);
      },
      onFocus: function onFocus2(e2) {
        var vertical = this.vertical;
        if (isEventFromHandle(e2, this.handlesRefs) && !this.dragTrack) {
          var handlePosition = getHandleCenterPosition(vertical, e2.target);
          this.dragOffset = 0;
          this.onStart(handlePosition);
          pauseEvent(e2);
          this.$emit("focus", e2);
        }
      },
      onBlur: function onBlur2(e2) {
        if (!this.dragTrack) {
          this.onEnd();
        }
        this.$emit("blur", e2);
      },
      onMouseUp: function onMouseUp2() {
        if (this.handlesRefs[this.prevMovedHandleIndex]) {
          this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
        }
      },
      onMouseMove: function onMouseMove3(e2) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        var position = getMousePosition(this.vertical, e2);
        this.onMove(e2, position - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove: function onTouchMove(e2) {
        if (isNotTouchEvent(e2) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        var position = getTouchPosition(this.vertical, e2);
        this.onMove(e2, position - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown: function onKeyDown(e2) {
        if (this.sliderRef && isEventFromHandle(e2, this.handlesRefs)) {
          this.onKeyboard(e2);
        }
      },
      onClickMarkLabel: function onClickMarkLabel(e2, value) {
        var _this3 = this;
        e2.stopPropagation();
        this.onChange({
          sValue: value
        });
        this.setState({
          sValue: value
        }, function() {
          return _this3.onEnd(true);
        });
      },
      getSliderStart: function getSliderStart() {
        var slider = this.sliderRef;
        var vertical = this.vertical, reverse2 = this.reverse;
        var rect = slider.getBoundingClientRect();
        if (vertical) {
          return reverse2 ? rect.bottom : rect.top;
        }
        return window.pageXOffset + (reverse2 ? rect.right : rect.left);
      },
      getSliderLength: function getSliderLength() {
        var slider = this.sliderRef;
        if (!slider) {
          return 0;
        }
        var coords = slider.getBoundingClientRect();
        return this.vertical ? coords.height : coords.width;
      },
      addDocumentTouchEvents: function addDocumentTouchEvents() {
        this.onTouchMoveListener = addEventListenerWrap(this.document, "touchmove", this.onTouchMove);
        this.onTouchUpListener = addEventListenerWrap(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents: function addDocumentMouseEvents() {
        this.onMouseMoveListener = addEventListenerWrap(this.document, "mousemove", this.onMouseMove);
        this.onMouseUpListener = addEventListenerWrap(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents: function removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove();
        this.onTouchUpListener && this.onTouchUpListener.remove();
        this.onMouseMoveListener && this.onMouseMoveListener.remove();
        this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus: function focus() {
        var _this$handlesRefs$;
        if (this.$props.disabled) {
          return;
        }
        (_this$handlesRefs$ = this.handlesRefs[0]) === null || _this$handlesRefs$ === void 0 ? void 0 : _this$handlesRefs$.focus();
      },
      blur: function blur() {
        var _this4 = this;
        if (this.$props.disabled) {
          return;
        }
        Object.keys(this.handlesRefs).forEach(function(key2) {
          var _this4$handlesRefs$ke, _this4$handlesRefs$ke2;
          (_this4$handlesRefs$ke = _this4.handlesRefs[key2]) === null || _this4$handlesRefs$ke === void 0 ? void 0 : (_this4$handlesRefs$ke2 = _this4$handlesRefs$ke.blur) === null || _this4$handlesRefs$ke2 === void 0 ? void 0 : _this4$handlesRefs$ke2.call(_this4$handlesRefs$ke);
        });
      },
      calcValue: function calcValue(offset3) {
        var vertical = this.vertical, min3 = this.min, max3 = this.max;
        var ratio = Math.abs(Math.max(offset3, 0) / this.getSliderLength());
        var value = vertical ? (1 - ratio) * (max3 - min3) + min3 : ratio * (max3 - min3) + min3;
        return value;
      },
      calcValueByPos: function calcValueByPos(position) {
        var sign2 = this.reverse ? -1 : 1;
        var pixelOffset = sign2 * (position - this.getSliderStart());
        var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
        return nextValue;
      },
      calcOffset: function calcOffset(value) {
        var min3 = this.min, max3 = this.max;
        var ratio = (value - min3) / (max3 - min3);
        return Math.max(0, ratio * 100);
      },
      saveSlider: function saveSlider(slider) {
        this.sliderRef = slider;
      },
      saveHandle: function saveHandle(index2, handle) {
        this.handlesRefs[index2] = handle;
      }
    },
    render: function render14() {
      var _classNames;
      var prefixCls = this.prefixCls, marks = this.marks, dots = this.dots, step = this.step, included = this.included, disabled = this.disabled, vertical = this.vertical, reverse2 = this.reverse, min3 = this.min, max3 = this.max, maximumTrackStyle = this.maximumTrackStyle, railStyle = this.railStyle, dotStyle = this.dotStyle, activeDotStyle = this.activeDotStyle, id = this.id;
      var _this$$attrs = this.$attrs, className = _this$$attrs.class, style2 = _this$$attrs.style;
      var _this$renderSlider = this.renderSlider(), tracks = _this$renderSlider.tracks, handles = _this$renderSlider.handles;
      var sliderClassName = classNames(prefixCls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-with-marks"), Object.keys(marks).length), _defineProperty$U(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls, "-vertical"), vertical), _classNames));
      var markProps = {
        vertical,
        marks,
        included,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: max3,
        min: min3,
        reverse: reverse2,
        class: "".concat(prefixCls, "-mark"),
        onClickLabel: disabled ? noop$4 : this.onClickMarkLabel
      };
      var touchEvents = _defineProperty$U({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", disabled ? noop$4 : this.onTouchStart);
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "id": id,
        "ref": this.saveSlider,
        "tabindex": "-1",
        "class": sliderClassName
      }, touchEvents), {}, {
        "onMousedown": disabled ? noop$4 : this.onMouseDown,
        "onMouseup": disabled ? noop$4 : this.onMouseUp,
        "onKeydown": disabled ? noop$4 : this.onKeyDown,
        "onFocus": disabled ? noop$4 : this.onFocus,
        "onBlur": disabled ? noop$4 : this.onBlur,
        "style": style2
      }), [createVNode("div", {
        "class": "".concat(prefixCls, "-rail"),
        "style": _objectSpread2$1(_objectSpread2$1({}, maximumTrackStyle), railStyle)
      }, null), tracks, createVNode(Steps$3, {
        "prefixCls": prefixCls,
        "vertical": vertical,
        "reverse": reverse2,
        "marks": marks,
        "dots": dots,
        "step": step,
        "included": included,
        "lowerBound": this.getLowerBound(),
        "upperBound": this.getUpperBound(),
        "max": max3,
        "min": min3,
        "dotStyle": dotStyle,
        "activeDotStyle": activeDotStyle
      }, null), handles, createVNode(Marks$1, markProps, {
        mark: this.$slots.mark
      }), getSlot(this)]);
    }
  });
}
var Slider$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: PropTypes$1.oneOfType([PropTypes$1.number, PropTypes$1.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data: function data6() {
    var defaultValue = this.defaultValue !== void 0 ? this.defaultValue : this.min;
    var value = this.value !== void 0 ? this.value : defaultValue;
    return {
      sValue: this.trimAlignValue(value),
      dragging: false
    };
  },
  watch: {
    value: {
      handler: function handler3(val) {
        this.setChangeValue(val);
      },
      deep: true
    },
    min: function min() {
      var sValue = this.sValue;
      this.setChangeValue(sValue);
    },
    max: function max() {
      var sValue = this.sValue;
      this.setChangeValue(sValue);
    }
  },
  methods: {
    setChangeValue: function setChangeValue(value) {
      var newValue = value !== void 0 ? value : this.sValue;
      var nextValue = this.trimAlignValue(newValue, this.$props);
      if (nextValue === this.sValue)
        return;
      this.setState({
        sValue: nextValue
      });
      if (isValueOutOfRange(newValue, this.$props)) {
        this.$emit("change", nextValue);
      }
    },
    onChange: function onChange(state) {
      var isNotControlled = !hasProp(this, "value");
      var nextState = state.sValue > this.max ? _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        sValue: this.max
      }) : state;
      if (isNotControlled) {
        this.setState(nextState);
      }
      var changedValue = nextState.sValue;
      this.$emit("change", changedValue);
    },
    onStart: function onStart(position) {
      this.setState({
        dragging: true
      });
      var sValue = this.sValue;
      this.$emit("beforeChange", sValue);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      if (value === sValue)
        return;
      this.prevMovedHandleIndex = 0;
      this.onChange({
        sValue: value
      });
    },
    onEnd: function onEnd(force) {
      var dragging = this.dragging;
      this.removeDocumentEvents();
      if (dragging || force) {
        this.$emit("afterChange", this.sValue);
      }
      this.setState({
        dragging: false
      });
    },
    onMove: function onMove(e2, position) {
      pauseEvent(e2);
      var sValue = this.sValue;
      var value = this.calcValueByPos(position);
      if (value === sValue)
        return;
      this.onChange({
        sValue: value
      });
    },
    onKeyboard: function onKeyboard(e2) {
      var _this$$props = this.$props, reverse2 = _this$$props.reverse, vertical = _this$$props.vertical;
      var valueMutator = getKeyboardValueMutator(e2, vertical, reverse2);
      if (valueMutator) {
        pauseEvent(e2);
        var sValue = this.sValue;
        var mutatedValue = valueMutator(sValue, this.$props);
        var value = this.trimAlignValue(mutatedValue);
        if (value === sValue)
          return;
        this.onChange({
          sValue: value
        });
        this.$emit("afterChange", value);
        this.onEnd();
      }
    },
    getLowerBound: function getLowerBound() {
      var minPoint = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > minPoint ? minPoint : this.$data.sValue;
    },
    getUpperBound: function getUpperBound() {
      if (this.$data.sValue < this.$props.startPoint) {
        return this.$props.startPoint;
      }
      return this.$data.sValue;
    },
    trimAlignValue: function trimAlignValue(v2) {
      var nextProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (v2 === null) {
        return null;
      }
      var mergedProps = _objectSpread2$1(_objectSpread2$1({}, this.$props), nextProps);
      var val = ensureValueInRange(v2, mergedProps);
      return ensureValuePrecision(val, mergedProps);
    },
    getTrack: function getTrack(_ref) {
      var prefixCls = _ref.prefixCls, reverse2 = _ref.reverse, vertical = _ref.vertical, included = _ref.included, minimumTrackStyle = _ref.minimumTrackStyle, mergedTrackStyle = _ref.mergedTrackStyle, length = _ref.length, offset3 = _ref.offset;
      return createVNode(Track$1, {
        "class": "".concat(prefixCls, "-track"),
        "vertical": vertical,
        "included": included,
        "offset": offset3,
        "reverse": reverse2,
        "length": length,
        "style": _objectSpread2$1(_objectSpread2$1({}, minimumTrackStyle), mergedTrackStyle)
      }, null);
    },
    renderSlider: function renderSlider() {
      var _this = this;
      var prefixCls = this.prefixCls, vertical = this.vertical, included = this.included, disabled = this.disabled, minimumTrackStyle = this.minimumTrackStyle, trackStyle = this.trackStyle, handleStyle = this.handleStyle, tabindex = this.tabindex, ariaLabelForHandle = this.ariaLabelForHandle, ariaLabelledByForHandle = this.ariaLabelledByForHandle, ariaValueTextFormatterForHandle = this.ariaValueTextFormatterForHandle, min3 = this.min, max3 = this.max, startPoint = this.startPoint, reverse2 = this.reverse, handle = this.handle, defaultHandle = this.defaultHandle;
      var handleGenerator = handle || defaultHandle;
      var sValue = this.sValue, dragging = this.dragging;
      var offset3 = this.calcOffset(sValue);
      var handles = handleGenerator({
        class: "".concat(prefixCls, "-handle"),
        prefixCls,
        vertical,
        offset: offset3,
        value: sValue,
        dragging,
        disabled,
        min: min3,
        max: max3,
        reverse: reverse2,
        index: 0,
        tabindex,
        ariaLabel: ariaLabelForHandle,
        ariaLabelledBy: ariaLabelledByForHandle,
        ariaValueTextFormatter: ariaValueTextFormatterForHandle,
        style: handleStyle[0] || handleStyle,
        ref: function ref2(h2) {
          return _this.saveHandle(0, h2);
        },
        onFocus: this.onFocus,
        onBlur: this.onBlur
      });
      var trackOffset = startPoint !== void 0 ? this.calcOffset(startPoint) : 0;
      var mergedTrackStyle = trackStyle[0] || trackStyle;
      return {
        tracks: this.getTrack({
          prefixCls,
          reverse: reverse2,
          vertical,
          included,
          offset: trackOffset,
          minimumTrackStyle,
          mergedTrackStyle,
          length: offset3 - trackOffset
        }),
        handles
      };
    }
  }
});
const VcSlider = createSlider(Slider$1);
var _trimAlignValue = function trimAlignValue2(_ref) {
  var value = _ref.value, handle = _ref.handle, bounds = _ref.bounds, props3 = _ref.props;
  var allowCross = props3.allowCross, pushable = props3.pushable;
  var thershold = Number(pushable);
  var valInRange = ensureValueInRange(value, props3);
  var valNotConflict = valInRange;
  if (!allowCross && handle != null && bounds !== void 0) {
    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {
      valNotConflict = bounds[handle - 1] + thershold;
    }
    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {
      valNotConflict = bounds[handle + 1] - thershold;
    }
  }
  return ensureValuePrecision(valNotConflict, props3);
};
var rangeProps = {
  defaultValue: PropTypes$1.arrayOf(PropTypes$1.number),
  value: PropTypes$1.arrayOf(PropTypes$1.number),
  count: Number,
  pushable: withUndefined(PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: PropTypes$1.arrayOf(PropTypes$1.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
};
var Range = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [BaseMixin],
  inheritAttrs: false,
  props: initDefaultProps$1(rangeProps, {
    count: 1,
    allowCross: true,
    pushable: false,
    tabindex: [],
    draggableTrack: false,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data: function data7() {
    var _this = this;
    var count = this.count, min3 = this.min, max3 = this.max;
    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function() {
      return min3;
    });
    var defaultValue = hasProp(this, "defaultValue") ? this.defaultValue : initialValue;
    var value = this.value;
    if (value === void 0) {
      value = defaultValue;
    }
    var bounds = value.map(function(v2, i2) {
      return _trimAlignValue({
        value: v2,
        handle: i2,
        props: _this.$props
      });
    });
    var recent = bounds[0] === max3 ? 0 : bounds.length - 1;
    return {
      sHandle: null,
      recent,
      bounds
    };
  },
  watch: {
    value: {
      handler: function handler4(val) {
        var bounds = this.bounds;
        this.setChangeValue(val || bounds);
      },
      deep: true
    },
    min: function min2() {
      var value = this.value;
      this.setChangeValue(value || this.bounds);
    },
    max: function max2() {
      var value = this.value;
      this.setChangeValue(value || this.bounds);
    }
  },
  methods: {
    setChangeValue: function setChangeValue2(value) {
      var _this2 = this;
      var bounds = this.bounds;
      var nextBounds = value.map(function(v2, i2) {
        return _trimAlignValue({
          value: v2,
          handle: i2,
          bounds,
          props: _this2.$props
        });
      });
      if (bounds.length === nextBounds.length) {
        if (nextBounds.every(function(v2, i2) {
          return v2 === bounds[i2];
        })) {
          return null;
        }
      } else {
        nextBounds = value.map(function(v2, i2) {
          return _trimAlignValue({
            value: v2,
            handle: i2,
            props: _this2.$props
          });
        });
      }
      this.setState({
        bounds: nextBounds
      });
      if (value.some(function(v2) {
        return isValueOutOfRange(v2, _this2.$props);
      })) {
        var newValues = value.map(function(v2) {
          return ensureValueInRange(v2, _this2.$props);
        });
        this.$emit("change", newValues);
      }
    },
    onChange: function onChange2(state) {
      var isNotControlled = !hasProp(this, "value");
      if (isNotControlled) {
        this.setState(state);
      } else {
        var controlledState = {};
        ["sHandle", "recent"].forEach(function(item) {
          if (state[item] !== void 0) {
            controlledState[item] = state[item];
          }
        });
        if (Object.keys(controlledState).length) {
          this.setState(controlledState);
        }
      }
      var data9 = _objectSpread2$1(_objectSpread2$1({}, this.$data), state);
      var changedValue = data9.bounds;
      this.$emit("change", changedValue);
    },
    positionGetValue: function positionGetValue(position) {
      var bounds = this.getValue();
      var value = this.calcValueByPos(position);
      var closestBound = this.getClosestBound(value);
      var index2 = this.getBoundNeedMoving(value, closestBound);
      var prevValue = bounds[index2];
      if (value === prevValue)
        return null;
      var nextBounds = _toConsumableArray(bounds);
      nextBounds[index2] = value;
      return nextBounds;
    },
    onStart: function onStart2(position) {
      var bounds = this.bounds;
      this.$emit("beforeChange", bounds);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      var closestBound = this.getClosestBound(value);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      var prevValue = bounds[this.prevMovedHandleIndex];
      if (value === prevValue)
        return;
      var nextBounds = _toConsumableArray(bounds);
      nextBounds[this.prevMovedHandleIndex] = value;
      this.onChange({
        bounds: nextBounds
      });
    },
    onEnd: function onEnd2(force) {
      var sHandle = this.sHandle;
      this.removeDocumentEvents();
      if (!sHandle) {
        this.dragTrack = false;
      }
      if (sHandle !== null || force) {
        this.$emit("afterChange", this.bounds);
      }
      this.setState({
        sHandle: null
      });
    },
    onMove: function onMove2(e2, position, dragTrack, startBounds) {
      pauseEvent(e2);
      var state = this.$data, props3 = this.$props;
      var maxValue = props3.max || 100;
      var minValue = props3.min || 0;
      if (dragTrack) {
        var pos2 = props3.vertical ? -position : position;
        pos2 = props3.reverse ? -pos2 : pos2;
        var max3 = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));
        var min3 = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));
        var ratio = Math.min(Math.max(pos2 / (this.getSliderLength() / 100), min3), max3);
        var nextBounds = startBounds.map(function(v2) {
          return Math.floor(Math.max(Math.min(v2 + ratio, maxValue), minValue));
        });
        if (state.bounds.map(function(c2, i2) {
          return c2 === nextBounds[i2];
        }).some(function(c2) {
          return !c2;
        })) {
          this.onChange({
            bounds: nextBounds
          });
        }
        return;
      }
      var bounds = this.bounds, sHandle = this.sHandle;
      var value = this.calcValueByPos(position);
      var oldValue = bounds[sHandle];
      if (value === oldValue)
        return;
      this.moveTo(value);
    },
    onKeyboard: function onKeyboard2(e2) {
      var _this$$props = this.$props, reverse2 = _this$$props.reverse, vertical = _this$$props.vertical;
      var valueMutator = getKeyboardValueMutator(e2, vertical, reverse2);
      if (valueMutator) {
        pauseEvent(e2);
        var bounds = this.bounds, sHandle = this.sHandle;
        var oldValue = bounds[sHandle === null ? this.recent : sHandle];
        var mutatedValue = valueMutator(oldValue, this.$props);
        var value = _trimAlignValue({
          value: mutatedValue,
          handle: sHandle,
          bounds,
          props: this.$props
        });
        if (value === oldValue)
          return;
        var isFromKeyboardEvent = true;
        this.moveTo(value, isFromKeyboardEvent);
      }
    },
    getClosestBound: function getClosestBound(value) {
      var bounds = this.bounds;
      var closestBound = 0;
      for (var i2 = 1; i2 < bounds.length - 1; i2 += 1) {
        if (value >= bounds[i2]) {
          closestBound = i2;
        }
      }
      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound += 1;
      }
      return closestBound;
    },
    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {
      var bounds = this.bounds, recent = this.recent;
      var boundNeedMoving = closestBound;
      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];
      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }
      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }
      return boundNeedMoving;
    },
    getLowerBound: function getLowerBound2() {
      return this.bounds[0];
    },
    getUpperBound: function getUpperBound2() {
      var bounds = this.bounds;
      return bounds[bounds.length - 1];
    },
    getPoints: function getPoints() {
      var marks = this.marks, step = this.step, min3 = this.min, max3 = this.max;
      var cache = this.internalPointsCache;
      if (!cache || cache.marks !== marks || cache.step !== step) {
        var pointsObject = _objectSpread2$1({}, marks);
        if (step !== null) {
          for (var point = min3; point <= max3; point += step) {
            pointsObject[point] = point;
          }
        }
        var points = Object.keys(pointsObject).map(parseFloat);
        points.sort(function(a2, b2) {
          return a2 - b2;
        });
        this.internalPointsCache = {
          marks,
          step,
          points
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo: function moveTo(value, isFromKeyboardEvent) {
      var _this3 = this;
      var nextBounds = _toConsumableArray(this.bounds);
      var sHandle = this.sHandle, recent = this.recent;
      var handle = sHandle === null ? recent : sHandle;
      nextBounds[handle] = value;
      var nextHandle = handle;
      if (this.$props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (this.$props.allowCross) {
        nextBounds.sort(function(a2, b2) {
          return a2 - b2;
        });
        nextHandle = nextBounds.indexOf(value);
      }
      this.onChange({
        recent: nextHandle,
        sHandle: nextHandle,
        bounds: nextBounds
      });
      if (isFromKeyboardEvent) {
        this.$emit("afterChange", nextBounds);
        this.setState({}, function() {
          _this3.handlesRefs[nextHandle].focus();
        });
        this.onEnd();
      }
    },
    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {
      var value = bounds[handle];
      var pushable = this.pushable;
      var threshold = Number(pushable);
      var direction = 0;
      if (bounds[handle + 1] - value < threshold) {
        direction = 1;
      }
      if (value - bounds[handle - 1] < threshold) {
        direction = -1;
      }
      if (direction === 0) {
        return;
      }
      var nextHandle = handle + direction;
      var diffToNext = direction * (bounds[nextHandle] - value);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    },
    pushHandle: function pushHandle(bounds, handle, direction, amount) {
      var originalValue = bounds[handle];
      var currentValue = bounds[handle];
      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          bounds[handle] = originalValue;
          return false;
        }
        currentValue = bounds[handle];
      }
      return true;
    },
    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {
      var points = this.getPoints();
      var pointIndex = points.indexOf(bounds[handle]);
      var nextPointIndex = pointIndex + direction;
      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        return false;
      }
      var nextHandle = handle + direction;
      var nextValue = points[nextPointIndex];
      var pushable = this.pushable;
      var threshold = Number(pushable);
      var diffToNext = direction * (bounds[nextHandle] - nextValue);
      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        return false;
      }
      bounds[handle] = nextValue;
      return true;
    },
    trimAlignValue: function trimAlignValue3(value) {
      var sHandle = this.sHandle, bounds = this.bounds;
      return _trimAlignValue({
        value,
        handle: sHandle,
        bounds,
        props: this.$props
      });
    },
    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {
      var allowCross = _ref2.allowCross, thershold = _ref2.pushable;
      var state = this.$data || {};
      var bounds = state.bounds;
      handle = handle === void 0 ? state.sHandle : handle;
      thershold = Number(thershold);
      if (!allowCross && handle != null && bounds !== void 0) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }
        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      return val;
    },
    getTrack: function getTrack2(_ref3) {
      var bounds = _ref3.bounds, prefixCls = _ref3.prefixCls, reverse2 = _ref3.reverse, vertical = _ref3.vertical, included = _ref3.included, offsets = _ref3.offsets, trackStyle = _ref3.trackStyle;
      return bounds.slice(0, -1).map(function(_2, index2) {
        var _classNames;
        var i2 = index2 + 1;
        var trackClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-track"), true), _defineProperty$U(_classNames, "".concat(prefixCls, "-track-").concat(i2), true), _classNames));
        return createVNode(Track$1, {
          "class": trackClassName,
          "vertical": vertical,
          "reverse": reverse2,
          "included": included,
          "offset": offsets[i2 - 1],
          "length": offsets[i2] - offsets[i2 - 1],
          "style": trackStyle[index2],
          "key": i2
        }, null);
      });
    },
    renderSlider: function renderSlider2() {
      var _this4 = this;
      var sHandle = this.sHandle, bounds = this.bounds, prefixCls = this.prefixCls, vertical = this.vertical, included = this.included, disabled = this.disabled, min3 = this.min, max3 = this.max, reverse2 = this.reverse, handle = this.handle, defaultHandle = this.defaultHandle, trackStyle = this.trackStyle, handleStyle = this.handleStyle, tabindex = this.tabindex, ariaLabelGroupForHandles = this.ariaLabelGroupForHandles, ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles, ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;
      var handleGenerator = handle || defaultHandle;
      var offsets = bounds.map(function(v2) {
        return _this4.calcOffset(v2);
      });
      var handleClassName = "".concat(prefixCls, "-handle");
      var handles = bounds.map(function(v2, i2) {
        var _classNames2;
        var mergedTabIndex = tabindex[i2] || 0;
        if (disabled || tabindex[i2] === null) {
          mergedTabIndex = null;
        }
        var dragging = sHandle === i2;
        return handleGenerator({
          class: classNames((_classNames2 = {}, _defineProperty$U(_classNames2, handleClassName, true), _defineProperty$U(_classNames2, "".concat(handleClassName, "-").concat(i2 + 1), true), _defineProperty$U(_classNames2, "".concat(handleClassName, "-dragging"), dragging), _classNames2)),
          prefixCls,
          vertical,
          dragging,
          offset: offsets[i2],
          value: v2,
          index: i2,
          tabindex: mergedTabIndex,
          min: min3,
          max: max3,
          reverse: reverse2,
          disabled,
          style: handleStyle[i2],
          ref: function ref2(h2) {
            return _this4.saveHandle(i2, h2);
          },
          onFocus: _this4.onFocus,
          onBlur: _this4.onBlur,
          ariaLabel: ariaLabelGroupForHandles[i2],
          ariaLabelledBy: ariaLabelledByGroupForHandles[i2],
          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i2]
        });
      });
      return {
        tracks: this.getTrack({
          bounds,
          prefixCls,
          reverse: reverse2,
          vertical,
          included,
          offsets,
          trackStyle
        }),
        handles
      };
    }
  }
});
const VcRange = createSlider(Range);
const SliderTooltip = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: false,
  props: tooltipProps(),
  setup: function setup169(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var innerRef = ref(null);
    var rafRef = ref(null);
    function cancelKeepAlign() {
      wrapperRaf.cancel(rafRef.value);
      rafRef.value = null;
    }
    function keepAlign() {
      rafRef.value = wrapperRaf(function() {
        var _innerRef$value;
        (_innerRef$value = innerRef.value) === null || _innerRef$value === void 0 ? void 0 : _innerRef$value.forcePopupAlign();
        rafRef.value = null;
      });
    }
    var align = function align2() {
      cancelKeepAlign();
      if (props3.visible) {
        keepAlign();
      }
    };
    watch([function() {
      return props3.visible;
    }, function() {
      return props3.title;
    }], function() {
      align();
    }, {
      flush: "post",
      immediate: true
    });
    onActivated(function() {
      align();
    });
    onBeforeUnmount(function() {
      cancelKeepAlign();
    });
    return function() {
      return createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1({
        "ref": innerRef
      }, props3), attrs), slots);
    };
  }
});
var _excluded$g = ["value", "dragging", "index"], _excluded2$1 = ["tooltipPrefixCls", "range", "id"];
var defaultTipFormatter = function defaultTipFormatter2(value) {
  return typeof value === "number" ? value.toString() : "";
};
var sliderProps = function sliderProps2() {
  return {
    id: String,
    prefixCls: String,
    tooltipPrefixCls: String,
    range: {
      type: [Boolean, Object],
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    step: {
      type: [Number, Object]
    },
    marks: {
      type: Object
    },
    dots: {
      type: Boolean,
      default: void 0
    },
    value: {
      type: [Number, Array]
    },
    defaultValue: {
      type: [Number, Array]
    },
    included: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    tipFormatter: {
      type: [Function, Object],
      default: function _default9() {
        return defaultTipFormatter;
      }
    },
    tooltipVisible: {
      type: Boolean,
      default: void 0
    },
    tooltipPlacement: {
      type: String
    },
    getTooltipPopupContainer: {
      type: Function
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    handleStyle: {
      type: [Object, Array]
    },
    trackStyle: {
      type: [Object, Array]
    },
    onChange: {
      type: Function
    },
    onAfterChange: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    "onUpdate:value": {
      type: Function
    }
  };
};
var Slider = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: false,
  props: sliderProps(),
  slots: ["mark"],
  setup: function setup170(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var _useConfigInject = useConfigInject("slider", props3), prefixCls = _useConfigInject.prefixCls, rootPrefixCls = _useConfigInject.rootPrefixCls, direction = _useConfigInject.direction, getPopupContainer = _useConfigInject.getPopupContainer, configProvider = _useConfigInject.configProvider;
    var formItemContext = useInjectFormItemContext();
    var sliderRef = ref();
    var visibles = ref({});
    var toggleTooltipVisible = function toggleTooltipVisible2(index2, visible) {
      visibles.value[index2] = visible;
    };
    var tooltipPlacement = computed(function() {
      if (props3.tooltipPlacement) {
        return props3.tooltipPlacement;
      }
      if (!props3.vertical) {
        return "top";
      }
      return direction.value === "rtl" ? "left" : "right";
    });
    var focus = function focus2() {
      var _sliderRef$value;
      (_sliderRef$value = sliderRef.value) === null || _sliderRef$value === void 0 ? void 0 : _sliderRef$value.focus();
    };
    var blur = function blur2() {
      var _sliderRef$value2;
      (_sliderRef$value2 = sliderRef.value) === null || _sliderRef$value2 === void 0 ? void 0 : _sliderRef$value2.blur();
    };
    var handleChange2 = function handleChange3(val) {
      emit("update:value", val);
      emit("change", val);
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
    };
    expose({
      focus,
      blur
    });
    var handleWithTooltip = function handleWithTooltip2(_ref2) {
      var tooltipPrefixCls = _ref2.tooltipPrefixCls, _ref2$info = _ref2.info, value = _ref2$info.value, dragging = _ref2$info.dragging, index2 = _ref2$info.index, restProps = _objectWithoutProperties$2(_ref2$info, _excluded$g);
      var tipFormatter = props3.tipFormatter, tooltipVisible = props3.tooltipVisible, getTooltipPopupContainer = props3.getTooltipPopupContainer;
      var isTipFormatter = tipFormatter ? visibles.value[index2] || dragging : false;
      var visible = tooltipVisible || tooltipVisible === void 0 && isTipFormatter;
      return createVNode(SliderTooltip, {
        "prefixCls": tooltipPrefixCls,
        "title": tipFormatter ? tipFormatter(value) : "",
        "visible": visible,
        "placement": tooltipPlacement.value,
        "transitionName": "".concat(rootPrefixCls.value, "-zoom-down"),
        "key": index2,
        "overlayClassName": "".concat(prefixCls.value, "-tooltip"),
        "getPopupContainer": getTooltipPopupContainer || getPopupContainer.value
      }, {
        default: function _default9() {
          return [createVNode(VcHandle, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
            "value": value,
            "onMouseenter": function onMouseenter2() {
              return toggleTooltipVisible(index2, true);
            },
            "onMouseleave": function onMouseleave2() {
              return toggleTooltipVisible(index2, false);
            }
          }), null)];
        }
      });
    };
    return function() {
      var customizeTooltipPrefixCls = props3.tooltipPrefixCls, range3 = props3.range, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id, restProps = _objectWithoutProperties$2(props3, _excluded2$1);
      var tooltipPrefixCls = configProvider.getPrefixCls("tooltip", customizeTooltipPrefixCls);
      var cls = classNames(attrs.class, _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"));
      if (direction.value === "rtl" && !restProps.vertical) {
        restProps.reverse = !restProps.reverse;
      }
      var draggableTrack;
      if (_typeof$3(range3) === "object") {
        draggableTrack = range3.draggableTrack;
      }
      if (range3) {
        return createVNode(VcRange, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          "step": restProps.step,
          "draggableTrack": draggableTrack,
          "class": cls,
          "ref": sliderRef,
          "handle": function handle(info) {
            return handleWithTooltip({
              tooltipPrefixCls,
              prefixCls: prefixCls.value,
              info
            });
          },
          "prefixCls": prefixCls.value,
          "onChange": handleChange2,
          "onBlur": handleBlur
        }), {
          mark: slots.mark
        });
      }
      return createVNode(VcSlider, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
        "id": id,
        "step": restProps.step,
        "class": cls,
        "ref": sliderRef,
        "handle": function handle(info) {
          return handleWithTooltip({
            tooltipPrefixCls,
            prefixCls: prefixCls.value,
            info
          });
        },
        "prefixCls": prefixCls.value,
        "onChange": handleChange2,
        "onBlur": handleBlur
      }), {
        mark: slots.mark
      });
    };
  }
});
const index$8 = withInstall(Slider);
var spaceSize = {
  small: 8,
  middle: 16,
  large: 24
};
var spaceProps = function spaceProps2() {
  return {
    prefixCls: String,
    size: {
      type: [String, Number, Array]
    },
    direction: PropTypes$1.oneOf(tuple$1("horizontal", "vertical")).def("horizontal"),
    align: PropTypes$1.oneOf(tuple$1("start", "end", "center", "baseline")),
    wrap: {
      type: Boolean,
      default: void 0
    }
  };
};
function getNumberSize(size2) {
  return typeof size2 === "string" ? spaceSize[size2] : size2 || 0;
}
var Space = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASpace",
  props: spaceProps(),
  slots: ["split"],
  setup: function setup171(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("space", props3), prefixCls = _useConfigInject.prefixCls, space = _useConfigInject.space, directionConfig = _useConfigInject.direction;
    var supportFlexGap = useFlexGapSupport();
    var size2 = computed(function() {
      var _ref2, _props$size, _space$value;
      return (_ref2 = (_props$size = props3.size) !== null && _props$size !== void 0 ? _props$size : (_space$value = space.value) === null || _space$value === void 0 ? void 0 : _space$value.size) !== null && _ref2 !== void 0 ? _ref2 : "small";
    });
    var horizontalSize = ref();
    var verticalSize = ref();
    watch(size2, function() {
      var _map = (Array.isArray(size2.value) ? size2.value : [size2.value, size2.value]).map(function(item) {
        return getNumberSize(item);
      });
      var _map2 = _slicedToArray$2(_map, 2);
      horizontalSize.value = _map2[0];
      verticalSize.value = _map2[1];
    }, {
      immediate: true
    });
    var mergedAlign = computed(function() {
      return props3.align === void 0 && props3.direction === "horizontal" ? "center" : props3.align;
    });
    var cn = computed(function() {
      var _classNames;
      return classNames(prefixCls.value, "".concat(prefixCls.value, "-").concat(props3.direction), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), directionConfig.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-align-").concat(mergedAlign.value), mergedAlign.value), _classNames));
    });
    var marginDirection = computed(function() {
      return directionConfig.value === "rtl" ? "marginLeft" : "marginRight";
    });
    var style2 = computed(function() {
      var gapStyle = {};
      if (supportFlexGap.value) {
        gapStyle.columnGap = "".concat(horizontalSize.value, "px");
        gapStyle.rowGap = "".concat(verticalSize.value, "px");
      }
      return _objectSpread2$1(_objectSpread2$1({}, gapStyle), props3.wrap && {
        flexWrap: "wrap",
        marginBottom: "".concat(-verticalSize.value, "px")
      });
    });
    return function() {
      var _slots$default, _slots$split;
      var wrap = props3.wrap, _props$direction = props3.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var items = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var len = items.length;
      if (len === 0) {
        return null;
      }
      var split2 = (_slots$split = slots.split) === null || _slots$split === void 0 ? void 0 : _slots$split.call(slots);
      var itemClassName = "".concat(prefixCls.value, "-item");
      var horizontalSizeVal = horizontalSize.value;
      var latestIndex = len - 1;
      return createVNode("div", {
        "class": cn.value,
        "style": style2.value
      }, [items.map(function(child, index2) {
        var itemStyle = {};
        if (!supportFlexGap.value) {
          if (direction === "vertical") {
            if (index2 < latestIndex) {
              itemStyle = {
                marginBottom: "".concat(horizontalSizeVal / (split2 ? 2 : 1), "px")
              };
            }
          } else {
            itemStyle = _objectSpread2$1(_objectSpread2$1({}, index2 < latestIndex && _defineProperty$U({}, marginDirection.value, "".concat(horizontalSizeVal / (split2 ? 2 : 1), "px"))), wrap && {
              paddingBottom: "".concat(verticalSize.value, "px")
            });
          }
        }
        return createVNode(Fragment, null, [createVNode("div", {
          "class": itemClassName,
          "style": itemStyle
        }, [child]), index2 < latestIndex && split2 && createVNode("span", {
          "class": "".concat(itemClassName, "-split"),
          "style": itemStyle
        }, [split2])]);
      })]);
    };
  }
});
const index$7 = withInstall(Space);
var _excluded$f = ["prefixCls"];
const Steps$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: {
    type: PropTypes$1.string.def("default"),
    prefixCls: PropTypes$1.string.def("vc-steps"),
    iconPrefix: PropTypes$1.string.def("vc"),
    direction: PropTypes$1.string.def("horizontal"),
    labelPlacement: PropTypes$1.string.def("horizontal"),
    status: PropTypes$1.string.def("process"),
    size: PropTypes$1.string.def(""),
    progressDot: PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.func]).def(void 0),
    initial: PropTypes$1.number.def(0),
    current: PropTypes$1.number.def(0),
    icons: PropTypes$1.shape({
      finish: PropTypes$1.any,
      error: PropTypes$1.any
    }).loose,
    stepIcon: Function
  },
  slots: ["stepIcon", "progressDot"],
  emits: ["change"],
  setup: function setup172(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var onStepClick = function onStepClick2(next2) {
      var current2 = props3.current;
      if (current2 !== next2) {
        emit("change", next2);
      }
    };
    return function() {
      var _classNames, _slots$default;
      var prefixCls = props3.prefixCls, direction = props3.direction, type4 = props3.type, labelPlacement = props3.labelPlacement, iconPrefix = props3.iconPrefix, status = props3.status, size2 = props3.size, current2 = props3.current, _props$progressDot = props3.progressDot, progressDot = _props$progressDot === void 0 ? slots.progressDot : _props$progressDot, initial = props3.initial, icons2 = props3.icons, _props$stepIcon = props3.stepIcon, stepIcon = _props$stepIcon === void 0 ? slots.stepIcon : _props$stepIcon;
      var isNav = type4 === "navigation";
      var adjustedLabelPlacement = progressDot ? "vertical" : labelPlacement;
      var classString = classNames(prefixCls, "".concat(prefixCls, "-").concat(direction), (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-").concat(size2), size2), _defineProperty$U(_classNames, "".concat(prefixCls, "-label-").concat(adjustedLabelPlacement), direction === "horizontal"), _defineProperty$U(_classNames, "".concat(prefixCls, "-dot"), !!progressDot), _defineProperty$U(_classNames, "".concat(prefixCls, "-navigation"), isNav), _classNames));
      var children = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      return createVNode("div", {
        "class": classString
      }, [children.map(function(child, index2) {
        var _ref2 = child.props || {}, _ref2$prefixCls = _ref2.prefixCls, pre = _ref2$prefixCls === void 0 ? prefixCls : _ref2$prefixCls, restProps = _objectWithoutProperties$2(_ref2, _excluded$f);
        var stepNumber = initial + index2;
        var stepProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
          stepNumber: stepNumber + 1,
          stepIndex: stepNumber,
          key: stepNumber,
          prefixCls: pre,
          iconPrefix,
          progressDot,
          icons: icons2,
          stepIcon,
          onStepClick
        });
        if (status === "error" && index2 === current2 - 1) {
          stepProps.class = "".concat(prefixCls, "-next-error");
        }
        if (!restProps.status) {
          if (stepNumber === current2) {
            stepProps.status = status;
          } else if (stepNumber < current2) {
            stepProps.status = "finish";
          } else {
            stepProps.status = "wait";
          }
        }
        stepProps.active = stepNumber === current2;
        return cloneElement(child, stepProps);
      })]);
    };
  }
});
function isString$2(str) {
  return typeof str === "string";
}
function noop$3() {
}
var VcStepProps = function VcStepProps2() {
  return {
    prefixCls: String,
    wrapperStyle: {
      type: Object,
      default: void 0
    },
    itemWidth: String,
    active: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    status: String,
    iconPrefix: String,
    icon: PropTypes$1.any,
    adjustMarginRight: String,
    stepNumber: Number,
    stepIndex: Number,
    description: PropTypes$1.any,
    title: PropTypes$1.any,
    subTitle: PropTypes$1.any,
    progressDot: withUndefined(PropTypes$1.oneOfType([PropTypes$1.looseBool, PropTypes$1.func])),
    tailContent: PropTypes$1.any,
    icons: PropTypes$1.shape({
      finish: PropTypes$1.any,
      error: PropTypes$1.any
    }).loose,
    onClick: Function,
    onStepClick: Function,
    stepIcon: Function
  };
};
const VcStep = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Step",
  props: VcStepProps(),
  slots: ["title", "subTitle", "description", "tailContent", "stepIcon", "progressDot"],
  emits: ["click", "stepClick"],
  setup: function setup173(props3, _ref) {
    var slots = _ref.slots, emit = _ref.emit;
    var onItemClick2 = function onItemClick3(e2) {
      emit("click", e2);
      emit("stepClick", props3.stepIndex);
    };
    var renderIconNode = function renderIconNode2(_ref2) {
      var _iconClassName;
      var icon = _ref2.icon, title = _ref2.title, description = _ref2.description;
      var prefixCls = props3.prefixCls, stepNumber = props3.stepNumber, status = props3.status, iconPrefix = props3.iconPrefix, icons2 = props3.icons, _props$progressDot = props3.progressDot, progressDot = _props$progressDot === void 0 ? slots.progressDot : _props$progressDot, _props$stepIcon = props3.stepIcon, stepIcon = _props$stepIcon === void 0 ? slots.stepIcon : _props$stepIcon;
      var iconNode;
      var iconClassName = (_iconClassName = {}, _defineProperty$U(_iconClassName, "".concat(prefixCls, "-icon"), true), _defineProperty$U(_iconClassName, "".concat(iconPrefix, "icon"), true), _defineProperty$U(_iconClassName, "".concat(iconPrefix, "icon-").concat(icon), icon && isString$2(icon)), _defineProperty$U(_iconClassName, "".concat(iconPrefix, "icon-check"), !icon && status === "finish" && icons2 && !icons2.finish), _defineProperty$U(_iconClassName, "".concat(iconPrefix, "icon-close"), !icon && status === "error" && icons2 && !icons2.error), _iconClassName);
      var iconDot = createVNode("span", {
        "class": "".concat(prefixCls, "-icon-dot")
      }, null);
      if (progressDot) {
        if (typeof progressDot === "function") {
          iconNode = createVNode("span", {
            "class": "".concat(prefixCls, "-icon")
          }, [progressDot({
            iconDot,
            index: stepNumber - 1,
            status,
            title,
            description,
            prefixCls
          })]);
        } else {
          iconNode = createVNode("span", {
            "class": "".concat(prefixCls, "-icon")
          }, [iconDot]);
        }
      } else if (icon && !isString$2(icon)) {
        iconNode = createVNode("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [icon]);
      } else if (icons2 && icons2.finish && status === "finish") {
        iconNode = createVNode("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [icons2.finish]);
      } else if (icons2 && icons2.error && status === "error") {
        iconNode = createVNode("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [icons2.error]);
      } else if (icon || status === "finish" || status === "error") {
        iconNode = createVNode("span", {
          "class": iconClassName
        }, null);
      } else {
        iconNode = createVNode("span", {
          "class": "".concat(prefixCls, "-icon")
        }, [stepNumber]);
      }
      if (stepIcon) {
        iconNode = stepIcon({
          index: stepNumber - 1,
          status,
          title,
          description,
          node: iconNode
        });
      }
      return iconNode;
    };
    return function() {
      var _slots$title, _slots$description, _slots$subTitle, _slots$icon, _classString;
      var prefixCls = props3.prefixCls, itemWidth = props3.itemWidth, active = props3.active, _props$status = props3.status, status = _props$status === void 0 ? "wait" : _props$status, tailContent = props3.tailContent, adjustMarginRight = props3.adjustMarginRight, disabled = props3.disabled, _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots) : _props$title, _props$description = props3.description, description = _props$description === void 0 ? (_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.call(slots) : _props$description, _props$subTitle = props3.subTitle, subTitle = _props$subTitle === void 0 ? (_slots$subTitle = slots.subTitle) === null || _slots$subTitle === void 0 ? void 0 : _slots$subTitle.call(slots) : _props$subTitle, _props$icon = props3.icon, icon = _props$icon === void 0 ? (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots) : _props$icon, onClick2 = props3.onClick, onStepClick = props3.onStepClick;
      var classString = (_classString = {}, _defineProperty$U(_classString, "".concat(prefixCls, "-item"), true), _defineProperty$U(_classString, "".concat(prefixCls, "-item-").concat(status), true), _defineProperty$U(_classString, "".concat(prefixCls, "-item-custom"), icon), _defineProperty$U(_classString, "".concat(prefixCls, "-item-active"), active), _defineProperty$U(_classString, "".concat(prefixCls, "-item-disabled"), disabled === true), _classString);
      var stepProps = {
        class: classString
      };
      var stepItemStyle = {};
      if (itemWidth) {
        stepItemStyle.width = itemWidth;
      }
      if (adjustMarginRight) {
        stepItemStyle.marginRight = adjustMarginRight;
      }
      var accessibilityProps = {
        onClick: onClick2 || noop$3
      };
      if (onStepClick && !disabled) {
        accessibilityProps.role = "button";
        accessibilityProps.tabindex = 0;
        accessibilityProps.onClick = onItemClick2;
      }
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, stepProps), {}, {
        "style": stepItemStyle
      }), [createVNode("div", _objectSpread2$1(_objectSpread2$1({}, accessibilityProps), {}, {
        "class": "".concat(prefixCls, "-item-container")
      }), [createVNode("div", {
        "class": "".concat(prefixCls, "-item-tail")
      }, [tailContent]), createVNode("div", {
        "class": "".concat(prefixCls, "-item-icon")
      }, [renderIconNode({
        icon,
        title,
        description
      })]), createVNode("div", {
        "class": "".concat(prefixCls, "-item-content")
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-item-title")
      }, [title, subTitle && createVNode("div", {
        "title": subTitle,
        "class": "".concat(prefixCls, "-item-subtitle")
      }, [subTitle])]), description && createVNode("div", {
        "class": "".concat(prefixCls, "-item-description")
      }, [description])])])]);
    };
  }
});
var stepsProps2 = function stepsProps3() {
  return {
    prefixCls: String,
    iconPrefix: String,
    current: Number,
    initial: Number,
    percent: Number,
    responsive: {
      type: Boolean,
      default: void 0
    },
    labelPlacement: String,
    status: String,
    size: String,
    direction: String,
    progressDot: {
      type: [Boolean, Function],
      default: void 0
    },
    type: String,
    onChange: Function,
    "onUpdate:current": Function
  };
};
var Steps2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASteps",
  inheritAttrs: false,
  props: initDefaultProps$1(stepsProps2(), {
    current: 0,
    responsive: true,
    labelPlacement: "horizontal"
  }),
  slots: ["progressDot"],
  setup: function setup174(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var _useConfigInject = useConfigInject("steps", props3), prefixCls = _useConfigInject.prefixCls, rtlDirection = _useConfigInject.direction, configProvider = _useConfigInject.configProvider;
    var screens2 = useBreakpoint();
    var direction = computed(function() {
      return props3.responsive && screens2.value.xs ? "vertical" : props3.direction;
    });
    var iconPrefix = computed(function() {
      return configProvider.getPrefixCls("", props3.iconPrefix);
    });
    var handleChange2 = function handleChange3(current2) {
      emit("update:current", current2);
      emit("change", current2);
    };
    var stepIconRender = function stepIconRender2(_ref2) {
      var node = _ref2.node, status = _ref2.status;
      if (status === "process" && props3.percent !== void 0) {
        var progressWidth = props3.size === "small" ? 32 : 40;
        var iconWithProgress = createVNode("div", {
          "class": "".concat(prefixCls, "-progress-icon")
        }, [createVNode(Progress, {
          "type": "circle",
          "percent": props3.percent,
          "width": progressWidth,
          "strokeWidth": 4,
          "format": function format5() {
            return null;
          }
        }, null), node]);
        return iconWithProgress;
      }
      return node;
    };
    return function() {
      var _classNames;
      var stepsClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), rtlDirection.value === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-with-progress"), props3.percent !== void 0), _classNames), attrs.class);
      var icons2 = {
        finish: createVNode(CheckOutlined$1, {
          "class": "".concat(prefixCls, "-finish-icon")
        }, null),
        error: createVNode(CloseOutlined$1, {
          "class": "".concat(prefixCls, "-error-icon")
        }, null)
      };
      return createVNode(Steps$1, _objectSpread2$1(_objectSpread2$1({
        "icons": icons2
      }, omit$2(props3, ["percent", "responsive"])), {}, {
        "direction": direction.value,
        "prefixCls": prefixCls.value,
        "iconPrefix": iconPrefix.value,
        "class": stepsClassName,
        "onChange": handleChange2
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        stepIcon: stepIconRender
      }));
    };
  }
});
var Step = defineComponent(_objectSpread2$1(_objectSpread2$1({
  compatConfig: {
    MODE: 3
  }
}, VcStep), {}, {
  name: "AStep",
  props: VcStepProps()
}));
const index$6 = _extends$1(Steps2, {
  Step,
  install: function install6(app) {
    app.component(Steps2.name, Steps2);
    app.component(Step.name, Step);
    return app;
  }
});
var SwitchSizes = tuple$1("small", "default");
var switchProps = function switchProps2() {
  return {
    id: String,
    prefixCls: String,
    size: PropTypes$1.oneOf(SwitchSizes),
    disabled: {
      type: Boolean,
      default: void 0
    },
    checkedChildren: PropTypes$1.any,
    unCheckedChildren: PropTypes$1.any,
    tabindex: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number]),
    autofocus: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: void 0
    },
    checked: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]),
    checkedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(true),
    unCheckedValue: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.number, PropTypes$1.looseBool]).def(false),
    onChange: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onMouseup: {
      type: Function
    },
    "onUpdate:checked": {
      type: Function
    },
    onBlur: Function,
    onFocus: Function
  };
};
var Switch$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: true,
  inheritAttrs: false,
  props: switchProps(),
  slots: ["checkedChildren", "unCheckedChildren"],
  setup: function setup175(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose, emit = _ref.emit;
    var formItemContext = useInjectFormItemContext();
    onBeforeMount(function() {
      warning$2(!("defaultChecked" in attrs), "Switch", "'defaultChecked' is deprecated, please use 'v-model:checked'");
      warning$2(!("value" in attrs), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    var checked = ref(props3.checked !== void 0 ? props3.checked : attrs.defaultChecked);
    var checkedStatus = computed(function() {
      return checked.value === props3.checkedValue;
    });
    watch(function() {
      return props3.checked;
    }, function() {
      checked.value = props3.checked;
    });
    var _useConfigInject = useConfigInject("switch", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, size2 = _useConfigInject.size;
    var refSwitchNode = ref();
    var focus = function focus2() {
      var _refSwitchNode$value;
      (_refSwitchNode$value = refSwitchNode.value) === null || _refSwitchNode$value === void 0 ? void 0 : _refSwitchNode$value.focus();
    };
    var blur = function blur2() {
      var _refSwitchNode$value2;
      (_refSwitchNode$value2 = refSwitchNode.value) === null || _refSwitchNode$value2 === void 0 ? void 0 : _refSwitchNode$value2.blur();
    };
    expose({
      focus,
      blur
    });
    onMounted(function() {
      nextTick(function() {
        if (props3.autofocus && !props3.disabled) {
          refSwitchNode.value.focus();
        }
      });
    });
    var setChecked2 = function setChecked3(check, e2) {
      if (props3.disabled) {
        return;
      }
      emit("update:checked", check);
      emit("change", check, e2);
      formItemContext.onFieldChange();
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
    };
    var handleClick2 = function handleClick3(e2) {
      focus();
      var newChecked = checkedStatus.value ? props3.unCheckedValue : props3.checkedValue;
      setChecked2(newChecked, e2);
      emit("click", newChecked, e2);
    };
    var handleKeyDown2 = function handleKeyDown3(e2) {
      if (e2.keyCode === KeyCode$1.LEFT) {
        setChecked2(props3.unCheckedValue, e2);
      } else if (e2.keyCode === KeyCode$1.RIGHT) {
        setChecked2(props3.checkedValue, e2);
      }
      emit("keydown", e2);
    };
    var handleMouseUp = function handleMouseUp2(e2) {
      var _refSwitchNode$value3;
      (_refSwitchNode$value3 = refSwitchNode.value) === null || _refSwitchNode$value3 === void 0 ? void 0 : _refSwitchNode$value3.blur();
      emit("mouseup", e2);
    };
    var classNames2 = computed(function() {
      var _ref2;
      return _ref2 = {}, _defineProperty$U(_ref2, "".concat(prefixCls.value, "-small"), size2.value === "small"), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-loading"), props3.loading), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-checked"), checkedStatus.value), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-disabled"), props3.disabled), _defineProperty$U(_ref2, prefixCls.value, true), _defineProperty$U(_ref2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _ref2;
    });
    return function() {
      var _props$id;
      return createVNode(Wave, {
        "insertExtraNode": true
      }, {
        default: function _default9() {
          return [createVNode("button", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$2(props3, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), attrs), {}, {
            "id": (_props$id = props3.id) !== null && _props$id !== void 0 ? _props$id : formItemContext.id.value,
            "onKeydown": handleKeyDown2,
            "onClick": handleClick2,
            "onBlur": handleBlur,
            "onMouseup": handleMouseUp,
            "type": "button",
            "role": "switch",
            "aria-checked": checked.value,
            "disabled": props3.disabled || props3.loading,
            "class": [attrs.class, classNames2.value],
            "ref": refSwitchNode
          }), [createVNode("div", {
            "class": "".concat(prefixCls.value, "-handle")
          }, [props3.loading ? createVNode(LoadingOutlined$1, {
            "class": "".concat(prefixCls.value, "-loading-icon")
          }, null) : null]), createVNode("span", {
            "class": "".concat(prefixCls.value, "-inner")
          }, [checkedStatus.value ? getPropsSlot(slots, props3, "checkedChildren") : getPropsSlot(slots, props3, "unCheckedChildren")])])];
        }
      });
    };
  }
});
const index$5 = withInstall(Switch$1);
var TableContextKey = Symbol("TableContextProps");
var useProvideTable = function useProvideTable2(props3) {
  provide(TableContextKey, props3);
};
var useInjectTable = function useInjectTable2() {
  return inject(TableContextKey, {});
};
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray$1(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getPathValue(record, path2) {
  if (!path2 && typeof path2 !== "number") {
    return record;
  }
  var pathList = toArray$1(path2);
  var current2 = record;
  for (var i2 = 0; i2 < pathList.length; i2 += 1) {
    if (!current2) {
      return null;
    }
    var prop = pathList[i2];
    current2 = current2[prop];
  }
  return current2;
}
function getColumnsKey(columns) {
  var columnKeys = [];
  var keys2 = {};
  columns.forEach(function(column2) {
    var _ref = column2 || {}, key2 = _ref.key, dataIndex = _ref.dataIndex;
    var mergedKey = key2 || toArray$1(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = "".concat(mergedKey, "_next");
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function mergeObject() {
  var merged = {};
  function fillProps(obj, clone3) {
    if (clone3) {
      Object.keys(clone3).forEach(function(key2) {
        var value = clone3[key2];
        if (value && _typeof$3(value) === "object") {
          obj[key2] = obj[key2] || {};
          fillProps(obj[key2], value);
        } else {
          obj[key2] = value;
        }
      });
    }
  }
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  objects.forEach(function(clone3) {
    fillProps(merged, clone3);
  });
  return merged;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
var SlotsContextKey = Symbol("SlotsContextProps");
var useProvideSlots = function useProvideSlots2(props3) {
  provide(SlotsContextKey, props3);
};
var useInjectSlots = function useInjectSlots2() {
  return inject(SlotsContextKey, computed(function() {
    return {};
  }));
};
var ContextKey = Symbol("ContextProps");
var useProvideTableContext = function useProvideTableContext2(props3) {
  provide(ContextKey, props3);
};
var useInjectTableContext = function useInjectTableContext2() {
  return inject(ContextKey, {
    onResizeColumn: function onResizeColumn() {
    }
  });
};
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
var HoverContextKey = Symbol("HoverContextProps");
var useProvideHover = function useProvideHover2(props3) {
  provide(HoverContextKey, props3);
};
var useInjectHover = function useInjectHover2() {
  return inject(HoverContextKey, {
    startRow: ref(-1),
    endRow: ref(-1),
    onHover: function onHover() {
    }
  });
};
var supportSticky = ref(false);
var useProvideSticky = function useProvideSticky2() {
  onMounted(function() {
    supportSticky.value = supportSticky.value || isStyleSupport("position", "sticky");
  });
};
var useInjectSticky = function useInjectSticky2() {
  return supportSticky;
};
var _excluded$e = ["colSpan", "rowSpan", "style", "class"];
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data9) {
  return data9 && _typeof$3(data9) === "object" && !Array.isArray(data9) && !isVNode(data9);
}
const Cell2 = defineComponent({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  slots: ["appendNode"],
  setup: function setup176(props3, _ref) {
    var slots = _ref.slots;
    var contextSlots = useInjectSlots();
    var _useInjectHover = useInjectHover(), onHover = _useInjectHover.onHover, startRow = _useInjectHover.startRow, endRow = _useInjectHover.endRow;
    var colSpan = computed(function() {
      var _ref2, _props$colSpan, _props$additionalProp, _props$additionalProp2;
      return (_ref2 = (_props$colSpan = props3.colSpan) !== null && _props$colSpan !== void 0 ? _props$colSpan : (_props$additionalProp = props3.additionalProps) === null || _props$additionalProp === void 0 ? void 0 : _props$additionalProp.colSpan) !== null && _ref2 !== void 0 ? _ref2 : (_props$additionalProp2 = props3.additionalProps) === null || _props$additionalProp2 === void 0 ? void 0 : _props$additionalProp2.colspan;
    });
    var rowSpan = computed(function() {
      var _ref3, _props$rowSpan, _props$additionalProp3, _props$additionalProp4;
      return (_ref3 = (_props$rowSpan = props3.rowSpan) !== null && _props$rowSpan !== void 0 ? _props$rowSpan : (_props$additionalProp3 = props3.additionalProps) === null || _props$additionalProp3 === void 0 ? void 0 : _props$additionalProp3.rowSpan) !== null && _ref3 !== void 0 ? _ref3 : (_props$additionalProp4 = props3.additionalProps) === null || _props$additionalProp4 === void 0 ? void 0 : _props$additionalProp4.rowspan;
    });
    var hovering = eagerComputed(function() {
      var index2 = props3.index;
      return inHoverRange(index2, rowSpan.value || 1, startRow.value, endRow.value);
    });
    var supportSticky2 = useInjectSticky();
    var _onMouseenter = function onMouseenter2(event2, mergedRowSpan) {
      var _additionalProps$onMo;
      var record = props3.record, index2 = props3.index, additionalProps = props3.additionalProps;
      if (record) {
        onHover(index2, index2 + mergedRowSpan - 1);
      }
      additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo = additionalProps.onMouseenter) === null || _additionalProps$onMo === void 0 ? void 0 : _additionalProps$onMo.call(additionalProps, event2);
    };
    var onMouseleave2 = function onMouseleave3(event2) {
      var _additionalProps$onMo2;
      var record = props3.record, additionalProps = props3.additionalProps;
      if (record) {
        onHover(-1, -1);
      }
      additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo2 = additionalProps.onMouseleave) === null || _additionalProps$onMo2 === void 0 ? void 0 : _additionalProps$onMo2.call(additionalProps, event2);
    };
    var getTitle = function getTitle2(vnodes) {
      var vnode = filterEmpty(vnodes)[0];
      if (isVNode(vnode)) {
        if (vnode.type === Text$2) {
          return vnode.children;
        } else {
          return Array.isArray(vnode.children) ? getTitle2(vnode.children) : void 0;
        }
      } else {
        return vnode;
      }
    };
    return function() {
      var _slots$appendNode, _slots$default, _ref5, _ref6, _classNames, _slots$dragHandle;
      var prefixCls = props3.prefixCls, record = props3.record, index2 = props3.index, renderIndex = props3.renderIndex, dataIndex = props3.dataIndex, customRender = props3.customRender, _props$component = props3.component, Component = _props$component === void 0 ? "td" : _props$component, fixLeft = props3.fixLeft, fixRight = props3.fixRight, firstFixLeft = props3.firstFixLeft, lastFixLeft = props3.lastFixLeft, firstFixRight = props3.firstFixRight, lastFixRight = props3.lastFixRight, _props$appendNode = props3.appendNode, appendNode = _props$appendNode === void 0 ? (_slots$appendNode = slots.appendNode) === null || _slots$appendNode === void 0 ? void 0 : _slots$appendNode.call(slots) : _props$appendNode, _props$additionalProp5 = props3.additionalProps, additionalProps = _props$additionalProp5 === void 0 ? {} : _props$additionalProp5, ellipsis = props3.ellipsis, align = props3.align, rowType = props3.rowType, isSticky = props3.isSticky, _props$column = props3.column, column2 = _props$column === void 0 ? {} : _props$column, cellType = props3.cellType;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var cellProps;
      var childNode;
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      if (validateValue(children) || cellType === "header") {
        childNode = children;
      } else {
        var _column$slots;
        var value = getPathValue(record, dataIndex);
        childNode = value;
        if (customRender) {
          var renderData = customRender({
            text: value,
            value,
            record,
            index: index2,
            renderIndex,
            column: column2.__originColumn__
          });
          if (isRenderCell(renderData)) {
            childNode = renderData.children;
            cellProps = renderData.props;
          } else {
            childNode = renderData;
          }
        }
        if (!(INTERNAL_COL_DEFINE in column2) && cellType === "body" && contextSlots.value.bodyCell && !((_column$slots = column2.slots) !== null && _column$slots !== void 0 && _column$slots.customRender)) {
          var child = renderSlot(contextSlots.value, "bodyCell", {
            text: value,
            value,
            record,
            index: index2,
            column: column2.__originColumn__
          }, function() {
            var fallback = childNode === void 0 ? value : childNode;
            return [_typeof$3(fallback) === "object" && isValidElement(fallback) || _typeof$3(fallback) !== "object" ? fallback : null];
          });
          childNode = flattenChildren(child);
        }
        if (props3.transformCellText) {
          childNode = props3.transformCellText({
            text: childNode,
            record,
            index: index2,
            column: column2.__originColumn__
          });
        }
      }
      if (_typeof$3(childNode) === "object" && !Array.isArray(childNode) && !isVNode(childNode)) {
        childNode = null;
      }
      if (ellipsis && (lastFixLeft || firstFixRight)) {
        childNode = createVNode("span", {
          "class": "".concat(cellPrefixCls, "-content")
        }, [childNode]);
      }
      if (Array.isArray(childNode) && childNode.length === 1) {
        childNode = childNode[0];
      }
      var _ref4 = cellProps || {}, cellColSpan = _ref4.colSpan, cellRowSpan = _ref4.rowSpan, cellStyle = _ref4.style, cellClassName = _ref4.class, restCellProps = _objectWithoutProperties$2(_ref4, _excluded$e);
      var mergedColSpan = (_ref5 = cellColSpan !== void 0 ? cellColSpan : colSpan.value) !== null && _ref5 !== void 0 ? _ref5 : 1;
      var mergedRowSpan = (_ref6 = cellRowSpan !== void 0 ? cellRowSpan : rowSpan.value) !== null && _ref6 !== void 0 ? _ref6 : 1;
      if (mergedColSpan === 0 || mergedRowSpan === 0) {
        return null;
      }
      var fixedStyle = {};
      var isFixLeft = typeof fixLeft === "number" && supportSticky2.value;
      var isFixRight = typeof fixRight === "number" && supportSticky2.value;
      if (isFixLeft) {
        fixedStyle.position = "sticky";
        fixedStyle.left = "".concat(fixLeft, "px");
      }
      if (isFixRight) {
        fixedStyle.position = "sticky";
        fixedStyle.right = "".concat(fixRight, "px");
      }
      var alignStyle = {};
      if (align) {
        alignStyle.textAlign = align;
      }
      var title;
      var ellipsisConfig = ellipsis === true ? {
        showTitle: true
      } : ellipsis;
      if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
        if (typeof childNode === "string" || typeof childNode === "number") {
          title = childNode.toString();
        } else if (isVNode(childNode)) {
          title = getTitle([childNode]);
        }
      }
      var componentProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        title
      }, restCellProps), additionalProps), {}, {
        colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
        rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
        class: classNames(cellPrefixCls, (_classNames = {}, _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky2.value), _defineProperty$U(_classNames, "".concat(cellPrefixCls, "-row-hover"), !cellProps && hovering.value), _classNames), additionalProps.class, cellClassName),
        onMouseenter: function onMouseenter2(e2) {
          _onMouseenter(e2, mergedRowSpan);
        },
        onMouseleave: onMouseleave2,
        style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, parseStyleText(additionalProps.style)), alignStyle), fixedStyle), cellStyle)
      });
      return createVNode(Component, componentProps, {
        default: function _default9() {
          return [appendNode, childNode, (_slots$dragHandle = slots.dragHandle) === null || _slots$dragHandle === void 0 ? void 0 : _slots$dragHandle.call(slots)];
        }
      });
    };
  }
});
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  var startColumn = columns[colStart] || {};
  var endColumn = columns[colEnd] || {};
  var fixLeft;
  var fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[colEnd];
  }
  var lastFixLeft = false;
  var firstFixRight = false;
  var lastFixRight = false;
  var firstFixLeft = false;
  var nextColumn = columns[colEnd + 1];
  var prevColumn = columns[colStart - 1];
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      var prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== void 0) {
      var nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== void 0) {
    var nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== void 0) {
    var prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
var events = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  }
};
var defaultMinWidth = 50;
const DragHandleVue = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: true
    },
    minWidth: {
      type: Number,
      default: defaultMinWidth
    },
    maxWidth: {
      type: Number,
      default: Infinity
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup177(props3) {
    var startX = 0;
    var moveEvent = {
      remove: function remove2() {
      }
    };
    var stopEvent = {
      remove: function remove2() {
      }
    };
    var removeEvents2 = function removeEvents3() {
      moveEvent.remove();
      stopEvent.remove();
    };
    onUnmounted(function() {
      removeEvents2();
    });
    watchEffect(function() {
      devWarning(!isNaN(props3.width), "Table", "width must be a number when use resizable");
    });
    var _useInjectTableContex = useInjectTableContext(), onResizeColumn = _useInjectTableContex.onResizeColumn;
    var minWidth = computed(function() {
      return typeof props3.minWidth === "number" && !isNaN(props3.minWidth) ? props3.minWidth : defaultMinWidth;
    });
    var maxWidth2 = computed(function() {
      return typeof props3.maxWidth === "number" && !isNaN(props3.maxWidth) ? props3.maxWidth : Infinity;
    });
    var instance = getCurrentInstance();
    var baseWidth = 0;
    var dragging = ref(false);
    var rafId;
    var updateWidth = function updateWidth2(e2) {
      var pageX = 0;
      if (e2.touches) {
        if (e2.touches.length) {
          pageX = e2.touches[0].pageX;
        } else {
          pageX = e2.changedTouches[0].pageX;
        }
      } else {
        pageX = e2.pageX;
      }
      var tmpDeltaX = startX - pageX;
      var w2 = Math.max(baseWidth - tmpDeltaX, minWidth.value);
      w2 = Math.min(w2, maxWidth2.value);
      wrapperRaf.cancel(rafId);
      rafId = wrapperRaf(function() {
        onResizeColumn(w2, props3.column.__originColumn__);
      });
    };
    var handleMove = function handleMove2(e2) {
      updateWidth(e2);
    };
    var handleStop = function handleStop2(e2) {
      dragging.value = false;
      updateWidth(e2);
      removeEvents2();
    };
    var handleStart = function handleStart2(e2, eventsFor) {
      dragging.value = true;
      removeEvents2();
      baseWidth = instance.vnode.el.parentNode.getBoundingClientRect().width;
      if (e2 instanceof MouseEvent && e2.which !== 1) {
        return;
      }
      if (e2.stopPropagation)
        e2.stopPropagation();
      startX = e2.touches ? e2.touches[0].pageX : e2.pageX;
      moveEvent = addEventListenerWrap(document.documentElement, eventsFor.move, handleMove);
      stopEvent = addEventListenerWrap(document.documentElement, eventsFor.stop, handleStop);
    };
    var handleDown = function handleDown2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.mouse);
    };
    var handleTouchDown = function handleTouchDown2(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      handleStart(e2, events.touch);
    };
    var handleClick2 = function handleClick3(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    };
    return function() {
      var prefixCls = props3.prefixCls;
      var touchEvents = _defineProperty$U({}, supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart", function(e2) {
        return handleTouchDown(e2);
      });
      return createVNode("div", _objectSpread2$1(_objectSpread2$1({
        "class": "".concat(prefixCls, "-resize-handle ").concat(dragging.value ? "dragging" : ""),
        "onMousedown": handleDown
      }, touchEvents), {}, {
        "onClick": handleClick2
      }), [createVNode("div", {
        "class": "".concat(prefixCls, "-resize-handle-line")
      }, null)]);
    };
  }
});
const HeaderRow = defineComponent({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup: function setup178(props3) {
    var tableContext = useInjectTable();
    return function() {
      var prefixCls = tableContext.prefixCls, direction = tableContext.direction;
      var cells = props3.cells, stickyOffsets = props3.stickyOffsets, flattenColumns = props3.flattenColumns, RowComponent = props3.rowComponent, CellComponent = props3.cellComponent, customHeaderRow = props3.customHeaderRow, index2 = props3.index;
      var rowProps3;
      if (customHeaderRow) {
        rowProps3 = customHeaderRow(cells.map(function(cell) {
          return cell.column;
        }), index2);
      }
      var columnsKey = getColumnsKey(cells.map(function(cell) {
        return cell.column;
      }));
      return createVNode(RowComponent, rowProps3, {
        default: function _default9() {
          return [cells.map(function(cell, cellIndex) {
            var column2 = cell.column;
            var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
            var additionalProps;
            if (column2 && column2.customHeaderCell) {
              additionalProps = cell.column.customHeaderCell(column2);
            }
            var col = column2;
            return createVNode(Cell2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, cell), {}, {
              "cellType": "header",
              "ellipsis": column2.ellipsis,
              "align": column2.align,
              "component": CellComponent,
              "prefixCls": prefixCls,
              "key": columnsKey[cellIndex]
            }, fixedInfo), {}, {
              "additionalProps": additionalProps,
              "rowType": "header",
              "column": column2
            }), {
              default: function _default10() {
                return column2.title;
              },
              dragHandle: function dragHandle() {
                return col.resizable ? createVNode(DragHandleVue, {
                  "prefixCls": prefixCls,
                  "width": col.width,
                  "minWidth": col.minWidth,
                  "maxWidth": col.maxWidth,
                  "column": col
                }, null) : null;
              }
            });
          })];
        }
      });
    };
  }
});
function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns, colIndex) {
    var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex2] = rows[rowIndex2] || [];
    var currentColIndex = colIndex;
    var colSpans = columns.filter(Boolean).map(function(column2) {
      var cell = {
        key: column2.key,
        class: classNames(column2.className, column2.class),
        column: column2,
        colStart: currentColIndex
      };
      var colSpan = 1;
      var subColumns = column2.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total3, count) {
          return total3 + count;
        }, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column2) {
        colSpan = column2.colSpan;
      }
      if ("rowSpan" in column2) {
        cell.rowSpan = column2.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex2].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  var rowCount = rows.length;
  var _loop = function _loop2(rowIndex2) {
    rows[rowIndex2].forEach(function(cell) {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex2;
      }
    });
  };
  for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    _loop(rowIndex);
  }
  return rows;
}
const Header$1 = defineComponent({
  name: "Header",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup: function setup179(props3) {
    var tableContext = useInjectTable();
    var rows = computed(function() {
      return parseHeaderRows(props3.columns);
    });
    return function() {
      var prefixCls = tableContext.prefixCls, getComponent3 = tableContext.getComponent;
      var stickyOffsets = props3.stickyOffsets, flattenColumns = props3.flattenColumns, customHeaderRow = props3.customHeaderRow;
      var WrapperComponent = getComponent3(["header", "wrapper"], "thead");
      var trComponent = getComponent3(["header", "row"], "tr");
      var thComponent = getComponent3(["header", "cell"], "th");
      return createVNode(WrapperComponent, {
        "class": "".concat(prefixCls, "-thead")
      }, {
        default: function _default9() {
          return [rows.value.map(function(row, rowIndex) {
            var rowNode = createVNode(HeaderRow, {
              "key": rowIndex,
              "flattenColumns": flattenColumns,
              "cells": row,
              "stickyOffsets": stickyOffsets,
              "rowComponent": trComponent,
              "cellComponent": thComponent,
              "customHeaderRow": customHeaderRow,
              "index": rowIndex
            }, null);
            return rowNode;
          })];
        }
      });
    };
  }
});
var ExpandedRowContextKey = Symbol("ExpandedRowProps");
var useProvideExpandedRow = function useProvideExpandedRow2(props3) {
  provide(ExpandedRowContextKey, props3);
};
var useInjectExpandedRow = function useInjectExpandedRow2() {
  return inject(ExpandedRowContextKey, {});
};
const ExpandedRow = defineComponent({
  name: "ExpandedRow",
  inheritAttrs: false,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup: function setup180(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var tableContext = useInjectTable();
    var expandedRowContext = useInjectExpandedRow();
    var fixHeader = expandedRowContext.fixHeader, fixColumn = expandedRowContext.fixColumn, componentWidth = expandedRowContext.componentWidth, horizonScroll = expandedRowContext.horizonScroll;
    return function() {
      var prefixCls = props3.prefixCls, Component = props3.component, cellComponent = props3.cellComponent, expanded = props3.expanded, colSpan = props3.colSpan, isEmpty = props3.isEmpty;
      return createVNode(Component, {
        "class": attrs.class,
        "style": {
          display: expanded ? null : "none"
        }
      }, {
        default: function _default9() {
          return [createVNode(Cell2, {
            "component": cellComponent,
            "prefixCls": prefixCls,
            "colSpan": colSpan
          }, {
            default: function _default10() {
              var _slots$default;
              var contentNode = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
              if (isEmpty ? horizonScroll.value : fixColumn.value) {
                contentNode = createVNode("div", {
                  "style": {
                    width: "".concat(componentWidth.value - (fixHeader.value ? tableContext.scrollbarSize : 0), "px"),
                    position: "sticky",
                    left: 0,
                    overflow: "hidden"
                  },
                  "class": "".concat(prefixCls, "-expanded-row-fixed")
                }, [contentNode]);
              }
              return contentNode;
            }
          })];
        }
      });
    };
  }
});
const MeasureCell = defineComponent({
  name: "MeasureCell",
  props: ["columnKey"],
  setup: function setup181(props3, _ref) {
    var emit = _ref.emit;
    var tdRef = ref();
    onMounted(function() {
      if (tdRef.value) {
        emit("columnResize", props3.columnKey, tdRef.value.offsetWidth);
      }
    });
    return function() {
      return createVNode(ResizeObserver$1, {
        "onResize": function onResize(_ref2) {
          var offsetWidth = _ref2.offsetWidth;
          emit("columnResize", props3.columnKey, offsetWidth);
        }
      }, {
        default: function _default9() {
          return [createVNode("td", {
            "ref": tdRef,
            "style": {
              padding: 0,
              border: 0,
              height: 0
            }
          }, [createVNode("div", {
            "style": {
              height: 0,
              overflow: "hidden"
            }
          }, [createTextVNode("\xA0")])])];
        }
      });
    };
  }
});
var BodyContextKey = Symbol("BodyContextProps");
var useProvideBody = function useProvideBody2(props3) {
  provide(BodyContextKey, props3);
};
var useInjectBody = function useInjectBody2() {
  return inject(BodyContextKey, {});
};
const BodyRow = defineComponent({
  name: "BodyRow",
  inheritAttrs: false,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup: function setup182(props3, _ref) {
    var attrs = _ref.attrs;
    var tableContext = useInjectTable();
    var bodyContext = useInjectBody();
    var expandRended = ref(false);
    var expanded = computed(function() {
      return props3.expandedKeys && props3.expandedKeys.has(props3.recordKey);
    });
    watchEffect(function() {
      if (expanded.value) {
        expandRended.value = true;
      }
    });
    var rowSupportExpand = computed(function() {
      return bodyContext.expandableType === "row" && (!props3.rowExpandable || props3.rowExpandable(props3.record));
    });
    var nestExpandable = computed(function() {
      return bodyContext.expandableType === "nest";
    });
    var hasNestChildren = computed(function() {
      return props3.childrenColumnName && props3.record && props3.record[props3.childrenColumnName];
    });
    var mergedExpandable = computed(function() {
      return rowSupportExpand.value || nestExpandable.value;
    });
    var onInternalTriggerExpand = function onInternalTriggerExpand2(record, event2) {
      bodyContext.onTriggerExpand(record, event2);
    };
    var additionalProps = computed(function() {
      var _props$customRow;
      return ((_props$customRow = props3.customRow) === null || _props$customRow === void 0 ? void 0 : _props$customRow.call(props3, props3.record, props3.index)) || {};
    });
    var onClick2 = function onClick3(event2) {
      var _additionalProps$valu, _additionalProps$valu2;
      if (bodyContext.expandRowByClick && mergedExpandable.value) {
        onInternalTriggerExpand(props3.record, event2);
      }
      for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args2[_key - 1] = arguments[_key];
      }
      (_additionalProps$valu = additionalProps.value) === null || _additionalProps$valu === void 0 ? void 0 : (_additionalProps$valu2 = _additionalProps$valu.onClick) === null || _additionalProps$valu2 === void 0 ? void 0 : _additionalProps$valu2.call.apply(_additionalProps$valu2, [_additionalProps$valu, event2].concat(args2));
    };
    var computeRowClassName = computed(function() {
      var record = props3.record, index2 = props3.index, indent = props3.indent;
      var rowClassName = bodyContext.rowClassName;
      if (typeof rowClassName === "string") {
        return rowClassName;
      } else if (typeof rowClassName === "function") {
        return rowClassName(record, index2, indent);
      }
      return "";
    });
    var columnsKey = computed(function() {
      return getColumnsKey(bodyContext.flattenColumns);
    });
    return function() {
      var className = attrs.class, style2 = attrs.style;
      var record = props3.record, index2 = props3.index, rowKey = props3.rowKey, _props$indent = props3.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props3.rowComponent, cellComponent = props3.cellComponent;
      var prefixCls = tableContext.prefixCls, fixedInfoList = tableContext.fixedInfoList, transformCellText = tableContext.transformCellText;
      var flattenColumns = bodyContext.flattenColumns, expandedRowClassName = bodyContext.expandedRowClassName, indentSize = bodyContext.indentSize, expandIcon = bodyContext.expandIcon, expandedRowRender = bodyContext.expandedRowRender, expandIconColumnIndex = bodyContext.expandIconColumnIndex;
      var baseRowNode = createVNode(RowComponent, _objectSpread2$1(_objectSpread2$1({}, additionalProps.value), {}, {
        "data-row-key": rowKey,
        "class": classNames(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName.value, additionalProps.value.class),
        "style": _objectSpread2$1(_objectSpread2$1({}, style2), parseStyleText(additionalProps.value.style)),
        "onClick": onClick2
      }), {
        default: function _default9() {
          return [flattenColumns.map(function(column2, colIndex) {
            var customRender = column2.customRender, dataIndex = column2.dataIndex, columnClassName = column2.className;
            var key2 = columnsKey[colIndex];
            var fixedInfo = fixedInfoList[colIndex];
            var additionalCellProps;
            if (column2.customCell) {
              additionalCellProps = column2.customCell(record, index2, column2);
            }
            var appendNode = colIndex === (expandIconColumnIndex || 0) && nestExpandable.value ? createVNode(Fragment, null, [createVNode("span", {
              "style": {
                paddingLeft: "".concat(indentSize * indent, "px")
              },
              "class": "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
            }, null), expandIcon({
              prefixCls,
              expanded: expanded.value,
              expandable: hasNestChildren.value,
              record,
              onExpand: onInternalTriggerExpand
            })]) : null;
            return createVNode(Cell2, _objectSpread2$1(_objectSpread2$1({
              "cellType": "body",
              "class": columnClassName,
              "ellipsis": column2.ellipsis,
              "align": column2.align,
              "component": cellComponent,
              "prefixCls": prefixCls,
              "key": key2,
              "record": record,
              "index": index2,
              "renderIndex": props3.renderIndex,
              "dataIndex": dataIndex,
              "customRender": customRender
            }, fixedInfo), {}, {
              "additionalProps": additionalCellProps,
              "column": column2,
              "transformCellText": transformCellText,
              "appendNode": appendNode
            }), null);
          })];
        }
      });
      var expandRowNode;
      if (rowSupportExpand.value && (expandRended.value || expanded.value)) {
        var expandContent = expandedRowRender({
          record,
          index: index2,
          indent: indent + 1,
          expanded: expanded.value
        });
        var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
        expandRowNode = createVNode(ExpandedRow, {
          "expanded": expanded.value,
          "class": classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
          "prefixCls": prefixCls,
          "component": RowComponent,
          "cellComponent": cellComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": false
        }, {
          default: function _default9() {
            return [expandContent];
          }
        });
      }
      return createVNode(Fragment, null, [baseRowNode, expandRowNode]);
    };
  }
});
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  var arr = [];
  arr.push({
    record,
    indent,
    index: index2
  });
  var key2 = getRowKey(record);
  var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (var i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
      var tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
      arr.push.apply(arr, _toConsumableArray(tempArr));
    }
  }
  return arr;
}
function useFlattenRecords(dataRef, childrenColumnNameRef, expandedKeysRef, getRowKey) {
  var arr = computed(function() {
    var childrenColumnName = childrenColumnNameRef.value;
    var expandedKeys = expandedKeysRef.value;
    var data9 = dataRef.value;
    if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
      var temp = [];
      for (var i2 = 0; i2 < (data9 === null || data9 === void 0 ? void 0 : data9.length); i2 += 1) {
        var record = data9[i2];
        temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey.value, i2)));
      }
      return temp;
    }
    return data9 === null || data9 === void 0 ? void 0 : data9.map(function(item, index2) {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  });
  return arr;
}
var ResizeContextKey = Symbol("ResizeContextProps");
var useProvideResize = function useProvideResize2(props3) {
  provide(ResizeContextKey, props3);
};
var useInjectResize = function useInjectResize2() {
  return inject(ResizeContextKey, {
    onColumnResize: function onColumnResize() {
    }
  });
};
const Body = defineComponent({
  name: "Body",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  slots: ["emptyNode"],
  setup: function setup183(props3, _ref) {
    var slots = _ref.slots;
    var resizeContext = useInjectResize();
    var tableContext = useInjectTable();
    var bodyContext = useInjectBody();
    var flattenData2 = useFlattenRecords(toRef(props3, "data"), toRef(props3, "childrenColumnName"), toRef(props3, "expandedKeys"), toRef(props3, "getRowKey"));
    var startRow = ref(-1);
    var endRow = ref(-1);
    var timeoutId;
    useProvideHover({
      startRow,
      endRow,
      onHover: function onHover(start, end) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(function() {
          startRow.value = start;
          endRow.value = end;
        }, 100);
      }
    });
    return function() {
      var data9 = props3.data, getRowKey = props3.getRowKey, measureColumnWidth = props3.measureColumnWidth, expandedKeys = props3.expandedKeys, customRow = props3.customRow, rowExpandable = props3.rowExpandable, childrenColumnName = props3.childrenColumnName;
      var onColumnResize = resizeContext.onColumnResize;
      var prefixCls = tableContext.prefixCls, getComponent3 = tableContext.getComponent;
      var flattenColumns = bodyContext.flattenColumns;
      var WrapperComponent = getComponent3(["body", "wrapper"], "tbody");
      var trComponent = getComponent3(["body", "row"], "tr");
      var tdComponent = getComponent3(["body", "cell"], "td");
      var rows;
      if (data9.length) {
        rows = flattenData2.value.map(function(item, idx) {
          var record = item.record, indent = item.indent, renderIndex = item.index;
          var key2 = getRowKey(record, idx);
          return createVNode(BodyRow, {
            "key": key2,
            "rowKey": key2,
            "record": record,
            "recordKey": key2,
            "index": idx,
            "renderIndex": renderIndex,
            "rowComponent": trComponent,
            "cellComponent": tdComponent,
            "expandedKeys": expandedKeys,
            "customRow": customRow,
            "getRowKey": getRowKey,
            "rowExpandable": rowExpandable,
            "childrenColumnName": childrenColumnName,
            "indent": indent
          }, null);
        });
      } else {
        var _slots$emptyNode;
        rows = createVNode(ExpandedRow, {
          "expanded": true,
          "class": "".concat(prefixCls, "-placeholder"),
          "prefixCls": prefixCls,
          "component": trComponent,
          "cellComponent": tdComponent,
          "colSpan": flattenColumns.length,
          "isEmpty": true
        }, {
          default: function _default9() {
            return [(_slots$emptyNode = slots.emptyNode) === null || _slots$emptyNode === void 0 ? void 0 : _slots$emptyNode.call(slots)];
          }
        });
      }
      var columnsKey = getColumnsKey(flattenColumns);
      return createVNode(WrapperComponent, {
        "class": "".concat(prefixCls, "-tbody")
      }, {
        default: function _default9() {
          return [measureColumnWidth && createVNode("tr", {
            "aria-hidden": "true",
            "class": "".concat(prefixCls, "-measure-row"),
            "style": {
              height: 0,
              fontSize: 0
            }
          }, [columnsKey.map(function(columnKey) {
            return createVNode(MeasureCell, {
              "key": columnKey,
              "columnKey": columnKey,
              "onColumnResize": onColumnResize
            }, null);
          })]), rows];
        }
      });
    };
  }
});
var EXPAND_COLUMN = {};
var _excluded$d = ["fixed"];
function flatColumns(columns) {
  return columns.reduce(function(list, column2) {
    var fixed = column2.fixed;
    var parsedFixed = fixed === true ? "left" : fixed;
    var subColumns = column2.children;
    if (subColumns && subColumns.length > 0) {
      return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns).map(function(subColum) {
        return _objectSpread2$1({
          fixed: parsedFixed
        }, subColum);
      })));
    }
    return [].concat(_toConsumableArray(list), [_objectSpread2$1(_objectSpread2$1({}, column2), {}, {
      fixed: parsedFixed
    })]);
  }, []);
}
function revertForRtl(columns) {
  return columns.map(function(column2) {
    var fixed = column2.fixed, restProps = _objectWithoutProperties$2(column2, _excluded$d);
    var parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return _objectSpread2$1({
      fixed: parsedFixed
    }, restProps);
  });
}
function useColumns$1(_ref, transformColumns) {
  var prefixCls = _ref.prefixCls, baseColumns = _ref.columns, expandable = _ref.expandable, expandedKeys = _ref.expandedKeys, getRowKey = _ref.getRowKey, onTriggerExpand = _ref.onTriggerExpand, expandIcon = _ref.expandIcon, rowExpandable = _ref.rowExpandable, expandIconColumnIndex = _ref.expandIconColumnIndex, direction = _ref.direction, expandRowByClick = _ref.expandRowByClick, expandColumnWidth = _ref.expandColumnWidth, expandFixed = _ref.expandFixed;
  var withExpandColumns = computed(function() {
    if (expandable.value) {
      var _expandColumn;
      var cloneColumns = baseColumns.value.slice();
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex.value || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function(column2, index2) {
        return column2 !== EXPAND_COLUMN || index2 === expandColumnIndex;
      });
      var prevColumn = baseColumns.value[expandColumnIndex];
      var fixedColumn;
      if ((expandFixed.value === "left" || expandFixed.value) && !expandIconColumnIndex.value) {
        fixedColumn = "left";
      } else if ((expandFixed.value === "right" || expandFixed.value) && expandIconColumnIndex.value === baseColumns.value.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      var expandedKeysValue = expandedKeys.value;
      var rowExpandableValue = rowExpandable.value;
      var expandIconValue = expandIcon.value;
      var prefixClsValue = prefixCls.value;
      var expandRowByClickValue = expandRowByClick.value;
      var expandColumn = (_expandColumn = {}, _defineProperty$U(_expandColumn, INTERNAL_COL_DEFINE, {
        class: "".concat(prefixCls.value, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), _defineProperty$U(_expandColumn, "title", ""), _defineProperty$U(_expandColumn, "fixed", fixedColumn), _defineProperty$U(_expandColumn, "class", "".concat(prefixCls.value, "-row-expand-icon-cell")), _defineProperty$U(_expandColumn, "width", expandColumnWidth.value), _defineProperty$U(_expandColumn, "customRender", function customRender(_ref2) {
        var record = _ref2.record, index2 = _ref2.index;
        var rowKey = getRowKey.value(record, index2);
        var expanded = expandedKeysValue.has(rowKey);
        var recordExpandable = rowExpandableValue ? rowExpandableValue(record) : true;
        var icon = expandIconValue({
          prefixCls: prefixClsValue,
          expanded,
          expandable: recordExpandable,
          record,
          onExpand: onTriggerExpand
        });
        if (expandRowByClickValue) {
          return createVNode("span", {
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            }
          }, [icon]);
        }
        return icon;
      }), _expandColumn);
      return cloneColumns.map(function(col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return baseColumns.value.filter(function(col) {
      return col !== EXPAND_COLUMN;
    });
  });
  var mergedColumns = computed(function() {
    var finalColumns = withExpandColumns.value;
    if (transformColumns.value) {
      finalColumns = transformColumns.value(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        customRender: function customRender() {
          return null;
        }
      }];
    }
    return finalColumns;
  });
  var flattenColumns = computed(function() {
    if (direction.value === "rtl") {
      return revertForRtl(flatColumns(mergedColumns.value));
    }
    return flatColumns(mergedColumns.value);
  });
  return [mergedColumns, flattenColumns];
}
function useLayoutState(defaultState) {
  var stateRef = shallowRef(defaultState);
  var rafId;
  var updateBatchRef = shallowRef([]);
  function setFrameState(updater) {
    updateBatchRef.value.push(updater);
    wrapperRaf.cancel(rafId);
    rafId = wrapperRaf(function() {
      var prevBatch = updateBatchRef.value;
      updateBatchRef.value = [];
      prevBatch.forEach(function(batchUpdater) {
        stateRef.value = batchUpdater(stateRef.value);
      });
    });
  }
  onBeforeUnmount(function() {
    wrapperRaf.cancel(rafId);
  });
  return [stateRef, setFrameState];
}
function useTimeoutLock(defaultState) {
  var frameRef = ref(defaultState || null);
  var timeoutRef = ref();
  function cleanUp() {
    clearTimeout(timeoutRef.value);
  }
  function setState2(newState) {
    frameRef.value = newState;
    cleanUp();
    timeoutRef.value = setTimeout(function() {
      frameRef.value = null;
      timeoutRef.value = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.value;
  }
  onBeforeUnmount(function() {
    cleanUp();
  });
  return [setState2, getState];
}
function useStickyOffsets(colWidthsRef, columnCountRef, directionRef) {
  var stickyOffsets = computed(function() {
    var leftOffsets = [];
    var rightOffsets = [];
    var left = 0;
    var right = 0;
    var colWidths = colWidthsRef.value;
    var columnCount = columnCountRef.value;
    var direction = directionRef.value;
    for (var start = 0; start < columnCount; start += 1) {
      if (direction === "rtl") {
        rightOffsets[start] = right;
        right += colWidths[start] || 0;
        var end = columnCount - start - 1;
        leftOffsets[end] = left;
        left += colWidths[end] || 0;
      } else {
        leftOffsets[start] = left;
        left += colWidths[start] || 0;
        var _end = columnCount - start - 1;
        rightOffsets[_end] = right;
        right += colWidths[_end] || 0;
      }
    }
    return {
      left: leftOffsets,
      right: rightOffsets
    };
  });
  return stickyOffsets;
}
var _excluded$c = ["columnType"];
function ColGroup(_ref) {
  var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
  var cols = [];
  var len = columCount || columns.length;
  var mustInsert = false;
  for (var i2 = len - 1; i2 >= 0; i2 -= 1) {
    var width = colWidths[i2];
    var column2 = columns && columns[i2];
    var additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      var _ref2 = additionalProps || {};
      _ref2.columnType;
      var restAdditionalProps = _objectWithoutProperties$2(_ref2, _excluded$c);
      cols.unshift(createVNode("col", _objectSpread2$1({
        "key": i2,
        "style": {
          width: typeof width === "number" ? "".concat(width, "px") : width
        }
      }, restAdditionalProps), null));
      mustInsert = true;
    }
  }
  return createVNode("colgroup", null, [cols]);
}
function Panel(_2, _ref) {
  var _slots$default;
  var slots = _ref.slots;
  return createVNode("div", null, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
}
Panel.displayName = "Panel";
var indexGuid = 0;
var Summary = defineComponent({
  name: "Summary",
  props: ["fixed"],
  setup: function setup184(props3, _ref) {
    var slots = _ref.slots;
    var tableContext = useInjectTable();
    var uniKey = "table-summary-uni-key-".concat(++indexGuid);
    var fixed = computed(function() {
      return props3.fixed === "" || props3.fixed;
    });
    watchEffect(function() {
      tableContext.summaryCollect(uniKey, fixed.value);
    });
    onBeforeUnmount(function() {
      tableContext.summaryCollect(uniKey, false);
    });
    return function() {
      var _slots$default;
      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }
});
const Summary$1 = Summary;
const SummaryRow = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "FooterRow",
  setup: function setup185(_props, _ref) {
    var slots = _ref.slots;
    return function() {
      var _slots$default;
      return createVNode("tr", null, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
var SummaryContextKey = Symbol("SummaryContextProps");
var useProvideSummary = function useProvideSummary2(props3) {
  provide(SummaryContextKey, props3);
};
var useInjectSummary = function useInjectSummary2() {
  return inject(SummaryContextKey, {});
};
const SummaryCell = defineComponent({
  name: "SummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup: function setup186(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var tableContext = useInjectTable();
    var summaryContext = useInjectSummary();
    return function() {
      var index2 = props3.index, _props$colSpan = props3.colSpan, colSpan = _props$colSpan === void 0 ? 1 : _props$colSpan, rowSpan = props3.rowSpan, align = props3.align;
      var prefixCls = tableContext.prefixCls, direction = tableContext.direction;
      var scrollColumnIndex = summaryContext.scrollColumnIndex, stickyOffsets = summaryContext.stickyOffsets, flattenColumns = summaryContext.flattenColumns;
      var lastIndex = index2 + colSpan - 1;
      var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
      var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
      return createVNode(Cell2, _objectSpread2$1({
        "class": attrs.class,
        "index": index2,
        "component": "td",
        "prefixCls": prefixCls,
        "record": null,
        "dataIndex": null,
        "align": align,
        "colSpan": mergedColSpan,
        "rowSpan": rowSpan,
        "customRender": function customRender() {
          var _slots$default;
          return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
        }
      }, fixedInfo), null);
    };
  }
});
const Footer$1 = defineComponent({
  name: "Footer",
  inheritAttrs: false,
  props: ["stickyOffsets", "flattenColumns"],
  setup: function setup187(props3, _ref) {
    var slots = _ref.slots;
    var tableContext = useInjectTable();
    useProvideSummary(reactive({
      stickyOffsets: toRef(props3, "stickyOffsets"),
      flattenColumns: toRef(props3, "flattenColumns"),
      scrollColumnIndex: computed(function() {
        var lastColumnIndex = props3.flattenColumns.length - 1;
        var scrollColumn = props3.flattenColumns[lastColumnIndex];
        return scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null;
      })
    }));
    return function() {
      var _slots$default;
      var prefixCls = tableContext.prefixCls;
      return createVNode("tfoot", {
        "class": "".concat(prefixCls, "-summary")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }
});
var FooterComponents = Summary$1;
function renderExpandIcon$1(_ref) {
  var _ref2;
  var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
  var expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable) {
    return createVNode("span", {
      "class": [expandClassName, "".concat(prefixCls, "-row-spaced")]
    }, null);
  }
  var onClick2 = function onClick3(event2) {
    onExpand(record, event2);
    event2.stopPropagation();
  };
  return createVNode("span", {
    "class": (_ref2 = {}, _defineProperty$U(_ref2, expandClassName, true), _defineProperty$U(_ref2, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$U(_ref2, "".concat(prefixCls, "-row-collapsed"), !expanded), _ref2),
    "onClick": onClick2
  }, null);
}
function findAllChildrenKeys(data9, getRowKey, childrenColumnName) {
  var keys2 = [];
  function dig(list) {
    (list || []).forEach(function(item, index2) {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data9);
  return keys2;
}
const StickyScrollBar = defineComponent({
  name: "StickyScrollBar",
  inheritAttrs: false,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup: function setup188(props3, _ref) {
    var emit = _ref.emit, expose = _ref.expose;
    var tableContext = useInjectTable();
    var bodyScrollWidth = ref(0);
    var bodyWidth = ref(0);
    var scrollBarWidth = ref(0);
    watchEffect(function() {
      bodyScrollWidth.value = props3.scrollBodySizeInfo.scrollWidth || 0;
      bodyWidth.value = props3.scrollBodySizeInfo.clientWidth || 0;
      scrollBarWidth.value = bodyScrollWidth.value && bodyWidth.value * (bodyWidth.value / bodyScrollWidth.value);
    }, {
      flush: "post"
    });
    var scrollBarRef = ref();
    var _useLayoutState = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: true
    }), _useLayoutState2 = _slicedToArray$2(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
    var refState = ref({
      delta: 0,
      x: 0
    });
    var isActive = ref(false);
    var onMouseUp2 = function onMouseUp3() {
      isActive.value = false;
    };
    var onMouseDown2 = function onMouseDown3(event2) {
      refState.value = {
        delta: event2.pageX - scrollState.value.scrollLeft,
        x: 0
      };
      isActive.value = true;
      event2.preventDefault();
    };
    var onMouseMove3 = function onMouseMove4(event2) {
      var _window2;
      var _ref2 = event2 || ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.event), buttons = _ref2.buttons;
      if (!isActive.value || buttons === 0) {
        if (isActive.value) {
          isActive.value = false;
        }
        return;
      }
      var left = refState.value.x + event2.pageX - refState.value.x - refState.value.delta;
      if (left <= 0) {
        left = 0;
      }
      if (left + scrollBarWidth.value >= bodyWidth.value) {
        left = bodyWidth.value - scrollBarWidth.value;
      }
      emit("scroll", {
        scrollLeft: left / bodyWidth.value * (bodyScrollWidth.value + 2)
      });
      refState.value.x = event2.pageX;
    };
    var onContainerScroll = function onContainerScroll2() {
      if (!props3.scrollBodyRef.value) {
        return;
      }
      var tableOffsetTop = getOffset(props3.scrollBodyRef.value).top;
      var tableBottomOffset = tableOffsetTop + props3.scrollBodyRef.value.offsetHeight;
      var currentClientOffset = props3.container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(props3.container).top + props3.container.clientHeight;
      if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - props3.offsetScroll) {
        setScrollState(function(state) {
          return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
            isHiddenScrollBar: true
          });
        });
      } else {
        setScrollState(function(state) {
          return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
            isHiddenScrollBar: false
          });
        });
      }
    };
    var setScrollLeft = function setScrollLeft2(left) {
      setScrollState(function(state) {
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          scrollLeft: left / bodyScrollWidth.value * bodyWidth.value || 0
        });
      });
    };
    expose({
      setScrollLeft
    });
    var onMouseUpListener = null;
    var onMouseMoveListener = null;
    var onResizeListener = null;
    var onScrollListener = null;
    onMounted(function() {
      onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp2, false);
      onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove3, false);
      onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
    });
    onActivated(function() {
      nextTick(function() {
        onContainerScroll();
      });
    });
    onMounted(function() {
      setTimeout(function() {
        watch([scrollBarWidth, isActive], function() {
          onContainerScroll();
        }, {
          immediate: true,
          flush: "post"
        });
      });
    });
    watch(function() {
      return props3.container;
    }, function() {
      var _onScrollListener;
      (_onScrollListener = onScrollListener) === null || _onScrollListener === void 0 ? void 0 : _onScrollListener.remove();
      onScrollListener = addEventListenerWrap(props3.container, "scroll", onContainerScroll, false);
    }, {
      immediate: true,
      flush: "post"
    });
    onBeforeUnmount(function() {
      var _onMouseUpListener, _onMouseMoveListener, _onScrollListener2, _onResizeListener;
      (_onMouseUpListener = onMouseUpListener) === null || _onMouseUpListener === void 0 ? void 0 : _onMouseUpListener.remove();
      (_onMouseMoveListener = onMouseMoveListener) === null || _onMouseMoveListener === void 0 ? void 0 : _onMouseMoveListener.remove();
      (_onScrollListener2 = onScrollListener) === null || _onScrollListener2 === void 0 ? void 0 : _onScrollListener2.remove();
      (_onResizeListener = onResizeListener) === null || _onResizeListener === void 0 ? void 0 : _onResizeListener.remove();
    });
    watch(function() {
      return _objectSpread2$1({}, scrollState.value);
    }, function(newState, preState) {
      if (newState.isHiddenScrollBar !== (preState === null || preState === void 0 ? void 0 : preState.isHiddenScrollBar) && !newState.isHiddenScrollBar) {
        setScrollState(function(state) {
          var bodyNode = props3.scrollBodyRef.value;
          if (!bodyNode) {
            return state;
          }
          return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
            scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
          });
        });
      }
    }, {
      immediate: true
    });
    var scrollbarSize = getScrollBarSize();
    return function() {
      if (bodyScrollWidth.value <= bodyWidth.value || !scrollBarWidth.value || scrollState.value.isHiddenScrollBar) {
        return null;
      }
      var prefixCls = tableContext.prefixCls;
      return createVNode("div", {
        "style": {
          height: "".concat(scrollbarSize, "px"),
          width: "".concat(bodyWidth.value, "px"),
          bottom: "".concat(props3.offsetScroll, "px")
        },
        "class": "".concat(prefixCls, "-sticky-scroll")
      }, [createVNode("div", {
        "onMousedown": onMouseDown2,
        "ref": scrollBarRef,
        "class": classNames("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$U({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive)),
        "style": {
          width: "".concat(scrollBarWidth.value, "px"),
          transform: "translate3d(".concat(scrollState.value.scrollLeft, "px, 0, 0)")
        }
      }, null)]);
    };
  }
});
var defaultContainer = canUseDom() ? window : null;
function useSticky(stickyRef, prefixClsRef) {
  return computed(function() {
    var _ref = _typeof$3(stickyRef.value) === "object" ? stickyRef.value : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer4 = _ref$getContainer === void 0 ? function() {
      return defaultContainer;
    } : _ref$getContainer;
    var container = getContainer4() || defaultContainer;
    var isSticky = !!stickyRef.value;
    return {
      isSticky,
      stickyClassName: isSticky ? "".concat(prefixClsRef.value, "-sticky-holder") : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  });
}
function useColumnWidth(colWidthsRef, columCountRef) {
  return computed(function() {
    var cloneColumns = [];
    var colWidths = colWidthsRef.value;
    var columCount = columCountRef.value;
    for (var i2 = 0; i2 < columCount; i2 += 1) {
      var val = colWidths[i2];
      if (val !== void 0) {
        cloneColumns[i2] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  });
}
const FixedHolder = defineComponent({
  name: "FixedHolder",
  inheritAttrs: false,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup: function setup189(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var tableContext = useInjectTable();
    var combinationScrollBarSize = computed(function() {
      return tableContext.isSticky && !props3.fixHeader ? 0 : tableContext.scrollbarSize;
    });
    var scrollRef = ref();
    var onWheel = function onWheel2(e2) {
      var currentTarget = e2.currentTarget, deltaX = e2.deltaX;
      if (deltaX) {
        emit("scroll", {
          currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e2.preventDefault();
      }
    };
    var wheelEvent = ref();
    onMounted(function() {
      nextTick(function() {
        wheelEvent.value = addEventListenerWrap(scrollRef.value, "wheel", onWheel);
      });
    });
    onBeforeUnmount(function() {
      var _wheelEvent$value;
      (_wheelEvent$value = wheelEvent.value) === null || _wheelEvent$value === void 0 ? void 0 : _wheelEvent$value.remove();
    });
    var allFlattenColumnsWithWidth = computed(function() {
      return props3.flattenColumns.every(function(column2) {
        return column2.width && column2.width !== 0 && column2.width !== "0px";
      });
    });
    var columnsWithScrollbar = ref([]);
    var flattenColumnsWithScrollbar = ref([]);
    watchEffect(function() {
      var lastColumn = props3.flattenColumns[props3.flattenColumns.length - 1];
      var ScrollBarColumn = {
        fixed: lastColumn ? lastColumn.fixed : null,
        scrollbar: true,
        customHeaderCell: function customHeaderCell() {
          return {
            class: "".concat(tableContext.prefixCls, "-cell-scrollbar")
          };
        }
      };
      columnsWithScrollbar.value = combinationScrollBarSize.value ? [].concat(_toConsumableArray(props3.columns), [ScrollBarColumn]) : props3.columns;
      flattenColumnsWithScrollbar.value = combinationScrollBarSize.value ? [].concat(_toConsumableArray(props3.flattenColumns), [ScrollBarColumn]) : props3.flattenColumns;
    });
    var headerStickyOffsets = computed(function() {
      var stickyOffsets = props3.stickyOffsets, direction = props3.direction;
      var right = stickyOffsets.right, left = stickyOffsets.left;
      return _objectSpread2$1(_objectSpread2$1({}, stickyOffsets), {}, {
        left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
          return width + combinationScrollBarSize.value;
        })), [0]) : left,
        right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
          return width + combinationScrollBarSize.value;
        })), [0]),
        isSticky: tableContext.isSticky
      });
    });
    var mergedColumnWidth = useColumnWidth(toRef(props3, "colWidths"), toRef(props3, "columCount"));
    return function() {
      var _slots$default;
      var noData = props3.noData, columCount = props3.columCount, stickyTopOffset = props3.stickyTopOffset, stickyBottomOffset = props3.stickyBottomOffset, stickyClassName = props3.stickyClassName, maxContentScroll = props3.maxContentScroll;
      var isSticky = tableContext.isSticky;
      return createVNode("div", {
        "style": _objectSpread2$1({
          overflow: "hidden"
        }, isSticky ? {
          top: "".concat(stickyTopOffset, "px"),
          bottom: "".concat(stickyBottomOffset, "px")
        } : {}),
        "ref": scrollRef,
        "class": classNames(attrs.class, _defineProperty$U({}, stickyClassName, !!stickyClassName))
      }, [createVNode("table", {
        "style": {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth.value ? null : "hidden"
        }
      }, [(!noData || !maxContentScroll || allFlattenColumnsWithWidth.value) && createVNode(ColGroup, {
        "colWidths": mergedColumnWidth.value ? [].concat(_toConsumableArray(mergedColumnWidth.value), [combinationScrollBarSize.value]) : [],
        "columCount": columCount + 1,
        "columns": flattenColumnsWithScrollbar.value
      }, null), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        stickyOffsets: headerStickyOffsets.value,
        columns: columnsWithScrollbar.value,
        flattenColumns: flattenColumnsWithScrollbar.value
      }))])]);
    };
  }
});
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
function reactivePick(obj) {
  for (var _len = arguments.length, keys2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys2[_key - 1] = arguments[_key];
  }
  return reactive(fromPairs(keys2.map(function(k2) {
    return [k2, toRef(obj, k2)];
  })));
}
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";
const Table$3 = defineComponent({
  name: "Table",
  inheritAttrs: false,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  slots: ["title", "footer", "summary", "emptyText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
  setup: function setup190(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit;
    var mergedData = computed(function() {
      return props3.data || EMPTY_DATA;
    });
    var hasData = computed(function() {
      return !!mergedData.value.length;
    });
    var mergedComponents = computed(function() {
      return mergeObject(props3.components, {});
    });
    var getComponent3 = function getComponent4(path2, defaultComponent) {
      return getPathValue(mergedComponents.value, path2) || defaultComponent;
    };
    var getRowKey = computed(function() {
      var rowKey = props3.rowKey;
      if (typeof rowKey === "function") {
        return rowKey;
      }
      return function(record) {
        var key2 = record && record[rowKey];
        return key2;
      };
    });
    var mergedExpandIcon = computed(function() {
      return props3.expandIcon || renderExpandIcon$1;
    });
    var mergedChildrenColumnName = computed(function() {
      return props3.childrenColumnName || "children";
    });
    var expandableType = computed(function() {
      if (props3.expandedRowRender) {
        return "row";
      }
      if (props3.canExpandable || mergedData.value.some(function(record) {
        return record && _typeof$3(record) === "object" && record[mergedChildrenColumnName.value];
      })) {
        return "nest";
      }
      return false;
    });
    var innerExpandedKeys = shallowRef([]);
    var stop2 = watchEffect(function() {
      if (props3.defaultExpandedRowKeys) {
        innerExpandedKeys.value = props3.defaultExpandedRowKeys;
      }
      if (props3.defaultExpandAllRows) {
        innerExpandedKeys.value = findAllChildrenKeys(mergedData.value, getRowKey.value, mergedChildrenColumnName.value);
      }
    });
    stop2();
    var mergedExpandedKeys = computed(function() {
      return new Set(props3.expandedRowKeys || innerExpandedKeys.value || []);
    });
    var onTriggerExpand = function onTriggerExpand2(record) {
      var key2 = getRowKey.value(record, mergedData.value.indexOf(record));
      var newExpandedKeys;
      var hasKey = mergedExpandedKeys.value.has(key2);
      if (hasKey) {
        mergedExpandedKeys.value.delete(key2);
        newExpandedKeys = _toConsumableArray(mergedExpandedKeys.value);
      } else {
        newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys.value), [key2]);
      }
      innerExpandedKeys.value = newExpandedKeys;
      emit("expand", !hasKey, record);
      emit("update:expandedRowKeys", newExpandedKeys);
      emit("expandedRowsChange", newExpandedKeys);
    };
    var componentWidth = ref(0);
    var _useColumns = useColumns$1(_objectSpread2$1(_objectSpread2$1({}, toRefs(props3)), {}, {
      expandable: computed(function() {
        return !!props3.expandedRowRender;
      }),
      expandedKeys: mergedExpandedKeys,
      getRowKey,
      onTriggerExpand,
      expandIcon: mergedExpandIcon
    }), computed(function() {
      return props3.internalHooks === INTERNAL_HOOKS ? props3.transformColumns : null;
    })), _useColumns2 = _slicedToArray$2(_useColumns, 2), columns = _useColumns2[0], flattenColumns = _useColumns2[1];
    var columnContext = computed(function() {
      return {
        columns: columns.value,
        flattenColumns: flattenColumns.value
      };
    });
    var fullTableRef = ref();
    var scrollHeaderRef = ref();
    var scrollBodyRef = ref();
    var scrollBodySizeInfo = ref({
      scrollWidth: 0,
      clientWidth: 0
    });
    var scrollSummaryRef = ref();
    var _useState = useState(false), _useState2 = _slicedToArray$2(_useState, 2), pingedLeft = _useState2[0], setPingedLeft = _useState2[1];
    var _useState3 = useState(false), _useState4 = _slicedToArray$2(_useState3, 2), pingedRight = _useState4[0], setPingedRight = _useState4[1];
    var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray$2(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
    var colsKeys = computed(function() {
      return getColumnsKey(flattenColumns.value);
    });
    var colWidths = computed(function() {
      return colsKeys.value.map(function(columnKey) {
        return colsWidths.value.get(columnKey);
      });
    });
    var columnCount = computed(function() {
      return flattenColumns.value.length;
    });
    var stickyOffsets = useStickyOffsets(colWidths, columnCount, toRef(props3, "direction"));
    var fixHeader = computed(function() {
      return props3.scroll && validateValue(props3.scroll.y);
    });
    var horizonScroll = computed(function() {
      return props3.scroll && validateValue(props3.scroll.x) || Boolean(props3.expandFixed);
    });
    var fixColumn = computed(function() {
      return horizonScroll.value && flattenColumns.value.some(function(_ref2) {
        var fixed = _ref2.fixed;
        return fixed;
      });
    });
    var stickyRef = ref();
    var stickyState = useSticky(toRef(props3, "sticky"), toRef(props3, "prefixCls"));
    var summaryFixedInfos = reactive({});
    var fixFooter = computed(function() {
      var info = Object.values(summaryFixedInfos)[0];
      return (fixHeader.value || stickyState.value.isSticky) && info;
    });
    var summaryCollect = function summaryCollect2(uniKey, fixed) {
      if (fixed) {
        summaryFixedInfos[uniKey] = fixed;
      } else {
        delete summaryFixedInfos[uniKey];
      }
    };
    var scrollXStyle = ref({});
    var scrollYStyle = ref({});
    var scrollTableStyle = ref({});
    watchEffect(function() {
      if (fixHeader.value) {
        scrollYStyle.value = {
          overflowY: "scroll",
          maxHeight: toPx(props3.scroll.y)
        };
      }
      if (horizonScroll.value) {
        scrollXStyle.value = {
          overflowX: "auto"
        };
        if (!fixHeader.value) {
          scrollYStyle.value = {
            overflowY: "hidden"
          };
        }
        scrollTableStyle.value = {
          width: props3.scroll.x === true ? "auto" : toPx(props3.scroll.x),
          minWidth: "100%"
        };
      }
    });
    var onColumnResize = function onColumnResize2(columnKey, width) {
      if (isVisible(fullTableRef.value)) {
        updateColsWidths(function(widths) {
          if (widths.get(columnKey) !== width) {
            var newWidths = new Map(widths);
            newWidths.set(columnKey, width);
            return newWidths;
          }
          return widths;
        });
      }
    };
    var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray$2(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
    function forceScroll(scrollLeft, target) {
      if (!target) {
        return;
      }
      if (typeof target === "function") {
        target(scrollLeft);
        return;
      }
      var domTarget = target.$el || target;
      if (domTarget.scrollLeft !== scrollLeft) {
        domTarget.scrollLeft = scrollLeft;
      }
    }
    var onScroll = function onScroll2(_ref3) {
      var currentTarget = _ref3.currentTarget, scrollLeft = _ref3.scrollLeft;
      var isRTL = props3.direction === "rtl";
      var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
      var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
      if (!getScrollTarget() || getScrollTarget() === compareTarget) {
        var _stickyRef$value;
        setScrollTarget(compareTarget);
        forceScroll(mergedScrollLeft, scrollHeaderRef.value);
        forceScroll(mergedScrollLeft, scrollBodyRef.value);
        forceScroll(mergedScrollLeft, scrollSummaryRef.value);
        forceScroll(mergedScrollLeft, (_stickyRef$value = stickyRef.value) === null || _stickyRef$value === void 0 ? void 0 : _stickyRef$value.setScrollLeft);
      }
      if (currentTarget) {
        var scrollWidth = currentTarget.scrollWidth, clientWidth = currentTarget.clientWidth;
        if (isRTL) {
          setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
          setPingedRight(-mergedScrollLeft > 0);
        } else {
          setPingedLeft(mergedScrollLeft > 0);
          setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
        }
      }
    };
    var triggerOnScroll = function triggerOnScroll2() {
      if (horizonScroll.value && scrollBodyRef.value) {
        onScroll({
          currentTarget: scrollBodyRef.value
        });
      } else {
        setPingedLeft(false);
        setPingedRight(false);
      }
    };
    var timtout;
    var updateWidth = function updateWidth2(width) {
      if (width !== componentWidth.value) {
        triggerOnScroll();
        componentWidth.value = fullTableRef.value ? fullTableRef.value.offsetWidth : width;
      }
    };
    var onFullTableResize = function onFullTableResize2(_ref4) {
      var width = _ref4.width;
      clearTimeout(timtout);
      if (componentWidth.value === 0) {
        updateWidth(width);
        return;
      }
      timtout = setTimeout(function() {
        updateWidth(width);
      }, 100);
    };
    watch([horizonScroll, function() {
      return props3.data;
    }, function() {
      return props3.columns;
    }], function() {
      if (horizonScroll.value) {
        triggerOnScroll();
      }
    }, {
      flush: "post"
    });
    var _useState5 = useState(0), _useState6 = _slicedToArray$2(_useState5, 2), scrollbarSize = _useState6[0], setScrollbarSize = _useState6[1];
    useProvideSticky();
    onMounted(function() {
      nextTick(function() {
        var _scrollBodyRef$value, _scrollBodyRef$value2;
        triggerOnScroll();
        setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.value).width);
        scrollBodySizeInfo.value = {
          scrollWidth: ((_scrollBodyRef$value = scrollBodyRef.value) === null || _scrollBodyRef$value === void 0 ? void 0 : _scrollBodyRef$value.scrollWidth) || 0,
          clientWidth: ((_scrollBodyRef$value2 = scrollBodyRef.value) === null || _scrollBodyRef$value2 === void 0 ? void 0 : _scrollBodyRef$value2.clientWidth) || 0
        };
      });
    });
    onUpdated(function() {
      nextTick(function() {
        var _scrollBodyRef$value3, _scrollBodyRef$value4;
        var scrollWidth = ((_scrollBodyRef$value3 = scrollBodyRef.value) === null || _scrollBodyRef$value3 === void 0 ? void 0 : _scrollBodyRef$value3.scrollWidth) || 0;
        var clientWidth = ((_scrollBodyRef$value4 = scrollBodyRef.value) === null || _scrollBodyRef$value4 === void 0 ? void 0 : _scrollBodyRef$value4.clientWidth) || 0;
        if (scrollBodySizeInfo.value.scrollWidth !== scrollWidth || scrollBodySizeInfo.value.clientWidth !== clientWidth) {
          scrollBodySizeInfo.value = {
            scrollWidth,
            clientWidth
          };
        }
      });
    });
    watchEffect(function() {
      if (props3.internalHooks === INTERNAL_HOOKS && props3.internalRefs) {
        props3.onUpdateInternalRefs({
          body: scrollBodyRef.value ? scrollBodyRef.value.$el || scrollBodyRef.value : null
        });
      }
    }, {
      flush: "post"
    });
    var mergedTableLayout = computed(function() {
      if (props3.tableLayout) {
        return props3.tableLayout;
      }
      if (fixColumn.value) {
        return props3.scroll.x === "max-content" ? "auto" : "fixed";
      }
      if (fixHeader.value || stickyState.value.isSticky || flattenColumns.value.some(function(_ref5) {
        var ellipsis = _ref5.ellipsis;
        return ellipsis;
      })) {
        return "fixed";
      }
      return "auto";
    });
    var emptyNode = function emptyNode2() {
      var _slots$emptyText;
      return hasData.value ? null : ((_slots$emptyText = slots.emptyText) === null || _slots$emptyText === void 0 ? void 0 : _slots$emptyText.call(slots)) || "No Data";
    };
    useProvideTable(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(props3, "prefixCls", "direction", "transformCellText"))), {}, {
      getComponent: getComponent3,
      scrollbarSize,
      fixedInfoList: computed(function() {
        return flattenColumns.value.map(function(_2, colIndex) {
          return getCellFixedInfo(colIndex, colIndex, flattenColumns.value, stickyOffsets.value, props3.direction);
        });
      }),
      isSticky: computed(function() {
        return stickyState.value.isSticky;
      }),
      summaryCollect
    })));
    useProvideBody(reactive(_objectSpread2$1(_objectSpread2$1({}, toRefs(reactivePick(props3, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {}, {
      columns,
      flattenColumns,
      tableLayout: mergedTableLayout,
      expandIcon: mergedExpandIcon,
      expandableType,
      onTriggerExpand
    })));
    useProvideResize({
      onColumnResize
    });
    useProvideExpandedRow({
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll
    });
    var bodyTable = function bodyTable2() {
      return createVNode(Body, {
        "data": mergedData.value,
        "measureColumnWidth": fixHeader.value || horizonScroll.value || stickyState.value.isSticky,
        "expandedKeys": mergedExpandedKeys.value,
        "rowExpandable": props3.rowExpandable,
        "getRowKey": getRowKey.value,
        "customRow": props3.customRow,
        "childrenColumnName": mergedChildrenColumnName.value
      }, {
        emptyNode
      });
    };
    var bodyColGroup = function bodyColGroup2() {
      return createVNode(ColGroup, {
        "colWidths": flattenColumns.value.map(function(_ref6) {
          var width = _ref6.width;
          return width;
        }),
        "columns": flattenColumns.value
      }, null);
    };
    return function() {
      var _slots$summary;
      var prefixCls = props3.prefixCls, scroll = props3.scroll, tableLayout = props3.tableLayout, direction = props3.direction, _props$title = props3.title, title = _props$title === void 0 ? slots.title : _props$title, _props$footer = props3.footer, footer = _props$footer === void 0 ? slots.footer : _props$footer, id = props3.id, showHeader = props3.showHeader, customHeaderRow = props3.customHeaderRow;
      var _stickyState$value = stickyState.value, isSticky = _stickyState$value.isSticky, offsetHeader = _stickyState$value.offsetHeader, offsetSummary = _stickyState$value.offsetSummary, offsetScroll = _stickyState$value.offsetScroll, stickyClassName = _stickyState$value.stickyClassName, container = _stickyState$value.container;
      var TableComponent = getComponent3(["table"], "table");
      var customizeScrollBody = getComponent3(["body"]);
      var summaryNode = (_slots$summary = slots.summary) === null || _slots$summary === void 0 ? void 0 : _slots$summary.call(slots, {
        pageData: mergedData.value
      });
      var groupTableNode = function groupTableNode2() {
        return null;
      };
      var headerProps = {
        colWidths: colWidths.value,
        columCount: flattenColumns.value.length,
        stickyOffsets: stickyOffsets.value,
        customHeaderRow,
        fixHeader: fixHeader.value,
        scroll
      };
      if (fixHeader.value || isSticky) {
        var bodyContent = function bodyContent2() {
          return null;
        };
        if (typeof customizeScrollBody === "function") {
          bodyContent = function bodyContent2() {
            return customizeScrollBody(mergedData.value, {
              scrollbarSize: scrollbarSize.value,
              ref: scrollBodyRef,
              onScroll
            });
          };
          headerProps.colWidths = flattenColumns.value.map(function(_ref7, index2) {
            var width = _ref7.width;
            var colWidth = index2 === columns.value.length - 1 ? width - scrollbarSize.value : width;
            if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
              return colWidth;
            }
            return 0;
          });
        } else {
          bodyContent = function bodyContent2() {
            return createVNode("div", {
              "style": _objectSpread2$1(_objectSpread2$1({}, scrollXStyle.value), scrollYStyle.value),
              "onScroll": onScroll,
              "ref": scrollBodyRef,
              "class": classNames("".concat(prefixCls, "-body"))
            }, [createVNode(TableComponent, {
              "style": _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle.value), {}, {
                tableLayout: mergedTableLayout.value
              })
            }, {
              default: function _default9() {
                return [bodyColGroup(), bodyTable(), !fixFooter.value && summaryNode && createVNode(Footer$1, {
                  "stickyOffsets": stickyOffsets.value,
                  "flattenColumns": flattenColumns.value
                }, {
                  default: function _default10() {
                    return [summaryNode];
                  }
                })];
              }
            })]);
          };
        }
        var fixedHolderProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          noData: !mergedData.value.length,
          maxContentScroll: horizonScroll.value && scroll.x === "max-content"
        }, headerProps), columnContext.value), {}, {
          direction,
          stickyClassName,
          onScroll
        });
        groupTableNode = function groupTableNode2() {
          return createVNode(Fragment, null, [showHeader !== false && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyTopOffset": offsetHeader,
            "class": "".concat(prefixCls, "-header"),
            "ref": scrollHeaderRef
          }), {
            default: function _default9(fixedHolderPassProps) {
              return createVNode(Fragment, null, [createVNode(Header$1, fixedHolderPassProps, null), fixFooter.value === "top" && createVNode(Footer$1, fixedHolderPassProps, {
                default: function _default10() {
                  return [summaryNode];
                }
              })]);
            }
          }), bodyContent(), fixFooter.value && fixFooter.value !== "top" && createVNode(FixedHolder, _objectSpread2$1(_objectSpread2$1({}, fixedHolderProps), {}, {
            "stickyBottomOffset": offsetSummary,
            "class": "".concat(prefixCls, "-summary"),
            "ref": scrollSummaryRef
          }), {
            default: function _default9(fixedHolderPassProps) {
              return createVNode(Footer$1, fixedHolderPassProps, {
                default: function _default10() {
                  return [summaryNode];
                }
              });
            }
          }), isSticky && scrollBodyRef.value && createVNode(StickyScrollBar, {
            "ref": stickyRef,
            "offsetScroll": offsetScroll,
            "scrollBodyRef": scrollBodyRef,
            "onScroll": onScroll,
            "container": container,
            "scrollBodySizeInfo": scrollBodySizeInfo.value
          }, null)]);
        };
      } else {
        groupTableNode = function groupTableNode2() {
          return createVNode("div", {
            "style": _objectSpread2$1(_objectSpread2$1({}, scrollXStyle.value), scrollYStyle.value),
            "class": classNames("".concat(prefixCls, "-content")),
            "onScroll": onScroll,
            "ref": scrollBodyRef
          }, [createVNode(TableComponent, {
            "style": _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle.value), {}, {
              tableLayout: mergedTableLayout.value
            })
          }, {
            default: function _default9() {
              return [bodyColGroup(), showHeader !== false && createVNode(Header$1, _objectSpread2$1(_objectSpread2$1({}, headerProps), columnContext.value), null), bodyTable(), summaryNode && createVNode(Footer$1, {
                "stickyOffsets": stickyOffsets.value,
                "flattenColumns": flattenColumns.value
              }, {
                default: function _default10() {
                  return [summaryNode];
                }
              })];
            }
          })]);
        };
      }
      var ariaProps = pickAttrs(attrs, {
        aria: true,
        data: true
      });
      var fullTable = function fullTable2() {
        var _classNames;
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, ariaProps), {}, {
          "class": classNames(prefixCls, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$U(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty$U(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns.value[0] && flattenColumns.value[0].fixed), _defineProperty$U(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns.value[columnCount.value - 1] && flattenColumns.value[columnCount.value - 1].fixed === "right"), _defineProperty$U(_classNames, attrs.class, attrs.class), _classNames)),
          "style": attrs.style,
          "id": id,
          "ref": fullTableRef
        }), [title && createVNode(Panel, {
          "class": "".concat(prefixCls, "-title")
        }, {
          default: function _default9() {
            return [title(mergedData.value)];
          }
        }), createVNode("div", {
          "class": "".concat(prefixCls, "-container")
        }, [groupTableNode()]), footer && createVNode(Panel, {
          "class": "".concat(prefixCls, "-footer")
        }, {
          default: function _default9() {
            return [footer(mergedData.value)];
          }
        })]);
      };
      if (horizonScroll.value) {
        return createVNode(ResizeObserver$1, {
          "onResize": onFullTableResize
        }, {
          default: fullTable
        });
      }
      return fullTable();
    };
  }
});
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(pagination, mergedPagination) {
  var param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  var paginationObj = pagination && _typeof$3(pagination) === "object" ? pagination : {};
  Object.keys(paginationObj).forEach(function(pageProp) {
    var value = mergedPagination[pageProp];
    if (typeof value !== "function") {
      param[pageProp] = value;
    }
  });
  return param;
}
function extendsObject() {
  var result = {};
  for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {
    list[_key] = arguments[_key];
  }
  list.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key2) {
        var val = obj[key2];
        if (val !== void 0) {
          result[key2] = val;
        }
      });
    }
  });
  return result;
}
function usePagination(totalRef, paginationRef, onChange3) {
  var pagination = computed(function() {
    return paginationRef.value && _typeof$3(paginationRef.value) === "object" ? paginationRef.value : {};
  });
  var paginationTotal = computed(function() {
    return pagination.value.total || 0;
  });
  var _useState = useState(function() {
    return {
      current: "defaultCurrent" in pagination.value ? pagination.value.defaultCurrent : 1,
      pageSize: "defaultPageSize" in pagination.value ? pagination.value.defaultPageSize : DEFAULT_PAGE_SIZE
    };
  }), _useState2 = _slicedToArray$2(_useState, 2), innerPagination = _useState2[0], setInnerPagination = _useState2[1];
  var mergedPagination = computed(function() {
    var mP = extendsObject(innerPagination.value, pagination.value, {
      total: paginationTotal.value > 0 ? paginationTotal.value : totalRef.value
    });
    var maxPage = Math.ceil((paginationTotal.value || totalRef.value) / mP.pageSize);
    if (mP.current > maxPage) {
      mP.current = maxPage || 1;
    }
    return mP;
  });
  var refreshPagination = function refreshPagination2(current2, pageSize2) {
    if (pagination.value === false)
      return;
    setInnerPagination({
      current: current2 !== null && current2 !== void 0 ? current2 : 1,
      pageSize: pageSize2 || mergedPagination.value.pageSize
    });
  };
  var onInternalChange = function onInternalChange2(current2, pageSize2) {
    if (pagination.value) {
      var _pagination$value$onC, _pagination$value;
      (_pagination$value$onC = (_pagination$value = pagination.value).onChange) === null || _pagination$value$onC === void 0 ? void 0 : _pagination$value$onC.call(_pagination$value, current2, pageSize2);
    }
    refreshPagination(current2, pageSize2);
    onChange3(current2, pageSize2 || mergedPagination.value.pageSize);
  };
  return [computed(function() {
    return pagination.value === false ? {} : _objectSpread2$1(_objectSpread2$1({}, mergedPagination.value), {}, {
      onChange: onInternalChange
    });
  }), refreshPagination];
}
function useLazyKVMap(dataRef, childrenColumnNameRef, getRowKeyRef) {
  var mapCacheRef = shallowRef({});
  watch([dataRef, childrenColumnNameRef, getRowKeyRef], function() {
    var kvMap = /* @__PURE__ */ new Map();
    var getRowKey = getRowKeyRef.value;
    var childrenColumnName = childrenColumnNameRef.value;
    function dig(records) {
      records.forEach(function(record, index2) {
        var rowKey = getRowKey(record, index2);
        kvMap.set(rowKey, record);
        if (record && _typeof$3(record) === "object" && childrenColumnName in record) {
          dig(record[childrenColumnName] || []);
        }
      });
    }
    dig(dataRef.value);
    mapCacheRef.value = {
      kvMap
    };
  }, {
    deep: true,
    immediate: true
  });
  function getRecordByKey(key2) {
    return mapCacheRef.value.kvMap.get(key2);
  }
  return [getRecordByKey];
}
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
function flattenData(data9, childrenColumnName) {
  var list = [];
  (data9 || []).forEach(function(record) {
    list.push(record);
    if (record && _typeof$3(record) === "object" && childrenColumnName in record) {
      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list;
}
function useSelection(rowSelectionRef, configRef) {
  var mergedRowSelection = computed(function() {
    var temp = rowSelectionRef.value || {};
    var _temp$checkStrictly = temp.checkStrictly, checkStrictly = _temp$checkStrictly === void 0 ? true : _temp$checkStrictly;
    return _objectSpread2$1(_objectSpread2$1({}, temp), {}, {
      checkStrictly
    });
  });
  var _useMergedState = useMergedState(mergedRowSelection.value.selectedRowKeys || mergedRowSelection.value.defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: computed(function() {
      return mergedRowSelection.value.selectedRowKeys;
    })
  }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedSelectedKeys = _useMergedState2[0], setMergedSelectedKeys = _useMergedState2[1];
  var preserveRecordsRef = shallowRef(/* @__PURE__ */ new Map());
  var updatePreserveRecordsCache = function updatePreserveRecordsCache2(keys2) {
    if (mergedRowSelection.value.preserveSelectedRowKeys) {
      var newCache = /* @__PURE__ */ new Map();
      keys2.forEach(function(key2) {
        var record = configRef.getRecordByKey(key2);
        if (!record && preserveRecordsRef.value.has(key2)) {
          record = preserveRecordsRef.value.get(key2);
        }
        newCache.set(key2, record);
      });
      preserveRecordsRef.value = newCache;
    }
  };
  watchEffect(function() {
    updatePreserveRecordsCache(mergedSelectedKeys.value);
  });
  var keyEntities = computed(function() {
    return mergedRowSelection.value.checkStrictly ? null : convertDataToEntities(configRef.data.value, {
      externalGetKey: configRef.getRowKey.value,
      childrenPropName: configRef.childrenColumnName.value
    }).keyEntities;
  });
  var flattedData = computed(function() {
    return flattenData(configRef.pageData.value, configRef.childrenColumnName.value);
  });
  var checkboxPropsMap = computed(function() {
    var map = /* @__PURE__ */ new Map();
    var getRowKey = configRef.getRowKey.value;
    var getCheckboxProps = mergedRowSelection.value.getCheckboxProps;
    flattedData.value.forEach(function(record, index2) {
      var key2 = getRowKey(record, index2);
      var checkboxProps3 = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key2, checkboxProps3);
    });
    return map;
  });
  var _useMaxLevel = useMaxLevel(keyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
  var isCheckboxDisabled = function isCheckboxDisabled2(r2) {
    var _checkboxPropsMap$val;
    return !!((_checkboxPropsMap$val = checkboxPropsMap.value.get(configRef.getRowKey.value(r2))) !== null && _checkboxPropsMap$val !== void 0 && _checkboxPropsMap$val.disabled);
  };
  var selectKeysState = computed(function() {
    if (mergedRowSelection.value.checkStrictly) {
      return [mergedSelectedKeys.value || [], []];
    }
    var _conductCheck = conductCheck(mergedSelectedKeys.value, true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
    return [checkedKeys || [], halfCheckedKeys];
  });
  var derivedSelectedKeys = computed(function() {
    return selectKeysState.value[0];
  });
  var derivedHalfSelectedKeys = computed(function() {
    return selectKeysState.value[1];
  });
  var derivedSelectedKeySet = computed(function() {
    var keys2 = mergedRowSelection.value.type === "radio" ? derivedSelectedKeys.value.slice(0, 1) : derivedSelectedKeys.value;
    return new Set(keys2);
  });
  var derivedHalfSelectedKeySet = computed(function() {
    return mergedRowSelection.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys.value);
  });
  var _useState = useState(null), _useState2 = _slicedToArray$2(_useState, 2), lastSelectedKey = _useState2[0], setLastSelectedKey = _useState2[1];
  var setSelectedKeys = function setSelectedKeys2(keys2) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys2);
    var _mergedRowSelection$v = mergedRowSelection.value, preserveSelectedRowKeys = _mergedRowSelection$v.preserveSelectedRowKeys, onSelectionChange = _mergedRowSelection$v.onChange;
    var getRecordByKey = configRef.getRecordByKey;
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map(function(key2) {
        return preserveRecordsRef.value.get(key2);
      });
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (record !== void 0) {
          availableKeys.push(key2);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records);
  };
  var triggerSingleSelection = function triggerSingleSelection2(key2, selected, keys2, event2) {
    var onSelect = mergedRowSelection.value.onSelect;
    var _ref = configRef || {}, getRecordByKey = _ref.getRecordByKey;
    if (onSelect) {
      var rows = keys2.map(function(k2) {
        return getRecordByKey(k2);
      });
      onSelect(getRecordByKey(key2), selected, rows, event2);
    }
    setSelectedKeys(keys2);
  };
  var mergedSelections = computed(function() {
    var _mergedRowSelection$v2 = mergedRowSelection.value, onSelectInvert = _mergedRowSelection$v2.onSelectInvert, onSelectNone = _mergedRowSelection$v2.onSelectNone, selections = _mergedRowSelection$v2.selections, hideSelectAll = _mergedRowSelection$v2.hideSelectAll;
    var data9 = configRef.data, pageData = configRef.pageData, getRowKey = configRef.getRowKey, tableLocale = configRef.locale;
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function(selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.value.selectionAll,
          onSelect: function onSelect() {
            setSelectedKeys(data9.value.map(function(record, index2) {
              return getRowKey.value(record, index2);
            }).filter(function(key2) {
              var checkProps = checkboxPropsMap.value.get(key2);
              return !(checkProps !== null && checkProps !== void 0 && checkProps.disabled) || derivedSelectedKeySet.value.has(key2);
            }));
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.value.selectInvert,
          onSelect: function onSelect() {
            var keySet = new Set(derivedSelectedKeySet.value);
            pageData.value.forEach(function(record, index2) {
              var key2 = getRowKey.value(record, index2);
              var checkProps = checkboxPropsMap.value.get(key2);
              if (!(checkProps !== null && checkProps !== void 0 && checkProps.disabled)) {
                if (keySet.has(key2)) {
                  keySet.delete(key2);
                } else {
                  keySet.add(key2);
                }
              }
            });
            var keys2 = Array.from(keySet);
            if (onSelectInvert) {
              devWarning(false, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead.");
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2);
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.value.selectNone,
          onSelect: function onSelect() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet.value).filter(function(key2) {
              var checkProps = checkboxPropsMap.value.get(key2);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }));
          }
        };
      }
      return selection;
    });
  });
  var flattedDataLength = computed(function() {
    return flattedData.value.length;
  });
  var transformColumns = function transformColumns2(columns) {
    var _prevCol$INTERNAL_COL;
    var _mergedRowSelection$v3 = mergedRowSelection.value, onSelectAll = _mergedRowSelection$v3.onSelectAll, onSelectMultiple = _mergedRowSelection$v3.onSelectMultiple, selectionColWidth = _mergedRowSelection$v3.columnWidth, selectionType = _mergedRowSelection$v3.type, fixed = _mergedRowSelection$v3.fixed, customizeRenderCell = _mergedRowSelection$v3.renderCell, hideSelectAll = _mergedRowSelection$v3.hideSelectAll, checkStrictly = _mergedRowSelection$v3.checkStrictly;
    var prefixCls = configRef.prefixCls, getRecordByKey = configRef.getRecordByKey, getRowKey = configRef.getRowKey, expandType = configRef.expandType, getPopupContainer = configRef.getPopupContainer;
    if (!rowSelectionRef.value) {
      return columns.filter(function(col) {
        return col !== SELECTION_COLUMN;
      });
    }
    var cloneColumns = columns.slice();
    var keySet = new Set(derivedSelectedKeySet.value);
    var recordKeys = flattedData.value.map(getRowKey.value).filter(function(key2) {
      return !checkboxPropsMap.value.get(key2).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function(key2) {
      return keySet.has(key2);
    });
    var checkedCurrentSome = recordKeys.some(function(key2) {
      return keySet.has(key2);
    });
    var onSelectAllChange = function onSelectAllChange2() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function(key2) {
          keySet.delete(key2);
          changeKeys.push(key2);
        });
      } else {
        recordKeys.forEach(function(key2) {
          if (!keySet.has(key2)) {
            keySet.add(key2);
            changeKeys.push(key2);
          }
        });
      }
      var keys2 = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map(function(k2) {
        return getRecordByKey(k2);
      }), changeKeys.map(function(k2) {
        return getRecordByKey(k2);
      }));
      setSelectedKeys(keys2);
    };
    var title;
    if (selectionType !== "radio") {
      var customizeSelections;
      if (mergedSelections.value) {
        var menu = createVNode(Menu, {
          "getPopupContainer": getPopupContainer.value
        }, {
          default: function _default9() {
            return [mergedSelections.value.map(function(selection, index2) {
              var key2 = selection.key, text = selection.text, onSelectionClick = selection.onSelect;
              return createVNode(Menu.Item, {
                "key": key2 || index2,
                "onClick": function onClick2() {
                  onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                }
              }, {
                default: function _default10() {
                  return [text];
                }
              });
            })];
          }
        });
        customizeSelections = createVNode("div", {
          "class": "".concat(prefixCls.value, "-selection-extra")
        }, [createVNode(Dropdown$1, {
          "overlay": menu,
          "getPopupContainer": getPopupContainer.value
        }, {
          default: function _default9() {
            return [createVNode("span", null, [createVNode(DownOutlined$1, null, null)])];
          }
        })]);
      }
      var allDisabledData = flattedData.value.map(function(record, index2) {
        var key2 = getRowKey.value(record, index2);
        var checkboxProps3 = checkboxPropsMap.value.get(key2) || {};
        return _objectSpread2$1({
          checked: keySet.has(key2)
        }, checkboxProps3);
      }).filter(function(_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedDataLength.value;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function(_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function(_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll && createVNode("div", {
        "class": "".concat(prefixCls.value, "-selection")
      }, [createVNode(Checkbox$1, {
        "checked": !allDisabled ? !!flattedDataLength.value && checkedCurrentAll : allDisabledAndChecked,
        "indeterminate": !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        "onChange": onSelectAllChange,
        "disabled": flattedDataLength.value === 0 || allDisabled,
        "skipGroup": true
      }, null), customizeSelections]);
    }
    var renderCell;
    if (selectionType === "radio") {
      renderCell = function renderCell2(_ref5) {
        var record = _ref5.record, index2 = _ref5.index;
        var key2 = getRowKey.value(record, index2);
        var checked = keySet.has(key2);
        return {
          node: createVNode(Radio, _objectSpread2$1(_objectSpread2$1({}, checkboxPropsMap.value.get(key2)), {}, {
            "checked": checked,
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            },
            "onChange": function onChange3(event2) {
              if (!keySet.has(key2)) {
                triggerSingleSelection(key2, true, [key2], event2.nativeEvent);
              }
            }
          }), null),
          checked
        };
      };
    } else {
      renderCell = function renderCell2(_ref6) {
        var record = _ref6.record, index2 = _ref6.index;
        var key2 = getRowKey.value(record, index2);
        var checked = keySet.has(key2);
        var indeterminate = derivedHalfSelectedKeySet.value.has(key2);
        var checkboxProps3 = checkboxPropsMap.value.get(key2);
        var mergedIndeterminate;
        if (expandType.value === "nest") {
          mergedIndeterminate = indeterminate;
          devWarning(typeof (checkboxProps3 === null || checkboxProps3 === void 0 ? void 0 : checkboxProps3.indeterminate) !== "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.");
        } else {
          var _checkboxProps$indete;
          mergedIndeterminate = (_checkboxProps$indete = checkboxProps3 === null || checkboxProps3 === void 0 ? void 0 : checkboxProps3.indeterminate) !== null && _checkboxProps$indete !== void 0 ? _checkboxProps$indete : indeterminate;
        }
        return {
          node: createVNode(Checkbox$1, _objectSpread2$1(_objectSpread2$1({}, checkboxProps3), {}, {
            "indeterminate": mergedIndeterminate,
            "checked": checked,
            "skipGroup": true,
            "onClick": function onClick2(e2) {
              return e2.stopPropagation();
            },
            "onChange": function onChange3(_ref7) {
              var nativeEvent = _ref7.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              if (shiftKey && checkStrictly) {
                var pointKeys = /* @__PURE__ */ new Set([lastSelectedKey.value, key2]);
                recordKeys.some(function(recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function(recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.delete(recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function(recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys2 = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys2);
              } else {
                var originCheckedKeys = derivedSelectedKeys.value;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                  triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                } else {
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key2]), true, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys, halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet.delete(key2);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities.value, maxLevel.value, levelEntities.value, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              setLastSelectedKey(key2);
            }
          }), null),
          checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell2(_ref8) {
      var record = _ref8.record, index2 = _ref8.index;
      var _renderCell = renderCell({
        record,
        index: index2
      }), node = _renderCell.node, checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex(function(col) {
        var _col$INTERNAL_COL_DEF;
        return ((_col$INTERNAL_COL_DEF = col[INTERNAL_COL_DEFINE]) === null || _col$INTERNAL_COL_DEF === void 0 ? void 0 : _col$INTERNAL_COL_DEF.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var _cloneColumns = cloneColumns, _cloneColumns2 = _toArray(_cloneColumns), expandColumn = _cloneColumns2[0], restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter(function(column2, index2) {
      return column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex;
    });
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_prevCol$INTERNAL_COL = prevCol[INTERNAL_COL_DEFINE]) === null || _prevCol$INTERNAL_COL === void 0 ? void 0 : _prevCol$INTERNAL_COL.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    var selectionColumn = _defineProperty$U({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: "".concat(prefixCls.value, "-selection-column"),
      title: mergedRowSelection.value.columnTitle || title,
      customRender: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      class: "".concat(prefixCls.value, "-selection-col")
    });
    return cloneColumns.map(function(col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  };
  return [transformColumns, derivedSelectedKeySet];
}
var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
const CaretDownOutlinedSvg = CaretDownOutlined$2;
function _objectSpread$g(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$g(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$g(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownOutlined = function CaretDownOutlined2(props3, context2) {
  var p2 = _objectSpread$g({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$g({}, p2, {
    "icon": CaretDownOutlinedSvg
  }), null);
};
CaretDownOutlined.displayName = "CaretDownOutlined";
CaretDownOutlined.inheritAttrs = false;
const CaretDownOutlined$1 = CaretDownOutlined;
var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
const CaretUpOutlinedSvg = CaretUpOutlined$2;
function _objectSpread$f(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$f(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$f(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretUpOutlined = function CaretUpOutlined2(props3, context2) {
  var p2 = _objectSpread$f({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$f({}, p2, {
    "icon": CaretUpOutlinedSvg
  }), null);
};
CaretUpOutlined.displayName = "CaretUpOutlined";
CaretUpOutlined.inheritAttrs = false;
const CaretUpOutlined$1 = CaretUpOutlined;
var _excluded$b = ["default"];
function getColumnKey(column2, defaultKey) {
  if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
    return column2.key;
  }
  if (column2.dataIndex) {
    return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index2, pos2) {
  return pos2 ? "".concat(pos2, "-").concat(index2) : "".concat(index2);
}
function renderColumnTitle(title, props3) {
  if (typeof title === "function") {
    return title(props3);
  }
  return title;
}
function convertChildrenToColumns() {
  var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var flattenElements = flattenChildren(elements);
  var columns = [];
  flattenElements.forEach(function(element) {
    var _element$props, _element$props2, _element$type;
    if (!element) {
      return;
    }
    var key2 = element.key;
    var style2 = ((_element$props = element.props) === null || _element$props === void 0 ? void 0 : _element$props.style) || {};
    var cls = ((_element$props2 = element.props) === null || _element$props2 === void 0 ? void 0 : _element$props2.class) || "";
    var props3 = element.props || {};
    for (var _i = 0, _Object$entries = Object.entries(props3); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray$2(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
      props3[camelize$2(k2)] = v2;
    }
    var _ref = element.children || {}, children = _ref.default, restSlots = _objectWithoutProperties$2(_ref, _excluded$b);
    var column2 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restSlots), props3), {}, {
      style: style2,
      class: cls
    });
    if (key2) {
      column2.key = key2;
    }
    if ((_element$type = element.type) !== null && _element$type !== void 0 && _element$type.__ANT_TABLE_COLUMN_GROUP) {
      column2.children = convertChildrenToColumns(typeof children === "function" ? children() : children);
    } else {
      var _element$children;
      var customRender = (_element$children = element.children) === null || _element$children === void 0 ? void 0 : _element$children.default;
      column2.customRender = column2.customRender || customRender;
    }
    columns.push(column2);
  });
  return columns;
}
var ASCEND = "ascend";
var DESCEND = "descend";
function getMultiplePriority(column2) {
  if (_typeof$3(column2.sorter) === "object" && typeof column2.sorter.multiple === "number") {
    return column2.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && _typeof$3(sorter) === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current2) {
  if (!current2) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current2) + 1];
}
function collectSortStates(columns, init, pos2) {
  var sortStates = [];
  function pushState(column2, columnPos) {
    sortStates.push({
      column: column2,
      key: getColumnKey(column2, columnPos),
      multiplePriority: getMultiplePriority(column2),
      sortOrder: column2.sortOrder
    });
  }
  (columns || []).forEach(function(column2, index2) {
    var columnPos = getColumnPos(index2, pos2);
    if (column2.children) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)));
    } else if (column2.sorter) {
      if ("sortOrder" in column2) {
        pushState(column2, columnPos);
      } else if (init && column2.defaultSortOrder) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns, sorterSates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos2) {
  return (columns || []).map(function(column2, index2) {
    var columnPos = getColumnPos(index2, pos2);
    var newColumn = column2;
    if (newColumn.sorter) {
      var sortDirections = newColumn.sortDirections || defaultSortDirections;
      var showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      var columnKey = getColumnKey(newColumn, columnPos);
      var sorterState = sorterSates.find(function(_ref) {
        var key2 = _ref.key;
        return key2 === columnKey;
      });
      var sorterOrder = sorterState ? sorterState.sortOrder : null;
      var nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      var upNode = sortDirections.includes(ASCEND) && createVNode(CaretUpOutlined$1, {
        "class": classNames("".concat(prefixCls, "-column-sorter-up"), {
          active: sorterOrder === ASCEND
        })
      }, null);
      var downNode = sortDirections.includes(DESCEND) && createVNode(CaretDownOutlined$1, {
        "class": classNames("".concat(prefixCls, "-column-sorter-down"), {
          active: sorterOrder === DESCEND
        })
      }, null);
      var _ref2 = tableLocale || {}, cancelSort = _ref2.cancelSort, triggerAsc = _ref2.triggerAsc, triggerDesc = _ref2.triggerDesc;
      var sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      var tooltipProps3 = _typeof$3(showSorterTooltip) === "object" ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _objectSpread2$1(_objectSpread2$1({}, newColumn), {}, {
        className: classNames(newColumn.className, _defineProperty$U({}, "".concat(prefixCls, "-column-sort"), sorterOrder)),
        title: function title(renderProps) {
          var renderSortTitle = createVNode("div", {
            "class": "".concat(prefixCls, "-column-sorters")
          }, [createVNode("span", {
            "class": "".concat(prefixCls, "-column-title")
          }, [renderColumnTitle(column2.title, renderProps)]), createVNode("span", {
            "class": classNames("".concat(prefixCls, "-column-sorter"), _defineProperty$U({}, "".concat(prefixCls, "-column-sorter-full"), !!(upNode && downNode)))
          }, [createVNode("span", {
            "class": "".concat(prefixCls, "-column-sorter-inner")
          }, [upNode, downNode])])]);
          return showSorterTooltip ? createVNode(Tooltip, tooltipProps3, {
            default: function _default9() {
              return [renderSortTitle];
            }
          }) : renderSortTitle;
        },
        customHeaderCell: function customHeaderCell(col) {
          var cell = column2.customHeaderCell && column2.customHeaderCell(col) || {};
          var originOnClick = cell.onClick;
          cell.onClick = function(event2) {
            triggerSorter({
              column: column2,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column2)
            });
            if (originOnClick) {
              originOnClick(event2);
            }
          };
          cell.class = classNames(cell.class, "".concat(prefixCls, "-column-has-sorters"));
          return cell;
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _objectSpread2$1(_objectSpread2$1({}, newColumn), {}, {
        children: injectSorter(prefixCls, newColumn.children, sorterSates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  var column2 = sorterStates.column, sortOrder = sorterStates.sortOrder;
  return {
    column: column2,
    order: sortOrder,
    field: column2.dataIndex,
    columnKey: column2.key
  };
}
function generateSorterInfo(sorterStates) {
  var list = sorterStates.filter(function(_ref3) {
    var sortOrder = _ref3.sortOrder;
    return sortOrder;
  }).map(stateToInfo);
  if (list.length === 0 && sorterStates.length) {
    return _objectSpread2$1(_objectSpread2$1({}, stateToInfo(sorterStates[sorterStates.length - 1])), {}, {
      column: void 0
    });
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}
function getSortData(data9, sortStates, childrenColumnName) {
  var innerSorterStates = sortStates.slice().sort(function(a2, b2) {
    return b2.multiplePriority - a2.multiplePriority;
  });
  var cloneData = data9.slice();
  var runningSorters = innerSorterStates.filter(function(_ref4) {
    var sorter = _ref4.column.sorter, sortOrder = _ref4.sortOrder;
    return getSortFunction(sorter) && sortOrder;
  });
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort(function(record1, record2) {
    for (var i2 = 0; i2 < runningSorters.length; i2 += 1) {
      var sorterState = runningSorters[i2];
      var sorter = sorterState.column.sorter, sortOrder = sorterState.sortOrder;
      var compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        var compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map(function(record) {
    var subRecords = record[childrenColumnName];
    if (subRecords) {
      return _objectSpread2$1(_objectSpread2$1({}, record), {}, _defineProperty$U({}, childrenColumnName, getSortData(subRecords, sortStates, childrenColumnName)));
    }
    return record;
  });
}
function useFilterSorter(_ref5) {
  var prefixCls = _ref5.prefixCls, mergedColumns = _ref5.mergedColumns, onSorterChange = _ref5.onSorterChange, sortDirections = _ref5.sortDirections, tableLocale = _ref5.tableLocale, showSorterTooltip = _ref5.showSorterTooltip;
  var _useState = useState(collectSortStates(mergedColumns.value, true)), _useState2 = _slicedToArray$2(_useState, 2), sortStates = _useState2[0], setSortStates = _useState2[1];
  var mergedSorterStates = computed(function() {
    var validate = true;
    var collectedStates = collectSortStates(mergedColumns.value, false);
    if (!collectedStates.length) {
      return sortStates.value;
    }
    var validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push(_objectSpread2$1(_objectSpread2$1({}, state), {}, {
          sortOrder: null
        }));
      }
    }
    var multipleMode = null;
    collectedStates.forEach(function(state) {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  });
  var columnTitleSorterProps = computed(function() {
    var sortColumns = mergedSorterStates.value.map(function(_ref6) {
      var column2 = _ref6.column, sortOrder = _ref6.sortOrder;
      return {
        column: column2,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  });
  function triggerSorter(sortState) {
    var newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.value.length || mergedSorterStates.value[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.value.filter(function(_ref7) {
        var key2 = _ref7.key;
        return key2 !== sortState.key;
      })), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  var transformColumns = function transformColumns2(innerColumns) {
    return injectSorter(prefixCls.value, innerColumns, mergedSorterStates.value, triggerSorter, sortDirections.value, tableLocale.value, showSorterTooltip.value);
  };
  var sorters = computed(function() {
    return generateSorterInfo(mergedSorterStates.value);
  });
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, sorters];
}
var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
const FilterFilledSvg = FilterFilled$2;
function _objectSpread$e(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$e(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$e(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FilterFilled = function FilterFilled2(props3, context2) {
  var p2 = _objectSpread$e({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$e({}, p2, {
    "icon": FilterFilledSvg
  }), null);
};
FilterFilled.displayName = "FilterFilled";
FilterFilled.inheritAttrs = false;
const FilterFilled$1 = FilterFilled;
var FilterDropdownMenuWrapper = function FilterDropdownMenuWrapper2(_props, _ref) {
  var _slots$default;
  var slots = _ref.slots;
  return createVNode("div", {
    "onClick": function onClick2(e2) {
      return e2.stopPropagation();
    }
  }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
};
const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
const FilterSearch = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "FilterSearch",
  inheritAttrs: false,
  props: {
    value: String,
    onChange: Function,
    filterSearch: Boolean,
    tablePrefixCls: String,
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup: function setup191(props3) {
    return function() {
      var value = props3.value, onChange3 = props3.onChange, filterSearch = props3.filterSearch, tablePrefixCls = props3.tablePrefixCls, locale2 = props3.locale;
      if (!filterSearch) {
        return null;
      }
      return createVNode("div", {
        "class": "".concat(tablePrefixCls, "-filter-dropdown-search")
      }, [createVNode(Input$1, {
        "placeholder": locale2.filterSearchPlaceholder,
        "onChange": onChange3,
        "value": value,
        "htmlSize": 1,
        "class": "".concat(tablePrefixCls, "-filter-dropdown-search-input")
      }, {
        prefix: function prefix() {
          return createVNode(SearchOutlined$1, null, null);
        }
      })]);
    };
  }
});
var _excluded$a = ["motion", "motionNodes", "motionType", "active", "eventKey"];
const MotionTreeNode = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: false,
  props: _objectSpread2$1(_objectSpread2$1({}, treeNodeProps), {}, {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  slots: ["title", "icon", "switcherIcon", "checkable"],
  setup: function setup192(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var visible = ref(true);
    var context2 = useInjectTreeContext();
    var motionedRef = ref(false);
    var transitionProps = computed(function() {
      if (props3.motion) {
        return props3.motion;
      } else {
        return collapseMotion$1();
      }
    });
    var onMotionEnd = function onMotionEnd2(node, type4) {
      if (type4 === "appear") {
        var _transitionProps$valu, _transitionProps$valu2;
        (_transitionProps$valu = transitionProps.value) === null || _transitionProps$valu === void 0 ? void 0 : (_transitionProps$valu2 = _transitionProps$valu.onAfterEnter) === null || _transitionProps$valu2 === void 0 ? void 0 : _transitionProps$valu2.call(_transitionProps$valu, node);
      } else if (type4 === "leave") {
        var _transitionProps$valu3, _transitionProps$valu4;
        (_transitionProps$valu3 = transitionProps.value) === null || _transitionProps$valu3 === void 0 ? void 0 : (_transitionProps$valu4 = _transitionProps$valu3.onAfterLeave) === null || _transitionProps$valu4 === void 0 ? void 0 : _transitionProps$valu4.call(_transitionProps$valu3, node);
      }
      if (!motionedRef.value) {
        props3.onMotionEnd();
      }
      motionedRef.value = true;
    };
    watch(function() {
      return props3.motionNodes;
    }, function() {
      if (props3.motionNodes && props3.motionType === "hide" && visible.value) {
        nextTick(function() {
          visible.value = false;
        });
      }
    }, {
      immediate: true,
      flush: "post"
    });
    onMounted(function() {
      props3.motionNodes && props3.onMotionStart();
    });
    onBeforeUnmount(function() {
      props3.motionNodes && onMotionEnd();
    });
    return function() {
      props3.motion;
      var motionNodes = props3.motionNodes, motionType = props3.motionType, active = props3.active, eventKey = props3.eventKey, otherProps = _objectWithoutProperties$2(props3, _excluded$a);
      if (motionNodes) {
        return createVNode(Transition$1, _objectSpread2$1(_objectSpread2$1({}, transitionProps.value), {}, {
          "appear": motionType === "show",
          "onAfterAppear": function onAfterAppear(node) {
            return onMotionEnd(node, "appear");
          },
          "onAfterLeave": function onAfterLeave(node) {
            return onMotionEnd(node, "leave");
          }
        }), {
          default: function _default9() {
            return [withDirectives(createVNode("div", {
              "class": "".concat(context2.value.prefixCls, "-treenode-motion")
            }, [motionNodes.map(function(treeNode) {
              var restProps = _extends$1({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd2 = treeNode.isEnd;
              delete restProps.children;
              return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
                "title": title,
                "active": active,
                "data": treeNode.data,
                "key": key2,
                "eventKey": key2,
                "isStart": isStart,
                "isEnd": isEnd2
              }), slots);
            })]), [[vShow, visible.value]])];
          }
        });
      }
      return createVNode(VcTreeNode, _objectSpread2$1(_objectSpread2$1({
        "domRef": ref,
        "class": attrs.class,
        "style": attrs.style
      }, otherProps), {}, {
        "active": active,
        "eventKey": eventKey
      }), slots);
    };
  }
});
function findExpandedKeys() {
  var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var prevLen = prev2.length;
  var nextLen = next2.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find2(shorter, longer) {
    var cache = /* @__PURE__ */ new Map();
    shorter.forEach(function(key2) {
      cache.set(key2, true);
    });
    var keys2 = longer.filter(function(key2) {
      return !cache.has(key2);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find2(prev2, next2)
    };
  }
  return {
    add: false,
    key: find2(next2, prev2)
  };
}
function getExpandRange(shorter, longer, key2) {
  var shorterStartIndex = shorter.findIndex(function(item) {
    return item.key === key2;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function(item) {
    return item.key === key2;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(item) {
      return item.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var _excluded$9 = ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"];
var HIDDEN_STYLE$1 = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop$2 = function noop() {
};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight2) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight2) + 1);
}
function itemKey(item) {
  var key2 = item.key, pos2 = item.pos;
  return getKey2(key2, pos2);
}
function getAccessibilityPath(item) {
  var path2 = String(item.key);
  var current2 = item;
  while (current2.parent) {
    current2 = current2.parent;
    path2 = "".concat(current2.key, " > ").concat(path2);
  }
  return path2;
}
const NodeList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: false,
  props: nodeListProps,
  setup: function setup193(props3, _ref) {
    var expose = _ref.expose, attrs = _ref.attrs;
    var listRef = ref();
    var indentMeasurerRef = ref();
    var _useInjectKeysState = useInjectKeysState(), expandedKeys = _useInjectKeysState.expandedKeys, flattenNodes = _useInjectKeysState.flattenNodes;
    expose({
      scrollTo: function scrollTo2(scroll) {
        listRef.value.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.value.offsetWidth;
      }
    });
    var transitionData = shallowRef(flattenNodes.value);
    var transitionRange = shallowRef([]);
    var motionType = ref(null);
    function onMotionEnd() {
      transitionData.value = flattenNodes.value;
      transitionRange.value = [];
      motionType.value = null;
      props3.onListChangeEnd();
    }
    var context2 = useInjectTreeContext();
    watch([function() {
      return expandedKeys.value.slice();
    }, flattenNodes], function(_ref2, _ref3) {
      var _ref4 = _slicedToArray$2(_ref2, 2), expandedKeys2 = _ref4[0], data9 = _ref4[1];
      var _ref5 = _slicedToArray$2(_ref3, 2), prevExpandedKeys = _ref5[0], prevData = _ref5[1];
      var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys2);
      if (diffExpanded.key !== null) {
        var virtual = props3.virtual, height = props3.height, itemHeight2 = props3.itemHeight;
        if (diffExpanded.add) {
          var keyIndex = prevData.findIndex(function(_ref6) {
            var key2 = _ref6.key;
            return key2 === diffExpanded.key;
          });
          var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data9, diffExpanded.key), virtual, height, itemHeight2);
          var newTransitionData = prevData.slice();
          newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
          transitionData.value = newTransitionData;
          transitionRange.value = rangeNodes;
          motionType.value = "show";
        } else {
          var _keyIndex = data9.findIndex(function(_ref7) {
            var key2 = _ref7.key;
            return key2 === diffExpanded.key;
          });
          var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data9, prevData, diffExpanded.key), virtual, height, itemHeight2);
          var _newTransitionData = data9.slice();
          _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
          transitionData.value = _newTransitionData;
          transitionRange.value = _rangeNodes;
          motionType.value = "hide";
        }
      } else if (prevData !== data9) {
        transitionData.value = data9;
      }
    });
    watch(function() {
      return context2.value.dragging;
    }, function(dragging) {
      if (!dragging) {
        onMotionEnd();
      }
    });
    var mergedData = computed(function() {
      return props3.motion === void 0 ? transitionData.value : flattenNodes.value;
    });
    var onActiveChange = function onActiveChange2() {
      props3.onActiveChange(null);
    };
    return function() {
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), prefixCls = _props$attrs.prefixCls;
      _props$attrs.selectable;
      _props$attrs.checkable;
      var disabled = _props$attrs.disabled, motion = _props$attrs.motion, height = _props$attrs.height, itemHeight2 = _props$attrs.itemHeight, virtual = _props$attrs.virtual, focusable = _props$attrs.focusable, activeItem = _props$attrs.activeItem, focused = _props$attrs.focused, tabindex = _props$attrs.tabindex, onKeydown = _props$attrs.onKeydown, onFocus2 = _props$attrs.onFocus, onBlur2 = _props$attrs.onBlur, onListChangeStart = _props$attrs.onListChangeStart;
      _props$attrs.onListChangeEnd;
      var domProps = _objectWithoutProperties$2(_props$attrs, _excluded$9);
      return createVNode(Fragment, null, [focused && activeItem && createVNode("span", {
        "style": HIDDEN_STYLE$1,
        "aria-live": "assertive"
      }, [getAccessibilityPath(activeItem)]), createVNode("div", null, [createVNode("input", {
        "style": HIDDEN_STYLE$1,
        "disabled": focusable === false || disabled,
        "tabindex": focusable !== false ? tabindex : null,
        "onKeydown": onKeydown,
        "onFocus": onFocus2,
        "onBlur": onBlur2,
        "value": "",
        "onChange": noop$2,
        "aria-label": "for screen reader"
      }, null)]), createVNode("div", {
        "class": "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        "style": {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-indent")
      }, [createVNode("div", {
        "ref": indentMeasurerRef,
        "class": "".concat(prefixCls, "-indent-unit")
      }, null)])]), createVNode(List$4, _objectSpread2$1(_objectSpread2$1({}, omit$2(domProps, ["onActiveChange"])), {}, {
        "data": mergedData.value,
        "itemKey": itemKey,
        "height": height,
        "fullHeight": false,
        "virtual": virtual,
        "itemHeight": itemHeight2,
        "prefixCls": "".concat(prefixCls, "-list"),
        "ref": listRef,
        "onVisibleChange": function onVisibleChange(originList, fullList) {
          var originSet = new Set(originList);
          var restList = fullList.filter(function(item) {
            return !originSet.has(item);
          });
          if (restList.some(function(item) {
            return itemKey(item) === MOTION_KEY;
          })) {
            onMotionEnd();
          }
        }
      }), {
        default: function _default9(treeNode) {
          var pos2 = treeNode.pos, restProps = _extends$1({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd2 = treeNode.isEnd;
          var mergedKey = getKey2(key2, pos2);
          delete restProps.key;
          delete restProps.children;
          return createVNode(MotionTreeNode, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
            "eventKey": mergedKey,
            "title": title,
            "active": !!activeItem && key2 === activeItem.key,
            "data": treeNode.data,
            "isStart": isStart,
            "isEnd": isEnd2,
            "motion": motion,
            "motionNodes": key2 === MOTION_KEY ? transitionRange.value : null,
            "motionType": motionType.value,
            "onMotionStart": onListChangeStart,
            "onMotionEnd": onMotionEnd,
            "onMousemove": onActiveChange
          }), null);
        }
      })]);
    };
  }
});
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
  var style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "".concat(2, "px")
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = "".concat(-dropLevelOffset * indent, "px");
      break;
    case 1:
      style2.bottom = 0;
      style2.left = "".concat(-dropLevelOffset * indent, "px");
      break;
    case 0:
      style2.bottom = 0;
      style2.left = "".concat(indent);
      break;
  }
  return createVNode("div", {
    "style": style2
  }, null);
}
var MAX_RETRY_TIMES = 10;
const Tree$2 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: false,
  slots: ["checkable", "title", "icon", "titleRender"],
  props: initDefaultProps$1(treeProps$1(), {
    prefixCls: "vc-tree",
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: DropIndicator,
    allowDrop: function allowDrop() {
      return true;
    }
  }),
  setup: function setup194(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var destroyed = ref(false);
    var delayedDragEnterLogic = {};
    var indent = ref();
    var selectedKeys = shallowRef([]);
    var checkedKeys = shallowRef([]);
    var halfCheckedKeys = shallowRef([]);
    var loadedKeys = shallowRef([]);
    var loadingKeys = shallowRef([]);
    var expandedKeys = shallowRef([]);
    var loadingRetryTimes = {};
    var dragState = reactive({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      dragOverNodeKey: null
    });
    var treeData = shallowRef([]);
    watch([function() {
      return props3.treeData;
    }, function() {
      return props3.children;
    }], function() {
      treeData.value = props3.treeData !== void 0 ? toRaw(props3.treeData).slice() : convertTreeToData(toRaw(props3.children));
    }, {
      immediate: true,
      deep: true
    });
    var keyEntities = shallowRef({});
    var focused = ref(false);
    var activeKey = ref(null);
    var listChanging = ref(false);
    var fieldNames = computed(function() {
      return fillFieldNames$1(props3.fieldNames);
    });
    var listRef = ref();
    var dragStartMousePosition = null;
    var dragNode = null;
    var currentMouseOverDroppableNodeKey = null;
    var treeNodeRequiredProps = computed(function() {
      return {
        expandedKeysSet: expandedKeysSet.value,
        selectedKeysSet: selectedKeysSet.value,
        loadedKeysSet: loadedKeysSet.value,
        loadingKeysSet: loadingKeysSet.value,
        checkedKeysSet: checkedKeysSet.value,
        halfCheckedKeysSet: halfCheckedKeysSet.value,
        dragOverNodeKey: dragState.dragOverNodeKey,
        dropPosition: dragState.dropPosition,
        keyEntities: keyEntities.value
      };
    });
    var expandedKeysSet = computed(function() {
      return new Set(expandedKeys.value);
    });
    var selectedKeysSet = computed(function() {
      return new Set(selectedKeys.value);
    });
    var loadedKeysSet = computed(function() {
      return new Set(loadedKeys.value);
    });
    var loadingKeysSet = computed(function() {
      return new Set(loadingKeys.value);
    });
    var checkedKeysSet = computed(function() {
      return new Set(checkedKeys.value);
    });
    var halfCheckedKeysSet = computed(function() {
      return new Set(halfCheckedKeys.value);
    });
    watchEffect(function() {
      if (treeData.value) {
        var entitiesMap = convertDataToEntities(treeData.value, {
          fieldNames: fieldNames.value
        });
        keyEntities.value = _objectSpread2$1(_defineProperty$U({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
    });
    var init = false;
    watch(
      [function() {
        return props3.expandedKeys;
      }, function() {
        return props3.autoExpandParent;
      }, keyEntities],
      function(_ref2, _ref3) {
        var _ref4 = _slicedToArray$2(_ref2, 2);
        _ref4[0];
        var newAutoExpandParent = _ref4[1];
        var _ref5 = _slicedToArray$2(_ref3, 2);
        _ref5[0];
        var oldAutoExpandParent = _ref5[1];
        var keys2 = expandedKeys.value;
        if (props3.expandedKeys !== void 0 || init && newAutoExpandParent !== oldAutoExpandParent) {
          keys2 = props3.autoExpandParent || !init && props3.defaultExpandParent ? conductExpandParent(props3.expandedKeys, keyEntities.value) : props3.expandedKeys;
        } else if (!init && props3.defaultExpandAll) {
          var cloneKeyEntities = _objectSpread2$1({}, keyEntities.value);
          delete cloneKeyEntities[MOTION_KEY];
          keys2 = Object.keys(cloneKeyEntities).map(function(key2) {
            return cloneKeyEntities[key2].key;
          });
        } else if (!init && props3.defaultExpandedKeys) {
          keys2 = props3.autoExpandParent || props3.defaultExpandParent ? conductExpandParent(props3.defaultExpandedKeys, keyEntities.value) : props3.defaultExpandedKeys;
        }
        if (keys2) {
          expandedKeys.value = keys2;
        }
        init = true;
      },
      {
        immediate: true
      }
    );
    var flattenNodes = shallowRef([]);
    watchEffect(function() {
      flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);
    });
    watchEffect(function() {
      if (props3.selectable) {
        if (props3.selectedKeys !== void 0) {
          selectedKeys.value = calcSelectedKeys(props3.selectedKeys, props3);
        } else if (!init && props3.defaultSelectedKeys) {
          selectedKeys.value = calcSelectedKeys(props3.defaultSelectedKeys, props3);
        }
      }
    });
    var _useMaxLevel = useMaxLevel(keyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
    watchEffect(function() {
      if (props3.checkable) {
        var checkedKeyEntity;
        if (props3.checkedKeys !== void 0) {
          checkedKeyEntity = parseCheckedKeys(props3.checkedKeys) || {};
        } else if (!init && props3.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props3.defaultCheckedKeys) || {};
        } else if (treeData.value) {
          checkedKeyEntity = parseCheckedKeys(props3.checkedKeys) || {
            checkedKeys: checkedKeys.value,
            halfCheckedKeys: halfCheckedKeys.value
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, newCheckedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, newHalfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props3.checkStrictly) {
            var conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);
            newCheckedKeys = conductKeys.checkedKeys;
            newHalfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          checkedKeys.value = newCheckedKeys;
          halfCheckedKeys.value = newHalfCheckedKeys;
        }
      }
    });
    watchEffect(function() {
      if (props3.loadedKeys) {
        loadedKeys.value = props3.loadedKeys;
      }
    });
    var resetDragState = function resetDragState2() {
      _extends$1(dragState, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    };
    var scrollTo2 = function scrollTo3(scroll) {
      listRef.value.scrollTo(scroll);
    };
    watch(function() {
      return props3.activeKey;
    }, function() {
      if (props3.activeKey !== void 0) {
        activeKey.value = props3.activeKey;
      }
    }, {
      immediate: true
    });
    watch(activeKey, function(val) {
      nextTick(function() {
        if (val !== null) {
          scrollTo2({
            key: val
          });
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    var setExpandedKeys = function setExpandedKeys2(keys2) {
      if (props3.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
    };
    var cleanDragState = function cleanDragState2() {
      if (dragState.draggingNodeKey !== null) {
        _extends$1(dragState, {
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      dragStartMousePosition = null;
      currentMouseOverDroppableNodeKey = null;
    };
    var onNodeDragEnd = function onNodeDragEnd2(event2, node) {
      var onDragend = props3.onDragend;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      onDragend === null || onDragend === void 0 ? void 0 : onDragend({
        event: event2,
        node: node.eventData
      });
      dragNode = null;
    };
    var onWindowDragEnd = function onWindowDragEnd2(event2) {
      onNodeDragEnd(event2, null);
      window.removeEventListener("dragend", onWindowDragEnd2);
    };
    var onNodeDragStart = function onNodeDragStart2(event2, node) {
      var onDragstart = props3.onDragstart;
      var eventKey = node.eventKey, eventData = node.eventData;
      dragNode = node;
      dragStartMousePosition = {
        x: event2.clientX,
        y: event2.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys.value, eventKey);
      dragState.draggingNodeKey = eventKey;
      dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);
      indent.value = listRef.value.getIndentWidth();
      setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", onWindowDragEnd);
      if (onDragstart) {
        onDragstart({
          event: event2,
          node: eventData
        });
      }
    };
    var onNodeDragEnter = function onNodeDragEnter2(event2, node) {
      var onDragenter = props3.onDragenter, onExpand = props3.onExpand, allowDrop2 = props3.allowDrop, direction = props3.direction;
      var pos2 = node.pos, eventKey = node.eventKey;
      if (currentMouseOverDroppableNodeKey !== eventKey) {
        currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event2, dragNode, node, indent.value, dragStartMousePosition, allowDrop2, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        resetDragState();
        return;
      }
      if (!delayedDragEnterLogic) {
        delayedDragEnterLogic = {};
      }
      Object.keys(delayedDragEnterLogic).forEach(function(key2) {
        clearTimeout(delayedDragEnterLogic[key2]);
      });
      if (dragNode.eventKey !== node.eventKey) {
        delayedDragEnterLogic[pos2] = window.setTimeout(function() {
          if (dragState.draggingNodeKey === null)
            return;
          var newExpandedKeys = expandedKeys.value.slice();
          var entity = keyEntities.value[node.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys.value, node.eventKey);
          }
          setExpandedKeys(newExpandedKeys);
          if (onExpand) {
            onExpand(newExpandedKeys, {
              node: node.eventData,
              expanded: true,
              nativeEvent: event2
            });
          }
        }, 800);
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        resetDragState();
        return;
      }
      _extends$1(dragState, {
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      if (onDragenter) {
        onDragenter({
          event: event2,
          node: node.eventData,
          expandedKeys: expandedKeys.value
        });
      }
    };
    var onNodeDragOver = function onNodeDragOver2(event2, node) {
      var onDragover = props3.onDragover, allowDrop2 = props3.allowDrop, direction = props3.direction;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event2, dragNode, node, indent.value, dragStartMousePosition, allowDrop2, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {
          resetDragState();
        }
      } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {
        _extends$1(dragState, {
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      if (onDragover) {
        onDragover({
          event: event2,
          node: node.eventData
        });
      }
    };
    var onNodeDragLeave = function onNodeDragLeave2(event2, node) {
      if (currentMouseOverDroppableNodeKey === node.eventKey && !event2.currentTarget.contains(event2.relatedTarget)) {
        resetDragState();
        currentMouseOverDroppableNodeKey = null;
      }
      var onDragleave = props3.onDragleave;
      if (onDragleave) {
        onDragleave({
          event: event2,
          node: node.eventData
        });
      }
    };
    var onNodeDrop = function onNodeDrop2(event2, _node) {
      var _activeItem$value;
      var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var dragChildrenKeys = dragState.dragChildrenKeys, dropPosition = dragState.dropPosition, dropTargetKey = dragState.dropTargetKey, dropTargetPos = dragState.dropTargetPos, dropAllowed = dragState.dropAllowed;
      if (!dropAllowed)
        return;
      var onDrop = props3.onDrop;
      dragState.dragOverNodeKey = null;
      cleanDragState();
      if (dropTargetKey === null)
        return;
      var abstractDropNodeProps = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(dropTargetKey, toRaw(treeNodeRequiredProps.value))), {}, {
        active: ((_activeItem$value = activeItem.value) === null || _activeItem$value === void 0 ? void 0 : _activeItem$value.key) === dropTargetKey,
        data: keyEntities.value[dropTargetKey].node
      });
      dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event: event2,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: dragNode ? dragNode.eventData : null,
        dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      dragNode = null;
    };
    var onNodeClick = function onNodeClick2(e2, treeNode) {
      var onClick2 = props3.onClick;
      if (onClick2) {
        onClick2(e2, treeNode);
      }
    };
    var onNodeDoubleClick = function onNodeDoubleClick2(e2, treeNode) {
      var onDblclick = props3.onDblclick;
      if (onDblclick) {
        onDblclick(e2, treeNode);
      }
    };
    var onNodeSelect = function onNodeSelect2(e2, treeNode) {
      var newSelectedKeys = selectedKeys.value;
      var onSelect = props3.onSelect, multiple = props3.multiple;
      var selected = treeNode.selected;
      var key2 = treeNode[fieldNames.value.key];
      var targetSelected = !selected;
      if (!targetSelected) {
        newSelectedKeys = arrDel(newSelectedKeys, key2);
      } else if (!multiple) {
        newSelectedKeys = [key2];
      } else {
        newSelectedKeys = arrAdd(newSelectedKeys, key2);
      }
      var keyEntitiesValue = keyEntities.value;
      var selectedNodes = newSelectedKeys.map(function(selectedKey) {
        var entity = keyEntitiesValue[selectedKey];
        if (!entity)
          return null;
        return entity.node;
      }).filter(function(node) {
        return node;
      });
      if (props3.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
      if (onSelect) {
        onSelect(newSelectedKeys, {
          event: "select",
          selected: targetSelected,
          node: treeNode,
          selectedNodes,
          nativeEvent: e2
        });
      }
    };
    var onNodeCheck = function onNodeCheck2(e2, treeNode, checked) {
      var checkStrictly = props3.checkStrictly, onCheck = props3.onCheck;
      var key2 = treeNode[fieldNames.value.key];
      var checkedObj;
      var eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e2
      };
      var keyEntitiesValue = keyEntities.value;
      if (checkStrictly) {
        var newCheckedKeys = checked ? arrAdd(checkedKeys.value, key2) : arrDel(checkedKeys.value, key2);
        var newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key2);
        checkedObj = {
          checked: newCheckedKeys,
          halfChecked: newHalfCheckedKeys
        };
        eventObj.checkedNodes = newCheckedKeys.map(function(checkedKey) {
          return keyEntitiesValue[checkedKey];
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        });
        if (props3.checkedKeys === void 0) {
          checkedKeys.value = newCheckedKeys;
        }
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(checkedKeys.value), [key2]), true, keyEntitiesValue, maxLevel.value, levelEntities.value), _newCheckedKeys = _conductCheck.checkedKeys, _newHalfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_newCheckedKeys);
          keySet.delete(key2);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _newHalfCheckedKeys
          }, keyEntitiesValue, maxLevel.value, levelEntities.value);
          _newCheckedKeys = _conductCheck2.checkedKeys;
          _newHalfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _newCheckedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _newHalfCheckedKeys;
        _newCheckedKeys.forEach(function(checkedKey) {
          var entity = keyEntitiesValue[checkedKey];
          if (!entity)
            return;
          var node = entity.node, pos2 = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node,
            pos: pos2
          });
        });
        if (props3.checkedKeys === void 0) {
          checkedKeys.value = _newCheckedKeys;
          halfCheckedKeys.value = _newHalfCheckedKeys;
        }
      }
      if (onCheck) {
        onCheck(checkedObj, eventObj);
      }
    };
    var onNodeLoad = function onNodeLoad2(treeNode) {
      var key2 = treeNode[fieldNames.value.key];
      var loadPromise = new Promise(function(resolve2, reject) {
        var loadData = props3.loadData, onLoad = props3.onLoad;
        if (!loadData || loadedKeysSet.value.has(key2) || loadingKeysSet.value.has(key2)) {
          return null;
        }
        var promise = loadData(treeNode);
        promise.then(function() {
          var newLoadedKeys = arrAdd(loadedKeys.value, key2);
          var newLoadingKeys = arrDel(loadingKeys.value, key2);
          if (onLoad) {
            onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
          }
          if (props3.loadedKeys === void 0) {
            loadedKeys.value = newLoadedKeys;
          }
          loadingKeys.value = newLoadingKeys;
          resolve2();
        }).catch(function(e2) {
          var newLoadingKeys = arrDel(loadingKeys.value, key2);
          loadingKeys.value = newLoadingKeys;
          loadingRetryTimes[key2] = (loadingRetryTimes[key2] || 0) + 1;
          if (loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
            var newLoadedKeys = arrAdd(loadedKeys.value, key2);
            if (props3.loadedKeys === void 0) {
              loadedKeys.value = newLoadedKeys;
            }
            resolve2();
          }
          reject(e2);
        });
        loadingKeys.value = arrAdd(loadingKeys.value, key2);
      });
      loadPromise.catch(function() {
      });
      return loadPromise;
    };
    var onNodeMouseEnter = function onNodeMouseEnter2(event2, node) {
      var onMouseenter2 = props3.onMouseenter;
      if (onMouseenter2) {
        onMouseenter2({
          event: event2,
          node
        });
      }
    };
    var onNodeMouseLeave = function onNodeMouseLeave2(event2, node) {
      var onMouseleave2 = props3.onMouseleave;
      if (onMouseleave2) {
        onMouseleave2({
          event: event2,
          node
        });
      }
    };
    var onNodeContextMenu = function onNodeContextMenu2(event2, node) {
      var onRightClick = props3.onRightClick;
      if (onRightClick) {
        event2.preventDefault();
        onRightClick({
          event: event2,
          node
        });
      }
    };
    var onFocus2 = function onFocus3(e2) {
      var onFocus4 = props3.onFocus;
      focused.value = true;
      if (onFocus4) {
        onFocus4(e2);
      }
    };
    var onBlur2 = function onBlur3(e2) {
      var onBlur4 = props3.onBlur;
      focused.value = false;
      onActiveChange(null);
      if (onBlur4) {
        onBlur4(e2);
      }
    };
    var onNodeExpand = function onNodeExpand2(e2, treeNode) {
      var newExpandedKeys = expandedKeys.value;
      var onExpand = props3.onExpand, loadData = props3.loadData;
      var expanded = treeNode.expanded;
      var key2 = treeNode[fieldNames.value.key];
      if (listChanging.value) {
        return;
      }
      newExpandedKeys.indexOf(key2);
      var targetExpanded = !expanded;
      if (targetExpanded) {
        newExpandedKeys = arrAdd(newExpandedKeys, key2);
      } else {
        newExpandedKeys = arrDel(newExpandedKeys, key2);
      }
      setExpandedKeys(newExpandedKeys);
      if (onExpand) {
        onExpand(newExpandedKeys, {
          node: treeNode,
          expanded: targetExpanded,
          nativeEvent: e2
        });
      }
      if (targetExpanded && loadData) {
        var loadPromise = onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function() {
          }).catch(function(e3) {
            var expandedKeysToRestore = arrDel(expandedKeys.value, key2);
            setExpandedKeys(expandedKeysToRestore);
            Promise.reject(e3);
          });
        }
      }
    };
    var onListChangeStart = function onListChangeStart2() {
      listChanging.value = true;
    };
    var onListChangeEnd = function onListChangeEnd2() {
      setTimeout(function() {
        listChanging.value = false;
      });
    };
    var onActiveChange = function onActiveChange2(newActiveKey) {
      var onActiveChange3 = props3.onActiveChange;
      if (activeKey.value === newActiveKey) {
        return;
      }
      if (props3.activeKey !== void 0) {
        activeKey.value = newActiveKey;
      }
      if (newActiveKey !== null) {
        scrollTo2({
          key: newActiveKey
        });
      }
      if (onActiveChange3) {
        onActiveChange3(newActiveKey);
      }
    };
    var activeItem = computed(function() {
      if (activeKey.value === null) {
        return null;
      }
      return flattenNodes.value.find(function(_ref6) {
        var key2 = _ref6.key;
        return key2 === activeKey.value;
      }) || null;
    });
    var offsetActiveKey = function offsetActiveKey2(offset3) {
      var index2 = flattenNodes.value.findIndex(function(_ref7) {
        var key3 = _ref7.key;
        return key3 === activeKey.value;
      });
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.value.length;
      }
      index2 = (index2 + offset3 + flattenNodes.value.length) % flattenNodes.value.length;
      var item = flattenNodes.value[index2];
      if (item) {
        var key2 = item.key;
        onActiveChange(key2);
      } else {
        onActiveChange(null);
      }
    };
    var activeItemEventNode = computed(function() {
      return convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {}, {
        data: activeItem.value.data,
        active: true
      }));
    });
    var onKeydown = function onKeydown2(event2) {
      var onKeydown3 = props3.onKeydown, checkable = props3.checkable, selectable = props3.selectable;
      switch (event2.which) {
        case KeyCode$1.UP: {
          offsetActiveKey(-1);
          event2.preventDefault();
          break;
        }
        case KeyCode$1.DOWN: {
          offsetActiveKey(1);
          event2.preventDefault();
          break;
        }
      }
      var item = activeItem.value;
      if (item && item.data) {
        var expandable = item.data.isLeaf === false || !!(item.data.children || []).length;
        var eventNode = activeItemEventNode.value;
        switch (event2.which) {
          case KeyCode$1.LEFT: {
            if (expandable && expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.parent) {
              onActiveChange(item.parent.key);
            }
            event2.preventDefault();
            break;
          }
          case KeyCode$1.RIGHT: {
            if (expandable && !expandedKeysSet.value.has(activeKey.value)) {
              onNodeExpand({}, eventNode);
            } else if (item.children && item.children.length) {
              onActiveChange(item.children[0].key);
            }
            event2.preventDefault();
            break;
          }
          case KeyCode$1.ENTER:
          case KeyCode$1.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      if (onKeydown3) {
        onKeydown3(event2);
      }
    };
    expose({
      onNodeExpand,
      scrollTo: scrollTo2,
      onKeydown,
      selectedKeys: computed(function() {
        return selectedKeys.value;
      }),
      checkedKeys: computed(function() {
        return checkedKeys.value;
      }),
      halfCheckedKeys: computed(function() {
        return halfCheckedKeys.value;
      }),
      loadedKeys: computed(function() {
        return loadedKeys.value;
      }),
      loadingKeys: computed(function() {
        return loadingKeys.value;
      }),
      expandedKeys: computed(function() {
        return expandedKeys.value;
      })
    });
    onUnmounted(function() {
      window.removeEventListener("dragend", onWindowDragEnd);
      destroyed.value = true;
    });
    useProvideKeysState({
      expandedKeys,
      selectedKeys,
      loadedKeys,
      loadingKeys,
      checkedKeys,
      halfCheckedKeys,
      expandedKeysSet,
      selectedKeysSet,
      loadedKeysSet,
      loadingKeysSet,
      checkedKeysSet,
      halfCheckedKeysSet,
      flattenNodes
    });
    return function() {
      var _classNames;
      var draggingNodeKey = dragState.draggingNodeKey, dropLevelOffset = dragState.dropLevelOffset, dropContainerKey = dragState.dropContainerKey, dropTargetKey = dragState.dropTargetKey, dropPosition = dragState.dropPosition, dragOverNodeKey = dragState.dragOverNodeKey;
      var prefixCls = props3.prefixCls, showLine = props3.showLine, focusable = props3.focusable, _props$tabindex = props3.tabindex, tabindex = _props$tabindex === void 0 ? 0 : _props$tabindex, selectable = props3.selectable, showIcon = props3.showIcon, _props$icon = props3.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, switcherIcon = props3.switcherIcon, draggable = props3.draggable, checkable = props3.checkable, checkStrictly = props3.checkStrictly, disabled = props3.disabled, motion = props3.motion, loadData = props3.loadData, filterTreeNode = props3.filterTreeNode, height = props3.height, itemHeight2 = props3.itemHeight, virtual = props3.virtual, dropIndicatorRender2 = props3.dropIndicatorRender, onContextmenu2 = props3.onContextmenu, onScroll = props3.onScroll, direction = props3.direction;
      var className = attrs.class, style2 = attrs.style;
      var domProps = pickAttrs(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {
        aria: true,
        data: true
      });
      var draggableConfig;
      if (draggable) {
        if (_typeof$3(draggable) === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return createVNode(TreeContext, {
        "value": {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          customCheckable: slots.checkable,
          checkStrictly,
          disabled,
          keyEntities: keyEntities.value,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          dragging: draggingNodeKey !== null,
          indent: indent.value,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          onNodeClick,
          onNodeDoubleClick,
          onNodeExpand,
          onNodeSelect,
          onNodeCheck,
          onNodeLoad,
          onNodeMouseEnter,
          onNodeMouseLeave,
          onNodeContextMenu,
          onNodeDragStart,
          onNodeDragEnter,
          onNodeDragOver,
          onNodeDragLeave,
          onNodeDragEnd,
          onNodeDrop,
          slots
        }
      }, {
        default: function _default9() {
          return [createVNode("div", {
            "role": "tree",
            "class": classNames(prefixCls, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$U(_classNames, "".concat(prefixCls, "-focused"), focused.value), _defineProperty$U(_classNames, "".concat(prefixCls, "-active-focused"), activeKey.value !== null), _classNames))
          }, [createVNode(NodeList, _objectSpread2$1({
            "ref": listRef,
            "prefixCls": prefixCls,
            "style": style2,
            "disabled": disabled,
            "selectable": selectable,
            "checkable": !!checkable,
            "motion": motion,
            "height": height,
            "itemHeight": itemHeight2,
            "virtual": virtual,
            "focusable": focusable,
            "focused": focused.value,
            "tabindex": tabindex,
            "activeItem": activeItem.value,
            "onFocus": onFocus2,
            "onBlur": onBlur2,
            "onKeydown": onKeydown,
            "onActiveChange": onActiveChange,
            "onListChangeStart": onListChangeStart,
            "onListChangeEnd": onListChangeEnd,
            "onContextmenu": onContextmenu2,
            "onScroll": onScroll
          }, domProps), null)])];
        }
      });
    };
  }
});
var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
const FileOutlinedSvg = FileOutlined$2;
function _objectSpread$d(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$d(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$d(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileOutlined = function FileOutlined2(props3, context2) {
  var p2 = _objectSpread$d({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$d({}, p2, {
    "icon": FileOutlinedSvg
  }), null);
};
FileOutlined.displayName = "FileOutlined";
FileOutlined.inheritAttrs = false;
const FileOutlined$1 = FileOutlined;
var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
const MinusSquareOutlinedSvg = MinusSquareOutlined$2;
function _objectSpread$c(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$c(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$c(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var MinusSquareOutlined = function MinusSquareOutlined2(props3, context2) {
  var p2 = _objectSpread$c({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$c({}, p2, {
    "icon": MinusSquareOutlinedSvg
  }), null);
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
MinusSquareOutlined.inheritAttrs = false;
const MinusSquareOutlined$1 = MinusSquareOutlined;
var PlusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
const PlusSquareOutlinedSvg = PlusSquareOutlined$2;
function _objectSpread$b(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$b(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$b(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PlusSquareOutlined = function PlusSquareOutlined2(props3, context2) {
  var p2 = _objectSpread$b({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$b({}, p2, {
    "icon": PlusSquareOutlinedSvg
  }), null);
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
PlusSquareOutlined.inheritAttrs = false;
const PlusSquareOutlined$1 = PlusSquareOutlined;
var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
const CaretDownFilledSvg = CaretDownFilled$2;
function _objectSpread$a(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$a(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$a(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CaretDownFilled = function CaretDownFilled2(props3, context2) {
  var p2 = _objectSpread$a({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$a({}, p2, {
    "icon": CaretDownFilledSvg
  }), null);
};
CaretDownFilled.displayName = "CaretDownFilled";
CaretDownFilled.inheritAttrs = false;
const CaretDownFilled$1 = CaretDownFilled;
function renderSwitcherIcon(prefixCls, switcherIcon, showLine, props3) {
  var isLeaf2 = props3.isLeaf, expanded = props3.expanded, loading = props3.loading;
  var icon = switcherIcon;
  if (loading) {
    return createVNode(LoadingOutlined$1, {
      "class": "".concat(prefixCls, "-switcher-loading-icon")
    }, null);
  }
  var showLeafIcon;
  if (showLine && _typeof$3(showLine) === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  var defaultIcon = null;
  var switcherCls = "".concat(prefixCls, "-switcher-icon");
  if (isLeaf2) {
    if (showLine) {
      if (_typeof$3(showLine) === "object" && !showLeafIcon) {
        defaultIcon = createVNode("span", {
          "class": "".concat(prefixCls, "-switcher-leaf-line")
        }, null);
      } else {
        defaultIcon = createVNode(FileOutlined$1, {
          "class": "".concat(prefixCls, "-switcher-line-icon")
        }, null);
      }
    }
    return defaultIcon;
  } else {
    defaultIcon = createVNode(CaretDownFilled$1, {
      "class": switcherCls
    }, null);
    if (showLine) {
      defaultIcon = expanded ? createVNode(MinusSquareOutlined$1, {
        "class": "".concat(prefixCls, "-switcher-line-icon")
      }, null) : createVNode(PlusSquareOutlined$1, {
        "class": "".concat(prefixCls, "-switcher-line-icon")
      }, null);
    }
  }
  if (typeof switcherIcon === "function") {
    icon = switcherIcon(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
      defaultIcon,
      switcherCls
    }));
  } else if (isValidElement(icon)) {
    icon = cloneVNode(icon, {
      class: switcherCls
    });
  }
  return icon || defaultIcon;
}
var offset2 = 4;
function dropIndicatorRender(props3) {
  var _style;
  var dropPosition = props3.dropPosition, dropLevelOffset = props3.dropLevelOffset, prefixCls = props3.prefixCls, indent = props3.indent, _props$direction = props3.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction;
  var startPosition = direction === "ltr" ? "left" : "right";
  var endPosition = direction === "ltr" ? "right" : "left";
  var style2 = (_style = {}, _defineProperty$U(_style, startPosition, "".concat(-dropLevelOffset * indent + offset2, "px")), _defineProperty$U(_style, endPosition, 0), _style);
  switch (dropPosition) {
    case -1:
      style2.top = "".concat(-3, "px");
      break;
    case 1:
      style2.bottom = "".concat(-3, "px");
      break;
    default:
      style2.bottom = "".concat(-3, "px");
      style2[startPosition] = "".concat(indent + offset2, "px");
      break;
  }
  return createVNode("div", {
    "style": style2,
    "class": "".concat(prefixCls, "-drop-indicator")
  }, null);
}
var treeProps2 = function treeProps3() {
  var baseTreeProps = treeProps$1();
  return _objectSpread2$1(_objectSpread2$1({}, baseTreeProps), {}, {
    showLine: {
      type: [Boolean, Object],
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    autoExpandParent: {
      type: Boolean,
      default: void 0
    },
    checkStrictly: {
      type: Boolean,
      default: void 0
    },
    checkable: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    defaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    defaultExpandParent: {
      type: Boolean,
      default: void 0
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    checkedKeys: {
      type: [Array, Object]
    },
    defaultCheckedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectable: {
      type: Boolean,
      default: void 0
    },
    loadedKeys: {
      type: Array
    },
    draggable: {
      type: Boolean,
      default: void 0
    },
    showIcon: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: Function
    },
    switcherIcon: PropTypes$1.any,
    prefixCls: String,
    replaceFields: {
      type: Object
    },
    blockNode: {
      type: Boolean,
      default: void 0
    },
    openAnimation: PropTypes$1.any,
    onDoubleclick: baseTreeProps.onDblclick,
    "onUpdate:selectedKeys": Function,
    "onUpdate:checkedKeys": Function,
    "onUpdate:expandedKeys": Function
  });
};
const Tree$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATree",
  inheritAttrs: false,
  props: initDefaultProps$1(treeProps2(), {
    checkable: false,
    selectable: true,
    showIcon: false,
    blockNode: false
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  setup: function setup195(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, emit = _ref.emit, slots = _ref.slots;
    warning$3(!(props3.treeData === void 0 && slots.default));
    var _useConfigInject = useConfigInject("tree", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction, virtual = _useConfigInject.virtual;
    var treeRef = ref();
    var scrollTo2 = function scrollTo3(scroll) {
      var _treeRef$value;
      (_treeRef$value = treeRef.value) === null || _treeRef$value === void 0 ? void 0 : _treeRef$value.scrollTo(scroll);
    };
    expose({
      treeRef,
      onNodeExpand: function onNodeExpand() {
        var _treeRef$value2;
        for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
          args2[_key] = arguments[_key];
        }
        (_treeRef$value2 = treeRef.value) === null || _treeRef$value2 === void 0 ? void 0 : _treeRef$value2.onNodeExpand.apply(_treeRef$value2, args2);
      },
      scrollTo: scrollTo2,
      selectedKeys: computed(function() {
        var _treeRef$value3;
        return (_treeRef$value3 = treeRef.value) === null || _treeRef$value3 === void 0 ? void 0 : _treeRef$value3.selectedKeys;
      }),
      checkedKeys: computed(function() {
        var _treeRef$value4;
        return (_treeRef$value4 = treeRef.value) === null || _treeRef$value4 === void 0 ? void 0 : _treeRef$value4.checkedKeys;
      }),
      halfCheckedKeys: computed(function() {
        var _treeRef$value5;
        return (_treeRef$value5 = treeRef.value) === null || _treeRef$value5 === void 0 ? void 0 : _treeRef$value5.halfCheckedKeys;
      }),
      loadedKeys: computed(function() {
        var _treeRef$value6;
        return (_treeRef$value6 = treeRef.value) === null || _treeRef$value6 === void 0 ? void 0 : _treeRef$value6.loadedKeys;
      }),
      loadingKeys: computed(function() {
        var _treeRef$value7;
        return (_treeRef$value7 = treeRef.value) === null || _treeRef$value7 === void 0 ? void 0 : _treeRef$value7.loadingKeys;
      }),
      expandedKeys: computed(function() {
        var _treeRef$value8;
        return (_treeRef$value8 = treeRef.value) === null || _treeRef$value8 === void 0 ? void 0 : _treeRef$value8.expandedKeys;
      })
    });
    watchEffect(function() {
      devWarning(props3.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    var handleCheck = function handleCheck2(checkedObjOrKeys, eventObj) {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    var handleExpand = function handleExpand2(expandedKeys, eventObj) {
      emit("update:expandedKeys", expandedKeys);
      emit("expand", expandedKeys, eventObj);
    };
    var handleSelect = function handleSelect2(selectedKeys, eventObj) {
      emit("update:selectedKeys", selectedKeys);
      emit("select", selectedKeys, eventObj);
    };
    return function() {
      var _classNames;
      var showIcon = props3.showIcon, showLine = props3.showLine, _props$switcherIcon = props3.switcherIcon, _switcherIcon = _props$switcherIcon === void 0 ? slots.switcherIcon : _props$switcherIcon, _props$icon = props3.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, blockNode = props3.blockNode, checkable = props3.checkable, selectable = props3.selectable, _props$fieldNames = props3.fieldNames, fieldNames = _props$fieldNames === void 0 ? props3.replaceFields : _props$fieldNames, _props$motion = props3.motion, motion = _props$motion === void 0 ? props3.openAnimation : _props$motion, _props$itemHeight = props3.itemHeight, itemHeight2 = _props$itemHeight === void 0 ? 28 : _props$itemHeight, onDoubleclick = props3.onDoubleclick, onDblclick = props3.onDblclick;
      var newProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$2(props3, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {}, {
        showLine: Boolean(showLine),
        dropIndicatorRender,
        fieldNames,
        icon,
        itemHeight: itemHeight2
      });
      var children = slots.default ? filterEmpty(slots.default()) : void 0;
      return createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({}, newProps), {}, {
        "virtual": virtual.value,
        "motion": motion,
        "ref": treeRef,
        "prefixCls": prefixCls.value,
        "class": classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-icon-hide"), !showIcon), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-block-node"), blockNode), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-unselectable"), !selectable), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames), attrs.class),
        "direction": direction.value,
        "checkable": checkable,
        "selectable": selectable,
        "switcherIcon": function switcherIcon(nodeProps) {
          return renderSwitcherIcon(prefixCls.value, _switcherIcon, showLine, nodeProps);
        },
        "onCheck": handleCheck,
        "onExpand": handleExpand,
        "onSelect": handleSelect,
        "onDblclick": onDblclick || onDoubleclick,
        "children": children
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        checkable: function checkable2() {
          return createVNode("span", {
            "class": "".concat(prefixCls.value, "-checkbox-inner")
          }, null);
        }
      }));
    };
  }
});
var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
const FolderOpenOutlinedSvg = FolderOpenOutlined$2;
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$9(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$9(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOpenOutlined = function FolderOpenOutlined2(props3, context2) {
  var p2 = _objectSpread$9({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$9({}, p2, {
    "icon": FolderOpenOutlinedSvg
  }), null);
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
FolderOpenOutlined.inheritAttrs = false;
const FolderOpenOutlined$1 = FolderOpenOutlined;
var FolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
const FolderOutlinedSvg = FolderOutlined$2;
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$8(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$8(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FolderOutlined = function FolderOutlined2(props3, context2) {
  var p2 = _objectSpread$8({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$8({}, p2, {
    "icon": FolderOutlinedSvg
  }), null);
};
FolderOutlined.displayName = "FolderOutlined";
FolderOutlined.inheritAttrs = false;
const FolderOutlined$1 = FolderOutlined;
var Record;
(function(Record2) {
  Record2[Record2["None"] = 0] = "None";
  Record2[Record2["Start"] = 1] = "Start";
  Record2[Record2["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, fieldNames, callback) {
  function processNode(dataNode) {
    var key2 = dataNode[fieldNames.key];
    var children = dataNode[fieldNames.children];
    if (callback(key2, dataNode) !== false) {
      traverseNodesKey(children || [], fieldNames, callback);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys(_ref) {
  var treeData = _ref.treeData, expandedKeys = _ref.expandedKeys, startKey = _ref.startKey, endKey = _ref.endKey, _ref$fieldNames = _ref.fieldNames, fieldNames = _ref$fieldNames === void 0 ? {
    title: "title",
    key: "key",
    children: "children"
  } : _ref$fieldNames;
  var keys2 = [];
  var record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key2) {
    return key2 === startKey || key2 === endKey;
  }
  traverseNodesKey(treeData, fieldNames, function(key2) {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key2)) {
      keys2.push(key2);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      keys2.push(key2);
    }
    if (expandedKeys.indexOf(key2) === -1) {
      return false;
    }
    return true;
  });
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
  var restKeys = _toConsumableArray(keys2);
  var nodes = [];
  traverseNodesKey(treeData, fieldNames, function(key2, node) {
    var index2 = restKeys.indexOf(key2);
    if (index2 !== -1) {
      nodes.push(node);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}
var _excluded$8 = ["icon", "blockNode"];
var directoryTreeProps = function directoryTreeProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, treeProps2()), {}, {
    expandAction: {
      type: [Boolean, String]
    }
  });
};
function getIcon(props3) {
  var isLeaf2 = props3.isLeaf, expanded = props3.expanded;
  if (isLeaf2) {
    return createVNode(FileOutlined$1, null, null);
  }
  return expanded ? createVNode(FolderOpenOutlined$1, null, null) : createVNode(FolderOutlined$1, null, null);
}
const DirectoryTree = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ADirectoryTree",
  inheritAttrs: false,
  props: initDefaultProps$1(directoryTreeProps(), {
    showIcon: true,
    expandAction: "click"
  }),
  slots: ["icon", "title", "switcherIcon", "titleRender"],
  setup: function setup196(props3, _ref) {
    var _slots$default;
    var attrs = _ref.attrs, slots = _ref.slots, emit = _ref.emit, expose = _ref.expose;
    var treeData = ref(props3.treeData || convertTreeToData(filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))));
    watch(function() {
      return props3.treeData;
    }, function() {
      treeData.value = props3.treeData;
    });
    onUpdated(function() {
      nextTick(function() {
        if (props3.treeData === void 0 && slots.default) {
          var _slots$default2;
          treeData.value = convertTreeToData(filterEmpty((_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots)));
        }
      });
    });
    var lastSelectedKey = ref();
    var cachedSelectedKeys = ref();
    var fieldNames = computed(function() {
      return fillFieldNames$1(props3.fieldNames);
    });
    var treeRef = ref();
    var scrollTo2 = function scrollTo3(scroll) {
      var _treeRef$value;
      (_treeRef$value = treeRef.value) === null || _treeRef$value === void 0 ? void 0 : _treeRef$value.scrollTo(scroll);
    };
    expose({
      scrollTo: scrollTo2,
      selectedKeys: computed(function() {
        var _treeRef$value2;
        return (_treeRef$value2 = treeRef.value) === null || _treeRef$value2 === void 0 ? void 0 : _treeRef$value2.selectedKeys;
      }),
      checkedKeys: computed(function() {
        var _treeRef$value3;
        return (_treeRef$value3 = treeRef.value) === null || _treeRef$value3 === void 0 ? void 0 : _treeRef$value3.checkedKeys;
      }),
      halfCheckedKeys: computed(function() {
        var _treeRef$value4;
        return (_treeRef$value4 = treeRef.value) === null || _treeRef$value4 === void 0 ? void 0 : _treeRef$value4.halfCheckedKeys;
      }),
      loadedKeys: computed(function() {
        var _treeRef$value5;
        return (_treeRef$value5 = treeRef.value) === null || _treeRef$value5 === void 0 ? void 0 : _treeRef$value5.loadedKeys;
      }),
      loadingKeys: computed(function() {
        var _treeRef$value6;
        return (_treeRef$value6 = treeRef.value) === null || _treeRef$value6 === void 0 ? void 0 : _treeRef$value6.loadingKeys;
      }),
      expandedKeys: computed(function() {
        var _treeRef$value7;
        return (_treeRef$value7 = treeRef.value) === null || _treeRef$value7 === void 0 ? void 0 : _treeRef$value7.expandedKeys;
      })
    });
    var getInitExpandedKeys = function getInitExpandedKeys2() {
      var _convertDataToEntitie = convertDataToEntities(treeData.value, {
        fieldNames: fieldNames.value
      }), keyEntities = _convertDataToEntitie.keyEntities;
      var initExpandedKeys;
      if (props3.defaultExpandAll) {
        initExpandedKeys = Object.keys(keyEntities);
      } else if (props3.defaultExpandParent) {
        initExpandedKeys = conductExpandParent(props3.expandedKeys || props3.defaultExpandedKeys || [], keyEntities);
      } else {
        initExpandedKeys = props3.expandedKeys || props3.defaultExpandedKeys;
      }
      return initExpandedKeys;
    };
    var selectedKeys = ref(props3.selectedKeys || props3.defaultSelectedKeys || []);
    var expandedKeys = ref(getInitExpandedKeys());
    watch(function() {
      return props3.selectedKeys;
    }, function() {
      if (props3.selectedKeys !== void 0) {
        selectedKeys.value = props3.selectedKeys;
      }
    }, {
      immediate: true
    });
    watch(function() {
      return props3.expandedKeys;
    }, function() {
      if (props3.expandedKeys !== void 0) {
        expandedKeys.value = props3.expandedKeys;
      }
    }, {
      immediate: true
    });
    var expandFolderNode = function expandFolderNode2(event2, node) {
      var isLeaf2 = node.isLeaf;
      if (isLeaf2 || event2.shiftKey || event2.metaKey || event2.ctrlKey) {
        return;
      }
      treeRef.value.onNodeExpand(event2, node);
    };
    var onDebounceExpand = debounce(expandFolderNode, 200, {
      leading: true
    });
    var onExpand = function onExpand2(keys2, info) {
      if (props3.expandedKeys === void 0) {
        expandedKeys.value = keys2;
      }
      emit("update:expandedKeys", keys2);
      emit("expand", keys2, info);
    };
    var onClick2 = function onClick3(event2, node) {
      var expandAction = props3.expandAction;
      if (expandAction === "click") {
        onDebounceExpand(event2, node);
      }
      emit("click", event2, node);
    };
    var onDoubleClick = function onDoubleClick2(event2, node) {
      var expandAction = props3.expandAction;
      if (expandAction === "dblclick" || expandAction === "doubleclick") {
        onDebounceExpand(event2, node);
      }
      emit("doubleclick", event2, node);
      emit("dblclick", event2, node);
    };
    var onSelect = function onSelect2(keys2, event2) {
      var multiple = props3.multiple;
      var node = event2.node, nativeEvent = event2.nativeEvent;
      var key2 = node[fieldNames.value.key];
      var newEvent = _objectSpread2$1(_objectSpread2$1({}, event2), {}, {
        selected: true
      });
      var ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
      var shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
      var newSelectedKeys;
      if (multiple && ctrlPick) {
        newSelectedKeys = keys2;
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else if (multiple && shiftPick) {
        newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.value || []), _toConsumableArray(calcRangeKeys({
          treeData: treeData.value,
          expandedKeys: expandedKeys.value,
          startKey: key2,
          endKey: lastSelectedKey.value,
          fieldNames: fieldNames.value
        })))));
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      } else {
        newSelectedKeys = [key2];
        lastSelectedKey.value = key2;
        cachedSelectedKeys.value = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData.value, newSelectedKeys, fieldNames.value);
      }
      emit("update:selectedKeys", newSelectedKeys);
      emit("select", newSelectedKeys, newEvent);
      if (props3.selectedKeys === void 0) {
        selectedKeys.value = newSelectedKeys;
      }
    };
    var onCheck = function onCheck2(checkedObjOrKeys, eventObj) {
      emit("update:checkedKeys", checkedObjOrKeys);
      emit("check", checkedObjOrKeys, eventObj);
    };
    var _useConfigInject = useConfigInject("tree", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    return function() {
      var connectClassName = classNames("".concat(prefixCls.value, "-directory"), _defineProperty$U({}, "".concat(prefixCls.value, "-directory-rtl"), direction.value === "rtl"), attrs.class);
      var _props$icon = props3.icon, icon = _props$icon === void 0 ? slots.icon : _props$icon, _props$blockNode = props3.blockNode, blockNode = _props$blockNode === void 0 ? true : _props$blockNode, otherProps = _objectWithoutProperties$2(props3, _excluded$8);
      return createVNode(Tree$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
        "icon": icon || getIcon,
        "ref": treeRef,
        "blockNode": blockNode
      }, otherProps), {}, {
        "prefixCls": prefixCls.value,
        "class": connectClassName,
        "expandedKeys": expandedKeys.value,
        "selectedKeys": selectedKeys.value,
        "onSelect": onSelect,
        "onClick": onClick2,
        "onDblclick": onDoubleClick,
        "onExpand": onExpand,
        "onCheck": onCheck
      }), slots);
    };
  }
});
var TreeNode$2 = defineComponent(_objectSpread2$1(_objectSpread2$1({}, VcTreeNode), {}, {
  name: "ATreeNode",
  props: treeNodeProps
}));
const Tree = _extends$1(Tree$1, {
  DirectoryTree,
  TreeNode: TreeNode$2,
  install: function install7(app) {
    app.component(Tree$1.name, Tree$1);
    app.component(TreeNode$2.name, TreeNode$2);
    app.component(DirectoryTree.name, DirectoryTree);
    return app;
  }
});
var SubMenu = Menu.SubMenu, MenuItem = Menu.Item;
function hasSubMenu(filters) {
  return filters.some(function(_ref) {
    var children = _ref.children;
    return children && children.length > 0;
  });
}
function searchValueMatched(searchValue, text) {
  if (typeof text === "string" || typeof text === "number") {
    return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  var filters = _ref2.filters, prefixCls = _ref2.prefixCls, filteredKeys = _ref2.filteredKeys, filterMultiple = _ref2.filterMultiple, searchValue = _ref2.searchValue, filterSearch = _ref2.filterSearch;
  return filters.map(function(filter, index2) {
    var key2 = String(filter.value);
    if (filter.children) {
      return createVNode(SubMenu, {
        "key": key2 || index2,
        "title": filter.text,
        "popupClassName": "".concat(prefixCls, "-dropdown-submenu")
      }, {
        default: function _default9() {
          return [renderFilterItems({
            filters: filter.children,
            prefixCls,
            filteredKeys,
            filterMultiple,
            searchValue,
            filterSearch
          })];
        }
      });
    }
    var Component = filterMultiple ? Checkbox$1 : Radio;
    var item = createVNode(MenuItem, {
      "key": filter.value !== void 0 ? key2 : index2
    }, {
      default: function _default9() {
        return [createVNode(Component, {
          "checked": filteredKeys.includes(key2)
        }, null), createVNode("span", null, [filter.text])];
      }
    });
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter) ? item : void 0;
      }
      return searchValueMatched(searchValue, filter.text) ? item : void 0;
    }
    return item;
  });
}
const FilterDropdown = defineComponent({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup: function setup197(props3, _ref3) {
    var slots = _ref3.slots;
    var contextSlots = useInjectSlots();
    var filterMode = computed(function() {
      var _props$filterMode;
      return (_props$filterMode = props3.filterMode) !== null && _props$filterMode !== void 0 ? _props$filterMode : "menu";
    });
    var filterSearch = computed(function() {
      var _props$filterSearch;
      return (_props$filterSearch = props3.filterSearch) !== null && _props$filterSearch !== void 0 ? _props$filterSearch : false;
    });
    var filterDropdownVisible = computed(function() {
      return props3.column.filterDropdownVisible;
    });
    var visible = ref(false);
    var filtered = computed(function() {
      var _props$filterState$fi;
      return !!(props3.filterState && ((_props$filterState$fi = props3.filterState.filteredKeys) !== null && _props$filterState$fi !== void 0 && _props$filterState$fi.length || props3.filterState.forceFiltered));
    });
    var filterFlattenKeys = computed(function() {
      var _props$column;
      return flattenKeys((_props$column = props3.column) === null || _props$column === void 0 ? void 0 : _props$column.filters);
    });
    var filterDropdownRef = computed(function() {
      var _props$column2 = props3.column, filterDropdown = _props$column2.filterDropdown, _props$column2$slots = _props$column2.slots, slots2 = _props$column2$slots === void 0 ? {} : _props$column2$slots, customFilterDropdown = _props$column2.customFilterDropdown;
      return filterDropdown || slots2.filterDropdown && contextSlots.value[slots2.filterDropdown] || customFilterDropdown && contextSlots.value.customFilterDropdown;
    });
    var filterIconRef = computed(function() {
      var _props$column3 = props3.column, filterIcon = _props$column3.filterIcon, _props$column3$slots = _props$column3.slots, slots2 = _props$column3$slots === void 0 ? {} : _props$column3$slots;
      return filterIcon || slots2.filterIcon && contextSlots.value[slots2.filterIcon] || contextSlots.value.customFilterIcon;
    });
    var triggerVisible = function triggerVisible2(newVisible) {
      var _props$column$onFilte, _props$column4;
      visible.value = newVisible;
      (_props$column$onFilte = (_props$column4 = props3.column).onFilterDropdownVisibleChange) === null || _props$column$onFilte === void 0 ? void 0 : _props$column$onFilte.call(_props$column4, newVisible);
    };
    var mergedVisible = computed(function() {
      return typeof filterDropdownVisible.value === "boolean" ? filterDropdownVisible.value : visible.value;
    });
    var propFilteredKeys = computed(function() {
      var _props$filterState;
      return (_props$filterState = props3.filterState) === null || _props$filterState === void 0 ? void 0 : _props$filterState.filteredKeys;
    });
    var filteredKeys = shallowRef([]);
    var onSelectKeys = function onSelectKeys2(_ref4) {
      var selectedKeys = _ref4.selectedKeys;
      filteredKeys.value = selectedKeys;
    };
    var onCheck = function onCheck2(keys2, _ref5) {
      var node = _ref5.node, checked = _ref5.checked;
      if (!props3.filterMultiple) {
        onSelectKeys({
          selectedKeys: checked && node.key ? [node.key] : []
        });
      } else {
        onSelectKeys({
          selectedKeys: keys2
        });
      }
    };
    watch(propFilteredKeys, function() {
      if (!visible.value) {
        return;
      }
      onSelectKeys({
        selectedKeys: propFilteredKeys.value || []
      });
    }, {
      immediate: true
    });
    var openKeys = shallowRef([]);
    var openRef = ref();
    var onOpenChange = function onOpenChange2(keys2) {
      openRef.value = setTimeout(function() {
        openKeys.value = keys2;
      });
    };
    var onMenuClick = function onMenuClick2() {
      clearTimeout(openRef.value);
    };
    onBeforeUnmount(function() {
      clearTimeout(openRef.value);
    });
    var searchValue = ref("");
    var onSearch = function onSearch2(e2) {
      var value = e2.target.value;
      searchValue.value = value;
    };
    watch(visible, function() {
      if (!visible.value) {
        searchValue.value = "";
      }
    });
    var internalTriggerFilter = function internalTriggerFilter2(keys2) {
      var column2 = props3.column, columnKey = props3.columnKey, filterState = props3.filterState;
      var mergedKeys = keys2 && keys2.length ? keys2 : null;
      if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
        return null;
      }
      if (isEqual$1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys)) {
        return null;
      }
      props3.triggerFilter({
        column: column2,
        key: columnKey,
        filteredKeys: mergedKeys
      });
    };
    var onConfirm = function onConfirm2() {
      triggerVisible(false);
      internalTriggerFilter(filteredKeys.value);
    };
    var onReset = function onReset2() {
      var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: false,
        closeDropdown: false
      }, confirm3 = _ref6.confirm, closeDropdown = _ref6.closeDropdown;
      if (confirm3) {
        internalTriggerFilter([]);
      }
      if (closeDropdown) {
        triggerVisible(false);
      }
      searchValue.value = "";
      filteredKeys.value = [];
    };
    var doFilter = function doFilter2() {
      var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: true
      }, closeDropdown = _ref7.closeDropdown;
      if (closeDropdown) {
        triggerVisible(false);
      }
      internalTriggerFilter(filteredKeys.value);
    };
    var onVisibleChange = function onVisibleChange2(newVisible) {
      if (newVisible && propFilteredKeys.value !== void 0) {
        filteredKeys.value = propFilteredKeys.value || [];
      }
      triggerVisible(newVisible);
      if (!newVisible && !filterDropdownRef.value) {
        onConfirm();
      }
    };
    var _useConfigInject = useConfigInject("", props3), direction = _useConfigInject.direction;
    var onCheckAll = function onCheckAll2(e2) {
      if (e2.target.checked) {
        var allFilterKeys = filterFlattenKeys.value;
        filteredKeys.value = allFilterKeys;
      } else {
        filteredKeys.value = [];
      }
    };
    var getTreeData = function getTreeData2(_ref8) {
      var filters = _ref8.filters;
      return (filters || []).map(function(filter, index2) {
        var key2 = String(filter.value);
        var item = {
          title: filter.text,
          key: filter.value !== void 0 ? key2 : index2
        };
        if (filter.children) {
          item.children = getTreeData2({
            filters: filter.children
          });
        }
        return item;
      });
    };
    var treeData = computed(function() {
      return getTreeData({
        filters: props3.column.filters
      });
    });
    var dropdownMenuClass = computed(function() {
      return classNames(_defineProperty$U({}, "".concat(props3.dropdownPrefixCls, "-menu-without-submenu"), !hasSubMenu(props3.column.filters || [])));
    });
    var getFilterComponent = function getFilterComponent2() {
      var selectedKeys = filteredKeys.value;
      var column2 = props3.column, locale2 = props3.locale, tablePrefixCls = props3.tablePrefixCls, filterMultiple = props3.filterMultiple, dropdownPrefixCls = props3.dropdownPrefixCls, getPopupContainer = props3.getPopupContainer, prefixCls = props3.prefixCls;
      if ((column2.filters || []).length === 0) {
        return createVNode(Empty$1, {
          "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
          "description": locale2.filterEmptyText,
          "imageStyle": {
            height: 24
          },
          "style": {
            margin: 0,
            padding: "16px 0"
          }
        }, null);
      }
      if (filterMode.value === "tree") {
        return createVNode(Fragment, null, [createVNode(FilterSearch, {
          "filterSearch": filterSearch.value,
          "value": searchValue.value,
          "onChange": onSearch,
          "tablePrefixCls": tablePrefixCls,
          "locale": locale2
        }, null), createVNode("div", {
          "class": "".concat(tablePrefixCls, "-filter-dropdown-tree")
        }, [filterMultiple ? createVNode(Checkbox$1, {
          "class": "".concat(tablePrefixCls, "-filter-dropdown-checkall"),
          "onChange": onCheckAll,
          "checked": selectedKeys.length === filterFlattenKeys.value.length,
          "indeterminate": selectedKeys.length > 0 && selectedKeys.length < filterFlattenKeys.value.length
        }, {
          default: function _default9() {
            return [locale2.filterCheckall];
          }
        }) : null, createVNode(Tree, {
          "checkable": true,
          "selectable": false,
          "blockNode": true,
          "multiple": filterMultiple,
          "checkStrictly": !filterMultiple,
          "class": "".concat(dropdownPrefixCls, "-menu"),
          "onCheck": onCheck,
          "checkedKeys": selectedKeys,
          "selectedKeys": selectedKeys,
          "showIcon": false,
          "treeData": treeData.value,
          "autoExpandParent": true,
          "defaultExpandAll": true,
          "filterTreeNode": searchValue.value.trim() ? function(node) {
            return searchValueMatched(searchValue.value, node.title);
          } : void 0
        }, null)])]);
      }
      return createVNode(Fragment, null, [createVNode(FilterSearch, {
        "filterSearch": filterSearch.value,
        "value": searchValue.value,
        "onChange": onSearch,
        "tablePrefixCls": tablePrefixCls,
        "locale": locale2
      }, null), createVNode(Menu, {
        "multiple": filterMultiple,
        "prefixCls": "".concat(dropdownPrefixCls, "-menu"),
        "class": dropdownMenuClass.value,
        "onClick": onMenuClick,
        "onSelect": onSelectKeys,
        "onDeselect": onSelectKeys,
        "selectedKeys": selectedKeys,
        "getPopupContainer": getPopupContainer,
        "openKeys": openKeys.value,
        "onOpenChange": onOpenChange
      }, {
        default: function _default9() {
          return renderFilterItems({
            filters: column2.filters || [],
            filterSearch: filterSearch.value,
            prefixCls,
            filteredKeys: filteredKeys.value,
            filterMultiple,
            searchValue: searchValue.value
          });
        }
      })]);
    };
    return function() {
      var _slots$default;
      var tablePrefixCls = props3.tablePrefixCls, prefixCls = props3.prefixCls, column2 = props3.column, dropdownPrefixCls = props3.dropdownPrefixCls, locale2 = props3.locale, getPopupContainer = props3.getPopupContainer;
      var dropdownContent;
      if (typeof filterDropdownRef.value === "function") {
        dropdownContent = filterDropdownRef.value({
          prefixCls: "".concat(dropdownPrefixCls, "-custom"),
          setSelectedKeys: function setSelectedKeys(selectedKeys2) {
            return onSelectKeys({
              selectedKeys: selectedKeys2
            });
          },
          selectedKeys: filteredKeys.value,
          confirm: doFilter,
          clearFilters: onReset,
          filters: column2.filters,
          visible: mergedVisible.value,
          column: column2.__originColumn__
        });
      } else if (filterDropdownRef.value) {
        dropdownContent = filterDropdownRef.value;
      } else {
        var selectedKeys = filteredKeys.value;
        dropdownContent = createVNode(Fragment, null, [getFilterComponent(), createVNode("div", {
          "class": "".concat(prefixCls, "-dropdown-btns")
        }, [createVNode(Button$1, {
          "type": "link",
          "size": "small",
          "disabled": selectedKeys.length === 0,
          "onClick": function onClick2() {
            return onReset();
          }
        }, {
          default: function _default9() {
            return [locale2.filterReset];
          }
        }), createVNode(Button$1, {
          "type": "primary",
          "size": "small",
          "onClick": onConfirm
        }, {
          default: function _default9() {
            return [locale2.filterConfirm];
          }
        })])]);
      }
      var menu = createVNode(FilterDropdownMenuWrapper$1, {
        "class": "".concat(prefixCls, "-dropdown")
      }, {
        default: function _default9() {
          return [dropdownContent];
        }
      });
      var filterIcon;
      if (typeof filterIconRef.value === "function") {
        filterIcon = filterIconRef.value({
          filtered: filtered.value,
          column: column2.__originColumn__
        });
      } else if (filterIconRef.value) {
        filterIcon = filterIconRef.value;
      } else {
        filterIcon = createVNode(FilterFilled$1, null, null);
      }
      return createVNode("div", {
        "class": "".concat(prefixCls, "-column")
      }, [createVNode("span", {
        "class": "".concat(tablePrefixCls, "-column-title")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), createVNode(Dropdown$1, {
        "overlay": menu,
        "trigger": ["click"],
        "visible": mergedVisible.value,
        "onVisibleChange": onVisibleChange,
        "getPopupContainer": getPopupContainer,
        "placement": direction.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: function _default9() {
          return [createVNode("span", {
            "role": "button",
            "tabindex": -1,
            "class": classNames("".concat(prefixCls, "-trigger"), {
              active: filtered.value
            }),
            "onClick": function onClick2(e2) {
              e2.stopPropagation();
            }
          }, [filterIcon])];
        }
      })]);
    };
  }
});
function collectFilterStates(columns, init, pos2) {
  var filterStates = [];
  (columns || []).forEach(function(column2, index2) {
    var _column$slots;
    var columnPos = getColumnPos(index2, pos2);
    var hasFilterDropdown = column2.filterDropdown || (column2 === null || column2 === void 0 ? void 0 : (_column$slots = column2.slots) === null || _column$slots === void 0 ? void 0 : _column$slots.filterDropdown) || column2.customFilterDropdown;
    if (column2.filters || hasFilterDropdown || "onFilter" in column2) {
      if ("filteredValue" in column2) {
        var filteredValues = column2.filteredValue;
        if (!hasFilterDropdown) {
          var _filteredValues$map, _filteredValues;
          filteredValues = (_filteredValues$map = (_filteredValues = filteredValues) === null || _filteredValues === void 0 ? void 0 : _filteredValues.map(String)) !== null && _filteredValues$map !== void 0 ? _filteredValues$map : filteredValues;
        }
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column2.filtered
        });
      } else {
        filterStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
          forceFiltered: column2.filtered
        });
      }
    }
    if ("children" in column2) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos)));
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, triggerFilter, getPopupContainer, locale2, pos2) {
  return columns.map(function(column2, index2) {
    var _column$slots2;
    var columnPos = getColumnPos(index2, pos2);
    var _column$filterMultipl = column2.filterMultiple, filterMultiple = _column$filterMultipl === void 0 ? true : _column$filterMultipl, filterMode = column2.filterMode, filterSearch = column2.filterSearch;
    var newColumn = column2;
    var hasFilterDropdown = column2.filterDropdown || (column2 === null || column2 === void 0 ? void 0 : (_column$slots2 = column2.slots) === null || _column$slots2 === void 0 ? void 0 : _column$slots2.filterDropdown) || column2.customFilterDropdown;
    if (newColumn.filters || hasFilterDropdown) {
      var columnKey = getColumnKey(newColumn, columnPos);
      var filterState = filterStates.find(function(_ref) {
        var key2 = _ref.key;
        return columnKey === key2;
      });
      newColumn = _objectSpread2$1(_objectSpread2$1({}, newColumn), {}, {
        title: function title(renderProps) {
          return createVNode(FilterDropdown, {
            "tablePrefixCls": prefixCls,
            "prefixCls": "".concat(prefixCls, "-filter"),
            "dropdownPrefixCls": dropdownPrefixCls,
            "column": newColumn,
            "columnKey": columnKey,
            "filterState": filterState,
            "filterMultiple": filterMultiple,
            "filterMode": filterMode,
            "filterSearch": filterSearch,
            "triggerFilter": triggerFilter,
            "locale": locale2,
            "getPopupContainer": getPopupContainer
          }, {
            default: function _default9() {
              return [renderColumnTitle(column2.title, renderProps)];
            }
          });
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _objectSpread2$1(_objectSpread2$1({}, newColumn), {}, {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, triggerFilter, getPopupContainer, locale2, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  var keys2 = [];
  (filters || []).forEach(function(_ref2) {
    var value = _ref2.value, children = _ref2.children;
    keys2.push(value);
    if (children) {
      keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys2;
}
function generateFilterInfo(filterStates) {
  var currentFilters = {};
  filterStates.forEach(function(_ref3) {
    var _column$slots3;
    var key2 = _ref3.key, filteredKeys = _ref3.filteredKeys, column2 = _ref3.column;
    var hasFilterDropdown = column2.filterDropdown || (column2 === null || column2 === void 0 ? void 0 : (_column$slots3 = column2.slots) === null || _column$slots3 === void 0 ? void 0 : _column$slots3.filterDropdown) || column2.customFilterDropdown;
    var filters = column2.filters;
    if (hasFilterDropdown) {
      currentFilters[key2] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      var keys2 = flattenKeys(filters);
      currentFilters[key2] = keys2.filter(function(originKey) {
        return filteredKeys.includes(String(originKey));
      });
    } else {
      currentFilters[key2] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data9, filterStates) {
  return filterStates.reduce(function(currentData, filterState) {
    var _filterState$column = filterState.column, onFilter = _filterState$column.onFilter, filters = _filterState$column.filters, filteredKeys = filterState.filteredKeys;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter(function(record) {
        return filteredKeys.some(function(key2) {
          var keys2 = flattenKeys(filters);
          var keyIndex = keys2.findIndex(function(k2) {
            return String(k2) === String(key2);
          });
          var realKey = keyIndex !== -1 ? keys2[keyIndex] : key2;
          return onFilter(realKey, record);
        });
      });
    }
    return currentData;
  }, data9);
}
function useFilter(_ref4) {
  var prefixCls = _ref4.prefixCls, dropdownPrefixCls = _ref4.dropdownPrefixCls, mergedColumns = _ref4.mergedColumns, locale2 = _ref4.locale, onFilterChange = _ref4.onFilterChange, getPopupContainer = _ref4.getPopupContainer;
  var _useState = useState(collectFilterStates(mergedColumns.value, true)), _useState2 = _slicedToArray$2(_useState, 2), filterStates = _useState2[0], setFilterStates = _useState2[1];
  var mergedFilterStates = computed(function() {
    var collectedStates = collectFilterStates(mergedColumns.value, false);
    var filteredKeysIsNotControlled = collectedStates.every(function(_ref5) {
      var filteredKeys = _ref5.filteredKeys;
      return filteredKeys === void 0;
    });
    if (filteredKeysIsNotControlled) {
      return filterStates.value;
    }
    var filteredKeysIsAllControlled = collectedStates.every(function(_ref6) {
      var filteredKeys = _ref6.filteredKeys;
      return filteredKeys !== void 0;
    });
    devWarning(filteredKeysIsNotControlled || filteredKeysIsAllControlled, "Table", "`FilteredKeys` should all be controlled or not controlled.");
    return collectedStates;
  });
  var filters = computed(function() {
    return generateFilterInfo(mergedFilterStates.value);
  });
  var triggerFilter = function triggerFilter2(filterState) {
    var newFilterStates = mergedFilterStates.value.filter(function(_ref7) {
      var key2 = _ref7.key;
      return key2 !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  var transformColumns = function transformColumns2(innerColumns) {
    return injectFilter(prefixCls.value, dropdownPrefixCls.value, innerColumns, mergedFilterStates.value, triggerFilter, getPopupContainer.value, locale2.value);
  };
  return [transformColumns, mergedFilterStates, filters];
}
function fillTitle(columns, columnTitleProps) {
  return columns.map(function(column2) {
    var cloneColumn = _objectSpread2$1({}, column2);
    cloneColumn.title = renderColumnTitle(cloneColumn.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  var filledColumns = function filledColumns2(columns) {
    return fillTitle(columns, columnTitleProps.value);
  };
  return [filledColumns];
}
function renderExpandIcon(locale2) {
  return function expandIcon(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls, onExpand = _ref.onExpand, record = _ref.record, expanded = _ref.expanded, expandable = _ref.expandable;
    var iconPrefix = "".concat(prefixCls, "-row-expand-icon");
    return createVNode("button", {
      "type": "button",
      "onClick": function onClick2(e2) {
        onExpand(record, e2);
        e2.stopPropagation();
      },
      "class": classNames(iconPrefix, (_classNames = {}, _defineProperty$U(_classNames, "".concat(iconPrefix, "-spaced"), !expandable), _defineProperty$U(_classNames, "".concat(iconPrefix, "-expanded"), expandable && expanded), _defineProperty$U(_classNames, "".concat(iconPrefix, "-collapsed"), expandable && !expanded), _classNames)),
      "aria-label": expanded ? locale2.collapse : locale2.expand
    }, null);
  };
}
function fillSlots(columns, contextSlots) {
  var $slots = contextSlots.value;
  return columns.map(function(column2) {
    var _column$slots;
    if (column2 === SELECTION_COLUMN || column2 === EXPAND_COLUMN)
      return column2;
    var cloneColumn = _objectSpread2$1({}, column2);
    var _cloneColumn$slots = cloneColumn.slots, slots = _cloneColumn$slots === void 0 ? {} : _cloneColumn$slots;
    cloneColumn.__originColumn__ = column2;
    devWarning(!("slots" in cloneColumn), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead.");
    Object.keys(slots).forEach(function(key2) {
      var name2 = slots[key2];
      if (cloneColumn[key2] === void 0 && $slots[name2]) {
        cloneColumn[key2] = $slots[name2];
      }
    });
    if (contextSlots.value.headerCell && !((_column$slots = column2.slots) !== null && _column$slots !== void 0 && _column$slots.title)) {
      cloneColumn.title = renderSlot(contextSlots.value, "headerCell", {
        title: column2.title,
        column: column2
      }, function() {
        return [column2.title];
      });
    }
    if ("children" in cloneColumn) {
      cloneColumn.children = fillSlots(cloneColumn.children, contextSlots);
    }
    return cloneColumn;
  });
}
function useColumns(contextSlots) {
  var filledColumns = function filledColumns2(columns) {
    return fillSlots(columns, contextSlots);
  };
  return [filledColumns];
}
var EMPTY_LIST = [];
var tableProps = function tableProps2() {
  return {
    prefixCls: {
      type: String,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    rowKey: {
      type: [String, Function],
      default: void 0
    },
    tableLayout: {
      type: String,
      default: void 0
    },
    rowClassName: {
      type: [String, Function],
      default: void 0
    },
    title: {
      type: Function,
      default: void 0
    },
    footer: {
      type: Function,
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    showHeader: {
      type: Boolean,
      default: void 0
    },
    components: {
      type: Object,
      default: void 0
    },
    customRow: {
      type: Function,
      default: void 0
    },
    customHeaderRow: {
      type: Function,
      default: void 0
    },
    direction: {
      type: String,
      default: void 0
    },
    expandFixed: {
      type: [Boolean, String],
      default: void 0
    },
    expandColumnWidth: {
      type: Number,
      default: void 0
    },
    expandedRowKeys: {
      type: Array,
      default: void 0
    },
    defaultExpandedRowKeys: {
      type: Array,
      default: void 0
    },
    expandedRowRender: {
      type: Function,
      default: void 0
    },
    expandRowByClick: {
      type: Boolean,
      default: void 0
    },
    expandIcon: {
      type: Function,
      default: void 0
    },
    onExpand: {
      type: Function,
      default: void 0
    },
    onExpandedRowsChange: {
      type: Function,
      default: void 0
    },
    "onUpdate:expandedRowKeys": {
      type: Function,
      default: void 0
    },
    defaultExpandAllRows: {
      type: Boolean,
      default: void 0
    },
    indentSize: {
      type: Number,
      default: void 0
    },
    expandIconColumnIndex: {
      type: Number,
      default: void 0
    },
    showExpandColumn: {
      type: Boolean,
      default: void 0
    },
    expandedRowClassName: {
      type: Function,
      default: void 0
    },
    childrenColumnName: {
      type: String,
      default: void 0
    },
    rowExpandable: {
      type: Function,
      default: void 0
    },
    sticky: {
      type: [Boolean, Object],
      default: void 0
    },
    dropdownPrefixCls: String,
    dataSource: {
      type: Array,
      default: void 0
    },
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    loading: {
      type: [Boolean, Object],
      default: void 0
    },
    size: {
      type: String,
      default: void 0
    },
    bordered: Boolean,
    locale: {
      type: Object,
      default: void 0
    },
    onChange: {
      type: Function,
      default: void 0
    },
    onResizeColumn: {
      type: Function,
      default: void 0
    },
    rowSelection: {
      type: Object,
      default: void 0
    },
    getPopupContainer: {
      type: Function,
      default: void 0
    },
    scroll: {
      type: Object,
      default: void 0
    },
    sortDirections: {
      type: Array,
      default: void 0
    },
    showSorterTooltip: {
      type: [Boolean, Object],
      default: true
    },
    contextSlots: {
      type: Object
    },
    transformCellText: {
      type: Function
    }
  };
};
var InteralTable = defineComponent({
  name: "InteralTable",
  inheritAttrs: false,
  props: initDefaultProps$1(tableProps(), {
    rowKey: "key"
  }),
  slots: ["emptyText", "expandIcon", "title", "footer", "summary", "expandedRowRender", "bodyCell", "headerCell", "customFilterIcon", "customFilterDropdown"],
  setup: function setup198(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose, emit = _ref.emit;
    devWarning(!(typeof props3.rowKey === "function" && props3.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected.");
    useProvideSlots(computed(function() {
      return props3.contextSlots;
    }));
    useProvideTableContext({
      onResizeColumn: function onResizeColumn(w2, col) {
        emit("resizeColumn", w2, col);
      }
    });
    var screens2 = useBreakpoint();
    var mergedColumns = computed(function() {
      var matched = new Set(Object.keys(screens2.value).filter(function(m2) {
        return screens2.value[m2];
      }));
      return props3.columns.filter(function(c2) {
        return !c2.responsive || c2.responsive.some(function(r2) {
          return matched.has(r2);
        });
      });
    });
    var _useConfigInject = useConfigInject("table", props3), mergedSize = _useConfigInject.size, renderEmpty2 = _useConfigInject.renderEmpty, direction = _useConfigInject.direction, prefixCls = _useConfigInject.prefixCls, configProvider = _useConfigInject.configProvider;
    var transformCellText = computed(function() {
      return props3.transformCellText || configProvider.transformCellText;
    });
    var _useLocaleReceiver = useLocaleReceiver("Table", defaultLocale.Table, toRef(props3, "locale")), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), tableLocale = _useLocaleReceiver2[0];
    var rawData = computed(function() {
      return props3.dataSource || EMPTY_LIST;
    });
    var dropdownPrefixCls = computed(function() {
      return configProvider.getPrefixCls("dropdown", props3.dropdownPrefixCls);
    });
    var childrenColumnName = computed(function() {
      return props3.childrenColumnName || "children";
    });
    var expandType = computed(function() {
      if (rawData.value.some(function(item) {
        return item === null || item === void 0 ? void 0 : item[childrenColumnName.value];
      })) {
        return "nest";
      }
      if (props3.expandedRowRender) {
        return "row";
      }
      return null;
    });
    var internalRefs = reactive({
      body: null
    });
    var updateInternalRefs = function updateInternalRefs2(refs) {
      _extends$1(internalRefs, refs);
    };
    var getRowKey = computed(function() {
      if (typeof props3.rowKey === "function") {
        return props3.rowKey;
      }
      return function(record) {
        return record === null || record === void 0 ? void 0 : record[props3.rowKey];
      };
    });
    var _useLazyKVMap = useLazyKVMap(rawData, childrenColumnName, getRowKey), _useLazyKVMap2 = _slicedToArray$2(_useLazyKVMap, 1), getRecordByKey = _useLazyKVMap2[0];
    var changeEventInfo = {};
    var triggerOnChange = function triggerOnChange2(info, action) {
      var reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var pagination = props3.pagination, scroll = props3.scroll, onChange3 = props3.onChange;
      var changeInfo = _objectSpread2$1(_objectSpread2$1({}, changeEventInfo), info);
      if (reset) {
        changeEventInfo.resetPagination();
        if (changeInfo.pagination.current) {
          changeInfo.pagination.current = 1;
        }
        if (pagination && pagination.onChange) {
          pagination.onChange(1, changeInfo.pagination.pageSize);
        }
      }
      if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body) {
        scrollTo$1(0, {
          getContainer: function getContainer4() {
            return internalRefs.body;
          }
        });
      }
      onChange3 === null || onChange3 === void 0 ? void 0 : onChange3(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
        currentDataSource: getFilterData(getSortData(rawData.value, changeInfo.sorterStates, childrenColumnName.value), changeInfo.filterStates),
        action
      });
    };
    var onSorterChange = function onSorterChange2(sorter, sorterStates) {
      triggerOnChange({
        sorter,
        sorterStates
      }, "sort", false);
    };
    var _useSorter = useFilterSorter({
      prefixCls,
      mergedColumns,
      onSorterChange,
      sortDirections: computed(function() {
        return props3.sortDirections || ["ascend", "descend"];
      }),
      tableLocale,
      showSorterTooltip: toRef(props3, "showSorterTooltip")
    }), _useSorter2 = _slicedToArray$2(_useSorter, 4), transformSorterColumns = _useSorter2[0], sortStates = _useSorter2[1], sorterTitleProps = _useSorter2[2], sorters = _useSorter2[3];
    var sortedData = computed(function() {
      return getSortData(rawData.value, sortStates.value, childrenColumnName.value);
    });
    var onFilterChange = function onFilterChange2(filters2, filterStates2) {
      triggerOnChange({
        filters: filters2,
        filterStates: filterStates2
      }, "filter", true);
    };
    var _useFilter = useFilter({
      prefixCls,
      locale: tableLocale,
      dropdownPrefixCls,
      mergedColumns,
      onFilterChange,
      getPopupContainer: toRef(props3, "getPopupContainer")
    }), _useFilter2 = _slicedToArray$2(_useFilter, 3), transformFilterColumns = _useFilter2[0], filterStates = _useFilter2[1], filters = _useFilter2[2];
    var mergedData = computed(function() {
      return getFilterData(sortedData.value, filterStates.value);
    });
    var _useColumns = useColumns(toRef(props3, "contextSlots")), _useColumns2 = _slicedToArray$2(_useColumns, 1), transformBasicColumns = _useColumns2[0];
    var columnTitleProps = computed(function() {
      return _objectSpread2$1({}, sorterTitleProps.value);
    });
    var _useTitleColumns = useTitleColumns(columnTitleProps), _useTitleColumns2 = _slicedToArray$2(_useTitleColumns, 1), transformTitleColumns = _useTitleColumns2[0];
    var onPaginationChange = function onPaginationChange2(current2, pageSize2) {
      triggerOnChange({
        pagination: _objectSpread2$1(_objectSpread2$1({}, changeEventInfo.pagination), {}, {
          current: current2,
          pageSize: pageSize2
        })
      }, "paginate");
    };
    var _usePagination = usePagination(computed(function() {
      return mergedData.value.length;
    }), toRef(props3, "pagination"), onPaginationChange), _usePagination2 = _slicedToArray$2(_usePagination, 2), mergedPagination = _usePagination2[0], resetPagination = _usePagination2[1];
    watchEffect(function() {
      changeEventInfo.sorter = sorters.value;
      changeEventInfo.sorterStates = sortStates.value;
      changeEventInfo.filters = filters.value;
      changeEventInfo.filterStates = filterStates.value;
      changeEventInfo.pagination = props3.pagination === false ? {} : getPaginationParam(props3.pagination, mergedPagination.value);
      changeEventInfo.resetPagination = resetPagination;
    });
    var pageData = computed(function() {
      if (props3.pagination === false || !mergedPagination.value.pageSize) {
        return mergedData.value;
      }
      var _mergedPagination$val = mergedPagination.value, _mergedPagination$val2 = _mergedPagination$val.current, current2 = _mergedPagination$val2 === void 0 ? 1 : _mergedPagination$val2, total3 = _mergedPagination$val.total, _mergedPagination$val3 = _mergedPagination$val.pageSize, pageSize2 = _mergedPagination$val3 === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$val3;
      devWarning(current2 > 0, "Table", "`current` should be positive number.");
      if (mergedData.value.length < total3) {
        if (mergedData.value.length > pageSize2) {
          return mergedData.value.slice((current2 - 1) * pageSize2, current2 * pageSize2);
        }
        return mergedData.value;
      }
      return mergedData.value.slice((current2 - 1) * pageSize2, current2 * pageSize2);
    });
    watchEffect(function() {
      nextTick(function() {
        var _mergedPagination$val4 = mergedPagination.value, total3 = _mergedPagination$val4.total, _mergedPagination$val5 = _mergedPagination$val4.pageSize, pageSize2 = _mergedPagination$val5 === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$val5;
        if (mergedData.value.length < total3) {
          if (mergedData.value.length > pageSize2) {
            devWarning(false, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
          }
        }
      });
    }, {
      flush: "post"
    });
    var expandIconColumnIndex = computed(function() {
      if (props3.showExpandColumn === false)
        return -1;
      if (expandType.value === "nest" && props3.expandIconColumnIndex === void 0) {
        return props3.rowSelection ? 1 : 0;
      } else if (props3.expandIconColumnIndex > 0 && props3.rowSelection) {
        return props3.expandIconColumnIndex - 1;
      }
      return props3.expandIconColumnIndex;
    });
    var rowSelection = ref();
    watch(function() {
      return props3.rowSelection;
    }, function() {
      rowSelection.value = props3.rowSelection ? _objectSpread2$1({}, props3.rowSelection) : props3.rowSelection;
    }, {
      deep: true,
      immediate: true
    });
    var _useSelection = useSelection(rowSelection, {
      prefixCls,
      data: mergedData,
      pageData,
      getRowKey,
      getRecordByKey,
      expandType,
      childrenColumnName,
      locale: tableLocale,
      getPopupContainer: computed(function() {
        return props3.getPopupContainer;
      })
    }), _useSelection2 = _slicedToArray$2(_useSelection, 2), transformSelectionColumns = _useSelection2[0], selectedKeySet = _useSelection2[1];
    var internalRowClassName = function internalRowClassName2(record, index2, indent) {
      var mergedRowClassName;
      var rowClassName = props3.rowClassName;
      if (typeof rowClassName === "function") {
        mergedRowClassName = classNames(rowClassName(record, index2, indent));
      } else {
        mergedRowClassName = classNames(rowClassName);
      }
      return classNames(_defineProperty$U({}, "".concat(prefixCls.value, "-row-selected"), selectedKeySet.value.has(getRowKey.value(record, index2))), mergedRowClassName);
    };
    expose({
      selectedKeySet
    });
    var indentSize = computed(function() {
      return typeof props3.indentSize === "number" ? props3.indentSize : 15;
    });
    var transformColumns = function transformColumns2(innerColumns) {
      var res = transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(transformBasicColumns(innerColumns)))));
      return res;
    };
    return function() {
      var _mergedPagination$val6, _classNames3;
      var _props$expandIcon = props3.expandIcon, expandIcon = _props$expandIcon === void 0 ? slots.expandIcon || renderExpandIcon(tableLocale.value) : _props$expandIcon, pagination = props3.pagination, loading = props3.loading, bordered = props3.bordered;
      var topPaginationNode;
      var bottomPaginationNode;
      if (pagination !== false && (_mergedPagination$val6 = mergedPagination.value) !== null && _mergedPagination$val6 !== void 0 && _mergedPagination$val6.total) {
        var paginationSize;
        if (mergedPagination.value.size) {
          paginationSize = mergedPagination.value.size;
        } else {
          paginationSize = mergedSize.value === "small" || mergedSize.value === "middle" ? "small" : void 0;
        }
        var renderPagination = function renderPagination2(position2) {
          return createVNode(Pagination, _objectSpread2$1(_objectSpread2$1({}, mergedPagination.value), {}, {
            "class": ["".concat(prefixCls.value, "-pagination ").concat(prefixCls.value, "-pagination-").concat(position2), mergedPagination.value.class],
            "size": paginationSize
          }), null);
        };
        var defaultPosition = direction.value === "rtl" ? "left" : "right";
        var position = mergedPagination.value.position;
        if (position !== null && Array.isArray(position)) {
          var topPos = position.find(function(p2) {
            return p2.indexOf("top") !== -1;
          });
          var bottomPos = position.find(function(p2) {
            return p2.indexOf("bottom") !== -1;
          });
          var isDisable = position.every(function(p2) {
            return "".concat(p2) === "none";
          });
          if (!topPos && !bottomPos && !isDisable) {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
          if (topPos) {
            topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
          }
          if (bottomPos) {
            bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
          }
        } else {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
      }
      var spinProps3;
      if (typeof loading === "boolean") {
        spinProps3 = {
          spinning: loading
        };
      } else if (_typeof$3(loading) === "object") {
        spinProps3 = _objectSpread2$1({
          spinning: true
        }, loading);
      }
      var wrapperClassNames = classNames("".concat(prefixCls.value, "-wrapper"), _defineProperty$U({}, "".concat(prefixCls.value, "-wrapper-rtl"), direction.value === "rtl"), attrs.class);
      var tableProps3 = omit$2(props3, ["columns"]);
      return createVNode("div", {
        "class": wrapperClassNames,
        "style": attrs.style
      }, [createVNode(Spin, _objectSpread2$1({
        "spinning": false
      }, spinProps3), {
        default: function _default9() {
          return [topPaginationNode, createVNode(Table$3, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), tableProps3), {}, {
            "expandedRowKeys": props3.expandedRowKeys,
            "defaultExpandedRowKeys": props3.defaultExpandedRowKeys,
            "expandIconColumnIndex": expandIconColumnIndex.value,
            "indentSize": indentSize.value,
            "expandIcon": expandIcon,
            "columns": mergedColumns.value,
            "direction": direction.value,
            "prefixCls": prefixCls.value,
            "class": classNames((_classNames3 = {}, _defineProperty$U(_classNames3, "".concat(prefixCls.value, "-middle"), mergedSize.value === "middle"), _defineProperty$U(_classNames3, "".concat(prefixCls.value, "-small"), mergedSize.value === "small"), _defineProperty$U(_classNames3, "".concat(prefixCls.value, "-bordered"), bordered), _defineProperty$U(_classNames3, "".concat(prefixCls.value, "-empty"), rawData.value.length === 0), _classNames3)),
            "data": pageData.value,
            "rowKey": getRowKey.value,
            "rowClassName": internalRowClassName,
            "internalHooks": INTERNAL_HOOKS,
            "internalRefs": internalRefs,
            "onUpdateInternalRefs": updateInternalRefs,
            "transformColumns": transformColumns,
            "transformCellText": transformCellText.value
          }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
            emptyText: function emptyText() {
              var _slots$emptyText, _props$locale;
              return ((_slots$emptyText = slots.emptyText) === null || _slots$emptyText === void 0 ? void 0 : _slots$emptyText.call(slots)) || ((_props$locale = props3.locale) === null || _props$locale === void 0 ? void 0 : _props$locale.emptyText) || renderEmpty2.value("Table");
            }
          })), bottomPaginationNode];
        }
      })]);
    };
  }
});
var Table$1 = defineComponent({
  name: "ATable",
  inheritAttrs: false,
  setup: function setup199(_props, _ref2) {
    var attrs = _ref2.attrs, slots = _ref2.slots, expose = _ref2.expose;
    var table = ref();
    expose({
      table
    });
    return function() {
      var _slots$default;
      var props3 = attrs;
      var columns = props3.columns || convertChildrenToColumns((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      return createVNode(InteralTable, _objectSpread2$1(_objectSpread2$1({
        "ref": table
      }, attrs), {}, {
        "columns": columns || [],
        "expandedRowRender": slots.expandedRowRender,
        "contextSlots": _objectSpread2$1({}, slots)
      }), slots);
    };
  }
});
const Table$2 = Table$1;
const Column = defineComponent({
  name: "ATableColumn",
  slots: ["title", "filterIcon"],
  render: function render9() {
    return null;
  }
});
const ColumnGroup = defineComponent({
  name: "ATableColumnGroup",
  slots: ["title"],
  __ANT_TABLE_COLUMN_GROUP: true,
  render: function render10() {
    return null;
  }
});
var TableSummaryRow = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryRow), {}, {
  name: "ATableSummaryRow"
}));
var TableSummaryCell = defineComponent(_objectSpread2$1(_objectSpread2$1({}, SummaryCell), {}, {
  name: "ATableSummaryCell"
}));
var TableSummary = _extends$1(FooterComponents, {
  Cell: TableSummaryCell,
  Row: TableSummaryRow,
  name: "ATableSummary"
});
const Table = _extends$1(Table$2, {
  SELECTION_ALL,
  SELECTION_INVERT,
  SELECTION_NONE,
  SELECTION_COLUMN,
  EXPAND_COLUMN,
  Column,
  ColumnGroup,
  Summary: TableSummary,
  install: function install8(app) {
    app.component(TableSummary.name, TableSummary);
    app.component(TableSummaryCell.name, TableSummaryCell);
    app.component(TableSummaryRow.name, TableSummaryRow);
    app.component(Table$2.name, Table$2);
    app.component(Column.name, Column);
    app.component(ColumnGroup.name, ColumnGroup);
    return app;
  }
});
var transferSearchProps = {
  prefixCls: String,
  placeholder: String,
  value: String,
  handleClear: Function,
  disabled: {
    type: Boolean,
    default: void 0
  },
  onChange: Function
};
const Search$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Search",
  inheritAttrs: false,
  props: initDefaultProps$1(transferSearchProps, {
    placeholder: ""
  }),
  emits: ["change"],
  setup: function setup200(props3, _ref) {
    var emit = _ref.emit;
    var handleChange2 = function handleChange3(e2) {
      emit("change", e2);
      if (e2.target.value === "") {
        var _props$handleClear;
        (_props$handleClear = props3.handleClear) === null || _props$handleClear === void 0 ? void 0 : _props$handleClear.call(props3);
      }
    };
    return function() {
      var placeholder = props3.placeholder, value = props3.value, prefixCls = props3.prefixCls, disabled = props3.disabled;
      return createVNode(Input$1, {
        "placeholder": placeholder,
        "class": prefixCls,
        "value": value,
        "onChange": handleChange2,
        "disabled": disabled,
        "allowClear": true
      }, {
        prefix: function prefix() {
          return createVNode(SearchOutlined$1, null, null);
        }
      });
    };
  }
});
var DeleteOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
const DeleteOutlinedSvg = DeleteOutlined$2;
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$7(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$7(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DeleteOutlined = function DeleteOutlined2(props3, context2) {
  var p2 = _objectSpread$7({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$7({}, p2, {
    "icon": DeleteOutlinedSvg
  }), null);
};
DeleteOutlined.displayName = "DeleteOutlined";
DeleteOutlined.inheritAttrs = false;
const DeleteOutlined$1 = DeleteOutlined;
function noop$1() {
}
var transferListItemProps = {
  renderedText: PropTypes$1.any,
  renderedEl: PropTypes$1.any,
  item: PropTypes$1.any,
  checked: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  showRemove: {
    type: Boolean,
    default: void 0
  },
  onClick: Function,
  onRemove: Function
};
const ListItem$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: false,
  props: transferListItemProps,
  emits: ["click", "remove"],
  setup: function setup201(props3, _ref) {
    var emit = _ref.emit;
    return function() {
      var _classNames;
      var renderedText = props3.renderedText, renderedEl = props3.renderedEl, item = props3.item, checked = props3.checked, disabled = props3.disabled, prefixCls = props3.prefixCls, showRemove = props3.showRemove;
      var className = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-content-item"), true), _defineProperty$U(_classNames, "".concat(prefixCls, "-content-item-disabled"), disabled || item.disabled), _classNames));
      var title;
      if (typeof renderedText === "string" || typeof renderedText === "number") {
        title = String(renderedText);
      }
      return createVNode(LocaleReceiver, {
        "componentName": "Transfer",
        "defaultLocale": defaultLocale.Transfer
      }, {
        default: function _default9(transferLocale) {
          var labelNode = createVNode("span", {
            "class": "".concat(prefixCls, "-content-item-text")
          }, [renderedEl]);
          if (showRemove) {
            return createVNode("li", {
              "class": className,
              "title": title
            }, [labelNode, createVNode(TransButton$1, {
              "disabled": disabled || item.disabled,
              "class": "".concat(prefixCls, "-content-item-remove"),
              "aria-label": transferLocale.remove,
              "onClick": function onClick2() {
                emit("remove", item);
              }
            }, {
              default: function _default10() {
                return [createVNode(DeleteOutlined$1, null, null)];
              }
            })]);
          }
          return createVNode("li", {
            "class": className,
            "title": title,
            "onClick": disabled || item.disabled ? noop$1 : function() {
              emit("click", item);
            }
          }, [createVNode(Checkbox$1, {
            "class": "".concat(prefixCls, "-checkbox"),
            "checked": checked,
            "disabled": disabled || item.disabled
          }, null), labelNode]);
        }
      });
    };
  }
});
var transferListBodyProps = {
  prefixCls: String,
  filteredRenderItems: PropTypes$1.array.def([]),
  selectedKeys: PropTypes$1.array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  showRemove: {
    type: Boolean,
    default: void 0
  },
  pagination: PropTypes$1.any,
  onItemSelect: Function,
  onScroll: Function,
  onItemRemove: Function
};
function parsePagination(pagination) {
  if (!pagination) {
    return null;
  }
  var defaultPagination = {
    pageSize: 10
  };
  if (_typeof$3(pagination) === "object") {
    return _objectSpread2$1(_objectSpread2$1({}, defaultPagination), pagination);
  }
  return defaultPagination;
}
var ListBody = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListBody",
  inheritAttrs: false,
  props: transferListBodyProps,
  emits: ["itemSelect", "itemRemove", "scroll"],
  setup: function setup202(props3, _ref) {
    var emit = _ref.emit, expose = _ref.expose;
    var current2 = ref(1);
    var handleItemSelect = function handleItemSelect2(item) {
      var selectedKeys = props3.selectedKeys;
      var checked = selectedKeys.indexOf(item.key) >= 0;
      emit("itemSelect", item.key, !checked);
    };
    var handleItemRemove = function handleItemRemove2(item) {
      emit("itemRemove", [item.key]);
    };
    var handleScroll = function handleScroll2(e2) {
      emit("scroll", e2);
    };
    var mergedPagination = computed(function() {
      return parsePagination(props3.pagination);
    });
    watch([mergedPagination, function() {
      return props3.filteredRenderItems;
    }], function() {
      if (mergedPagination.value) {
        var maxPageCount = Math.ceil(props3.filteredRenderItems.length / mergedPagination.value.pageSize);
        if (current2.value > maxPageCount) {
          current2.value = maxPageCount;
        }
      }
    }, {
      immediate: true
    });
    var items = computed(function() {
      var filteredRenderItems = props3.filteredRenderItems;
      var displayItems = filteredRenderItems;
      if (mergedPagination.value) {
        displayItems = filteredRenderItems.slice((current2.value - 1) * mergedPagination.value.pageSize, current2.value * mergedPagination.value.pageSize);
      }
      return displayItems;
    });
    var onPageChange = function onPageChange2(cur) {
      current2.value = cur;
    };
    expose({
      items
    });
    return function() {
      var prefixCls = props3.prefixCls, filteredRenderItems = props3.filteredRenderItems, selectedKeys = props3.selectedKeys, globalDisabled = props3.disabled, showRemove = props3.showRemove;
      var paginationNode = null;
      if (mergedPagination.value) {
        paginationNode = createVNode(Pagination, {
          "simple": true,
          "size": "small",
          "disabled": globalDisabled,
          "class": "".concat(prefixCls, "-pagination"),
          "total": filteredRenderItems.length,
          "pageSize": mergedPagination.value.pageSize,
          "current": current2.value,
          "onChange": onPageChange
        }, null);
      }
      var itemsList = items.value.map(function(_ref2) {
        var renderedEl = _ref2.renderedEl, renderedText = _ref2.renderedText, item = _ref2.item;
        var disabled = item.disabled;
        var checked = selectedKeys.indexOf(item.key) >= 0;
        return createVNode(ListItem$1, {
          "disabled": globalDisabled || disabled,
          "key": item.key,
          "item": item,
          "renderedText": renderedText,
          "renderedEl": renderedEl,
          "checked": checked,
          "prefixCls": prefixCls,
          "onClick": handleItemSelect,
          "onRemove": handleItemRemove,
          "showRemove": showRemove
        }, null);
      });
      return createVNode(Fragment, null, [createVNode("ul", {
        "class": classNames("".concat(prefixCls, "-content"), _defineProperty$U({}, "".concat(prefixCls, "-content-show-remove"), showRemove)),
        "onScroll": handleScroll
      }, [itemsList]), paginationNode]);
    };
  }
});
const ListBody$1 = ListBody;
var defaultRender2 = function defaultRender3() {
  return null;
};
function isRenderResultPlainObject(result) {
  return result && !isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]";
}
function getEnabledItemKeys(items) {
  return items.filter(function(data9) {
    return !data9.disabled;
  }).map(function(data9) {
    return data9.key;
  });
}
var transferListProps = {
  prefixCls: String,
  dataSource: {
    type: Array,
    default: []
  },
  filter: String,
  filterOption: Function,
  checkedKeys: PropTypes$1.arrayOf(PropTypes$1.string),
  handleFilter: Function,
  handleClear: Function,
  renderItem: Function,
  showSearch: {
    type: Boolean,
    default: false
  },
  searchPlaceholder: String,
  notFoundContent: PropTypes$1.any,
  itemUnit: String,
  itemsUnit: String,
  renderList: PropTypes$1.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  direction: String,
  showSelectAll: {
    type: Boolean,
    default: void 0
  },
  remove: String,
  selectAll: String,
  selectCurrent: String,
  selectInvert: String,
  removeAll: String,
  removeCurrent: String,
  selectAllLabel: PropTypes$1.any,
  showRemove: {
    type: Boolean,
    default: void 0
  },
  pagination: PropTypes$1.any,
  onItemSelect: Function,
  onItemSelectAll: Function,
  onItemRemove: Function,
  onScroll: Function
};
const List = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TransferList",
  inheritAttrs: false,
  props: transferListProps,
  slots: ["footer", "titleText"],
  setup: function setup203(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots;
    var filterValue = ref("");
    var transferNode = ref();
    var defaultListBodyRef = ref();
    var renderListBody = function renderListBody2(renderList2, props4) {
      var bodyContent = renderList2 ? renderList2(props4) : null;
      var customize = !!bodyContent && filterEmpty(bodyContent).length > 0;
      if (!customize) {
        bodyContent = createVNode(ListBody$1, _objectSpread2$1(_objectSpread2$1({}, props4), {}, {
          "ref": defaultListBodyRef
        }), null);
      }
      return {
        customize,
        bodyContent
      };
    };
    var renderItemHtml = function renderItemHtml2(item) {
      var _props$renderItem = props3.renderItem, renderItem = _props$renderItem === void 0 ? defaultRender2 : _props$renderItem;
      var renderResult = renderItem(item);
      var isRenderResultPlain = isRenderResultPlainObject(renderResult);
      return {
        renderedText: isRenderResultPlain ? renderResult.value : renderResult,
        renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
        item
      };
    };
    var filteredItems = ref([]);
    var filteredRenderItems = ref([]);
    watchEffect(function() {
      var fItems = [];
      var fRenderItems = [];
      props3.dataSource.forEach(function(item) {
        var renderedItem = renderItemHtml(item);
        var renderedText = renderedItem.renderedText;
        if (filterValue.value && filterValue.value.trim() && !matchFilter(renderedText, item)) {
          return null;
        }
        fItems.push(item);
        fRenderItems.push(renderedItem);
      });
      filteredItems.value = fItems;
      filteredRenderItems.value = fRenderItems;
    });
    var checkStatus = computed(function() {
      var checkedKeys = props3.checkedKeys;
      if (checkedKeys.length === 0) {
        return "none";
      }
      if (filteredItems.value.every(function(item) {
        return checkedKeys.indexOf(item.key) >= 0 || !!item.disabled;
      })) {
        return "all";
      }
      return "part";
    });
    var enabledItemKeys = computed(function() {
      return getEnabledItemKeys(filteredItems.value);
    });
    var getNewSelectKeys = function getNewSelectKeys2(keys2, unCheckedKeys) {
      return Array.from(new Set([].concat(_toConsumableArray(keys2), _toConsumableArray(props3.checkedKeys)))).filter(function(key2) {
        return unCheckedKeys.indexOf(key2) === -1;
      });
    };
    var getCheckBox = function getCheckBox2(_ref2) {
      var disabled = _ref2.disabled, prefixCls = _ref2.prefixCls;
      var checkedAll = checkStatus.value === "all";
      var checkAllCheckbox = createVNode(Checkbox$1, {
        "disabled": disabled,
        "checked": checkedAll,
        "indeterminate": checkStatus.value === "part",
        "class": "".concat(prefixCls, "-checkbox"),
        "onChange": function onChange3() {
          var keys2 = enabledItemKeys.value;
          props3.onItemSelectAll(getNewSelectKeys(!checkedAll ? keys2 : [], checkedAll ? props3.checkedKeys : []));
        }
      }, null);
      return checkAllCheckbox;
    };
    var handleFilter = function handleFilter2(e2) {
      var _props$handleFilter;
      var filter = e2.target.value;
      filterValue.value = filter;
      (_props$handleFilter = props3.handleFilter) === null || _props$handleFilter === void 0 ? void 0 : _props$handleFilter.call(props3, e2);
    };
    var handleClear = function handleClear2(e2) {
      var _props$handleClear;
      filterValue.value = "";
      (_props$handleClear = props3.handleClear) === null || _props$handleClear === void 0 ? void 0 : _props$handleClear.call(props3, e2);
    };
    var matchFilter = function matchFilter2(text, item) {
      var filterOption2 = props3.filterOption;
      if (filterOption2) {
        return filterOption2(filterValue.value, item);
      }
      return text.indexOf(filterValue.value) >= 0;
    };
    var getSelectAllLabel = function getSelectAllLabel2(selectedCount, totalCount) {
      var itemsUnit = props3.itemsUnit, itemUnit = props3.itemUnit, selectAllLabel = props3.selectAllLabel;
      if (selectAllLabel) {
        return typeof selectAllLabel === "function" ? selectAllLabel({
          selectedCount,
          totalCount
        }) : selectAllLabel;
      }
      var unit = totalCount > 1 ? itemsUnit : itemUnit;
      return createVNode(Fragment, null, [(selectedCount > 0 ? "".concat(selectedCount, "/") : "") + totalCount, createTextVNode(" "), unit]);
    };
    var getListBody = function getListBody2(prefixCls, searchPlaceholder, checkedKeys, renderList2, showSearch, disabled) {
      var search = showSearch ? createVNode("div", {
        "class": "".concat(prefixCls, "-body-search-wrapper")
      }, [createVNode(Search$1, {
        "prefixCls": "".concat(prefixCls, "-search"),
        "onChange": handleFilter,
        "handleClear": handleClear,
        "placeholder": searchPlaceholder,
        "value": filterValue.value,
        "disabled": disabled
      }, null)]) : null;
      var bodyNode;
      var _splitAttrs = splitAttrs(attrs), onEvents = _splitAttrs.onEvents;
      var _renderListBody = renderListBody(renderList2, _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        filteredItems: filteredItems.value,
        filteredRenderItems: filteredRenderItems.value,
        selectedKeys: checkedKeys
      }, onEvents)), bodyContent = _renderListBody.bodyContent, customize = _renderListBody.customize;
      if (customize) {
        bodyNode = createVNode("div", {
          "class": "".concat(prefixCls, "-body-customize-wrapper")
        }, [bodyContent]);
      } else {
        bodyNode = filteredItems.value.length ? bodyContent : createVNode("div", {
          "class": "".concat(prefixCls, "-body-not-found")
        }, [props3.notFoundContent]);
      }
      return createVNode("div", {
        "class": showSearch ? "".concat(prefixCls, "-body ").concat(prefixCls, "-body-with-search") : "".concat(prefixCls, "-body"),
        "ref": transferNode
      }, [search, bodyNode]);
    };
    return function() {
      var _slots$footer, _classNames, _slots$titleText;
      var prefixCls = props3.prefixCls, checkedKeys = props3.checkedKeys, disabled = props3.disabled, showSearch = props3.showSearch, searchPlaceholder = props3.searchPlaceholder, selectAll = props3.selectAll, selectCurrent = props3.selectCurrent, selectInvert = props3.selectInvert, removeAll = props3.removeAll, removeCurrent = props3.removeCurrent, renderList2 = props3.renderList, onItemSelectAll = props3.onItemSelectAll, onItemRemove = props3.onItemRemove, _props$showSelectAll = props3.showSelectAll, showSelectAll = _props$showSelectAll === void 0 ? true : _props$showSelectAll, showRemove = props3.showRemove, pagination = props3.pagination;
      var footerDom = (_slots$footer = slots.footer) === null || _slots$footer === void 0 ? void 0 : _slots$footer.call(slots, _objectSpread2$1({}, props3));
      var listCls = classNames(prefixCls, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls, "-with-pagination"), !!pagination), _defineProperty$U(_classNames, "".concat(prefixCls, "-with-footer"), !!footerDom), _classNames));
      var listBody = getListBody(prefixCls, searchPlaceholder, checkedKeys, renderList2, showSearch, disabled);
      var listFooter = footerDom ? createVNode("div", {
        "class": "".concat(prefixCls, "-footer")
      }, [footerDom]) : null;
      var checkAllCheckbox = !showRemove && !pagination && getCheckBox({
        disabled,
        prefixCls
      });
      var menu = null;
      if (showRemove) {
        menu = createVNode(Menu, null, {
          default: function _default9() {
            return [pagination && createVNode(Menu.Item, {
              "key": "removeCurrent",
              "onClick": function onClick2() {
                var pageKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map(function(entity) {
                  return entity.item;
                }));
                onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(pageKeys);
              }
            }, {
              default: function _default10() {
                return [removeCurrent];
              }
            }), createVNode(Menu.Item, {
              "key": "removeAll",
              "onClick": function onClick2() {
                onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(enabledItemKeys.value);
              }
            }, {
              default: function _default10() {
                return [removeAll];
              }
            })];
          }
        });
      } else {
        menu = createVNode(Menu, null, {
          default: function _default9() {
            return [createVNode(Menu.Item, {
              "key": "selectAll",
              "onClick": function onClick2() {
                var keys2 = enabledItemKeys.value;
                onItemSelectAll(getNewSelectKeys(keys2, []));
              }
            }, {
              default: function _default10() {
                return [selectAll];
              }
            }), pagination && createVNode(Menu.Item, {
              "onClick": function onClick2() {
                var pageKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map(function(entity) {
                  return entity.item;
                }));
                onItemSelectAll(getNewSelectKeys(pageKeys, []));
              }
            }, {
              default: function _default10() {
                return [selectCurrent];
              }
            }), createVNode(Menu.Item, {
              "key": "selectInvert",
              "onClick": function onClick2() {
                var availableKeys;
                if (pagination) {
                  availableKeys = getEnabledItemKeys((defaultListBodyRef.value.items || []).map(function(entity) {
                    return entity.item;
                  }));
                } else {
                  availableKeys = enabledItemKeys.value;
                }
                var checkedKeySet = new Set(checkedKeys);
                var newCheckedKeys = [];
                var newUnCheckedKeys = [];
                availableKeys.forEach(function(key2) {
                  if (checkedKeySet.has(key2)) {
                    newUnCheckedKeys.push(key2);
                  } else {
                    newCheckedKeys.push(key2);
                  }
                });
                onItemSelectAll(getNewSelectKeys(newCheckedKeys, newUnCheckedKeys));
              }
            }, {
              default: function _default10() {
                return [selectInvert];
              }
            })];
          }
        });
      }
      var dropdown = createVNode(Dropdown$1, {
        "class": "".concat(prefixCls, "-header-dropdown"),
        "overlay": menu,
        "disabled": disabled
      }, {
        default: function _default9() {
          return [createVNode(DownOutlined$1, null, null)];
        }
      });
      return createVNode("div", {
        "class": listCls,
        "style": attrs.style
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-header")
      }, [showSelectAll ? createVNode(Fragment, null, [checkAllCheckbox, dropdown]) : null, createVNode("span", {
        "class": "".concat(prefixCls, "-header-selected")
      }, [createVNode("span", null, [getSelectAllLabel(checkedKeys.length, filteredItems.value.length)]), createVNode("span", {
        "class": "".concat(prefixCls, "-header-title")
      }, [(_slots$titleText = slots.titleText) === null || _slots$titleText === void 0 ? void 0 : _slots$titleText.call(slots)])])]), listBody, listFooter]);
    };
  }
});
function noop2() {
}
var Operation = function Operation2(props3) {
  var disabled = props3.disabled, _props$moveToLeft = props3.moveToLeft, moveToLeft = _props$moveToLeft === void 0 ? noop2 : _props$moveToLeft, _props$moveToRight = props3.moveToRight, moveToRight = _props$moveToRight === void 0 ? noop2 : _props$moveToRight, _props$leftArrowText = props3.leftArrowText, leftArrowText = _props$leftArrowText === void 0 ? "" : _props$leftArrowText, _props$rightArrowText = props3.rightArrowText, rightArrowText = _props$rightArrowText === void 0 ? "" : _props$rightArrowText, leftActive = props3.leftActive, rightActive = props3.rightActive, className = props3.class, style2 = props3.style, direction = props3.direction, oneWay = props3.oneWay;
  return createVNode("div", {
    "class": className,
    "style": style2
  }, [createVNode(Button$1, {
    "type": "primary",
    "size": "small",
    "disabled": disabled || !rightActive,
    "onClick": moveToRight,
    "icon": direction !== "rtl" ? createVNode(RightOutlined$1, null, null) : createVNode(LeftOutlined$1, null, null)
  }, {
    default: function _default9() {
      return [rightArrowText];
    }
  }), !oneWay && createVNode(Button$1, {
    "type": "primary",
    "size": "small",
    "disabled": disabled || !leftActive,
    "onClick": moveToLeft,
    "icon": direction !== "rtl" ? createVNode(LeftOutlined$1, null, null) : createVNode(RightOutlined$1, null, null)
  }, {
    default: function _default9() {
      return [leftArrowText];
    }
  })]);
};
Operation.displayName = "Operation";
Operation.inheritAttrs = false;
const Operation$1 = Operation;
var transferProps = function transferProps2() {
  return {
    id: String,
    prefixCls: String,
    dataSource: {
      type: Array,
      default: []
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    targetKeys: {
      type: Array,
      default: void 0
    },
    selectedKeys: {
      type: Array,
      default: void 0
    },
    render: {
      type: Function
    },
    listStyle: {
      type: [Function, Object],
      default: function _default9() {
        return {};
      }
    },
    operationStyle: {
      type: Object,
      default: void 0
    },
    titles: {
      type: Array
    },
    operations: {
      type: Array
    },
    showSearch: {
      type: Boolean,
      default: false
    },
    filterOption: {
      type: Function
    },
    searchPlaceholder: String,
    notFoundContent: PropTypes$1.any,
    locale: {
      type: Object,
      default: function _default9() {
        return {};
      }
    },
    rowKey: {
      type: Function
    },
    showSelectAll: {
      type: Boolean,
      default: void 0
    },
    selectAllLabels: {
      type: Array
    },
    children: {
      type: Function
    },
    oneWay: {
      type: Boolean,
      default: void 0
    },
    pagination: {
      type: [Object, Boolean],
      default: void 0
    },
    onChange: Function,
    onSelectChange: Function,
    onSearch: Function,
    onScroll: Function,
    "onUpdate:targetKeys": Function,
    "onUpdate:selectedKeys": Function
  };
};
var Transfer = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATransfer",
  inheritAttrs: false,
  props: transferProps(),
  slots: ["leftTitle", "rightTitle", "children", "render", "notFoundContent", "leftSelectAllLabel", "rightSelectAllLabel", "footer"],
  setup: function setup204(props3, _ref) {
    var emit = _ref.emit, attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose;
    var _useConfigInject = useConfigInject("transfer", props3), configProvider = _useConfigInject.configProvider, prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var sourceSelectedKeys = ref([]);
    var targetSelectedKeys = ref([]);
    var formItemContext = useInjectFormItemContext();
    watch(function() {
      return props3.selectedKeys;
    }, function() {
      var _props$selectedKeys, _props$selectedKeys2;
      sourceSelectedKeys.value = ((_props$selectedKeys = props3.selectedKeys) === null || _props$selectedKeys === void 0 ? void 0 : _props$selectedKeys.filter(function(key2) {
        return props3.targetKeys.indexOf(key2) === -1;
      })) || [];
      targetSelectedKeys.value = ((_props$selectedKeys2 = props3.selectedKeys) === null || _props$selectedKeys2 === void 0 ? void 0 : _props$selectedKeys2.filter(function(key2) {
        return props3.targetKeys.indexOf(key2) > -1;
      })) || [];
    }, {
      immediate: true
    });
    var getLocale = function getLocale2(transferLocale, renderEmpty2) {
      var oldLocale = {
        notFoundContent: renderEmpty2("Transfer")
      };
      var notFoundContent = getPropsSlot(slots, props3, "notFoundContent");
      if (notFoundContent) {
        oldLocale.notFoundContent = notFoundContent;
      }
      if (props3.searchPlaceholder !== void 0) {
        oldLocale.searchPlaceholder = props3.searchPlaceholder;
      }
      return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, transferLocale), oldLocale), props3.locale);
    };
    var moveTo2 = function moveTo3(direction2) {
      var _props$targetKeys = props3.targetKeys, targetKeys = _props$targetKeys === void 0 ? [] : _props$targetKeys, _props$dataSource = props3.dataSource, dataSource = _props$dataSource === void 0 ? [] : _props$dataSource;
      var moveKeys = direction2 === "right" ? sourceSelectedKeys.value : targetSelectedKeys.value;
      var newMoveKeys = moveKeys.filter(function(key2) {
        return !dataSource.some(function(data9) {
          return !!(key2 === data9.key && data9.disabled);
        });
      });
      var newTargetKeys = direction2 === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter(function(targetKey) {
        return newMoveKeys.indexOf(targetKey) === -1;
      });
      var oppositeDirection = direction2 === "right" ? "left" : "right";
      direction2 === "right" ? sourceSelectedKeys.value = [] : targetSelectedKeys.value = [];
      emit("update:targetKeys", newTargetKeys);
      handleSelectChange(oppositeDirection, []);
      emit("change", newTargetKeys, direction2, newMoveKeys);
      formItemContext.onFieldChange();
    };
    var moveToLeft = function moveToLeft2() {
      moveTo2("left");
    };
    var moveToRight = function moveToRight2() {
      moveTo2("right");
    };
    var onItemSelectAll = function onItemSelectAll2(direction2, selectedKeys) {
      handleSelectChange(direction2, selectedKeys);
    };
    var onLeftItemSelectAll = function onLeftItemSelectAll2(selectedKeys) {
      return onItemSelectAll("left", selectedKeys);
    };
    var onRightItemSelectAll = function onRightItemSelectAll2(selectedKeys) {
      return onItemSelectAll("right", selectedKeys);
    };
    var handleSelectChange = function handleSelectChange2(direction2, holder) {
      if (direction2 === "left") {
        if (!props3.selectedKeys) {
          sourceSelectedKeys.value = holder;
        }
        emit("update:selectedKeys", [].concat(_toConsumableArray(holder), _toConsumableArray(targetSelectedKeys.value)));
        emit("selectChange", holder, toRaw(targetSelectedKeys.value));
      } else {
        if (!props3.selectedKeys) {
          targetSelectedKeys.value = holder;
        }
        emit("update:selectedKeys", [].concat(_toConsumableArray(holder), _toConsumableArray(sourceSelectedKeys.value)));
        emit("selectChange", toRaw(sourceSelectedKeys.value), holder);
      }
    };
    var handleFilter = function handleFilter2(direction2, e2) {
      var value = e2.target.value;
      emit("search", direction2, value);
    };
    var handleLeftFilter = function handleLeftFilter2(e2) {
      handleFilter("left", e2);
    };
    var handleRightFilter = function handleRightFilter2(e2) {
      handleFilter("right", e2);
    };
    var handleClear = function handleClear2(direction2) {
      emit("search", direction2, "");
    };
    var handleLeftClear = function handleLeftClear2() {
      handleClear("left");
    };
    var handleRightClear = function handleRightClear2() {
      handleClear("right");
    };
    var onItemSelect = function onItemSelect2(direction2, selectedKey, checked) {
      var holder = direction2 === "left" ? _toConsumableArray(sourceSelectedKeys.value) : _toConsumableArray(targetSelectedKeys.value);
      var index2 = holder.indexOf(selectedKey);
      if (index2 > -1) {
        holder.splice(index2, 1);
      }
      if (checked) {
        holder.push(selectedKey);
      }
      handleSelectChange(direction2, holder);
    };
    var onLeftItemSelect = function onLeftItemSelect2(selectedKey, checked) {
      return onItemSelect("left", selectedKey, checked);
    };
    var onRightItemSelect = function onRightItemSelect2(selectedKey, checked) {
      return onItemSelect("right", selectedKey, checked);
    };
    var onRightItemRemove = function onRightItemRemove2(targetedKeys) {
      var _props$targetKeys2 = props3.targetKeys, targetKeys = _props$targetKeys2 === void 0 ? [] : _props$targetKeys2;
      var newTargetKeys = targetKeys.filter(function(key2) {
        return !targetedKeys.includes(key2);
      });
      emit("update:targetKeys", newTargetKeys);
      emit("change", newTargetKeys, "left", _toConsumableArray(targetedKeys));
    };
    var handleScroll = function handleScroll2(direction2, e2) {
      emit("scroll", direction2, e2);
    };
    var handleLeftScroll = function handleLeftScroll2(e2) {
      handleScroll("left", e2);
    };
    var handleRightScroll = function handleRightScroll2(e2) {
      handleScroll("right", e2);
    };
    var handleListStyle = function handleListStyle2(listStyle, direction2) {
      if (typeof listStyle === "function") {
        return listStyle({
          direction: direction2
        });
      }
      return listStyle;
    };
    var leftDataSource = ref([]);
    var rightDataSource = ref([]);
    watchEffect(function() {
      var dataSource = props3.dataSource, rowKey = props3.rowKey, _props$targetKeys3 = props3.targetKeys, targetKeys = _props$targetKeys3 === void 0 ? [] : _props$targetKeys3;
      var ld = [];
      var rd = new Array(targetKeys.length);
      dataSource.forEach(function(record) {
        if (rowKey) {
          record.key = rowKey(record);
        }
        var indexOfKey = targetKeys.indexOf(record.key);
        if (indexOfKey !== -1) {
          rd[indexOfKey] = record;
        } else {
          ld.push(record);
        }
      });
      leftDataSource.value = ld;
      rightDataSource.value = rd;
    });
    expose({
      handleSelectChange
    });
    var renderTransfer = function renderTransfer2(transferLocale) {
      var _classNames, _ref2, _ref3, _slots$leftTitle, _ref4, _ref5, _slots$rightTitle;
      var disabled = props3.disabled, _props$operations = props3.operations, operations = _props$operations === void 0 ? [] : _props$operations, showSearch = props3.showSearch, listStyle = props3.listStyle, operationStyle = props3.operationStyle, filterOption2 = props3.filterOption, showSelectAll = props3.showSelectAll, _props$selectAllLabel = props3.selectAllLabels, selectAllLabels = _props$selectAllLabel === void 0 ? [] : _props$selectAllLabel, oneWay = props3.oneWay, pagination = props3.pagination, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var className = attrs.class, style2 = attrs.style;
      var children = slots.children;
      var mergedPagination = !children && pagination;
      var renderEmpty2 = configProvider.renderEmpty;
      var locale2 = getLocale(transferLocale, renderEmpty2);
      var footer = slots.footer;
      var renderItem = props3.render || slots.render;
      var leftActive = targetSelectedKeys.value.length > 0;
      var rightActive = sourceSelectedKeys.value.length > 0;
      var cls = classNames(prefixCls.value, className, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-customize-list"), !!children), _classNames));
      var titles = props3.titles;
      var leftTitle = (_ref2 = (_ref3 = titles && titles[0]) !== null && _ref3 !== void 0 ? _ref3 : (_slots$leftTitle = slots.leftTitle) === null || _slots$leftTitle === void 0 ? void 0 : _slots$leftTitle.call(slots)) !== null && _ref2 !== void 0 ? _ref2 : (locale2.titles || ["", ""])[0];
      var rightTitle = (_ref4 = (_ref5 = titles && titles[1]) !== null && _ref5 !== void 0 ? _ref5 : (_slots$rightTitle = slots.rightTitle) === null || _slots$rightTitle === void 0 ? void 0 : _slots$rightTitle.call(slots)) !== null && _ref4 !== void 0 ? _ref4 : (locale2.titles || ["", ""])[1];
      return createVNode("div", {
        "class": cls,
        "style": style2,
        "id": id
      }, [createVNode(List, _objectSpread2$1({
        "key": "leftList",
        "prefixCls": "".concat(prefixCls.value, "-list"),
        "dataSource": leftDataSource.value,
        "filterOption": filterOption2,
        "style": handleListStyle(listStyle, "left"),
        "checkedKeys": sourceSelectedKeys.value,
        "handleFilter": handleLeftFilter,
        "handleClear": handleLeftClear,
        "onItemSelect": onLeftItemSelect,
        "onItemSelectAll": onLeftItemSelectAll,
        "renderItem": renderItem,
        "showSearch": showSearch,
        "renderList": children,
        "onScroll": handleLeftScroll,
        "disabled": disabled,
        "direction": direction.value === "rtl" ? "right" : "left",
        "showSelectAll": showSelectAll,
        "selectAllLabel": selectAllLabels[0] || slots.leftSelectAllLabel,
        "pagination": mergedPagination
      }, locale2), {
        titleText: function titleText() {
          return leftTitle;
        },
        footer
      }), createVNode(Operation$1, {
        "key": "operation",
        "class": "".concat(prefixCls.value, "-operation"),
        "rightActive": rightActive,
        "rightArrowText": operations[0],
        "moveToRight": moveToRight,
        "leftActive": leftActive,
        "leftArrowText": operations[1],
        "moveToLeft": moveToLeft,
        "style": operationStyle,
        "disabled": disabled,
        "direction": direction.value,
        "oneWay": oneWay
      }, null), createVNode(List, _objectSpread2$1({
        "key": "rightList",
        "prefixCls": "".concat(prefixCls.value, "-list"),
        "dataSource": rightDataSource.value,
        "filterOption": filterOption2,
        "style": handleListStyle(listStyle, "right"),
        "checkedKeys": targetSelectedKeys.value,
        "handleFilter": handleRightFilter,
        "handleClear": handleRightClear,
        "onItemSelect": onRightItemSelect,
        "onItemSelectAll": onRightItemSelectAll,
        "onItemRemove": onRightItemRemove,
        "renderItem": renderItem,
        "showSearch": showSearch,
        "renderList": children,
        "onScroll": handleRightScroll,
        "disabled": disabled,
        "direction": direction.value === "rtl" ? "left" : "right",
        "showSelectAll": showSelectAll,
        "selectAllLabel": selectAllLabels[1] || slots.rightSelectAllLabel,
        "showRemove": oneWay,
        "pagination": mergedPagination
      }, locale2), {
        titleText: function titleText() {
          return rightTitle;
        },
        footer
      })]);
    };
    return function() {
      return createVNode(LocaleReceiver, {
        "componentName": "Transfer",
        "defaultLocale": defaultLocale.Transfer,
        "children": renderTransfer
      }, null);
    };
  }
});
const index$4 = withInstall(Transfer);
function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, children = _ref.children;
  var mergedValue = value || "value";
  return {
    _title: label ? [label] : ["title", "label"],
    value: mergedValue,
    key: mergedValue,
    children: children || "children"
  };
}
function isCheckDisabled(node) {
  return node.disabled || node.disableCheckbox || node.checkable === false;
}
function getAllKeys(treeData, fieldNames) {
  var keys2 = [];
  function dig(list) {
    list.forEach(function(item) {
      keys2.push(item[fieldNames.value]);
      var children = item[fieldNames.children];
      if (children) {
        dig(children);
      }
    });
  }
  dig(treeData);
  return keys2;
}
function isNil(val) {
  return val === null || val === void 0;
}
var TreeSelectContextPropsKey = Symbol("TreeSelectContextPropsKey");
function useProvideSelectContext(props3) {
  return provide(TreeSelectContextPropsKey, props3);
}
function useInjectSelectContext() {
  return inject(TreeSelectContextPropsKey, {});
}
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
const OptionList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: false,
  slots: ["notFoundContent", "menuItemSelectedIcon"],
  setup: function setup205(_2, _ref) {
    var slots = _ref.slots, expose = _ref.expose;
    var baseProps3 = useBaseProps();
    var legacyContext = useInjectLegacySelectContext();
    var context2 = useInjectSelectContext();
    var treeRef = ref();
    var memoTreeData = useMemo(function() {
      return context2.treeData;
    }, [function() {
      return baseProps3.open;
    }, function() {
      return context2.treeData;
    }], function(next2) {
      return next2[0];
    });
    var mergedCheckedKeys = computed(function() {
      var checkable = legacyContext.checkable, halfCheckedKeys = legacyContext.halfCheckedKeys, checkedKeys = legacyContext.checkedKeys;
      if (!checkable) {
        return null;
      }
      return {
        checked: checkedKeys,
        halfChecked: halfCheckedKeys
      };
    });
    watch(function() {
      return baseProps3.open;
    }, function() {
      nextTick(function() {
        if (baseProps3.open && !baseProps3.multiple && legacyContext.checkedKeys.length) {
          var _treeRef$value;
          (_treeRef$value = treeRef.value) === null || _treeRef$value === void 0 ? void 0 : _treeRef$value.scrollTo({
            key: legacyContext.checkedKeys[0]
          });
        }
      });
    }, {
      immediate: true,
      flush: "post"
    });
    var lowerSearchValue = computed(function() {
      return String(baseProps3.searchValue).toLowerCase();
    });
    var filterTreeNode = function filterTreeNode2(treeNode) {
      if (!lowerSearchValue.value) {
        return false;
      }
      return String(treeNode[legacyContext.treeNodeFilterProp]).toLowerCase().includes(lowerSearchValue.value);
    };
    var expandedKeys = shallowRef(legacyContext.treeDefaultExpandedKeys);
    var searchExpandedKeys = shallowRef(null);
    watch(function() {
      return baseProps3.searchValue;
    }, function() {
      if (baseProps3.searchValue) {
        searchExpandedKeys.value = getAllKeys(toRaw(context2.treeData), toRaw(context2.fieldNames));
      }
    }, {
      immediate: true
    });
    var mergedExpandedKeys = computed(function() {
      if (legacyContext.treeExpandedKeys) {
        return legacyContext.treeExpandedKeys.slice();
      }
      return baseProps3.searchValue ? searchExpandedKeys.value : expandedKeys.value;
    });
    var onInternalExpand = function onInternalExpand2(keys2) {
      var _legacyContext$onTree;
      expandedKeys.value = keys2;
      searchExpandedKeys.value = keys2;
      (_legacyContext$onTree = legacyContext.onTreeExpand) === null || _legacyContext$onTree === void 0 ? void 0 : _legacyContext$onTree.call(legacyContext, keys2);
    };
    var onListMouseDown = function onListMouseDown2(event2) {
      event2.preventDefault();
    };
    var onInternalSelect = function onInternalSelect2(_3, _ref2) {
      var _context$onSelect;
      var node = _ref2.node;
      var checkable = legacyContext.checkable, checkedKeys = legacyContext.checkedKeys;
      if (checkable && isCheckDisabled(node)) {
        return;
      }
      (_context$onSelect = context2.onSelect) === null || _context$onSelect === void 0 ? void 0 : _context$onSelect.call(context2, node.key, {
        selected: !checkedKeys.includes(node.key)
      });
      if (!baseProps3.multiple) {
        var _baseProps$toggleOpen;
        (_baseProps$toggleOpen = baseProps3.toggleOpen) === null || _baseProps$toggleOpen === void 0 ? void 0 : _baseProps$toggleOpen.call(baseProps3, false);
      }
    };
    var activeKey = ref(null);
    var activeEntity = computed(function() {
      return legacyContext.keyEntities[activeKey.value];
    });
    var setActiveKey = function setActiveKey2(key2) {
      activeKey.value = key2;
    };
    expose({
      scrollTo: function scrollTo2() {
        var _treeRef$value2, _treeRef$value2$scrol;
        for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
          args2[_key] = arguments[_key];
        }
        return (_treeRef$value2 = treeRef.value) === null || _treeRef$value2 === void 0 ? void 0 : (_treeRef$value2$scrol = _treeRef$value2.scrollTo) === null || _treeRef$value2$scrol === void 0 ? void 0 : _treeRef$value2$scrol.call.apply(_treeRef$value2$scrol, [_treeRef$value2].concat(args2));
      },
      onKeydown: function onKeydown(event2) {
        var _treeRef$value3;
        var which = event2.which;
        switch (which) {
          case KeyCode$1.UP:
          case KeyCode$1.DOWN:
          case KeyCode$1.LEFT:
          case KeyCode$1.RIGHT:
            (_treeRef$value3 = treeRef.value) === null || _treeRef$value3 === void 0 ? void 0 : _treeRef$value3.onKeydown(event2);
            break;
          case KeyCode$1.ENTER: {
            if (activeEntity.value) {
              var _ref3 = activeEntity.value.node || {}, selectable = _ref3.selectable, value = _ref3.value;
              if (selectable !== false) {
                onInternalSelect(null, {
                  node: {
                    key: activeKey.value
                  },
                  selected: !legacyContext.checkedKeys.includes(value)
                });
              }
            }
            break;
          }
          case KeyCode$1.ESC: {
            baseProps3.toggleOpen(false);
          }
        }
      },
      onKeyup: function onKeyup() {
      }
    });
    return function() {
      var _slots$notFoundConten;
      var prefixCls = baseProps3.prefixCls, multiple = baseProps3.multiple, searchValue = baseProps3.searchValue, open2 = baseProps3.open, _baseProps$notFoundCo = baseProps3.notFoundContent, notFoundContent = _baseProps$notFoundCo === void 0 ? (_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots) : _baseProps$notFoundCo;
      var listHeight = context2.listHeight, listItemHeight = context2.listItemHeight, virtual = context2.virtual;
      var checkable = legacyContext.checkable, treeDefaultExpandAll = legacyContext.treeDefaultExpandAll, treeIcon = legacyContext.treeIcon, showTreeIcon = legacyContext.showTreeIcon, switcherIcon = legacyContext.switcherIcon, treeLine = legacyContext.treeLine, loadData = legacyContext.loadData, treeLoadedKeys = legacyContext.treeLoadedKeys, treeMotion = legacyContext.treeMotion, onTreeLoad = legacyContext.onTreeLoad, checkedKeys = legacyContext.checkedKeys;
      if (memoTreeData.value.length === 0) {
        return createVNode("div", {
          "role": "listbox",
          "class": "".concat(prefixCls, "-empty"),
          "onMousedown": onListMouseDown
        }, [notFoundContent]);
      }
      var treeProps4 = {
        fieldNames: context2.fieldNames
      };
      if (treeLoadedKeys) {
        treeProps4.loadedKeys = treeLoadedKeys;
      }
      if (mergedExpandedKeys.value) {
        treeProps4.expandedKeys = mergedExpandedKeys.value;
      }
      return createVNode("div", {
        "onMousedown": onListMouseDown
      }, [activeEntity.value && open2 && createVNode("span", {
        "style": HIDDEN_STYLE,
        "aria-live": "assertive"
      }, [activeEntity.value.node.value]), createVNode(Tree$2, _objectSpread2$1(_objectSpread2$1({
        "ref": treeRef,
        "focusable": false,
        "prefixCls": "".concat(prefixCls, "-tree"),
        "treeData": memoTreeData.value,
        "height": listHeight,
        "itemHeight": listItemHeight,
        "virtual": virtual,
        "multiple": multiple,
        "icon": treeIcon,
        "showIcon": showTreeIcon,
        "switcherIcon": switcherIcon,
        "showLine": treeLine,
        "loadData": searchValue ? null : loadData,
        "motion": treeMotion,
        "activeKey": activeKey.value,
        "checkable": checkable,
        "checkStrictly": true,
        "checkedKeys": mergedCheckedKeys.value,
        "selectedKeys": !checkable ? checkedKeys : [],
        "defaultExpandAll": treeDefaultExpandAll
      }, treeProps4), {}, {
        "onActiveChange": setActiveKey,
        "onSelect": onInternalSelect,
        "onCheck": onInternalSelect,
        "onExpand": onInternalExpand,
        "onLoad": onTreeLoad,
        "filterTreeNode": filterTreeNode
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        checkable: legacyContext.customSlots.treeCheckable
      }))]);
    };
  }
});
var SHOW_ALL = "SHOW_ALL";
var SHOW_PARENT = "SHOW_PARENT";
var SHOW_CHILD = "SHOW_CHILD";
function formatStrategyValues(values, strategy, keyEntities, fieldNames) {
  var valueSet = new Set(values);
  if (strategy === SHOW_CHILD) {
    return values.filter(function(key2) {
      var entity = keyEntities[key2];
      if (entity && entity.children && entity.children.some(function(_ref) {
        var node = _ref.node;
        return valueSet.has(node[fieldNames.value]);
      }) && entity.children.every(function(_ref2) {
        var node = _ref2.node;
        return isCheckDisabled(node) || valueSet.has(node[fieldNames.value]);
      })) {
        return false;
      }
      return true;
    });
  }
  if (strategy === SHOW_PARENT) {
    return values.filter(function(key2) {
      var entity = keyEntities[key2];
      var parent2 = entity ? entity.parent : null;
      if (parent2 && !isCheckDisabled(parent2.node) && valueSet.has(parent2.key)) {
        return false;
      }
      return true;
    });
  }
  return values;
}
var TreeNode = function TreeNode2() {
  return null;
};
TreeNode.inheritAttrs = false;
TreeNode.displayName = "ATreeSelectNode";
TreeNode.isTreeSelectNode = true;
const TreeNode$1 = TreeNode;
var _excluded$7 = ["title", "switcherIcon"];
function isTreeSelectNode(node) {
  return node && node.type && node.type.isTreeSelectNode;
}
function convertChildrenToData(rootNodes) {
  function dig() {
    var treeNodes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return filterEmpty(treeNodes).map(function(treeNode) {
      var _slots$title, _slots$switcherIcon, _slots$default;
      if (!isTreeSelectNode(treeNode)) {
        return null;
      }
      var slots = treeNode.children || {};
      var key2 = treeNode.key;
      var props3 = {};
      for (var _i = 0, _Object$entries = Object.entries(treeNode.props); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray$2(_Object$entries[_i], 2), k2 = _Object$entries$_i[0], v2 = _Object$entries$_i[1];
        props3[camelize$2(k2)] = v2;
      }
      var isLeaf2 = props3.isLeaf, checkable = props3.checkable, selectable = props3.selectable, disabled = props3.disabled, disableCheckbox = props3.disableCheckbox;
      var newProps = {
        isLeaf: isLeaf2 || isLeaf2 === "" || void 0,
        checkable: checkable || checkable === "" || void 0,
        selectable: selectable || selectable === "" || void 0,
        disabled: disabled || disabled === "" || void 0,
        disableCheckbox: disableCheckbox || disableCheckbox === "" || void 0
      };
      var slotsProps = _objectSpread2$1(_objectSpread2$1({}, props3), newProps);
      var _props$title = props3.title, title = _props$title === void 0 ? (_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots, slotsProps) : _props$title, _props$switcherIcon = props3.switcherIcon, switcherIcon = _props$switcherIcon === void 0 ? (_slots$switcherIcon = slots.switcherIcon) === null || _slots$switcherIcon === void 0 ? void 0 : _slots$switcherIcon.call(slots, slotsProps) : _props$switcherIcon, rest = _objectWithoutProperties$2(props3, _excluded$7);
      var children = (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      var dataNode = _objectSpread2$1(_objectSpread2$1({}, rest), {}, {
        title,
        switcherIcon,
        key: key2,
        isLeaf: isLeaf2
      }, newProps);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function fillLegacyProps(dataNode) {
  if (!dataNode) {
    return dataNode;
  }
  var cloneNode = _objectSpread2$1({}, dataNode);
  if (!("props" in cloneNode)) {
    Object.defineProperty(cloneNode, "props", {
      get: function get4() {
        return cloneNode;
      }
    });
  }
  return cloneNode;
}
function fillAdditionalInfo(extra, triggerValue, checkedValues, treeData, showPosition, fieldNames) {
  var triggerNode = null;
  var nodeList = null;
  function generateMap() {
    function dig(list) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0";
      var parentIncluded = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return list.map(function(option, index2) {
        var pos2 = "".concat(level, "-").concat(index2);
        var value = option[fieldNames.value];
        var included = checkedValues.includes(value);
        var children = dig(option[fieldNames.children] || [], pos2, included);
        var node = createVNode(TreeNode$1, option, {
          default: function _default9() {
            return [children.map(function(child) {
              return child.node;
            })];
          }
        });
        if (triggerValue === value) {
          triggerNode = node;
        }
        if (included) {
          var checkedNode = {
            pos: pos2,
            node,
            children
          };
          if (!parentIncluded) {
            nodeList.push(checkedNode);
          }
          return checkedNode;
        }
        return null;
      }).filter(function(node) {
        return node;
      });
    }
    if (!nodeList) {
      nodeList = [];
      dig(treeData);
      nodeList.sort(function(_ref, _ref2) {
        var val1 = _ref.node.props.value;
        var val2 = _ref2.node.props.value;
        var index1 = checkedValues.indexOf(val1);
        var index2 = checkedValues.indexOf(val2);
        return index1 - index2;
      });
    }
  }
  Object.defineProperty(extra, "triggerNode", {
    get: function get4() {
      generateMap();
      return triggerNode;
    }
  });
  Object.defineProperty(extra, "allCheckedNodes", {
    get: function get4() {
      generateMap();
      if (showPosition) {
        return nodeList;
      }
      return nodeList.map(function(_ref3) {
        var node = _ref3.node;
        return node;
      });
    }
  });
}
function parseSimpleTreeData(treeData, _ref) {
  var id = _ref.id, pId = _ref.pId, rootPId = _ref.rootPId;
  var keyNodes = {};
  var rootNodeList = [];
  var nodeList = treeData.map(function(node) {
    var clone3 = _objectSpread2$1({}, node);
    var key2 = clone3[id];
    keyNodes[key2] = clone3;
    clone3.key = clone3.key || key2;
    return clone3;
  });
  nodeList.forEach(function(node) {
    var parentKey = node[pId];
    var parent2 = keyNodes[parentKey];
    if (parent2) {
      parent2.children = parent2.children || [];
      parent2.children.push(node);
    }
    if (parentKey === rootPId || !parent2 && rootPId === null) {
      rootNodeList.push(node);
    }
  });
  return rootNodeList;
}
function useTreeData(treeData, children, simpleMode) {
  var mergedTreeData = shallowRef();
  watch([simpleMode, treeData, children], function() {
    var simpleModeValue = simpleMode.value;
    if (treeData.value) {
      mergedTreeData.value = simpleMode.value ? parseSimpleTreeData(toRaw(treeData.value), _objectSpread2$1({
        id: "id",
        pId: "pId",
        rootPId: null
      }, simpleModeValue !== true ? simpleModeValue : {})) : toRaw(treeData.value).slice();
    } else {
      mergedTreeData.value = convertChildrenToData(toRaw(children.value));
    }
  }, {
    immediate: true,
    deep: true
  });
  return mergedTreeData;
}
const useCache = function(values) {
  var cacheRef = shallowRef({
    valueLabels: /* @__PURE__ */ new Map()
  });
  var mergedValues = shallowRef();
  watch(values, function() {
    mergedValues.value = toRaw(values.value);
  }, {
    immediate: true
  });
  var newFilledValues = computed(function() {
    var valueLabels = cacheRef.value.valueLabels;
    var valueLabelsCache = /* @__PURE__ */ new Map();
    var filledValues = mergedValues.value.map(function(item) {
      var _item$label;
      var value = item.value;
      var mergedLabel = (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : valueLabels.get(value);
      valueLabelsCache.set(value, mergedLabel);
      return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
        label: mergedLabel
      });
    });
    cacheRef.value.valueLabels = valueLabelsCache;
    return filledValues;
  });
  return [newFilledValues];
};
const useDataEntities = function(treeData, fieldNames) {
  var valueEntities = shallowRef(/* @__PURE__ */ new Map());
  var keyEntities = shallowRef({});
  watchEffect(function() {
    var fieldNamesValue = fieldNames.value;
    var collection = convertDataToEntities(treeData.value, {
      fieldNames: fieldNamesValue,
      initWrapper: function initWrapper(wrapper) {
        return _objectSpread2$1(_objectSpread2$1({}, wrapper), {}, {
          valueEntities: /* @__PURE__ */ new Map()
        });
      },
      processEntity: function processEntity(entity, wrapper) {
        var val = entity.node[fieldNamesValue.value];
        wrapper.valueEntities.set(val, entity);
      }
    });
    valueEntities.value = collection.valueEntities;
    keyEntities.value = collection.keyEntities;
  });
  return {
    valueEntities,
    keyEntities
  };
};
const useCheckedKeys = function(rawLabeledValues, rawHalfCheckedValues, treeConduction, keyEntities, maxLevel, levelEntities) {
  var newRawCheckedValues = shallowRef([]);
  var newRawHalfCheckedValues = shallowRef([]);
  watchEffect(function() {
    var checkedKeys = rawLabeledValues.value.map(function(_ref) {
      var value = _ref.value;
      return value;
    });
    var halfCheckedKeys = rawHalfCheckedValues.value.map(function(_ref2) {
      var value = _ref2.value;
      return value;
    });
    var missingValues = checkedKeys.filter(function(key2) {
      return !keyEntities.value[key2];
    });
    if (treeConduction.value) {
      var _conductCheck = conductCheck(checkedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);
      checkedKeys = _conductCheck.checkedKeys;
      halfCheckedKeys = _conductCheck.halfCheckedKeys;
    }
    newRawCheckedValues.value = Array.from(new Set([].concat(_toConsumableArray(missingValues), _toConsumableArray(checkedKeys))));
    newRawHalfCheckedValues.value = halfCheckedKeys;
  });
  return [newRawCheckedValues, newRawHalfCheckedValues];
};
const useFilterTreeData = function(treeData, searchValue, _ref) {
  var treeNodeFilterProp = _ref.treeNodeFilterProp, filterTreeNode = _ref.filterTreeNode, fieldNames = _ref.fieldNames;
  return computed(function() {
    var fieldChildren = fieldNames.value.children;
    var searchValueVal = searchValue.value;
    var treeNodeFilterPropValue = treeNodeFilterProp === null || treeNodeFilterProp === void 0 ? void 0 : treeNodeFilterProp.value;
    if (!searchValueVal || filterTreeNode.value === false) {
      return treeData.value;
    }
    var filterOptionFunc;
    if (typeof filterTreeNode.value === "function") {
      filterOptionFunc = filterTreeNode.value;
    } else {
      var upperStr = searchValueVal.toUpperCase();
      filterOptionFunc = function filterOptionFunc2(_2, dataNode) {
        var value = dataNode[treeNodeFilterPropValue];
        return String(value).toUpperCase().includes(upperStr);
      };
    }
    function dig(list) {
      var keepAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var res = [];
      for (var index2 = 0, len = list.length; index2 < len; index2++) {
        var dataNode = list[index2];
        var children = dataNode[fieldChildren];
        var match2 = keepAll || filterOptionFunc(searchValueVal, fillLegacyProps(dataNode));
        var childList = dig(children || [], match2);
        if (match2 || childList.length) {
          res.push(_objectSpread2$1(_objectSpread2$1({}, dataNode), {}, _defineProperty$U({}, fieldChildren, childList)));
        }
      }
      return res;
    }
    return dig(treeData.value);
  });
};
function treeSelectProps$1() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseSelectPropsWithoutPrivate(), ["mode"])), {}, {
    prefixCls: String,
    id: String,
    value: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array]
    },
    onChange: {
      type: Function
    },
    searchValue: String,
    inputValue: String,
    onSearch: {
      type: Function
    },
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    filterTreeNode: {
      type: [Boolean, Function],
      default: void 0
    },
    treeNodeFilterProp: String,
    onSelect: Function,
    onDeselect: Function,
    showCheckedStrategy: {
      type: String
    },
    treeNodeLabelProp: String,
    fieldNames: {
      type: Object
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    treeCheckable: {
      type: Boolean,
      default: void 0
    },
    treeCheckStrictly: {
      type: Boolean,
      default: void 0
    },
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    treeData: {
      type: Array
    },
    treeDataSimpleMode: {
      type: [Boolean, Object],
      default: void 0
    },
    loadData: {
      type: Function
    },
    treeLoadedKeys: {
      type: Array
    },
    onTreeLoad: {
      type: Function
    },
    treeDefaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    treeExpandedKeys: {
      type: Array
    },
    treeDefaultExpandedKeys: {
      type: Array
    },
    onTreeExpand: {
      type: Function
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    onDropdownVisibleChange: {
      type: Function
    },
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    treeIcon: PropTypes$1.any,
    showTreeIcon: {
      type: Boolean,
      default: void 0
    },
    switcherIcon: PropTypes$1.any,
    treeMotion: PropTypes$1.any,
    children: Array,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: PropTypes$1.any,
    maxTagPlaceholder: {
      type: Function
    },
    dropdownPopupAlign: PropTypes$1.any,
    customSlots: Object
  });
}
function isRawValue(value) {
  return !value || _typeof$3(value) !== "object";
}
const TreeSelect$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "TreeSelect",
  inheritAttrs: false,
  props: initDefaultProps$1(treeSelectProps$1(), {
    treeNodeFilterProp: "value",
    autoClearSearchValue: true,
    showCheckedStrategy: SHOW_CHILD,
    listHeight: 200,
    listItemHeight: 20,
    prefixCls: "vc-tree-select"
  }),
  setup: function setup206(props3, _ref) {
    var attrs = _ref.attrs, expose = _ref.expose, slots = _ref.slots;
    var mergedId = useId(toRef(props3, "id"));
    var treeConduction = computed(function() {
      return props3.treeCheckable && !props3.treeCheckStrictly;
    });
    var mergedCheckable = computed(function() {
      return props3.treeCheckable || props3.treeCheckStrictly;
    });
    var mergedLabelInValue = computed(function() {
      return props3.treeCheckStrictly || props3.labelInValue;
    });
    var mergedMultiple = computed(function() {
      return mergedCheckable.value || props3.multiple;
    });
    var mergedFieldNames = computed(function() {
      return fillFieldNames(props3.fieldNames);
    });
    var _useMergedState = useMergedState("", {
      value: computed(function() {
        return props3.searchValue !== void 0 ? props3.searchValue : props3.inputValue;
      }),
      postState: function postState(search) {
        return search || "";
      }
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
    var onInternalSearch = function onInternalSearch2(searchText) {
      var _props$onSearch;
      setSearchValue(searchText);
      (_props$onSearch = props3.onSearch) === null || _props$onSearch === void 0 ? void 0 : _props$onSearch.call(props3, searchText);
    };
    var mergedTreeData = useTreeData(toRef(props3, "treeData"), toRef(props3, "children"), toRef(props3, "treeDataSimpleMode"));
    var _useDataEntities = useDataEntities(mergedTreeData, mergedFieldNames), keyEntities = _useDataEntities.keyEntities, valueEntities = _useDataEntities.valueEntities;
    var splitRawValues = function splitRawValues2(newRawValues) {
      var missingRawValues = [];
      var existRawValues = [];
      newRawValues.forEach(function(val) {
        if (valueEntities.value.has(val)) {
          existRawValues.push(val);
        } else {
          missingRawValues.push(val);
        }
      });
      return {
        missingRawValues,
        existRawValues
      };
    };
    var filteredTreeData = useFilterTreeData(mergedTreeData, mergedSearchValue, {
      fieldNames: mergedFieldNames,
      treeNodeFilterProp: toRef(props3, "treeNodeFilterProp"),
      filterTreeNode: toRef(props3, "filterTreeNode")
    });
    var getLabel = function getLabel2(item) {
      if (item) {
        if (props3.treeNodeLabelProp) {
          return item[props3.treeNodeLabelProp];
        }
        var titleList = mergedFieldNames.value._title;
        for (var i2 = 0; i2 < titleList.length; i2 += 1) {
          var title = item[titleList[i2]];
          if (title !== void 0) {
            return title;
          }
        }
      }
    };
    var toLabeledValues = function toLabeledValues2(draftValues) {
      var values = toArray(draftValues);
      return values.map(function(val) {
        if (isRawValue(val)) {
          return {
            value: val
          };
        }
        return val;
      });
    };
    var convert2LabelValues = function convert2LabelValues2(draftValues) {
      var values = toLabeledValues(draftValues);
      return values.map(function(item) {
        var rawLabel = item.label;
        var rawValue = item.value, rawHalfChecked = item.halfChecked;
        var rawDisabled;
        var entity = valueEntities.value.get(rawValue);
        if (entity) {
          var _rawLabel;
          rawLabel = (_rawLabel = rawLabel) !== null && _rawLabel !== void 0 ? _rawLabel : getLabel(entity.node);
          rawDisabled = entity.node.disabled;
        }
        return {
          label: rawLabel,
          value: rawValue,
          halfChecked: rawHalfChecked,
          disabled: rawDisabled
        };
      });
    };
    var _useMergedState3 = useMergedState(props3.defaultValue, {
      value: toRef(props3, "value")
    }), _useMergedState4 = _slicedToArray$2(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
    var rawMixedLabeledValues = computed(function() {
      return toLabeledValues(internalValue.value);
    });
    var rawLabeledValues = shallowRef([]);
    var rawHalfLabeledValues = shallowRef([]);
    watchEffect(function() {
      var fullCheckValues = [];
      var halfCheckValues = [];
      rawMixedLabeledValues.value.forEach(function(item) {
        if (item.halfChecked) {
          halfCheckValues.push(item);
        } else {
          fullCheckValues.push(item);
        }
      });
      rawLabeledValues.value = fullCheckValues;
      rawHalfLabeledValues.value = halfCheckValues;
    });
    var rawValues = computed(function() {
      return rawLabeledValues.value.map(function(item) {
        return item.value;
      });
    });
    var _useMaxLevel = useMaxLevel(keyEntities), maxLevel = _useMaxLevel.maxLevel, levelEntities = _useMaxLevel.levelEntities;
    var _useCheckedKeys = useCheckedKeys(rawLabeledValues, rawHalfLabeledValues, treeConduction, keyEntities, maxLevel, levelEntities), _useCheckedKeys2 = _slicedToArray$2(_useCheckedKeys, 2), rawCheckedValues = _useCheckedKeys2[0], rawHalfCheckedValues = _useCheckedKeys2[1];
    var displayValues = computed(function() {
      var displayKeys = formatStrategyValues(rawCheckedValues.value, props3.showCheckedStrategy, keyEntities.value, mergedFieldNames.value);
      var values = displayKeys.map(function(key2) {
        var _keyEntities$value$ke, _keyEntities$value$ke2, _keyEntities$value$ke3;
        return (_keyEntities$value$ke = (_keyEntities$value$ke2 = keyEntities.value[key2]) === null || _keyEntities$value$ke2 === void 0 ? void 0 : (_keyEntities$value$ke3 = _keyEntities$value$ke2.node) === null || _keyEntities$value$ke3 === void 0 ? void 0 : _keyEntities$value$ke3[mergedFieldNames.value.value]) !== null && _keyEntities$value$ke !== void 0 ? _keyEntities$value$ke : key2;
      });
      var labeledValues = values.map(function(val) {
        var targetItem = rawLabeledValues.value.find(function(item) {
          return item.value === val;
        });
        return {
          value: val,
          label: targetItem === null || targetItem === void 0 ? void 0 : targetItem.label
        };
      });
      var rawDisplayValues = convert2LabelValues(labeledValues);
      var firstVal = rawDisplayValues[0];
      if (!mergedMultiple.value && firstVal && isNil(firstVal.value) && isNil(firstVal.label)) {
        return [];
      }
      return rawDisplayValues.map(function(item) {
        var _item$label;
        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
        });
      });
    });
    var _useCache = useCache(displayValues), _useCache2 = _slicedToArray$2(_useCache, 1), cachedDisplayValues = _useCache2[0];
    var triggerChange = function triggerChange2(newRawValues, extra, source2) {
      var labeledValues = convert2LabelValues(newRawValues);
      setInternalValue(labeledValues);
      if (props3.autoClearSearchValue) {
        setSearchValue("");
      }
      if (props3.onChange) {
        var eventValues = newRawValues;
        if (treeConduction.value) {
          var formattedKeyList = formatStrategyValues(newRawValues, props3.showCheckedStrategy, keyEntities.value, mergedFieldNames.value);
          eventValues = formattedKeyList.map(function(key2) {
            var entity = valueEntities.value.get(key2);
            return entity ? entity.node[mergedFieldNames.value.value] : key2;
          });
        }
        var _ref2 = extra || {
          triggerValue: void 0,
          selected: void 0
        }, triggerValue = _ref2.triggerValue, selected = _ref2.selected;
        var returnRawValues = eventValues;
        if (props3.treeCheckStrictly) {
          var halfValues = rawHalfLabeledValues.value.filter(function(item) {
            return !eventValues.includes(item.value);
          });
          returnRawValues = [].concat(_toConsumableArray(returnRawValues), _toConsumableArray(halfValues));
        }
        var returnLabeledValues = convert2LabelValues(returnRawValues);
        var additionalInfo = {
          preValue: rawLabeledValues.value,
          triggerValue
        };
        var showPosition = true;
        if (props3.treeCheckStrictly || source2 === "selection" && !selected) {
          showPosition = false;
        }
        fillAdditionalInfo(additionalInfo, triggerValue, newRawValues, mergedTreeData.value, showPosition, mergedFieldNames.value);
        if (mergedCheckable.value) {
          additionalInfo.checked = selected;
        } else {
          additionalInfo.selected = selected;
        }
        var returnValues = mergedLabelInValue.value ? returnLabeledValues : returnLabeledValues.map(function(item) {
          return item.value;
        });
        props3.onChange(mergedMultiple.value ? returnValues : returnValues[0], mergedLabelInValue.value ? null : returnLabeledValues.map(function(item) {
          return item.label;
        }), additionalInfo);
      }
    };
    var onOptionSelect = function onOptionSelect2(selectedKey, _ref3) {
      var _node$mergedFieldName;
      var selected = _ref3.selected, source2 = _ref3.source;
      var keyEntitiesValue = toRaw(keyEntities.value);
      var valueEntitiesValue = toRaw(valueEntities.value);
      var entity = keyEntitiesValue[selectedKey];
      var node = entity === null || entity === void 0 ? void 0 : entity.node;
      var selectedValue = (_node$mergedFieldName = node === null || node === void 0 ? void 0 : node[mergedFieldNames.value.value]) !== null && _node$mergedFieldName !== void 0 ? _node$mergedFieldName : selectedKey;
      if (!mergedMultiple.value) {
        triggerChange([selectedValue], {
          selected: true,
          triggerValue: selectedValue
        }, "option");
      } else {
        var newRawValues = selected ? [].concat(_toConsumableArray(rawValues.value), [selectedValue]) : rawCheckedValues.value.filter(function(v2) {
          return v2 !== selectedValue;
        });
        if (treeConduction.value) {
          var _splitRawValues = splitRawValues(newRawValues), missingRawValues = _splitRawValues.missingRawValues, existRawValues = _splitRawValues.existRawValues;
          var keyList = existRawValues.map(function(val) {
            return valueEntitiesValue.get(val).key;
          });
          var checkedKeys;
          if (selected) {
            var _conductCheck = conductCheck(keyList, true, keyEntitiesValue, maxLevel.value, levelEntities.value);
            checkedKeys = _conductCheck.checkedKeys;
          } else {
            var _conductCheck2 = conductCheck(keyList, {
              checked: false,
              halfCheckedKeys: rawHalfCheckedValues.value
            }, keyEntitiesValue, maxLevel.value, levelEntities.value);
            checkedKeys = _conductCheck2.checkedKeys;
          }
          newRawValues = [].concat(_toConsumableArray(missingRawValues), _toConsumableArray(checkedKeys.map(function(key2) {
            return keyEntitiesValue[key2].node[mergedFieldNames.value.value];
          })));
        }
        triggerChange(newRawValues, {
          selected,
          triggerValue: selectedValue
        }, source2 || "option");
      }
      if (selected || !mergedMultiple.value) {
        var _props$onSelect;
        (_props$onSelect = props3.onSelect) === null || _props$onSelect === void 0 ? void 0 : _props$onSelect.call(props3, selectedValue, fillLegacyProps(node));
      } else {
        var _props$onDeselect;
        (_props$onDeselect = props3.onDeselect) === null || _props$onDeselect === void 0 ? void 0 : _props$onDeselect.call(props3, selectedValue, fillLegacyProps(node));
      }
    };
    var onInternalDropdownVisibleChange = function onInternalDropdownVisibleChange2(open2) {
      if (props3.onDropdownVisibleChange) {
        var legacyParam = {};
        Object.defineProperty(legacyParam, "documentClickClose", {
          get: function get4() {
            return false;
          }
        });
        props3.onDropdownVisibleChange(open2, legacyParam);
      }
    };
    var onDisplayValuesChange = function onDisplayValuesChange2(newValues, info) {
      var newRawValues = newValues.map(function(item) {
        return item.value;
      });
      if (info.type === "clear") {
        triggerChange(newRawValues, {}, "selection");
        return;
      }
      if (info.values.length) {
        onOptionSelect(info.values[0].value, {
          selected: false,
          source: "selection"
        });
      }
    };
    var _toRefs = toRefs(props3), treeNodeFilterProp = _toRefs.treeNodeFilterProp, loadData = _toRefs.loadData, treeLoadedKeys = _toRefs.treeLoadedKeys, onTreeLoad = _toRefs.onTreeLoad, treeDefaultExpandAll = _toRefs.treeDefaultExpandAll, treeExpandedKeys = _toRefs.treeExpandedKeys, treeDefaultExpandedKeys = _toRefs.treeDefaultExpandedKeys, onTreeExpand = _toRefs.onTreeExpand, virtual = _toRefs.virtual, listHeight = _toRefs.listHeight, listItemHeight = _toRefs.listItemHeight, treeLine = _toRefs.treeLine, treeIcon = _toRefs.treeIcon, showTreeIcon = _toRefs.showTreeIcon, switcherIcon = _toRefs.switcherIcon, treeMotion = _toRefs.treeMotion, customSlots = _toRefs.customSlots;
    useProvideLegacySelectContext(toReactive({
      checkable: mergedCheckable,
      loadData,
      treeLoadedKeys,
      onTreeLoad,
      checkedKeys: rawCheckedValues,
      halfCheckedKeys: rawHalfCheckedValues,
      treeDefaultExpandAll,
      treeExpandedKeys,
      treeDefaultExpandedKeys,
      onTreeExpand,
      treeIcon,
      treeMotion,
      showTreeIcon,
      switcherIcon,
      treeLine,
      treeNodeFilterProp,
      keyEntities,
      customSlots
    }));
    useProvideSelectContext(toReactive({
      virtual,
      listHeight,
      listItemHeight,
      treeData: filteredTreeData,
      fieldNames: mergedFieldNames,
      onSelect: onOptionSelect
    }));
    var selectRef = ref();
    expose({
      focus: function focus() {
        var _selectRef$value;
        (_selectRef$value = selectRef.value) === null || _selectRef$value === void 0 ? void 0 : _selectRef$value.focus();
      },
      blur: function blur() {
        var _selectRef$value2;
        (_selectRef$value2 = selectRef.value) === null || _selectRef$value2 === void 0 ? void 0 : _selectRef$value2.blur();
      },
      scrollTo: function scrollTo2(arg) {
        var _selectRef$value3;
        (_selectRef$value3 = selectRef.value) === null || _selectRef$value3 === void 0 ? void 0 : _selectRef$value3.scrollTo(arg);
      }
    });
    return function() {
      var _props$dropdownMatchS;
      var restProps = omit$2(props3, [
        "id",
        "prefixCls",
        "value",
        "defaultValue",
        "onChange",
        "onSelect",
        "onDeselect",
        "searchValue",
        "inputValue",
        "onSearch",
        "autoClearSearchValue",
        "filterTreeNode",
        "treeNodeFilterProp",
        "showCheckedStrategy",
        "treeNodeLabelProp",
        "multiple",
        "treeCheckable",
        "treeCheckStrictly",
        "labelInValue",
        "fieldNames",
        "treeDataSimpleMode",
        "treeData",
        "children",
        "loadData",
        "treeLoadedKeys",
        "onTreeLoad",
        "treeDefaultExpandAll",
        "treeExpandedKeys",
        "treeDefaultExpandedKeys",
        "onTreeExpand",
        "virtual",
        "listHeight",
        "listItemHeight",
        "onDropdownVisibleChange",
        "treeLine",
        "treeIcon",
        "showTreeIcon",
        "switcherIcon",
        "treeMotion"
      ]);
      return createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        "ref": selectRef
      }, attrs), restProps), {}, {
        "id": mergedId,
        "prefixCls": props3.prefixCls,
        "mode": mergedMultiple.value ? "multiple" : void 0,
        "displayValues": cachedDisplayValues.value,
        "onDisplayValuesChange": onDisplayValuesChange,
        "searchValue": mergedSearchValue.value,
        "onSearch": onInternalSearch,
        "OptionList": OptionList,
        "emptyOptions": !mergedTreeData.value.length,
        "onDropdownVisibleChange": onInternalDropdownVisibleChange,
        "tagRender": props3.tagRender || slots.tagRender,
        "dropdownMatchSelectWidth": (_props$dropdownMatchS = props3.dropdownMatchSelectWidth) !== null && _props$dropdownMatchS !== void 0 ? _props$dropdownMatchS : true
      }), slots);
    };
  }
});
var getTransitionName2 = function getTransitionName3(rootPrefixCls, motion, transitionName2) {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
function treeSelectProps() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(treeSelectProps$1(), ["showTreeIcon", "treeMotion", "inputIcon", "getInputElement", "treeLine", "customSlots"])), {}, {
    suffixIcon: PropTypes$1.any,
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    replaceFields: {
      type: Object
    },
    "onUpdate:value": {
      type: Function
    },
    "onUpdate:treeExpandedKeys": {
      type: Function
    },
    "onUpdate:searchValue": {
      type: Function
    }
  });
}
var TreeSelect = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeSelect",
  inheritAttrs: false,
  props: initDefaultProps$1(treeSelectProps(), {
    choiceTransitionName: "",
    listHeight: 256,
    treeIcon: false,
    listItemHeight: 26,
    bordered: true
  }),
  slots: ["title", "titleRender", "placeholder", "maxTagPlaceholder", "treeIcon", "switcherIcon", "notFoundContent"],
  setup: function setup207(props3, _ref) {
    var attrs = _ref.attrs, slots = _ref.slots, expose = _ref.expose, emit = _ref.emit;
    warning$3(!(props3.treeData === void 0 && slots.default));
    watchEffect(function() {
      devWarning(props3.multiple !== false || !props3.treeCheckable, "TreeSelect", "`multiple` will always be `true` when `treeCheckable` is true");
      devWarning(props3.replaceFields === void 0, "TreeSelect", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    var formItemContext = useInjectFormItemContext();
    var _useConfigInject = useConfigInject("select", props3), prefixCls = _useConfigInject.prefixCls, renderEmpty2 = _useConfigInject.renderEmpty, direction = _useConfigInject.direction, virtual = _useConfigInject.virtual, dropdownMatchSelectWidth = _useConfigInject.dropdownMatchSelectWidth, size2 = _useConfigInject.size, getPopupContainer = _useConfigInject.getPopupContainer, getPrefixCls2 = _useConfigInject.getPrefixCls;
    var rootPrefixCls = computed(function() {
      return getPrefixCls2();
    });
    var transitionName2 = computed(function() {
      return getTransitionName2(rootPrefixCls.value, "slide-up", props3.transitionName);
    });
    var choiceTransitionName = computed(function() {
      return getTransitionName2(rootPrefixCls.value, "", props3.choiceTransitionName);
    });
    var treePrefixCls = computed(function() {
      return getPrefixCls2("select-tree", props3.prefixCls);
    });
    var treeSelectPrefixCls = computed(function() {
      return getPrefixCls2("tree-select", props3.prefixCls);
    });
    var mergedDropdownClassName = computed(function() {
      return classNames(props3.dropdownClassName, "".concat(treeSelectPrefixCls.value, "-dropdown"), _defineProperty$U({}, "".concat(treeSelectPrefixCls.value, "-dropdown-rtl"), direction.value === "rtl"));
    });
    var isMultiple2 = computed(function() {
      return !!(props3.treeCheckable || props3.multiple);
    });
    var treeSelectRef = ref();
    expose({
      focus: function focus() {
        var _treeSelectRef$value$, _treeSelectRef$value;
        (_treeSelectRef$value$ = (_treeSelectRef$value = treeSelectRef.value).focus) === null || _treeSelectRef$value$ === void 0 ? void 0 : _treeSelectRef$value$.call(_treeSelectRef$value);
      },
      blur: function blur() {
        var _treeSelectRef$value$2, _treeSelectRef$value2;
        (_treeSelectRef$value$2 = (_treeSelectRef$value2 = treeSelectRef.value).blur) === null || _treeSelectRef$value$2 === void 0 ? void 0 : _treeSelectRef$value$2.call(_treeSelectRef$value2);
      }
    });
    var handleChange2 = function handleChange3() {
      for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
        args2[_key] = arguments[_key];
      }
      emit("update:value", args2[0]);
      emit.apply(void 0, ["change"].concat(args2));
      formItemContext.onFieldChange();
    };
    var handleTreeExpand = function handleTreeExpand2(keys2) {
      emit("update:treeExpandedKeys", keys2);
      emit("treeExpand", keys2);
    };
    var handleSearch = function handleSearch2(value) {
      emit("update:searchValue", value);
      emit("search", value);
    };
    var handleBlur = function handleBlur2(e2) {
      emit("blur", e2);
      formItemContext.onFieldBlur();
    };
    return function() {
      var _slots$notFoundConten, _slots$switcherIcon, _classNames2;
      var _props$notFoundConten = props3.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? (_slots$notFoundConten = slots.notFoundContent) === null || _slots$notFoundConten === void 0 ? void 0 : _slots$notFoundConten.call(slots) : _props$notFoundConten, customizePrefixCls = props3.prefixCls, bordered = props3.bordered, listHeight = props3.listHeight, listItemHeight = props3.listItemHeight, multiple = props3.multiple, treeIcon = props3.treeIcon, treeLine = props3.treeLine, _props$switcherIcon = props3.switcherIcon, _switcherIcon = _props$switcherIcon === void 0 ? (_slots$switcherIcon = slots.switcherIcon) === null || _slots$switcherIcon === void 0 ? void 0 : _slots$switcherIcon.call(slots) : _props$switcherIcon, _props$fieldNames = props3.fieldNames, fieldNames = _props$fieldNames === void 0 ? props3.replaceFields : _props$fieldNames, _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
      var _getIcons = getIcons(_objectSpread2$1(_objectSpread2$1({}, props3), {}, {
        multiple: isMultiple2.value,
        prefixCls: prefixCls.value
      }), slots), suffixIcon = _getIcons.suffixIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
      var mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else {
        mergedNotFound = renderEmpty2.value("Select");
      }
      var selectProps3 = omit$2(props3, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon", "bordered", "onUpdate:value", "onUpdate:treeExpandedKeys", "onUpdate:searchValue"]);
      var mergedClassName = classNames(!customizePrefixCls && treeSelectPrefixCls.value, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-lg"), size2.value === "large"), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-sm"), size2.value === "small"), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-borderless"), !bordered), _classNames2), attrs.class);
      var otherProps = {};
      if (props3.treeData === void 0 && slots.default) {
        otherProps.children = flattenChildren(slots.default());
      }
      return createVNode(TreeSelect$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), selectProps3), {}, {
        "virtual": virtual.value,
        "dropdownMatchSelectWidth": dropdownMatchSelectWidth.value,
        "id": id,
        "fieldNames": fieldNames,
        "ref": treeSelectRef,
        "prefixCls": prefixCls.value,
        "class": mergedClassName,
        "listHeight": listHeight,
        "listItemHeight": listItemHeight,
        "treeLine": !!treeLine,
        "inputIcon": suffixIcon,
        "multiple": multiple,
        "removeIcon": removeIcon,
        "clearIcon": clearIcon,
        "switcherIcon": function switcherIcon(nodeProps) {
          return renderSwitcherIcon(treePrefixCls.value, _switcherIcon, treeLine, nodeProps);
        },
        "showTreeIcon": treeIcon,
        "notFoundContent": mergedNotFound,
        "getPopupContainer": getPopupContainer.value,
        "treeMotion": null,
        "dropdownClassName": mergedDropdownClassName.value,
        "choiceTransitionName": choiceTransitionName.value,
        "onChange": handleChange2,
        "onBlur": handleBlur,
        "onSearch": handleSearch,
        "onTreeExpand": handleTreeExpand
      }, otherProps), {}, {
        "transitionName": transitionName2.value,
        "customSlots": _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
          treeCheckable: function treeCheckable() {
            return createVNode("span", {
              "class": "".concat(prefixCls.value, "-tree-checkbox-inner")
            }, null);
          }
        }),
        "maxTagPlaceholder": props3.maxTagPlaceholder || slots.maxTagPlaceholder
      }), _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
        treeCheckable: function treeCheckable() {
          return createVNode("span", {
            "class": "".concat(prefixCls.value, "-tree-checkbox-inner")
          }, null);
        }
      }));
    };
  }
});
var TreeSelectNode = TreeNode$1;
const index$3 = _extends$1(TreeSelect, {
  TreeNode: TreeNode$1,
  SHOW_ALL,
  SHOW_PARENT,
  SHOW_CHILD,
  install: function install9(app) {
    app.component(TreeSelect.name, TreeSelect);
    app.component(TreeSelectNode.displayName, TreeSelectNode);
    return app;
  }
});
var timePickerProps = function timePickerProps2() {
  return {
    format: String,
    showNow: {
      type: Boolean,
      default: void 0
    },
    showHour: {
      type: Boolean,
      default: void 0
    },
    showMinute: {
      type: Boolean,
      default: void 0
    },
    showSecond: {
      type: Boolean,
      default: void 0
    },
    use12Hours: {
      type: Boolean,
      default: void 0
    },
    hourStep: Number,
    minuteStep: Number,
    secondStep: Number,
    hideDisabledOptions: {
      type: Boolean,
      default: void 0
    },
    popupClassName: String
  };
};
function createTimePicker(generateConfig2) {
  var DatePicker2 = generatePicker(generateConfig2, _objectSpread2$1(_objectSpread2$1({}, timePickerProps()), {}, {
    order: {
      type: Boolean,
      default: true
    }
  }));
  var InternalTimePicker = DatePicker2.TimePicker, InternalRangePicker = DatePicker2.RangePicker;
  var TimePicker2 = defineComponent({
    name: "ATimePicker",
    inheritAttrs: false,
    props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), datePickerProps()), timePickerProps()), {}, {
      addon: {
        type: Function
      }
    }),
    slot: ["addon", "renderExtraFooter", "suffixIcon", "clearIcon"],
    setup: function setup219(props3, _ref) {
      var slots = _ref.slots, expose = _ref.expose, emit = _ref.emit, attrs = _ref.attrs;
      var formItemContext = useInjectFormItemContext();
      devWarning(!(slots.addon || props3.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      var pickerRef = ref();
      expose({
        focus: function focus() {
          var _pickerRef$value;
          (_pickerRef$value = pickerRef.value) === null || _pickerRef$value === void 0 ? void 0 : _pickerRef$value.focus();
        },
        blur: function blur() {
          var _pickerRef$value2;
          (_pickerRef$value2 = pickerRef.value) === null || _pickerRef$value2 === void 0 ? void 0 : _pickerRef$value2.blur();
        }
      });
      var onChange3 = function onChange4(value, dateString) {
        emit("update:value", value);
        emit("change", value, dateString);
        formItemContext.onFieldChange();
      };
      var onOpenChange = function onOpenChange2(open2) {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      var onFocus2 = function onFocus3(e2) {
        emit("focus", e2);
      };
      var onBlur2 = function onBlur3(e2) {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      var onOk = function onOk2(value) {
        emit("ok", value);
      };
      return function() {
        var _props$id = props3.id, id = _props$id === void 0 ? formItemContext.id.value : _props$id;
        return createVNode(InternalTimePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$2(props3, ["onUpdate:value", "onUpdate:open"])), {}, {
          "id": id,
          "dropdownClassName": props3.popupClassName,
          "mode": void 0,
          "ref": pickerRef,
          "renderExtraFooter": props3.addon || slots.addon || props3.renderExtraFooter || slots.renderExtraFooter,
          "onChange": onChange3,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus2,
          "onBlur": onBlur2,
          "onOk": onOk
        }), slots);
      };
    }
  });
  var TimeRangePicker2 = defineComponent({
    name: "ATimeRangePicker",
    inheritAttrs: false,
    props: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, commonProps()), rangePickerProps()), timePickerProps()), {}, {
      order: {
        type: Boolean,
        default: true
      }
    }),
    slot: ["renderExtraFooter", "suffixIcon", "clearIcon"],
    setup: function setup219(props3, _ref2) {
      var slots = _ref2.slots, expose = _ref2.expose, emit = _ref2.emit, attrs = _ref2.attrs;
      var pickerRef = ref();
      var formItemContext = useInjectFormItemContext();
      expose({
        focus: function focus() {
          var _pickerRef$value3;
          (_pickerRef$value3 = pickerRef.value) === null || _pickerRef$value3 === void 0 ? void 0 : _pickerRef$value3.focus();
        },
        blur: function blur() {
          var _pickerRef$value4;
          (_pickerRef$value4 = pickerRef.value) === null || _pickerRef$value4 === void 0 ? void 0 : _pickerRef$value4.blur();
        }
      });
      var onChange3 = function onChange4(values, dateStrings) {
        emit("update:value", values);
        emit("change", values, dateStrings);
        formItemContext.onFieldChange();
      };
      var onOpenChange = function onOpenChange2(open2) {
        emit("update:open", open2);
        emit("openChange", open2);
      };
      var onFocus2 = function onFocus3(e2) {
        emit("focus", e2);
      };
      var onBlur2 = function onBlur3(e2) {
        emit("blur", e2);
        formItemContext.onFieldBlur();
      };
      var onPanelChange = function onPanelChange2(values, modes) {
        emit("panelChange", values, modes);
      };
      var onOk = function onOk2(values) {
        emit("ok", values);
      };
      var onCalendarChange = function onCalendarChange2(values, dateStrings, info) {
        emit("calendarChange", values, dateStrings, info);
      };
      return function() {
        var _props$id2 = props3.id, id = _props$id2 === void 0 ? formItemContext.id.value : _props$id2;
        return createVNode(InternalRangePicker, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$2(props3, ["onUpdate:open", "onUpdate:value"])), {}, {
          "id": id,
          "dropdownClassName": props3.popupClassName,
          "picker": "time",
          "mode": void 0,
          "ref": pickerRef,
          "onChange": onChange3,
          "onOpenChange": onOpenChange,
          "onFocus": onFocus2,
          "onBlur": onBlur2,
          "onPanelChange": onPanelChange,
          "onOk": onOk,
          "onCalendarChange": onCalendarChange
        }), slots);
      };
    }
  });
  return {
    TimePicker: TimePicker2,
    TimeRangePicker: TimeRangePicker2
  };
}
var _createTimePicker = createTimePicker(dayjsGenerateConfig), TimePicker$1 = _createTimePicker.TimePicker, TimeRangePicker = _createTimePicker.TimeRangePicker;
const TimePicker$2 = _extends$1(TimePicker$1, {
  TimePicker: TimePicker$1,
  TimeRangePicker,
  install: function install10(app) {
    app.component(TimePicker$1.name, TimePicker$1);
    app.component(TimeRangePicker.name, TimeRangePicker);
    return app;
  }
});
var timelineItemProps = function timelineItemProps2() {
  return {
    prefixCls: String,
    color: String,
    dot: PropTypes$1.any,
    pending: {
      type: Boolean,
      default: void 0
    },
    position: PropTypes$1.oneOf(tuple$1("left", "right", "")).def(""),
    label: PropTypes$1.any
  };
};
const TimelineItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATimelineItem",
  props: initDefaultProps$1(timelineItemProps(), {
    color: "blue",
    pending: false
  }),
  slots: ["dot", "label"],
  setup: function setup208(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("timeline", props3), prefixCls = _useConfigInject.prefixCls;
    return function() {
      var _slots$label, _slots$dot, _classNames, _classNames2, _slots$default;
      var _props$color = props3.color, color = _props$color === void 0 ? "" : _props$color, pending = props3.pending, _props$label = props3.label, label = _props$label === void 0 ? (_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots) : _props$label, _props$dot = props3.dot, dot = _props$dot === void 0 ? (_slots$dot = slots.dot) === null || _slots$dot === void 0 ? void 0 : _slots$dot.call(slots) : _props$dot;
      var itemClassName = classNames((_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-item"), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-item-pending"), pending), _classNames));
      var dotClassName = classNames((_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-item-head"), true), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-item-head-custom"), dot), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-item-head-").concat(color), true), _classNames2));
      var customColor = /blue|red|green|gray/.test(color || "") ? void 0 : color;
      return createVNode("li", {
        "class": itemClassName
      }, [label && createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-label")
      }, [label]), createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-tail")
      }, null), createVNode("div", {
        "class": dotClassName,
        "style": {
          borderColor: customColor,
          color: customColor
        }
      }, [dot]), createVNode("div", {
        "class": "".concat(prefixCls.value, "-item-content")
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
    };
  }
});
var timelineProps = function timelineProps2() {
  return {
    prefixCls: String,
    pending: PropTypes$1.any,
    pendingDot: PropTypes$1.any,
    reverse: {
      type: Boolean,
      default: void 0
    },
    mode: PropTypes$1.oneOf(tuple$1("left", "alternate", "right", ""))
  };
};
const Timeline = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ATimeline",
  props: initDefaultProps$1(timelineProps(), {
    reverse: false,
    mode: ""
  }),
  slots: ["pending", "pendingDot"],
  setup: function setup209(props3, _ref) {
    var slots = _ref.slots;
    var _useConfigInject = useConfigInject("timeline", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var getPositionCls = function getPositionCls2(ele, idx) {
      var eleProps = ele.props || {};
      if (props3.mode === "alternate") {
        if (eleProps.position === "right")
          return "".concat(prefixCls.value, "-item-right");
        if (eleProps.position === "left")
          return "".concat(prefixCls.value, "-item-left");
        return idx % 2 === 0 ? "".concat(prefixCls.value, "-item-left") : "".concat(prefixCls.value, "-item-right");
      }
      if (props3.mode === "left")
        return "".concat(prefixCls.value, "-item-left");
      if (props3.mode === "right")
        return "".concat(prefixCls.value, "-item-right");
      if (eleProps.position === "right")
        return "".concat(prefixCls.value, "-item-right");
      return "";
    };
    return function() {
      var _slots$pending, _slots$pendingDot, _slots$default, _classNames;
      var _props$pending = props3.pending, pending = _props$pending === void 0 ? (_slots$pending = slots.pending) === null || _slots$pending === void 0 ? void 0 : _slots$pending.call(slots) : _props$pending, _props$pendingDot = props3.pendingDot, pendingDot = _props$pendingDot === void 0 ? (_slots$pendingDot = slots.pendingDot) === null || _slots$pendingDot === void 0 ? void 0 : _slots$pendingDot.call(slots) : _props$pendingDot, reverse2 = props3.reverse, mode = props3.mode;
      var pendingNode = typeof pending === "boolean" ? null : pending;
      var children = filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
      var pendingItem = pending ? createVNode(TimelineItem, {
        "pending": !!pending,
        "dot": pendingDot || createVNode(LoadingOutlined$1, null, null)
      }, {
        default: function _default9() {
          return [pendingNode];
        }
      }) : null;
      if (pendingItem) {
        children.push(pendingItem);
      }
      var timeLineItems = reverse2 ? children.reverse() : children;
      var itemsCount = timeLineItems.length;
      var lastCls = "".concat(prefixCls.value, "-item-last");
      var items = timeLineItems.map(function(ele, idx) {
        var pendingClass = idx === itemsCount - 2 ? lastCls : "";
        var readyClass = idx === itemsCount - 1 ? lastCls : "";
        return cloneVNode(ele, {
          class: classNames([!reverse2 && !!pending ? pendingClass : readyClass, getPositionCls(ele, idx)])
        });
      });
      var hasLabelItem = timeLineItems.some(function(item) {
        var _item$props, _item$children;
        return !!((_item$props = item.props) !== null && _item$props !== void 0 && _item$props.label || (_item$children = item.children) !== null && _item$children !== void 0 && _item$children.label);
      });
      var classString = classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-pending"), !!pending), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-reverse"), !!reverse2), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-").concat(mode), !!mode && !hasLabelItem), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-label"), hasLabelItem), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames));
      return createVNode("ul", {
        "class": classString
      }, [items]);
    };
  }
});
Timeline.Item = TimelineItem;
Timeline.install = function(app) {
  app.component(Timeline.name, Timeline);
  app.component(TimelineItem.name, TimelineItem);
  return app;
};
var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
const EnterOutlinedSvg = EnterOutlined$2;
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$6(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$6(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EnterOutlined = function EnterOutlined2(props3, context2) {
  var p2 = _objectSpread$6({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$6({}, p2, {
    "icon": EnterOutlinedSvg
  }), null);
};
EnterOutlined.displayName = "EnterOutlined";
EnterOutlined.inheritAttrs = false;
const EnterOutlined$1 = EnterOutlined;
var editableProps = function editableProps2() {
  return {
    prefixCls: String,
    value: String,
    maxlength: Number,
    autoSize: {
      type: [Boolean, Object]
    },
    onSave: Function,
    onCancel: Function,
    onEnd: Function,
    onChange: Function,
    originContent: String,
    direction: String
  };
};
var Editable = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Editable",
  props: editableProps(),
  setup: function setup210(props3, _ref) {
    var emit = _ref.emit, slots = _ref.slots;
    var state = reactive({
      current: props3.value || "",
      lastKeyCode: void 0,
      inComposition: false,
      cancelFlag: false
    });
    watch(function() {
      return props3.value;
    }, function(current2) {
      state.current = current2;
    });
    var textArea = ref();
    onMounted(function() {
      if (textArea.value) {
        var _textArea$value;
        var resizableTextArea = (_textArea$value = textArea.value) === null || _textArea$value === void 0 ? void 0 : _textArea$value.resizableTextArea;
        var innerTextArea = resizableTextArea === null || resizableTextArea === void 0 ? void 0 : resizableTextArea.textArea;
        innerTextArea.focus();
        var length = innerTextArea.value.length;
        innerTextArea.setSelectionRange(length, length);
      }
    });
    function saveTextAreaRef(node) {
      textArea.value = node;
    }
    function onChange3(_ref2) {
      var value = _ref2.target.value;
      state.current = value.replace(/[\r\n]/g, "");
      emit("change", state.current);
    }
    function onCompositionStart2() {
      state.inComposition = true;
    }
    function onCompositionEnd2() {
      state.inComposition = false;
    }
    function onKeyDown(e2) {
      var keyCode = e2.keyCode;
      if (keyCode === KeyCode$1.ENTER) {
        e2.preventDefault();
      }
      if (state.inComposition)
        return;
      state.lastKeyCode = keyCode;
    }
    function onKeyUp(e2) {
      var keyCode = e2.keyCode, ctrlKey = e2.ctrlKey, altKey = e2.altKey, metaKey = e2.metaKey, shiftKey = e2.shiftKey;
      if (state.lastKeyCode === keyCode && !state.inComposition && !ctrlKey && !altKey && !metaKey && !shiftKey) {
        if (keyCode === KeyCode$1.ENTER) {
          confirmChange();
          emit("end");
        } else if (keyCode === KeyCode$1.ESC) {
          state.current = props3.originContent;
          emit("cancel");
        }
      }
    }
    function onBlur2() {
      confirmChange();
    }
    function confirmChange() {
      emit("save", state.current.trim());
    }
    var textAreaClassName = computed(function() {
      var _ref3;
      return _ref3 = {}, _defineProperty$U(_ref3, "".concat(props3.prefixCls), true), _defineProperty$U(_ref3, "".concat(props3.prefixCls, "-edit-content"), true), _defineProperty$U(_ref3, "".concat(props3.prefixCls, "-rtl"), props3.direction === "rtl"), _ref3;
    });
    return function() {
      return createVNode("div", {
        "class": textAreaClassName.value
      }, [createVNode(TextArea, {
        "ref": saveTextAreaRef,
        "maxlength": props3.maxlength,
        "value": state.current,
        "onChange": onChange3,
        "onKeydown": onKeyDown,
        "onKeyup": onKeyUp,
        "onCompositionstart": onCompositionStart2,
        "onCompositionend": onCompositionEnd2,
        "onBlur": onBlur2,
        "rows": 1,
        "autoSize": props3.autoSize === void 0 || props3.autoSize
      }, null), slots.enterIcon ? slots.enterIcon({
        className: "".concat(props3.prefixCls, "-edit-content-confirm")
      }) : createVNode(EnterOutlined$1, {
        "class": "".concat(props3.prefixCls, "-edit-content-confirm")
      }, null)]);
    };
  }
});
const Editable$1 = Editable;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var ellipsisContainer;
var wrapperStyle = {
  padding: 0,
  margin: 0,
  display: "inline",
  lineHeight: "inherit"
};
function styleToString(style2) {
  var styleNames = Array.prototype.slice.apply(style2);
  return styleNames.map(function(name2) {
    return "".concat(name2, ": ").concat(style2.getPropertyValue(name2), ";");
  }).join("");
}
function resetDomStyles(target, origin) {
  target.setAttribute("aria-hidden", "true");
  var originStyle = window.getComputedStyle(origin);
  var originCSS = styleToString(originStyle);
  target.setAttribute("style", originCSS);
  target.style.position = "fixed";
  target.style.left = "0";
  target.style.height = "auto";
  target.style.minHeight = "auto";
  target.style.maxHeight = "auto";
  target.style.paddingTop = "0";
  target.style.paddingBottom = "0";
  target.style.borderTopWidth = "0";
  target.style.borderBottomWidth = "0";
  target.style.top = "-999999px";
  target.style.zIndex = "-1000";
  target.style.textOverflow = "clip";
  target.style.whiteSpace = "normal";
  target.style.webkitLineClamp = "none";
}
function getRealLineHeight(originElement) {
  var heightContainer = document.createElement("div");
  resetDomStyles(heightContainer, originElement);
  heightContainer.appendChild(document.createTextNode("text"));
  document.body.appendChild(heightContainer);
  var realHeight = heightContainer.getBoundingClientRect().height;
  document.body.removeChild(heightContainer);
  return realHeight;
}
const measure = function(originElement, option, content, fixedContent, ellipsisStr) {
  if (!ellipsisContainer) {
    ellipsisContainer = document.createElement("div");
    ellipsisContainer.setAttribute("aria-hidden", "true");
    document.body.appendChild(ellipsisContainer);
  }
  var rows = option.rows, _option$suffix = option.suffix, suffix = _option$suffix === void 0 ? "" : _option$suffix;
  var lineHeight = getRealLineHeight(originElement);
  var maxHeight = Math.round(lineHeight * rows * 100) / 100;
  resetDomStyles(ellipsisContainer, originElement);
  var vm = createApp({
    render: function render14() {
      return createVNode("div", {
        "style": wrapperStyle
      }, [createVNode("span", {
        "style": wrapperStyle
      }, [content, suffix]), createVNode("span", {
        "style": wrapperStyle
      }, [fixedContent])]);
    }
  });
  vm.mount(ellipsisContainer);
  function inRange() {
    var currentHeight = Math.round(ellipsisContainer.getBoundingClientRect().height * 100) / 100;
    return currentHeight - 0.1 <= maxHeight;
  }
  if (inRange()) {
    vm.unmount();
    return {
      content,
      text: ellipsisContainer.innerHTML,
      ellipsis: false
    };
  }
  var childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(function(_ref) {
    var nodeType = _ref.nodeType, data9 = _ref.data;
    return nodeType !== COMMENT_NODE && data9 !== "";
  });
  var fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);
  vm.unmount();
  var ellipsisChildren = [];
  ellipsisContainer.innerHTML = "";
  var ellipsisContentHolder = document.createElement("span");
  ellipsisContainer.appendChild(ellipsisContentHolder);
  var ellipsisTextNode = document.createTextNode(ellipsisStr + suffix);
  ellipsisContentHolder.appendChild(ellipsisTextNode);
  fixedNodes.forEach(function(childNode) {
    ellipsisContainer.appendChild(childNode);
  });
  function appendChildNode(node) {
    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);
  }
  function measureText(textNode, fullText) {
    var startLoc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var endLoc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fullText.length;
    var lastSuccessLoc = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var midLoc = Math.floor((startLoc + endLoc) / 2);
    var currentText = fullText.slice(0, midLoc);
    textNode.textContent = currentText;
    if (startLoc >= endLoc - 1) {
      for (var step = endLoc; step >= startLoc; step -= 1) {
        var currentStepText = fullText.slice(0, step);
        textNode.textContent = currentStepText;
        if (inRange() || !currentStepText) {
          return step === fullText.length ? {
            finished: false,
            vNode: fullText
          } : {
            finished: true,
            vNode: currentStepText
          };
        }
      }
    }
    if (inRange()) {
      return measureText(textNode, fullText, midLoc, endLoc, midLoc);
    }
    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);
  }
  function measureNode(childNode) {
    var type4 = childNode.nodeType;
    if (type4 === TEXT_NODE) {
      var fullText = childNode.textContent || "";
      var textNode = document.createTextNode(fullText);
      appendChildNode(textNode);
      return measureText(textNode, fullText);
    }
    return {
      finished: false,
      vNode: null
    };
  }
  childNodes.some(function(childNode) {
    var _measureNode = measureNode(childNode), finished = _measureNode.finished, vNode = _measureNode.vNode;
    if (vNode) {
      ellipsisChildren.push(vNode);
    }
    return finished;
  });
  return {
    content: ellipsisChildren,
    text: ellipsisContainer.innerHTML,
    ellipsis: true
  };
};
var _excluded$6 = ["prefixCls", "class", "direction", "component"];
var typographyProps = function typographyProps2() {
  return {
    prefixCls: String,
    direction: String,
    component: String
  };
};
var Typography = defineComponent({
  name: "ATypography",
  inheritAttrs: false,
  props: typographyProps(),
  setup: function setup211(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var _useConfigInject = useConfigInject("typography", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    return function() {
      var _slots$default;
      var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs);
      _props$attrs.prefixCls;
      _props$attrs.class;
      _props$attrs.direction;
      var _props$attrs$componen = _props$attrs.component, Component = _props$attrs$componen === void 0 ? "article" : _props$attrs$componen, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$6);
      return createVNode(Component, _objectSpread2$1({
        "class": classNames(prefixCls.value, _defineProperty$U({}, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), attrs.class)
      }, restProps), {
        default: function _default9() {
          return [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
        }
      });
    };
  }
});
const Typography$1 = Typography;
var deselectCurrent$1 = function deselectCurrent() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
const deselectCurrent$2 = deselectCurrent$1;
var clipboardToIE11Formatting$1 = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
};
var defaultMessage$1 = "Copy to clipboard: #{key}, Enter";
function format$5(message2) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message2.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text, options) {
  var message2, reselectPrevious, range3, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  var debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent$2();
    range3 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var _format = clipboardToIE11Formatting$1[options.format] || clipboardToIE11Formatting$1["default"];
          window.clipboardData.setData(_format, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range3.selectNodeContents(mark);
    selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message2 = format$5("message" in options ? options.message : defaultMessage$1);
      window.prompt(message2, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
const CopyOutlinedSvg = CopyOutlined$2;
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$5(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$5(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CopyOutlined = function CopyOutlined2(props3, context2) {
  var p2 = _objectSpread$5({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$5({}, p2, {
    "icon": CopyOutlinedSvg
  }), null);
};
CopyOutlined.displayName = "CopyOutlined";
CopyOutlined.inheritAttrs = false;
const CopyOutlined$1 = CopyOutlined;
var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
const EditOutlinedSvg = EditOutlined$2;
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$4(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$4(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var EditOutlined = function EditOutlined2(props3, context2) {
  var p2 = _objectSpread$4({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$4({}, p2, {
    "icon": EditOutlinedSvg
  }), null);
};
EditOutlined.displayName = "EditOutlined";
EditOutlined.inheritAttrs = false;
const EditOutlined$1 = EditOutlined;
var _excluded$5 = ["type", "disabled", "content", "class", "style"];
var isLineClampSupport = isStyleSupport("webkitLineClamp");
var isTextOverflowSupport = isStyleSupport("textOverflow");
var ELLIPSIS_STR = "...";
var baseProps = function baseProps2() {
  return {
    editable: {
      type: [Boolean, Object],
      default: void 0
    },
    copyable: {
      type: [Boolean, Object],
      default: void 0
    },
    prefixCls: String,
    component: String,
    type: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    ellipsis: {
      type: [Boolean, Object],
      default: void 0
    },
    code: {
      type: Boolean,
      default: void 0
    },
    mark: {
      type: Boolean,
      default: void 0
    },
    underline: {
      type: Boolean,
      default: void 0
    },
    delete: {
      type: Boolean,
      default: void 0
    },
    strong: {
      type: Boolean,
      default: void 0
    },
    keyboard: {
      type: Boolean,
      default: void 0
    },
    content: String,
    "onUpdate:content": Function
  };
};
var Base = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Base",
  inheritAttrs: false,
  props: baseProps(),
  setup: function setup212(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit = _ref.emit;
    var _useConfigInject = useConfigInject("typography", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var state = reactive({
      copied: false,
      ellipsisText: "",
      ellipsisContent: null,
      isEllipsis: false,
      expanded: false,
      clientRendered: false,
      expandStr: "",
      copyStr: "",
      copiedStr: "",
      editStr: "",
      copyId: void 0,
      rafId: void 0,
      prevProps: void 0,
      originContent: ""
    });
    var contentRef = ref();
    var editIcon = ref();
    var ellipsis = computed(function() {
      var ellipsis2 = props3.ellipsis;
      if (!ellipsis2)
        return {};
      return _objectSpread2$1({
        rows: 1,
        expandable: false
      }, _typeof$3(ellipsis2) === "object" ? ellipsis2 : null);
    });
    onMounted(function() {
      state.clientRendered = true;
    });
    onBeforeUnmount(function() {
      clearTimeout(state.copyId);
      wrapperRaf.cancel(state.rafId);
    });
    watch([function() {
      return ellipsis.value.rows;
    }, function() {
      return props3.content;
    }], function() {
      nextTick(function() {
        resizeOnNextFrame();
      });
    }, {
      flush: "post",
      deep: true,
      immediate: true
    });
    watchEffect(function() {
      if (props3.content === void 0) {
        warning$2(!props3.editable, "Typography", "When `editable` is enabled, please use `content` instead of children");
        warning$2(!props3.ellipsis, "Typography", "When `ellipsis` is enabled, please use `content` instead of children");
      }
    });
    function getChildrenText() {
      var _contentRef$value, _contentRef$value$$el;
      return props3.ellipsis || props3.editable ? props3.content : (_contentRef$value = contentRef.value) === null || _contentRef$value === void 0 ? void 0 : (_contentRef$value$$el = _contentRef$value.$el) === null || _contentRef$value$$el === void 0 ? void 0 : _contentRef$value$$el.innerText;
    }
    function onExpandClick(e2) {
      var onExpand = ellipsis.value.onExpand;
      state.expanded = true;
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(e2);
    }
    function onEditClick(e2) {
      e2.preventDefault();
      state.originContent = props3.content;
      triggerEdit(true);
    }
    function onEditChange(value) {
      onContentChange(value);
      triggerEdit(false);
    }
    function onContentChange(value) {
      var onChange3 = editable.value.onChange;
      if (value !== props3.content) {
        emit("update:content", value);
        onChange3 === null || onChange3 === void 0 ? void 0 : onChange3(value);
      }
    }
    function onEditCancel() {
      var _editable$value$onCan, _editable$value;
      (_editable$value$onCan = (_editable$value = editable.value).onCancel) === null || _editable$value$onCan === void 0 ? void 0 : _editable$value$onCan.call(_editable$value);
      triggerEdit(false);
    }
    function onCopyClick(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      var copyable = props3.copyable;
      var copyConfig = _objectSpread2$1({}, _typeof$3(copyable) === "object" ? copyable : null);
      if (copyConfig.text === void 0) {
        copyConfig.text = getChildrenText();
      }
      copy$1(copyConfig.text || "");
      state.copied = true;
      nextTick(function() {
        if (copyConfig.onCopy) {
          copyConfig.onCopy();
        }
        state.copyId = setTimeout(function() {
          state.copied = false;
        }, 3e3);
      });
    }
    var editable = computed(function() {
      var editable2 = props3.editable;
      if (!editable2)
        return {
          editing: false
        };
      return _objectSpread2$1({}, _typeof$3(editable2) === "object" ? editable2 : null);
    });
    var _useMergedState = useMergedState(false, {
      value: computed(function() {
        return editable.value.editing;
      })
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), editing = _useMergedState2[0], setEditing = _useMergedState2[1];
    function triggerEdit(edit) {
      var onStart3 = editable.value.onStart;
      if (edit && onStart3) {
        onStart3();
      }
      setEditing(edit);
    }
    watch(editing, function(val) {
      if (!val) {
        var _editIcon$value;
        (_editIcon$value = editIcon.value) === null || _editIcon$value === void 0 ? void 0 : _editIcon$value.focus();
      }
    }, {
      flush: "post"
    });
    function resizeOnNextFrame() {
      wrapperRaf.cancel(state.rafId);
      state.rafId = wrapperRaf(function() {
        syncEllipsis();
      });
    }
    var canUseCSSEllipsis = computed(function() {
      var _ellipsis$value = ellipsis.value, rows = _ellipsis$value.rows, expandable = _ellipsis$value.expandable, suffix = _ellipsis$value.suffix, onEllipsis = _ellipsis$value.onEllipsis, tooltip = _ellipsis$value.tooltip;
      if (suffix || tooltip)
        return false;
      if (props3.editable || props3.copyable || expandable || onEllipsis) {
        return false;
      }
      if (rows === 1) {
        return isTextOverflowSupport;
      }
      return isLineClampSupport;
    });
    var syncEllipsis = function syncEllipsis2() {
      var _contentRef$value2, _contentRef$value3;
      var ellipsisText = state.ellipsisText, isEllipsis = state.isEllipsis;
      var _ellipsis$value2 = ellipsis.value, rows = _ellipsis$value2.rows, suffix = _ellipsis$value2.suffix, onEllipsis = _ellipsis$value2.onEllipsis;
      if (!rows || rows < 0 || !((_contentRef$value2 = contentRef.value) !== null && _contentRef$value2 !== void 0 && _contentRef$value2.$el) || state.expanded || props3.content === void 0)
        return;
      if (canUseCSSEllipsis.value)
        return;
      var _measure = measure((_contentRef$value3 = contentRef.value) === null || _contentRef$value3 === void 0 ? void 0 : _contentRef$value3.$el, {
        rows,
        suffix
      }, props3.content, renderOperations(true), ELLIPSIS_STR), content = _measure.content, text = _measure.text, ell = _measure.ellipsis;
      if (ellipsisText !== text || state.isEllipsis !== ell) {
        state.ellipsisText = text;
        state.ellipsisContent = content;
        state.isEllipsis = ell;
        if (isEllipsis !== ell && onEllipsis) {
          onEllipsis(ell);
        }
      }
    };
    function wrapperDecorations(_ref2, content) {
      var mark = _ref2.mark, code = _ref2.code, underline = _ref2.underline, del = _ref2.delete, strong = _ref2.strong, keyboard = _ref2.keyboard;
      var currentContent = content;
      function wrap(needed, Tag2) {
        if (!needed)
          return;
        var _currentContent = function() {
          return currentContent;
        }();
        currentContent = createVNode(Tag2, null, {
          default: function _default9() {
            return [_currentContent];
          }
        });
      }
      wrap(strong, "strong");
      wrap(underline, "u");
      wrap(del, "del");
      wrap(code, "code");
      wrap(mark, "mark");
      wrap(keyboard, "kbd");
      return currentContent;
    }
    function renderExpand(forceRender) {
      var _ellipsis$value3 = ellipsis.value, expandable = _ellipsis$value3.expandable, symbol = _ellipsis$value3.symbol;
      if (!expandable)
        return null;
      if (!forceRender && (state.expanded || !state.isEllipsis))
        return null;
      var expandContent = (slots.ellipsisSymbol ? slots.ellipsisSymbol() : symbol) || state.expandStr;
      return createVNode("a", {
        "key": "expand",
        "class": "".concat(prefixCls.value, "-expand"),
        "onClick": onExpandClick,
        "aria-label": state.expandStr
      }, [expandContent]);
    }
    function renderEdit() {
      if (!props3.editable)
        return;
      var _props$editable = props3.editable, tooltip = _props$editable.tooltip, _props$editable$trigg = _props$editable.triggerType, triggerType = _props$editable$trigg === void 0 ? ["icon"] : _props$editable$trigg;
      var icon = slots.editableIcon ? slots.editableIcon() : createVNode(EditOutlined$1, {
        "role": "button"
      }, null);
      var title = slots.editableTooltip ? slots.editableTooltip() : state.editStr;
      var ariaLabel = typeof title === "string" ? title : "";
      return triggerType.indexOf("icon") !== -1 ? createVNode(Tooltip, {
        "key": "edit",
        "title": tooltip === false ? "" : title
      }, {
        default: function _default9() {
          return [createVNode(TransButton$1, {
            "ref": editIcon,
            "class": "".concat(prefixCls.value, "-edit"),
            "onClick": onEditClick,
            "aria-label": ariaLabel
          }, {
            default: function _default10() {
              return [icon];
            }
          })];
        }
      }) : null;
    }
    function renderCopy() {
      if (!props3.copyable)
        return;
      var tooltip = props3.copyable.tooltip;
      var defaultTitle2 = state.copied ? state.copiedStr : state.copyStr;
      var title = slots.copyableTooltip ? slots.copyableTooltip({
        copied: state.copied
      }) : defaultTitle2;
      var ariaLabel = typeof title === "string" ? title : "";
      var defaultIcon = state.copied ? createVNode(CheckOutlined$1, null, null) : createVNode(CopyOutlined$1, null, null);
      var icon = slots.copyableIcon ? slots.copyableIcon({
        copied: !!state.copied
      }) : defaultIcon;
      return createVNode(Tooltip, {
        "key": "copy",
        "title": tooltip === false ? "" : title
      }, {
        default: function _default9() {
          return [createVNode(TransButton$1, {
            "class": ["".concat(prefixCls.value, "-copy"), _defineProperty$U({}, "".concat(prefixCls.value, "-copy-success"), state.copied)],
            "onClick": onCopyClick,
            "aria-label": ariaLabel
          }, {
            default: function _default10() {
              return [icon];
            }
          })];
        }
      });
    }
    function renderEditInput() {
      var className = attrs.class, style2 = attrs.style;
      var _editable$value2 = editable.value, maxlength = _editable$value2.maxlength, autoSize = _editable$value2.autoSize, onEnd3 = _editable$value2.onEnd;
      return createVNode(Editable$1, {
        "class": className,
        "style": style2,
        "prefixCls": prefixCls.value,
        "value": props3.content,
        "originContent": state.originContent,
        "maxlength": maxlength,
        "autoSize": autoSize,
        "onSave": onEditChange,
        "onChange": onContentChange,
        "onCancel": onEditCancel,
        "onEnd": onEnd3,
        "direction": direction.value
      }, {
        enterIcon: slots.editableEnterIcon
      });
    }
    function renderOperations(forceRenderExpanded) {
      return [renderExpand(forceRenderExpanded), renderEdit(), renderCopy()].filter(function(node) {
        return node;
      });
    }
    return function() {
      var _slots$default;
      var _editable$value$trigg = editable.value.triggerType, triggerType = _editable$value$trigg === void 0 ? ["icon"] : _editable$value$trigg;
      var _children = props3.ellipsis || props3.editable ? props3.content !== void 0 ? props3.content : (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots) : slots.default ? slots.default() : props3.content;
      if (editing.value) {
        return renderEditInput();
      }
      return createVNode(LocaleReceiver, {
        "componentName": "Text",
        "children": function children(locale2) {
          var _ref4;
          var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), type4 = _props$attrs.type, disabled = _props$attrs.disabled;
          _props$attrs.content;
          var className = _props$attrs.class, style2 = _props$attrs.style, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$5);
          var _ellipsis$value4 = ellipsis.value, rows = _ellipsis$value4.rows, suffix = _ellipsis$value4.suffix, tooltip = _ellipsis$value4.tooltip;
          var edit = locale2.edit, copyStr = locale2.copy, copied = locale2.copied, expand = locale2.expand;
          state.editStr = edit;
          state.copyStr = copyStr;
          state.copiedStr = copied;
          state.expandStr = expand;
          var textProps3 = omit$2(restProps, ["prefixCls", "editable", "copyable", "ellipsis", "mark", "code", "delete", "underline", "strong", "keyboard", "onUpdate:content"]);
          var cssEllipsis = canUseCSSEllipsis.value;
          var cssTextOverflow = rows === 1 && cssEllipsis;
          var cssLineClamp = rows && rows > 1 && cssEllipsis;
          var textNode = _children;
          var ariaLabel;
          if (rows && state.isEllipsis && !state.expanded && !cssEllipsis) {
            var _restContent;
            var _title = restProps.title;
            var restContent = _title || "";
            if (!_title && (typeof _children === "string" || typeof _children === "number")) {
              restContent = String(_children);
            }
            restContent = (_restContent = restContent) === null || _restContent === void 0 ? void 0 : _restContent.slice(String(state.ellipsisContent || "").length);
            textNode = createVNode(Fragment, null, [toRaw(state.ellipsisContent), createVNode("span", {
              "title": restContent,
              "aria-hidden": "true"
            }, [ELLIPSIS_STR]), suffix]);
          } else {
            textNode = createVNode(Fragment, null, [_children, suffix]);
          }
          textNode = wrapperDecorations(props3, textNode);
          var showTooltip = tooltip && rows && state.isEllipsis && !state.expanded && !cssEllipsis;
          var title = slots.ellipsisTooltip ? slots.ellipsisTooltip() : tooltip;
          return createVNode(ResizeObserver$1, {
            "onResize": resizeOnNextFrame,
            "disabled": !rows
          }, {
            default: function _default9() {
              return [createVNode(Typography$1, _objectSpread2$1({
                "ref": contentRef,
                "class": [(_ref4 = {}, _defineProperty$U(_ref4, "".concat(prefixCls.value, "-").concat(type4), type4), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-ellipsis"), rows), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-single-line"), rows === 1 && !state.isEllipsis), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-ellipsis-single-line"), cssTextOverflow), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-ellipsis-multiple-line"), cssLineClamp), _ref4), className],
                "style": _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
                  WebkitLineClamp: cssLineClamp ? rows : void 0
                }),
                "aria-label": ariaLabel,
                "direction": direction.value,
                "onClick": triggerType.indexOf("text") !== -1 ? onEditClick : function() {
                }
              }, textProps3), {
                default: function _default10() {
                  return [showTooltip ? createVNode(Tooltip, {
                    "title": tooltip === true ? _children : title
                  }, {
                    default: function _default11() {
                      return [createVNode("span", null, [textNode])];
                    }
                  }) : textNode, renderOperations()];
                }
              })];
            }
          });
        }
      }, null);
    };
  }
});
const Base$1 = Base;
var _excluded$4 = ["ellipsis", "rel"];
var linkProps = function linkProps2() {
  return omit$2(_objectSpread2$1(_objectSpread2$1({}, baseProps()), {}, {
    ellipsis: {
      type: Boolean,
      default: void 0
    }
  }), ["component"]);
};
var Link = function Link2(props3, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  var _props$attrs = _objectSpread2$1(_objectSpread2$1({}, props3), attrs), ellipsis = _props$attrs.ellipsis, rel = _props$attrs.rel, restProps = _objectWithoutProperties$2(_props$attrs, _excluded$4);
  warning$2(_typeof$3(ellipsis) !== "object", "Typography.Link", "`ellipsis` only supports boolean value.");
  var mergedProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel,
    ellipsis: !!ellipsis,
    component: "a"
  });
  delete mergedProps.navigate;
  return createVNode(Base$1, mergedProps, slots);
};
Link.displayName = "ATypographyLink";
Link.inheritAttrs = false;
Link.props = linkProps();
const Link$1 = Link;
var paragraphProps = function paragraphProps2() {
  return omit$2(baseProps(), ["component"]);
};
var Paragraph = function Paragraph2(props3, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  var paragraphProps3 = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    component: "div"
  }, attrs);
  return createVNode(Base$1, paragraphProps3, slots);
};
Paragraph.displayName = "ATypographyParagraph";
Paragraph.inheritAttrs = false;
Paragraph.props = paragraphProps();
const Paragraph$1 = Paragraph;
var textProps = function textProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseProps(), ["component"])), {}, {
    ellipsis: {
      type: [Boolean, Object],
      default: void 0
    }
  });
};
var Text = function Text2(props3, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  var ellipsis = props3.ellipsis;
  warning$2(_typeof$3(ellipsis) !== "object" || !ellipsis || !("expandable" in ellipsis) && !("rows" in ellipsis), "Typography.Text", "`ellipsis` do not support `expandable` or `rows` props.");
  var textProps3 = _objectSpread2$1(_objectSpread2$1({}, props3), {}, {
    ellipsis: ellipsis && _typeof$3(ellipsis) === "object" ? omit$2(ellipsis, ["expandable", "rows"]) : ellipsis,
    component: "span"
  }, attrs);
  return createVNode(Base$1, textProps3, slots);
};
Text.displayName = "ATypographyText";
Text.inheritAttrs = false;
Text.props = textProps();
const Text$1 = Text;
var _excluded$3 = ["level"];
var TITLE_ELE_LIST = tupleNum(1, 2, 3, 4, 5);
var titleProps = function titleProps2() {
  return _objectSpread2$1(_objectSpread2$1({}, omit$2(baseProps(), ["component", "strong"])), {}, {
    level: Number
  });
};
var Title = function Title2(props3, _ref) {
  var slots = _ref.slots, attrs = _ref.attrs;
  var _props$level = props3.level, level = _props$level === void 0 ? 1 : _props$level, restProps = _objectWithoutProperties$2(props3, _excluded$3);
  var component;
  if (TITLE_ELE_LIST.indexOf(level) !== -1) {
    component = "h".concat(level);
  } else {
    warning$2(false, "Typography", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value.");
    component = "h1";
  }
  var titleProps3 = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
    component
  }, attrs);
  return createVNode(Base$1, titleProps3, slots);
};
Title.displayName = "ATypographyTitle";
Title.inheritAttrs = false;
Title.props = titleProps();
const Title$1 = Title;
Typography$1.Text = Text$1;
Typography$1.Title = Title$1;
Typography$1.Paragraph = Paragraph$1;
Typography$1.Link = Link$1;
Typography$1.Base = Base$1;
Typography$1.install = function(app) {
  app.component(Typography$1.name, Typography$1);
  app.component(Typography$1.Text.displayName, Text$1);
  app.component(Typography$1.Title.displayName, Title$1);
  app.component(Typography$1.Paragraph.displayName, Paragraph$1);
  app.component(Typography$1.Link.displayName, Link$1);
  return app;
};
function getError(option, xhr2) {
  var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr2.status, "'");
  var err = new Error(msg);
  err.status = xhr2.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}
function getBody(xhr2) {
  var text = xhr2.responseText || xhr2.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e2) {
    return text;
  }
}
function upload(option) {
  var xhr2 = new XMLHttpRequest();
  if (option.onProgress && xhr2.upload) {
    xhr2.upload.onprogress = function progress(e2) {
      if (e2.total > 0) {
        e2.percent = e2.loaded / e2.total * 100;
      }
      option.onProgress(e2);
    };
  }
  var formData = new FormData();
  if (option.data) {
    Object.keys(option.data).forEach(function(key2) {
      var value = option.data[key2];
      if (Array.isArray(value)) {
        value.forEach(function(item) {
          formData.append("".concat(key2, "[]"), item);
        });
        return;
      }
      formData.append(key2, value);
    });
  }
  if (option.file instanceof Blob) {
    formData.append(option.filename, option.file, option.file.name);
  } else {
    formData.append(option.filename, option.file);
  }
  xhr2.onerror = function error(e2) {
    option.onError(e2);
  };
  xhr2.onload = function onload() {
    if (xhr2.status < 200 || xhr2.status >= 300) {
      return option.onError(getError(option, xhr2), getBody(xhr2));
    }
    return option.onSuccess(getBody(xhr2), xhr2);
  };
  xhr2.open(option.method, option.action, true);
  if (option.withCredentials && "withCredentials" in xhr2) {
    xhr2.withCredentials = true;
  }
  var headers = option.headers || {};
  if (headers["X-Requested-With"] !== null) {
    xhr2.setRequestHeader("X-Requested-With", "XMLHttpRequest");
  }
  Object.keys(headers).forEach(function(h2) {
    if (headers[h2] !== null) {
      xhr2.setRequestHeader(h2, headers[h2]);
    }
  });
  xhr2.send(formData);
  return {
    abort: function abort() {
      xhr2.abort();
    }
  };
}
var now = +new Date();
var index$2 = 0;
function uid() {
  return "vc-upload-".concat(now, "-").concat(++index$2);
}
const attrAccept = function(file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
    var fileName = file.name || "";
    var mimeType = file.type || "";
    var baseMimeType = mimeType.replace(/\/.*$/, "");
    return acceptedFilesArray.some(function(type4) {
      var validType = type4.trim();
      if (/^\*(\/\*)?$/.test(type4)) {
        return true;
      }
      if (validType.charAt(0) === ".") {
        var lowerFileName = fileName.toLowerCase();
        var lowerType = validType.toLowerCase();
        var affixList = [lowerType];
        if (lowerType === ".jpg" || lowerType === ".jpeg") {
          affixList = [".jpg", ".jpeg"];
        }
        return affixList.some(function(affix) {
          return lowerFileName.endsWith(affix);
        });
      }
      if (/\/\*$/.test(validType)) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      if (mimeType === validType) {
        return true;
      }
      if (/^\w+$/.test(validType)) {
        return true;
      }
      return false;
    });
  }
  return true;
};
function loopFiles(item, callback) {
  var dirReader = item.createReader();
  var fileList = [];
  function sequence() {
    dirReader.readEntries(function(entries) {
      var entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList);
      var isFinished = !entryList.length;
      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }
  sequence();
}
var traverseFileTree = function traverseFileTree2(files, callback, isAccepted) {
  var _traverseFileTree = function _traverseFileTree2(item, path2) {
    item.path = path2 || "";
    if (item.isFile) {
      item.file(function(file) {
        if (isAccepted(file)) {
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, "");
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }
          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, function(entries) {
        entries.forEach(function(entryItem) {
          _traverseFileTree2(entryItem, "".concat(path2).concat(item.name, "/"));
        });
      });
    }
  };
  files.forEach(function(file) {
    _traverseFileTree(file.webkitGetAsEntry());
  });
};
const traverseFileTree$1 = traverseFileTree;
var uploadProps$1 = function uploadProps() {
  return {
    capture: [Boolean, String],
    multipart: {
      type: Boolean,
      default: void 0
    },
    name: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    componentTag: String,
    action: [String, Function],
    method: String,
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    headers: Object,
    accept: String,
    multiple: {
      type: Boolean,
      default: void 0
    },
    onBatchStart: Function,
    onReject: Function,
    onStart: Function,
    onError: Function,
    onSuccess: Function,
    onProgress: Function,
    beforeUpload: Function,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    id: String,
    onMouseenter: Function,
    onMouseleave: Function,
    onClick: Function
  };
};
function arrayAggregator(array4, setter, iteratee, accumulator) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    var value = array4[index2];
    setter(accumulator, value, iteratee(value), array4);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object4, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object4), props3 = keysFunc(object4), length = props3.length;
    while (length--) {
      var key2 = props3[fromRight ? length : ++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object4;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(object4, iteratee) {
  return object4 && baseFor$1(object4, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
const baseEach$1 = baseEach;
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$1(collection, function(value, key2, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$a(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
var partition = createAggregator(function(result, value, key2) {
  result[key2 ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
const partition$1 = partition;
var _excluded$2 = ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"];
const AjaxUpload = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: false,
  props: uploadProps$1(),
  setup: function setup213(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var uid$12 = ref(uid());
    var reqs = {};
    var fileInput = ref();
    var isMounted = false;
    var processFile = /* @__PURE__ */ function() {
      var _ref2 = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(file, fileList) {
        var beforeUpload, transformedFile, action, mergedAction, data9, mergedData, parsedData, parsedFile, mergedParsedFile;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beforeUpload = props3.beforeUpload;
                transformedFile = file;
                if (!beforeUpload) {
                  _context.next = 14;
                  break;
                }
                _context.prev = 3;
                _context.next = 6;
                return beforeUpload(file, fileList);
              case 6:
                transformedFile = _context.sent;
                _context.next = 12;
                break;
              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](3);
                transformedFile = false;
              case 12:
                if (!(transformedFile === false)) {
                  _context.next = 14;
                  break;
                }
                return _context.abrupt("return", {
                  origin: file,
                  parsedFile: null,
                  action: null,
                  data: null
                });
              case 14:
                action = props3.action;
                if (!(typeof action === "function")) {
                  _context.next = 21;
                  break;
                }
                _context.next = 18;
                return action(file);
              case 18:
                mergedAction = _context.sent;
                _context.next = 22;
                break;
              case 21:
                mergedAction = action;
              case 22:
                data9 = props3.data;
                if (!(typeof data9 === "function")) {
                  _context.next = 29;
                  break;
                }
                _context.next = 26;
                return data9(file);
              case 26:
                mergedData = _context.sent;
                _context.next = 30;
                break;
              case 29:
                mergedData = data9;
              case 30:
                parsedData = (_typeof$3(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
                if (parsedData instanceof File) {
                  parsedFile = parsedData;
                } else {
                  parsedFile = new File([parsedData], file.name, {
                    type: file.type
                  });
                }
                mergedParsedFile = parsedFile;
                mergedParsedFile.uid = file.uid;
                return _context.abrupt("return", {
                  origin: file,
                  data: mergedData,
                  parsedFile: mergedParsedFile,
                  action: mergedAction
                });
              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 9]]);
      }));
      return function processFile2(_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var post = function post2(_ref3) {
      var data9 = _ref3.data, origin = _ref3.origin, action = _ref3.action, parsedFile = _ref3.parsedFile;
      if (!isMounted) {
        return;
      }
      var onStart3 = props3.onStart, customRequest = props3.customRequest, name2 = props3.name, headers = props3.headers, withCredentials = props3.withCredentials, method4 = props3.method;
      var uid2 = origin.uid;
      var request2 = customRequest || upload;
      var requestOption = {
        action,
        filename: name2,
        data: data9,
        file: parsedFile,
        headers,
        withCredentials,
        method: method4 || "post",
        onProgress: function onProgress(e2) {
          var onProgress2 = props3.onProgress;
          onProgress2 === null || onProgress2 === void 0 ? void 0 : onProgress2(e2, parsedFile);
        },
        onSuccess: function onSuccess(ret, xhr2) {
          var onSuccess2 = props3.onSuccess;
          onSuccess2 === null || onSuccess2 === void 0 ? void 0 : onSuccess2(ret, parsedFile, xhr2);
          delete reqs[uid2];
        },
        onError: function onError(err, ret) {
          var onError2 = props3.onError;
          onError2 === null || onError2 === void 0 ? void 0 : onError2(err, ret, parsedFile);
          delete reqs[uid2];
        }
      };
      onStart3(origin);
      reqs[uid2] = request2(requestOption);
    };
    var reset = function reset2() {
      uid$12.value = uid();
    };
    var abort = function abort2(file) {
      if (file) {
        var _uid = file.uid ? file.uid : file;
        if (reqs[_uid] && reqs[_uid].abort) {
          reqs[_uid].abort();
        }
        delete reqs[_uid];
      } else {
        Object.keys(reqs).forEach(function(uid2) {
          if (reqs[uid2] && reqs[uid2].abort) {
            reqs[uid2].abort();
          }
          delete reqs[uid2];
        });
      }
    };
    onMounted(function() {
      isMounted = true;
    });
    onBeforeUnmount(function() {
      isMounted = false;
      abort();
    });
    var uploadFiles = function uploadFiles2(files) {
      var originFiles = _toConsumableArray(files);
      var postFiles = originFiles.map(function(file) {
        file.uid = uid();
        return processFile(file, originFiles);
      });
      Promise.all(postFiles).then(function(fileList) {
        var onBatchStart = props3.onBatchStart;
        onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map(function(_ref4) {
          var origin = _ref4.origin, parsedFile = _ref4.parsedFile;
          return {
            file: origin,
            parsedFile
          };
        }));
        fileList.filter(function(file) {
          return file.parsedFile !== null;
        }).forEach(function(file) {
          post(file);
        });
      });
    };
    var onChange3 = function onChange4(e2) {
      var accept = props3.accept, directory = props3.directory;
      var files = e2.target.files;
      var acceptedFiles = _toConsumableArray(files).filter(function(file) {
        return !directory || attrAccept(file, accept);
      });
      uploadFiles(acceptedFiles);
      reset();
    };
    var onClick2 = function onClick3(e2) {
      var el = fileInput.value;
      if (!el) {
        return;
      }
      var onClick4 = props3.onClick;
      el.click();
      if (onClick4) {
        onClick4(e2);
      }
    };
    var onKeyDown = function onKeyDown2(e2) {
      if (e2.key === "Enter") {
        onClick2(e2);
      }
    };
    var onFileDrop = function onFileDrop2(e2) {
      var multiple = props3.multiple;
      e2.preventDefault();
      if (e2.type === "dragover") {
        return;
      }
      if (props3.directory) {
        traverseFileTree$1(Array.prototype.slice.call(e2.dataTransfer.items), uploadFiles, function(_file) {
          return attrAccept(_file, props3.accept);
        });
      } else {
        var files = partition$1(Array.prototype.slice.call(e2.dataTransfer.files), function(file) {
          return attrAccept(file, props3.accept);
        });
        var successFiles = files[0];
        var errorFiles = files[1];
        if (multiple === false) {
          successFiles = successFiles.slice(0, 1);
        }
        uploadFiles(successFiles);
        if (errorFiles.length && props3.onReject)
          props3.onReject(errorFiles);
      }
    };
    expose({
      abort
    });
    return function() {
      var _cls, _slots$default;
      var Tag2 = props3.componentTag, prefixCls = props3.prefixCls, disabled = props3.disabled, id = props3.id, multiple = props3.multiple, accept = props3.accept, capture = props3.capture, directory = props3.directory, openFileDialogOnClick = props3.openFileDialogOnClick, onMouseenter2 = props3.onMouseenter, onMouseleave2 = props3.onMouseleave, otherProps = _objectWithoutProperties$2(props3, _excluded$2);
      var cls = (_cls = {}, _defineProperty$U(_cls, prefixCls, true), _defineProperty$U(_cls, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$U(_cls, attrs.class, !!attrs.class), _cls);
      var dirProps = directory ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      var events2 = disabled ? {} : {
        onClick: openFileDialogOnClick ? onClick2 : function() {
        },
        onKeydown: openFileDialogOnClick ? onKeyDown : function() {
        },
        onMouseenter: onMouseenter2,
        onMouseleave: onMouseleave2,
        onDrop: onFileDrop,
        onDragover: onFileDrop,
        tabindex: "0"
      };
      return createVNode(Tag2, _objectSpread2$1(_objectSpread2$1({}, events2), {}, {
        "class": cls,
        "role": "button",
        "style": attrs.style
      }), {
        default: function _default9() {
          return [createVNode("input", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickAttrs(otherProps, {
            aria: true,
            data: true
          })), {}, {
            "id": id,
            "type": "file",
            "ref": fileInput,
            "onClick": function onClick3(e2) {
              return e2.stopPropagation();
            },
            "key": uid$12.value,
            "style": {
              display: "none"
            },
            "accept": accept
          }, dirProps), {}, {
            "multiple": multiple,
            "onChange": onChange3
          }, capture != null ? {
            capture
          } : {}), null), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)];
        }
      });
    };
  }
});
function empty() {
}
const Upload$1 = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: false,
  props: initDefaultProps$1(uploadProps$1(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: false,
    onStart: empty,
    onError: empty,
    onSuccess: empty,
    multiple: false,
    beforeUpload: null,
    customRequest: null,
    withCredentials: false,
    openFileDialogOnClick: true
  }),
  setup: function setup214(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var uploader = ref();
    var abort = function abort2(file) {
      var _uploader$value;
      (_uploader$value = uploader.value) === null || _uploader$value === void 0 ? void 0 : _uploader$value.abort(file);
    };
    expose({
      abort
    });
    return function() {
      return createVNode(AjaxUpload, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props3), attrs), {}, {
        "ref": uploader
      }), slots);
    };
  }
});
var PaperClipOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
const PaperClipOutlinedSvg = PaperClipOutlined$2;
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$3(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$3(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PaperClipOutlined = function PaperClipOutlined2(props3, context2) {
  var p2 = _objectSpread$3({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$3({}, p2, {
    "icon": PaperClipOutlinedSvg
  }), null);
};
PaperClipOutlined.displayName = "PaperClipOutlined";
PaperClipOutlined.inheritAttrs = false;
const PaperClipOutlined$1 = PaperClipOutlined;
var PictureTwoTone$2 = { "icon": function render11(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
}, "name": "picture", "theme": "twotone" };
const PictureTwoToneSvg = PictureTwoTone$2;
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$2(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$2(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var PictureTwoTone = function PictureTwoTone2(props3, context2) {
  var p2 = _objectSpread$2({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$2({}, p2, {
    "icon": PictureTwoToneSvg
  }), null);
};
PictureTwoTone.displayName = "PictureTwoTone";
PictureTwoTone.inheritAttrs = false;
const PictureTwoTone$1 = PictureTwoTone;
var FileTwoTone$2 = { "icon": function render12(primaryColor, secondaryColor) {
  return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
}, "name": "file", "theme": "twotone" };
const FileTwoToneSvg = FileTwoTone$2;
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty$1(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty$1(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var FileTwoTone = function FileTwoTone2(props3, context2) {
  var p2 = _objectSpread$1({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread$1({}, p2, {
    "icon": FileTwoToneSvg
  }), null);
};
FileTwoTone.displayName = "FileTwoTone";
FileTwoTone.inheritAttrs = false;
const FileTwoTone$1 = FileTwoTone;
function uploadProps2() {
  return {
    capture: [Boolean, String],
    type: String,
    name: String,
    defaultFileList: Array,
    fileList: Array,
    action: [String, Function],
    directory: {
      type: Boolean,
      default: void 0
    },
    data: [Object, Function],
    method: String,
    headers: Object,
    showUploadList: {
      type: [Boolean, Object],
      default: void 0
    },
    multiple: {
      type: Boolean,
      default: void 0
    },
    accept: String,
    beforeUpload: Function,
    onChange: Function,
    "onUpdate:fileList": Function,
    onDrop: Function,
    listType: String,
    onPreview: Function,
    onDownload: Function,
    onReject: Function,
    onRemove: Function,
    remove: Function,
    supportServerRender: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    customRequest: Function,
    withCredentials: {
      type: Boolean,
      default: void 0
    },
    openFileDialogOnClick: {
      type: Boolean,
      default: void 0
    },
    locale: {
      type: Object,
      default: void 0
    },
    id: String,
    previewFile: Function,
    transformFile: Function,
    iconRender: Function,
    isImageUrl: Function,
    progress: Object,
    itemRender: Function,
    maxCount: Number,
    height: [Number, String],
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function
  };
}
function uploadListProps() {
  return {
    listType: String,
    onPreview: Function,
    onDownload: Function,
    onRemove: Function,
    items: Array,
    progress: Object,
    prefixCls: String,
    showRemoveIcon: {
      type: Boolean,
      default: void 0
    },
    showDownloadIcon: {
      type: Boolean,
      default: void 0
    },
    showPreviewIcon: {
      type: Boolean,
      default: void 0
    },
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function,
    locale: {
      type: Object,
      default: void 0
    },
    previewFile: Function,
    iconRender: Function,
    isImageUrl: Function,
    appendAction: Function,
    appendActionVisible: {
      type: Boolean,
      default: void 0
    },
    itemRender: Function
  };
}
function file2Obj(file) {
  return _objectSpread2$1(_objectSpread2$1({}, file), {}, {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
function updateFileList(file, fileList) {
  var nextFileList = _toConsumableArray(fileList);
  var fileIndex = nextFileList.findIndex(function(_ref) {
    var uid2 = _ref.uid;
    return uid2 === file.uid;
  });
  if (fileIndex === -1) {
    nextFileList.push(file);
  } else {
    nextFileList[fileIndex] = file;
  }
  return nextFileList;
}
function getFileItem(file, fileList) {
  var matchKey = file.uid !== void 0 ? "uid" : "name";
  return fileList.filter(function(item) {
    return item[matchKey] === file[matchKey];
  })[0];
}
function removeFileItem(file, fileList) {
  var matchKey = file.uid !== void 0 ? "uid" : "name";
  var removed = fileList.filter(function(item) {
    return item[matchKey] !== file[matchKey];
  });
  if (removed.length === fileList.length) {
    return null;
  }
  return removed;
}
var extname = function extname2() {
  var url2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var temp = url2.split("/");
  var filename = temp[temp.length - 1];
  var filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
};
var isImageFileType = function isImageFileType2(type4) {
  return type4.indexOf("image/") === 0;
};
var isImageUrl = function isImageUrl2(file) {
  if (file.type && !file.thumbUrl) {
    return isImageFileType(file.type);
  }
  var url2 = file.thumbUrl || file.url || "";
  var extension = extname(url2);
  if (/^data:image\//.test(url2) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
    return true;
  }
  if (/^data:/.test(url2)) {
    return false;
  }
  if (extension) {
    return false;
  }
  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise(function(resolve2) {
    if (!file.type || !isImageFileType(file.type)) {
      resolve2("");
      return;
    }
    var canvas = document.createElement("canvas");
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = "position: fixed; left: 0; top: 0; width: ".concat(MEASURE_SIZE, "px; height: ").concat(MEASURE_SIZE, "px; z-index: 9999; display: none;");
    document.body.appendChild(canvas);
    var ctx = canvas.getContext("2d");
    var img = new Image();
    img.onload = function() {
      var width = img.width, height = img.height;
      var drawWidth = MEASURE_SIZE;
      var drawHeight = MEASURE_SIZE;
      var offsetX = 0;
      var offsetY = 0;
      if (width > height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }
      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      var dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve2(dataURL);
    };
    img.src = window.URL.createObjectURL(file);
  });
}
var DownloadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
const DownloadOutlinedSvg = DownloadOutlined$2;
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? Object(arguments[i2]) : {};
    var ownKeys2 = Object.keys(source2);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source2).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source2, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key2) {
      _defineProperty(target, key2, source2[key2]);
    });
  }
  return target;
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var DownloadOutlined = function DownloadOutlined2(props3, context2) {
  var p2 = _objectSpread({}, props3, context2.attrs);
  return createVNode(AntdIcon, _objectSpread({}, p2, {
    "icon": DownloadOutlinedSvg
  }), null);
};
DownloadOutlined.displayName = "DownloadOutlined";
DownloadOutlined.inheritAttrs = false;
const DownloadOutlined$1 = DownloadOutlined;
var listItemProps2 = function listItemProps3() {
  return {
    prefixCls: String,
    locale: {
      type: Object,
      default: void 0
    },
    file: Object,
    items: Array,
    listType: String,
    isImgUrl: Function,
    showRemoveIcon: {
      type: Boolean,
      default: void 0
    },
    showDownloadIcon: {
      type: Boolean,
      default: void 0
    },
    showPreviewIcon: {
      type: Boolean,
      default: void 0
    },
    removeIcon: Function,
    downloadIcon: Function,
    previewIcon: Function,
    iconRender: Function,
    actionIconRender: Function,
    itemRender: Function,
    onPreview: Function,
    onClose: Function,
    onDownload: Function,
    progress: Object
  };
};
const ListItem = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: false,
  props: listItemProps2(),
  setup: function setup215(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var showProgress = ref(false);
    var progressRafRef = ref();
    onMounted(function() {
      progressRafRef.value = setTimeout(function() {
        showProgress.value = true;
      }, 300);
    });
    onBeforeUnmount(function() {
      clearTimeout(progressRafRef.value);
    });
    var _useConfigInject = useConfigInject("upload", props3), rootPrefixCls = _useConfigInject.rootPrefixCls;
    var transitionProps = computed(function() {
      return getTransitionProps("".concat(rootPrefixCls.value, "-fade"));
    });
    return function() {
      var _infoUploadingClass, _listContainerNameCla;
      var prefixCls = props3.prefixCls, locale2 = props3.locale, listType = props3.listType, file = props3.file, items = props3.items, progressProps3 = props3.progress, _props$iconRender = props3.iconRender, iconRender = _props$iconRender === void 0 ? slots.iconRender : _props$iconRender, _props$actionIconRend = props3.actionIconRender, actionIconRender = _props$actionIconRend === void 0 ? slots.actionIconRender : _props$actionIconRend, _props$itemRender = props3.itemRender, itemRender = _props$itemRender === void 0 ? slots.itemRender : _props$itemRender, isImgUrl = props3.isImgUrl, showPreviewIcon = props3.showPreviewIcon, showRemoveIcon = props3.showRemoveIcon, showDownloadIcon = props3.showDownloadIcon, _props$previewIcon = props3.previewIcon, customPreviewIcon = _props$previewIcon === void 0 ? slots.previewIcon : _props$previewIcon, _props$removeIcon = props3.removeIcon, customRemoveIcon = _props$removeIcon === void 0 ? slots.removeIcon : _props$removeIcon, _props$downloadIcon = props3.downloadIcon, customDownloadIcon = _props$downloadIcon === void 0 ? slots.downloadIcon : _props$downloadIcon, onPreview = props3.onPreview, onDownload = props3.onDownload, onClose = props3.onClose;
      var className = attrs.class, style2 = attrs.style;
      var spanClassName = "".concat(prefixCls, "-span");
      var iconNode = iconRender({
        file
      });
      var icon = createVNode("div", {
        "class": "".concat(prefixCls, "-text-icon")
      }, [iconNode]);
      if (listType === "picture" || listType === "picture-card") {
        if (file.status === "uploading" || !file.thumbUrl && !file.url) {
          var _uploadingClassName;
          var uploadingClassName = (_uploadingClassName = {}, _defineProperty$U(_uploadingClassName, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$U(_uploadingClassName, "".concat(prefixCls, "-list-item-file"), file.status !== "uploading"), _uploadingClassName);
          icon = createVNode("div", {
            "class": uploadingClassName
          }, [iconNode]);
        } else {
          var _aClassName;
          var thumbnail = isImgUrl !== null && isImgUrl !== void 0 && isImgUrl(file) ? createVNode("img", {
            "src": file.thumbUrl || file.url,
            "alt": file.name,
            "class": "".concat(prefixCls, "-list-item-image")
          }, null) : iconNode;
          var aClassName = (_aClassName = {}, _defineProperty$U(_aClassName, "".concat(prefixCls, "-list-item-thumbnail"), true), _defineProperty$U(_aClassName, "".concat(prefixCls, "-list-item-file"), isImgUrl && !isImgUrl(file)), _aClassName);
          icon = createVNode("a", {
            "class": aClassName,
            "onClick": function onClick2(e2) {
              return onPreview(file, e2);
            },
            "href": file.url || file.thumbUrl,
            "target": "_blank",
            "rel": "noopener noreferrer"
          }, [thumbnail]);
        }
      }
      var infoUploadingClass = (_infoUploadingClass = {}, _defineProperty$U(_infoUploadingClass, "".concat(prefixCls, "-list-item"), true), _defineProperty$U(_infoUploadingClass, "".concat(prefixCls, "-list-item-").concat(file.status), true), _defineProperty$U(_infoUploadingClass, "".concat(prefixCls, "-list-item-list-type-").concat(listType), true), _infoUploadingClass);
      var linkProps3 = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      var removeIcon = showRemoveIcon ? actionIconRender({
        customIcon: customRemoveIcon ? customRemoveIcon({
          file
        }) : createVNode(DeleteOutlined$1, null, null),
        callback: function callback() {
          return onClose(file);
        },
        prefixCls,
        title: locale2.removeFile
      }) : null;
      var downloadIcon = showDownloadIcon && file.status === "done" ? actionIconRender({
        customIcon: customDownloadIcon ? customDownloadIcon({
          file
        }) : createVNode(DownloadOutlined$1, null, null),
        callback: function callback() {
          return onDownload(file);
        },
        prefixCls,
        title: locale2.downloadFile
      }) : null;
      var downloadOrDelete = listType !== "picture-card" && createVNode("span", {
        "key": "download-delete",
        "class": ["".concat(prefixCls, "-list-item-card-actions"), {
          picture: listType === "picture"
        }]
      }, [downloadIcon, removeIcon]);
      var listItemNameClass = "".concat(prefixCls, "-list-item-name");
      var preview = file.url ? [createVNode("a", _objectSpread2$1(_objectSpread2$1({
        "key": "view",
        "target": "_blank",
        "rel": "noopener noreferrer",
        "class": listItemNameClass,
        "title": file.name
      }, linkProps3), {}, {
        "href": file.url,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        }
      }), [file.name]), downloadOrDelete] : [createVNode("span", {
        "key": "view",
        "class": listItemNameClass,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        },
        "title": file.name
      }, [file.name]), downloadOrDelete];
      var previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      var previewIcon = showPreviewIcon ? createVNode("a", {
        "href": file.url || file.thumbUrl,
        "target": "_blank",
        "rel": "noopener noreferrer",
        "style": file.url || file.thumbUrl ? void 0 : previewStyle,
        "onClick": function onClick2(e2) {
          return onPreview(file, e2);
        },
        "title": locale2.previewFile
      }, [customPreviewIcon ? customPreviewIcon({
        file
      }) : createVNode(EyeOutlined$1, null, null)]) : null;
      var actions = listType === "picture-card" && file.status !== "uploading" && createVNode("span", {
        "class": "".concat(prefixCls, "-list-item-actions")
      }, [previewIcon, file.status === "done" && downloadIcon, removeIcon]);
      var message2;
      if (file.response && typeof file.response === "string") {
        message2 = file.response;
      } else {
        var _file$error, _file$error2;
        message2 = ((_file$error = file.error) === null || _file$error === void 0 ? void 0 : _file$error.statusText) || ((_file$error2 = file.error) === null || _file$error2 === void 0 ? void 0 : _file$error2.message) || locale2.uploadError;
      }
      var iconAndPreview = createVNode("span", {
        "class": spanClassName
      }, [icon, preview]);
      var dom = createVNode("div", {
        "class": infoUploadingClass
      }, [createVNode("div", {
        "class": "".concat(prefixCls, "-list-item-info")
      }, [iconAndPreview]), actions, showProgress.value && createVNode(Transition, transitionProps.value, {
        default: function _default9() {
          return [withDirectives(createVNode("div", {
            "class": "".concat(prefixCls, "-list-item-progress")
          }, ["percent" in file ? createVNode(Progress, _objectSpread2$1(_objectSpread2$1({}, progressProps3), {}, {
            "type": "line",
            "percent": file.percent
          }), null) : null]), [[vShow, file.status === "uploading"]])];
        }
      })]);
      var listContainerNameClass = (_listContainerNameCla = {}, _defineProperty$U(_listContainerNameCla, "".concat(prefixCls, "-list-").concat(listType, "-container"), true), _defineProperty$U(_listContainerNameCla, "".concat(className), !!className), _listContainerNameCla);
      var item = file.status === "error" ? createVNode(Tooltip, {
        "title": message2,
        "getPopupContainer": function getPopupContainer(node) {
          return node.parentNode;
        }
      }, {
        default: function _default9() {
          return [dom];
        }
      }) : dom;
      return createVNode("div", {
        "class": listContainerNameClass,
        "style": style2,
        "ref": ref
      }, [itemRender ? itemRender({
        originNode: item,
        file,
        fileList: items,
        actions: {
          download: onDownload.bind(null, file),
          preview: onPreview.bind(null, file),
          remove: onClose.bind(null, file)
        }
      }) : item]);
    };
  }
});
var HackSlot = function HackSlot2(_2, _ref) {
  var _slots$default;
  var slots = _ref.slots;
  return filterEmpty((_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots))[0];
};
const UploadList = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: initDefaultProps$1(uploadListProps(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: false
    },
    showRemoveIcon: true,
    showDownloadIcon: false,
    showPreviewIcon: true,
    previewFile: previewImage,
    isImageUrl,
    items: [],
    appendActionVisible: true
  }),
  setup: function setup216(props3, _ref2) {
    var slots = _ref2.slots, expose = _ref2.expose;
    var motionAppear = ref(false);
    var instance = getCurrentInstance();
    onMounted(function() {
      motionAppear.value == true;
    });
    watchEffect(function() {
      if (props3.listType !== "picture" && props3.listType !== "picture-card") {
        return;
      }
      (props3.items || []).forEach(function(file) {
        if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
          return;
        }
        file.thumbUrl = "";
        if (props3.previewFile) {
          props3.previewFile(file.originFileObj).then(function(previewDataUrl) {
            file.thumbUrl = previewDataUrl || "";
            instance.update();
          });
        }
      });
    });
    var onInternalPreview = function onInternalPreview2(file, e2) {
      if (!props3.onPreview) {
        return;
      }
      e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
      return props3.onPreview(file);
    };
    var onInternalDownload = function onInternalDownload2(file) {
      if (typeof props3.onDownload === "function") {
        props3.onDownload(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };
    var onInternalClose = function onInternalClose2(file) {
      var _props$onRemove;
      (_props$onRemove = props3.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props3, file);
    };
    var internalIconRender = function internalIconRender2(_ref3) {
      var file = _ref3.file;
      var iconRender = props3.iconRender || slots.iconRender;
      if (iconRender) {
        return iconRender({
          file,
          listType: props3.listType
        });
      }
      var isLoading = file.status === "uploading";
      var fileIcon = props3.isImageUrl && props3.isImageUrl(file) ? createVNode(PictureTwoTone$1, null, null) : createVNode(FileTwoTone$1, null, null);
      var icon = isLoading ? createVNode(LoadingOutlined$1, null, null) : createVNode(PaperClipOutlined$1, null, null);
      if (props3.listType === "picture") {
        icon = isLoading ? createVNode(LoadingOutlined$1, null, null) : fileIcon;
      } else if (props3.listType === "picture-card") {
        icon = isLoading ? props3.locale.uploading : fileIcon;
      }
      return icon;
    };
    var actionIconRender = function actionIconRender2(opt) {
      var customIcon = opt.customIcon, callback = opt.callback, prefixCls2 = opt.prefixCls, title = opt.title;
      var btnProps = {
        type: "text",
        size: "small",
        title,
        onClick: function onClick2() {
          callback();
        },
        class: "".concat(prefixCls2, "-list-item-card-actions-btn")
      };
      if (isValidElement(customIcon)) {
        return createVNode(Button$1, btnProps, {
          icon: function icon() {
            return customIcon;
          }
        });
      }
      return createVNode(Button$1, btnProps, {
        default: function _default9() {
          return [createVNode("span", null, [customIcon])];
        }
      });
    };
    expose({
      handlePreview: onInternalPreview,
      handleDownload: onInternalDownload
    });
    var _useConfigInject = useConfigInject("upload", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var listClassNames = computed(function() {
      var _ref4;
      return _ref4 = {}, _defineProperty$U(_ref4, "".concat(prefixCls.value, "-list"), true), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-list-").concat(props3.listType), true), _defineProperty$U(_ref4, "".concat(prefixCls.value, "-list-rtl"), direction.value === "rtl"), _ref4;
    });
    var transitionGroupProps = computed(function() {
      return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, collapseMotion$1("".concat(prefixCls.value, "-").concat(props3.listType === "picture-card" ? "animate-inline" : "animate"))), getTransitionGroupProps("".concat(prefixCls.value, "-").concat(props3.listType === "picture-card" ? "animate-inline" : "animate"))), {}, {
        class: listClassNames.value,
        appear: motionAppear.value
      });
    });
    return function() {
      var listType = props3.listType, locale2 = props3.locale, isImgUrl = props3.isImageUrl, _props$items = props3.items, items = _props$items === void 0 ? [] : _props$items, showPreviewIcon = props3.showPreviewIcon, showRemoveIcon = props3.showRemoveIcon, showDownloadIcon = props3.showDownloadIcon, removeIcon = props3.removeIcon, previewIcon = props3.previewIcon, downloadIcon = props3.downloadIcon, progress = props3.progress, appendAction = props3.appendAction, itemRender = props3.itemRender, appendActionVisible = props3.appendActionVisible;
      var appendActionDom = appendAction === null || appendAction === void 0 ? void 0 : appendAction();
      return createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps.value), {}, {
        "tag": "div"
      }), {
        default: function _default9() {
          return [items.map(function(file) {
            var key2 = file.uid;
            return createVNode(ListItem, {
              "key": key2,
              "locale": locale2,
              "prefixCls": prefixCls.value,
              "file": file,
              "items": items,
              "progress": progress,
              "listType": listType,
              "isImgUrl": isImgUrl,
              "showPreviewIcon": showPreviewIcon,
              "showRemoveIcon": showRemoveIcon,
              "showDownloadIcon": showDownloadIcon,
              "onPreview": onInternalPreview,
              "onDownload": onInternalDownload,
              "onClose": onInternalClose,
              "removeIcon": removeIcon,
              "previewIcon": previewIcon,
              "downloadIcon": downloadIcon,
              "itemRender": itemRender
            }, _objectSpread2$1(_objectSpread2$1({}, slots), {}, {
              iconRender: internalIconRender,
              actionIconRender
            }));
          }), appendAction ? withDirectives(createVNode(HackSlot, {
            "key": "__ant_upload_appendAction"
          }, {
            default: function _default10() {
              return appendActionDom;
            }
          }), [[vShow, !!appendActionVisible]]) : null];
        }
      });
    };
  }
});
var _excluded$1 = ["class", "style"];
var LIST_IGNORE = "__LIST_IGNORE_".concat(Date.now(), "__");
const Upload = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: false,
  props: initDefaultProps$1(uploadProps2(), {
    type: "select",
    multiple: false,
    action: "",
    data: {},
    accept: "",
    showUploadList: true,
    listType: "text",
    disabled: false,
    supportServerRender: true
  }),
  setup: function setup217(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, expose = _ref.expose;
    var formItemContext = useInjectFormItemContext();
    var _useMergedState = useMergedState(props3.defaultFileList || [], {
      value: toRef(props3, "fileList"),
      postState: function postState(list) {
        var timestamp = Date.now();
        return (list !== null && list !== void 0 ? list : []).map(function(file, index2) {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = "__AUTO__".concat(timestamp, "_").concat(index2, "__");
          }
          return file;
        });
      }
    }), _useMergedState2 = _slicedToArray$2(_useMergedState, 2), mergedFileList = _useMergedState2[0], setMergedFileList = _useMergedState2[1];
    var dragState = ref("drop");
    var upload2 = ref();
    onMounted(function() {
      devWarning(props3.fileList !== void 0 || attrs.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?");
      devWarning(props3.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly.");
      devWarning(props3.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    var onInternalChange = function onInternalChange2(file, changedFileList, event2) {
      var _props$onUpdateFileL, _props$onChange;
      var cloneList = _toConsumableArray(changedFileList);
      if (props3.maxCount === 1) {
        cloneList = cloneList.slice(-1);
      } else if (props3.maxCount) {
        cloneList = cloneList.slice(0, props3.maxCount);
      }
      setMergedFileList(cloneList);
      var changeInfo = {
        file,
        fileList: cloneList
      };
      if (event2) {
        changeInfo.event = event2;
      }
      (_props$onUpdateFileL = props3["onUpdate:fileList"]) === null || _props$onUpdateFileL === void 0 ? void 0 : _props$onUpdateFileL.call(props3, changeInfo.fileList);
      (_props$onChange = props3.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props3, changeInfo);
      formItemContext.onFieldChange();
    };
    var mergedBeforeUpload = /* @__PURE__ */ function() {
      var _ref2 = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(file, fileListArgs) {
        var beforeUpload, transformFile, parsedFile, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                beforeUpload = props3.beforeUpload, transformFile = props3.transformFile;
                parsedFile = file;
                if (!beforeUpload) {
                  _context.next = 13;
                  break;
                }
                _context.next = 5;
                return beforeUpload(file, fileListArgs);
              case 5:
                result = _context.sent;
                if (!(result === false)) {
                  _context.next = 8;
                  break;
                }
                return _context.abrupt("return", false);
              case 8:
                delete file[LIST_IGNORE];
                if (!(result === LIST_IGNORE)) {
                  _context.next = 12;
                  break;
                }
                Object.defineProperty(file, LIST_IGNORE, {
                  value: true,
                  configurable: true
                });
                return _context.abrupt("return", false);
              case 12:
                if (_typeof$3(result) === "object" && result) {
                  parsedFile = result;
                }
              case 13:
                if (!transformFile) {
                  _context.next = 17;
                  break;
                }
                _context.next = 16;
                return transformFile(parsedFile);
              case 16:
                parsedFile = _context.sent;
              case 17:
                return _context.abrupt("return", parsedFile);
              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function mergedBeforeUpload2(_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    var onBatchStart = function onBatchStart2(batchFileInfoList) {
      var filteredFileInfoList = batchFileInfoList.filter(function(info) {
        return !info.file[LIST_IGNORE];
      });
      if (!filteredFileInfoList.length) {
        return;
      }
      var objectFileList = filteredFileInfoList.map(function(info) {
        return file2Obj(info.file);
      });
      var newFileList = _toConsumableArray(mergedFileList.value);
      objectFileList.forEach(function(fileObj) {
        newFileList = updateFileList(fileObj, newFileList);
      });
      objectFileList.forEach(function(fileObj, index2) {
        var triggerFileObj = fileObj;
        if (!filteredFileInfoList[index2].parsedFile) {
          var originFileObj = fileObj.originFileObj;
          var clone3;
          try {
            clone3 = new File([originFileObj], originFileObj.name, {
              type: originFileObj.type
            });
          } catch (e2) {
            clone3 = new Blob([originFileObj], {
              type: originFileObj.type
            });
            clone3.name = originFileObj.name;
            clone3.lastModifiedDate = new Date();
            clone3.lastModified = new Date().getTime();
          }
          clone3.uid = fileObj.uid;
          triggerFileObj = clone3;
        } else {
          fileObj.status = "uploading";
        }
        onInternalChange(triggerFileObj, newFileList);
      });
    };
    var onSuccess = function onSuccess2(response, file, xhr2) {
      try {
        if (typeof response === "string") {
          response = JSON.parse(response);
        }
      } catch (e2) {
      }
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.status = "done";
      targetItem.percent = 100;
      targetItem.response = response;
      targetItem.xhr = xhr2;
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    var onProgress = function onProgress2(e2, file) {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.status = "uploading";
      targetItem.percent = e2.percent;
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList, e2);
    };
    var onError = function onError2(error, response, file) {
      if (!getFileItem(file, mergedFileList.value)) {
        return;
      }
      var targetItem = file2Obj(file);
      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = "error";
      var nextFileList = updateFileList(targetItem, mergedFileList.value);
      onInternalChange(targetItem, nextFileList);
    };
    var handleRemove = function handleRemove2(file) {
      var currentFile;
      var mergedRemove = props3.onRemove || props3.remove;
      Promise.resolve(typeof mergedRemove === "function" ? mergedRemove(file) : mergedRemove).then(function(ret) {
        if (ret === false) {
          return;
        }
        var removedFileList = removeFileItem(file, mergedFileList.value);
        if (removedFileList) {
          var _mergedFileList$value, _upload$value;
          currentFile = _objectSpread2$1(_objectSpread2$1({}, file), {}, {
            status: "removed"
          });
          (_mergedFileList$value = mergedFileList.value) === null || _mergedFileList$value === void 0 ? void 0 : _mergedFileList$value.forEach(function(item) {
            var matchKey = currentFile.uid !== void 0 ? "uid" : "name";
            if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
              item.status = "removed";
            }
          });
          (_upload$value = upload2.value) === null || _upload$value === void 0 ? void 0 : _upload$value.abort(currentFile);
          onInternalChange(currentFile, removedFileList);
        }
      });
    };
    var onFileDrop = function onFileDrop2(e2) {
      dragState.value = e2.type;
      if (e2.type === "drop") {
        var _props$onDrop;
        (_props$onDrop = props3.onDrop) === null || _props$onDrop === void 0 ? void 0 : _props$onDrop.call(props3, e2);
      }
    };
    expose({
      onBatchStart,
      onSuccess,
      onProgress,
      onError,
      fileList: mergedFileList,
      upload: upload2
    });
    var _useConfigInject = useConfigInject("upload", props3), prefixCls = _useConfigInject.prefixCls, direction = _useConfigInject.direction;
    var _useLocaleReceiver = useLocaleReceiver("Upload", defaultLocale.Upload, computed(function() {
      return props3.locale;
    })), _useLocaleReceiver2 = _slicedToArray$2(_useLocaleReceiver, 1), locale2 = _useLocaleReceiver2[0];
    var renderUploadList = function renderUploadList2(button, buttonVisible) {
      var removeIcon = props3.removeIcon, previewIcon = props3.previewIcon, downloadIcon = props3.downloadIcon, previewFile = props3.previewFile, onPreview = props3.onPreview, onDownload = props3.onDownload, disabled = props3.disabled, isImageUrl3 = props3.isImageUrl, progress = props3.progress, itemRender = props3.itemRender, iconRender = props3.iconRender, showUploadList = props3.showUploadList;
      var _ref3 = typeof showUploadList === "boolean" ? {} : showUploadList, showDownloadIcon = _ref3.showDownloadIcon, showPreviewIcon = _ref3.showPreviewIcon, showRemoveIcon = _ref3.showRemoveIcon;
      return showUploadList ? createVNode(UploadList, {
        "listType": props3.listType,
        "items": mergedFileList.value,
        "previewFile": previewFile,
        "onPreview": onPreview,
        "onDownload": onDownload,
        "onRemove": handleRemove,
        "showRemoveIcon": !disabled && showRemoveIcon,
        "showPreviewIcon": showPreviewIcon,
        "showDownloadIcon": showDownloadIcon,
        "removeIcon": removeIcon,
        "previewIcon": previewIcon,
        "downloadIcon": downloadIcon,
        "iconRender": iconRender,
        "locale": locale2.value,
        "isImageUrl": isImageUrl3,
        "progress": progress,
        "itemRender": itemRender,
        "appendActionVisible": buttonVisible,
        "appendAction": button
      }, _objectSpread2$1({}, slots)) : button === null || button === void 0 ? void 0 : button();
    };
    return function() {
      var _props$id, _classNames2, _slots$default2;
      var listType = props3.listType, disabled = props3.disabled, type4 = props3.type;
      attrs.class;
      attrs.style;
      var transAttrs = _objectWithoutProperties$2(attrs, _excluded$1);
      var rcUploadProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, transAttrs), props3), {}, {
        id: (_props$id = props3.id) !== null && _props$id !== void 0 ? _props$id : formItemContext.id.value,
        prefixCls: prefixCls.value,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0
      });
      delete rcUploadProps.remove;
      if (!slots.default || disabled) {
        delete rcUploadProps.id;
      }
      if (type4 === "drag") {
        var _classNames, _slots$default;
        var dragCls = classNames(prefixCls.value, (_classNames = {}, _defineProperty$U(_classNames, "".concat(prefixCls.value, "-drag"), true), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-drag-uploading"), mergedFileList.value.some(function(file) {
          return file.status === "uploading";
        })), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-drag-hover"), dragState.value === "dragover"), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$U(_classNames, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames), attrs.class);
        return createVNode("span", null, [createVNode("div", {
          "class": dragCls,
          "onDrop": onFileDrop,
          "onDragover": onFileDrop,
          "onDragleave": onFileDrop,
          "style": attrs.style
        }, [createVNode(Upload$1, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
          "ref": upload2,
          "class": "".concat(prefixCls.value, "-btn")
        }), _objectSpread2$1({
          default: function _default9() {
            return [createVNode("div", {
              "class": "".concat(prefixCls, "-drag-container")
            }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])];
          }
        }, slots))]), renderUploadList()]);
      }
      var uploadButtonCls = classNames(prefixCls.value, (_classNames2 = {}, _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-select"), true), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-select-").concat(listType), true), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-disabled"), disabled), _defineProperty$U(_classNames2, "".concat(prefixCls.value, "-rtl"), direction.value === "rtl"), _classNames2));
      var children = flattenChildren((_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots));
      var renderUploadButton = function renderUploadButton2(uploadButtonStyle) {
        return createVNode("div", {
          "class": uploadButtonCls,
          "style": uploadButtonStyle
        }, [createVNode(Upload$1, _objectSpread2$1(_objectSpread2$1({}, rcUploadProps), {}, {
          "ref": upload2
        }), slots)]);
      };
      if (listType === "picture-card") {
        return createVNode("span", {
          "class": classNames("".concat(prefixCls.value, "-picture-card-wrapper"), attrs.class)
        }, [renderUploadList(renderUploadButton, !!(children && children.length))]);
      }
      return createVNode("span", {
        "class": attrs.class
      }, [renderUploadButton(children && children.length ? void 0 : {
        display: "none"
      }), renderUploadList()]);
    };
  }
});
var _excluded = ["height"], _excluded2 = ["style"];
const Dragger = defineComponent({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: false,
  props: uploadProps2(),
  setup: function setup218(props3, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    return function() {
      var height = props3.height, restProps = _objectWithoutProperties$2(props3, _excluded);
      var style2 = attrs.style, restAttrs = _objectWithoutProperties$2(attrs, _excluded2);
      var draggerProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), restAttrs), {}, {
        type: "drag",
        style: _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
          height: typeof height === "number" ? "".concat(height, "px") : height
        })
      });
      return createVNode(Upload, draggerProps, slots);
    };
  }
});
var UploadDragger = Dragger;
const index$1 = _extends$1(Upload, {
  Dragger,
  LIST_IGNORE,
  install: function install11(app) {
    app.component(Upload.name, Upload);
    app.component(Dragger.name, Dragger);
    return app;
  }
});
const components$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Affix: Affix$1,
  Anchor,
  AnchorLink,
  AutoComplete: AutoComplete$1,
  AutoCompleteOptGroup,
  AutoCompleteOption,
  Alert: Alert$1,
  Avatar: Avatar$1,
  AvatarGroup: Group$5,
  BackTop: index$l,
  Badge,
  BadgeRibbon: Ribbon,
  Breadcrumb: Breadcrumb$1,
  BreadcrumbItem,
  BreadcrumbSeparator,
  Button: Button$1,
  ButtonGroup: ButtonGroup$1,
  Calendar: Calendar$1,
  Card: Card$1,
  CardGrid: Grid,
  CardMeta: Meta,
  Collapse,
  CollapsePanel,
  Carousel: index$j,
  Cascader: index$i,
  Checkbox: Checkbox$1,
  CheckboxGroup: CheckboxGroup$1,
  Col,
  Comment: index$h,
  ConfigProvider,
  DatePicker: DatePicker$3,
  MonthPicker,
  WeekPicker,
  RangePicker: RangePicker$1,
  QuarterPicker,
  Descriptions: Descriptions$1,
  DescriptionsItem,
  Divider: index$g,
  Dropdown: Dropdown$1,
  DropdownButton,
  Drawer: index$f,
  Empty: Empty$1,
  Form: Form$1,
  FormItem,
  FormItemRest,
  Grid: index$k,
  Input: Input$1,
  InputGroup: Group$2,
  InputPassword: Password,
  InputSearch: Search$2,
  Textarea: TextArea,
  Image: Image$2,
  ImagePreviewGroup: PreviewGroup,
  InputNumber: index$e,
  Layout: index$d,
  LayoutHeader,
  LayoutSider,
  LayoutFooter,
  LayoutContent,
  List: List$2,
  ListItem: Item2,
  ListItemMeta: ItemMeta,
  message,
  Menu,
  MenuDivider: Divider$1,
  MenuItem: MenuItem$1,
  MenuItemGroup: ItemGroup,
  SubMenu: SubMenu$1,
  Mentions: index$c,
  MentionsOption,
  Modal,
  Statistic,
  StatisticCountdown,
  notification,
  PageHeader: index$b,
  Pagination,
  Popconfirm: index$a,
  Popover: Popover$1,
  Progress,
  Radio,
  RadioButton: Button,
  RadioGroup: Group$3,
  Rate: index$9,
  Result: Result$1,
  Row: Row$2,
  Select: VcSelect,
  SelectOptGroup,
  SelectOption,
  Skeleton: Skeleton$1,
  SkeletonButton: SkeletonButton$1,
  SkeletonAvatar: SkeletonAvatar$1,
  SkeletonInput: SkeletonInput$1,
  SkeletonImage: SkeletonImage$1,
  SkeletonTitle: SkeletonTitle$1,
  Slider: index$8,
  Space: index$7,
  Spin,
  Steps: index$6,
  Step,
  Switch: index$5,
  Table,
  TableColumn: Column,
  TableColumnGroup: ColumnGroup,
  TableSummary,
  TableSummaryRow,
  TableSummaryCell,
  Transfer: index$4,
  Tree,
  TreeNode: TreeNode$2,
  DirectoryTree,
  TreeSelect: index$3,
  TreeSelectNode,
  Tabs,
  TabPane: TabPane$1,
  Tag: Tag$1,
  CheckableTag: CheckableTag$1,
  TimePicker: TimePicker$2,
  TimeRangePicker,
  Timeline,
  TimelineItem,
  Tooltip,
  Typography: Typography$1,
  TypographyLink: Link$1,
  TypographyParagraph: Paragraph$1,
  TypographyText: Text$1,
  TypographyTitle: Title$1,
  Upload: index$1,
  UploadDragger,
  LocaleProvider: LocaleProvider$1
}, Symbol.toStringTag, { value: "Module" }));
const version$1 = "3.2.15";
var install12 = function install13(app) {
  Object.keys(components$1).forEach(function(key2) {
    var component = components$1[key2];
    if (component.install) {
      app.use(component);
    }
  });
  app.config.globalProperties.$message = message;
  app.config.globalProperties.$notification = notification;
  app.config.globalProperties.$info = Modal.info;
  app.config.globalProperties.$success = Modal.success;
  app.config.globalProperties.$error = Modal.error;
  app.config.globalProperties.$warning = Modal.warning;
  app.config.globalProperties.$confirm = Modal.confirm;
  app.config.globalProperties.$destroyAll = Modal.destroyAll;
  return app;
};
const Antd = {
  version: version$1,
  install: install12
};
var jquery = { exports: {} };
/*!
 * jQuery JavaScript Library v3.6.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-08-26T17:52Z
 */
(function(module2) {
  (function(global2, factory) {
    {
      module2.exports = global2.document ? factory(global2, true) : function(w2) {
        if (!w2.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w2);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto2 = Object.getPrototypeOf;
    var slice2 = arr.slice;
    var flat = arr.flat ? function(array4) {
      return arr.flat.call(array4);
    } : function(array4) {
      return arr.concat.apply([], array4);
    };
    var push2 = arr.push;
    var indexOf2 = arr.indexOf;
    var class2type = {};
    var toString3 = class2type.toString;
    var hasOwn3 = class2type.hasOwnProperty;
    var fnToString = hasOwn3.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction3 = function isFunction4(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow2 = function isWindow3(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc2) {
      doc2 = doc2 || document2;
      var i2, val, script = doc2.createElement("script");
      script.text = code;
      if (node) {
        for (i2 in preservedScriptAttributes) {
          val = node[i2] || node.getAttribute && node.getAttribute(i2);
          if (val) {
            script.setAttribute(i2, val);
          }
        }
      }
      doc2.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
    }
    var version2 = "3.6.1", jQuery = function(selector, context2) {
      return new jQuery.fn.init(selector, context2);
    };
    jQuery.fn = jQuery.prototype = {
      jquery: version2,
      constructor: jQuery,
      length: 0,
      toArray: function() {
        return slice2.call(this);
      },
      get: function(num) {
        if (num == null) {
          return slice2.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i2) {
          return callback.call(elem, i2, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice2.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i2) {
          return (i2 + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i2) {
          return i2 % 2;
        }));
      },
      eq: function(i2) {
        var len = this.length, j2 = +i2 + (i2 < 0 ? len : 0);
        return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      push: push2,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name2, src2, copy2, copyIsArray, clone3, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i2] || {};
        i2++;
      }
      if (typeof target !== "object" && !isFunction3(target)) {
        target = {};
      }
      if (i2 === length) {
        target = this;
        i2--;
      }
      for (; i2 < length; i2++) {
        if ((options = arguments[i2]) != null) {
          for (name2 in options) {
            copy2 = options[name2];
            if (name2 === "__proto__" || target === copy2) {
              continue;
            }
            if (deep && copy2 && (jQuery.isPlainObject(copy2) || (copyIsArray = Array.isArray(copy2)))) {
              src2 = target[name2];
              if (copyIsArray && !Array.isArray(src2)) {
                clone3 = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src2)) {
                clone3 = {};
              } else {
                clone3 = src2;
              }
              copyIsArray = false;
              target[name2] = jQuery.extend(deep, clone3, copy2);
            } else if (copy2 !== void 0) {
              target[name2] = copy2;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString3.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto2(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name2;
        for (name2 in obj) {
          return false;
        }
        return true;
      },
      globalEval: function(code, options, doc2) {
        DOMEval(code, { nonce: options && options.nonce }, doc2);
      },
      each: function(obj, callback) {
        var length, i2 = 0;
        if (isArrayLike2(obj)) {
          length = obj.length;
          for (; i2 < length; i2++) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        } else {
          for (i2 in obj) {
            if (callback.call(obj[i2], i2, obj[i2]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike2(Object(arr2))) {
            jQuery.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push2.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i2) {
        return arr2 == null ? -1 : indexOf2.call(arr2, elem, i2);
      },
      merge: function(first, second) {
        var len = +second.length, j2 = 0, i2 = first.length;
        for (; j2 < len; j2++) {
          first[i2++] = second[j2];
        }
        first.length = i2;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches2 = [], i2 = 0, length = elems.length, callbackExpect = !invert;
        for (; i2 < length; i2++) {
          callbackInverse = !callback(elems[i2], i2);
          if (callbackInverse !== callbackExpect) {
            matches2.push(elems[i2]);
          }
        }
        return matches2;
      },
      map: function(elems, callback, arg) {
        var length, value, i2 = 0, ret = [];
        if (isArrayLike2(elems)) {
          length = elems.length;
          for (; i2 < length; i2++) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i2 in elems) {
            value = callback(elems[i2], i2, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      guid: 1,
      support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name2) {
        class2type["[object " + name2 + "]"] = name2.toLowerCase();
      }
    );
    function isArrayLike2(obj) {
      var length = !!obj && "length" in obj && obj.length, type4 = toType(obj);
      if (isFunction3(obj) || isWindow2(obj)) {
        return false;
      }
      return type4 === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window3) {
      var i2, support2, Expr, getText, isXML, tokenize, compile2, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches2, contains2, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
        if (a2 === b2) {
          hasDuplicate = true;
        }
        return 0;
      }, hasOwn4 = {}.hasOwnProperty, arr2 = [], pop2 = arr2.pop, pushNative = arr2.push, push3 = arr2.push, slice3 = arr2.slice, indexOf3 = function(list, elem) {
        var i3 = 0, len = list.length;
        for (; i3 < len; i3++) {
          if (list[i3] === elem) {
            return i3;
          }
        }
        return -1;
      }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace4 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace4 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes2 = "\\[" + whitespace4 + "*(" + identifier + ")(?:" + whitespace4 + "*([*^$|!~]?=)" + whitespace4 + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace4 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes2 + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace4 + "+", "g"), rtrim2 = new RegExp("^" + whitespace4 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace4 + "+$", "g"), rcomma = new RegExp("^" + whitespace4 + "*," + whitespace4 + "*"), rcombinators = new RegExp("^" + whitespace4 + "*([>+~]|" + whitespace4 + ")" + whitespace4 + "*"), rdescend = new RegExp(whitespace4 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes2),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace4 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace4 + "*(?:([+-]|)" + whitespace4 + "*(\\d+)|))" + whitespace4 + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        "needsContext": new RegExp("^" + whitespace4 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace4 + "*((?:-\\d)?\\d*)" + whitespace4 + "*\\)|)(?=[^-]|$)", "i")
      }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace4 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
        var high = "0x" + escape2.slice(1) - 65536;
        return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }, unloadHandler = function() {
        setDocument();
      }, inDisabledFieldset = addCombinator(
        function(elem) {
          return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        },
        { dir: "parentNode", next: "legend" }
      );
      try {
        push3.apply(
          arr2 = slice3.call(preferredDoc.childNodes),
          preferredDoc.childNodes
        );
        arr2[preferredDoc.childNodes.length].nodeType;
      } catch (e2) {
        push3 = {
          apply: arr2.length ? function(target, els) {
            pushNative.apply(target, slice3.call(els));
          } : function(target, els) {
            var j2 = target.length, i3 = 0;
            while (target[j2++] = els[i3++]) {
            }
            target.length = j2 - 1;
          }
        };
      }
      function Sizzle2(selector, context2, results, seed2) {
        var m2, i3, elem, nid, match2, groups, newSelector, newContext = context2 && context2.ownerDocument, nodeType = context2 ? context2.nodeType : 9;
        results = results || [];
        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        }
        if (!seed2) {
          setDocument(context2);
          context2 = context2 || document3;
          if (documentIsHTML) {
            if (nodeType !== 11 && (match2 = rquickExpr2.exec(selector))) {
              if (m2 = match2[1]) {
                if (nodeType === 9) {
                  if (elem = context2.getElementById(m2)) {
                    if (elem.id === m2) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (newContext && (elem = newContext.getElementById(m2)) && contains2(context2, elem) && elem.id === m2) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match2[2]) {
                push3.apply(results, context2.getElementsByTagName(selector));
                return results;
              } else if ((m2 = match2[3]) && support2.getElementsByClassName && context2.getElementsByClassName) {
                push3.apply(results, context2.getElementsByClassName(m2));
                return results;
              }
            }
            if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context2.nodeName.toLowerCase() !== "object")) {
              newSelector = selector;
              newContext = context2;
              if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                newContext = rsibling.test(selector) && testContext(context2.parentNode) || context2;
                if (newContext !== context2 || !support2.scope) {
                  if (nid = context2.getAttribute("id")) {
                    nid = nid.replace(rcssescape, fcssescape);
                  } else {
                    context2.setAttribute("id", nid = expando);
                  }
                }
                groups = tokenize(selector);
                i3 = groups.length;
                while (i3--) {
                  groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                }
                newSelector = groups.join(",");
              }
              try {
                push3.apply(
                  results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {
                nonnativeSelectorCache(selector, true);
              } finally {
                if (nid === expando) {
                  context2.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector.replace(rtrim2, "$1"), context2, results, seed2);
      }
      function createCache() {
        var keys2 = [];
        function cache(key2, value) {
          if (keys2.push(key2 + " ") > Expr.cacheLength) {
            delete cache[keys2.shift()];
          }
          return cache[key2 + " "] = value;
        }
        return cache;
      }
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      function assert(fn) {
        var el = document3.createElement("fieldset");
        try {
          return !!fn(el);
        } catch (e2) {
          return false;
        } finally {
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
          el = null;
        }
      }
      function addHandle(attrs, handler5) {
        var arr3 = attrs.split("|"), i3 = arr3.length;
        while (i3--) {
          Expr.attrHandle[arr3[i3]] = handler5;
        }
      }
      function siblingCheck(a2, b2) {
        var cur = b2 && a2, diff2 = cur && a2.nodeType === 1 && b2.nodeType === 1 && a2.sourceIndex - b2.sourceIndex;
        if (diff2) {
          return diff2;
        }
        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b2) {
              return -1;
            }
          }
        }
        return a2 ? 1 : -1;
      }
      function createInputPseudo(type4) {
        return function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return name2 === "input" && elem.type === type4;
        };
      }
      function createButtonPseudo(type4) {
        return function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return (name2 === "input" || name2 === "button") && elem.type === type4;
        };
      }
      function createDisabledPseudo(disabled) {
        return function(elem) {
          if ("form" in elem) {
            if (elem.parentNode && elem.disabled === false) {
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }
              return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
            }
            return elem.disabled === disabled;
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }
          return false;
        };
      }
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed2, matches3) {
            var j2, matchIndexes = fn([], seed2.length, argument), i3 = matchIndexes.length;
            while (i3--) {
              if (seed2[j2 = matchIndexes[i3]]) {
                seed2[j2] = !(matches3[j2] = seed2[j2]);
              }
            }
          });
        });
      }
      function testContext(context2) {
        return context2 && typeof context2.getElementsByTagName !== "undefined" && context2;
      }
      support2 = Sizzle2.support = {};
      isXML = Sizzle2.isXML = function(elem) {
        var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
        return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
      };
      setDocument = Sizzle2.setDocument = function(node) {
        var hasCompare, subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
        if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
          return document3;
        }
        document3 = doc2;
        docElem = document3.documentElement;
        documentIsHTML = !isXML(document3);
        if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false);
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        support2.scope = assert(function(el) {
          docElem.appendChild(el).appendChild(document3.createElement("div"));
          return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
        });
        support2.attributes = assert(function(el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        support2.getElementsByTagName = assert(function(el) {
          el.appendChild(document3.createComment(""));
          return !el.getElementsByTagName("*").length;
        });
        support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
        support2.getById = assert(function(el) {
          docElem.appendChild(el).id = expando;
          return !document3.getElementsByName || !document3.getElementsByName(expando).length;
        });
        if (support2.getById) {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find["ID"] = function(id, context2) {
            if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
              var elem = context2.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node2 && node2.value === attrId;
            };
          };
          Expr.find["ID"] = function(id, context2) {
            if (typeof context2.getElementById !== "undefined" && documentIsHTML) {
              var node2, i3, elems, elem = context2.getElementById(id);
              if (elem) {
                node2 = elem.getAttributeNode("id");
                if (node2 && node2.value === id) {
                  return [elem];
                }
                elems = context2.getElementsByName(id);
                i3 = 0;
                while (elem = elems[i3++]) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                }
              }
              return [];
            }
          };
        }
        Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context2) {
          if (typeof context2.getElementsByTagName !== "undefined") {
            return context2.getElementsByTagName(tag);
          } else if (support2.qsa) {
            return context2.querySelectorAll(tag);
          }
        } : function(tag, context2) {
          var elem, tmp = [], i3 = 0, results = context2.getElementsByTagName(tag);
          if (tag === "*") {
            while (elem = results[i3++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }
            return tmp;
          }
          return results;
        };
        Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context2) {
          if (typeof context2.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context2.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if (support2.qsa = rnative.test(document3.querySelectorAll)) {
          assert(function(el) {
            var input;
            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace4 + `*(?:''|"")`);
            }
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace4 + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace4 + "*name" + whitespace4 + "*=" + whitespace4 + `*(?:''|"")`);
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            el.querySelectorAll("\\\f");
            rbuggyQSA.push("[\\r\\n\\f]");
          });
          assert(function(el) {
            el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
            var input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace4 + "*[*^$|!~]?=");
            }
            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            docElem.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if (support2.matchesSelector = rnative.test(matches2 = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function(el) {
            support2.disconnectedMatch = matches2.call(el, "*");
            matches2.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains2 = hasCompare || rnative.test(docElem.contains) ? function(a2, b2) {
          var adown = a2.nodeType === 9 ? a2.documentElement : a2, bup = b2 && b2.parentNode;
          return a2 === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
        } : function(a2, b2) {
          if (b2) {
            while (b2 = b2.parentNode) {
              if (b2 === a2) {
                return true;
              }
            }
          }
          return false;
        };
        sortOrder = hasCompare ? function(a2, b2) {
          if (a2 === b2) {
            hasDuplicate = true;
            return 0;
          }
          var compare2 = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
          if (compare2) {
            return compare2;
          }
          compare2 = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : 1;
          if (compare2 & 1 || !support2.sortDetached && b2.compareDocumentPosition(a2) === compare2) {
            if (a2 == document3 || a2.ownerDocument == preferredDoc && contains2(preferredDoc, a2)) {
              return -1;
            }
            if (b2 == document3 || b2.ownerDocument == preferredDoc && contains2(preferredDoc, b2)) {
              return 1;
            }
            return sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
          }
          return compare2 & 4 ? -1 : 1;
        } : function(a2, b2) {
          if (a2 === b2) {
            hasDuplicate = true;
            return 0;
          }
          var cur, i3 = 0, aup = a2.parentNode, bup = b2.parentNode, ap = [a2], bp = [b2];
          if (!aup || !bup) {
            return a2 == document3 ? -1 : b2 == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
          } else if (aup === bup) {
            return siblingCheck(a2, b2);
          }
          cur = a2;
          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }
          cur = b2;
          while (cur = cur.parentNode) {
            bp.unshift(cur);
          }
          while (ap[i3] === bp[i3]) {
            i3++;
          }
          return i3 ? siblingCheck(ap[i3], bp[i3]) : ap[i3] == preferredDoc ? -1 : bp[i3] == preferredDoc ? 1 : 0;
        };
        return document3;
      };
      Sizzle2.matches = function(expr, elements) {
        return Sizzle2(expr, null, null, elements);
      };
      Sizzle2.matchesSelector = function(elem, expr) {
        setDocument(elem);
        if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches2.call(elem, expr);
            if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e2) {
            nonnativeSelectorCache(expr, true);
          }
        }
        return Sizzle2(expr, document3, null, [elem]).length > 0;
      };
      Sizzle2.contains = function(context2, elem) {
        if ((context2.ownerDocument || context2) != document3) {
          setDocument(context2);
        }
        return contains2(context2, elem);
      };
      Sizzle2.attr = function(elem, name2) {
        if ((elem.ownerDocument || elem) != document3) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name2.toLowerCase()], val = fn && hasOwn4.call(Expr.attrHandle, name2.toLowerCase()) ? fn(elem, name2, !documentIsHTML) : void 0;
        return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
      };
      Sizzle2.escape = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      Sizzle2.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle2.uniqueSort = function(results) {
        var elem, duplicates = [], j2 = 0, i3 = 0;
        hasDuplicate = !support2.detectDuplicates;
        sortInput = !support2.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while (elem = results[i3++]) {
            if (elem === results[i3]) {
              j2 = duplicates.push(i3);
            }
          }
          while (j2--) {
            results.splice(duplicates[j2], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle2.getText = function(elem) {
        var node, ret = "", i3 = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node = elem[i3++]) {
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle2.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },
        preFilter: {
          "ATTR": function(match2) {
            match2[1] = match2[1].replace(runescape, funescape);
            match2[3] = (match2[3] || match2[4] || match2[5] || "").replace(runescape, funescape);
            if (match2[2] === "~=") {
              match2[3] = " " + match2[3] + " ";
            }
            return match2.slice(0, 4);
          },
          "CHILD": function(match2) {
            match2[1] = match2[1].toLowerCase();
            if (match2[1].slice(0, 3) === "nth") {
              if (!match2[3]) {
                Sizzle2.error(match2[0]);
              }
              match2[4] = +(match2[4] ? match2[5] + (match2[6] || 1) : 2 * (match2[3] === "even" || match2[3] === "odd"));
              match2[5] = +(match2[7] + match2[8] || match2[3] === "odd");
            } else if (match2[3]) {
              Sizzle2.error(match2[0]);
            }
            return match2;
          },
          "PSEUDO": function(match2) {
            var excess, unquoted = !match2[6] && match2[2];
            if (matchExpr["CHILD"].test(match2[0])) {
              return null;
            }
            if (match2[3]) {
              match2[2] = match2[4] || match2[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match2[0] = match2[0].slice(0, excess);
              match2[2] = unquoted.slice(0, excess);
            }
            return match2.slice(0, 3);
          }
        },
        filter: {
          "TAG": function(nodeNameSelector) {
            var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function() {
              return true;
            } : function(elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
            };
          },
          "CLASS": function(className) {
            var pattern4 = classCache[className + " "];
            return pattern4 || (pattern4 = new RegExp("(^|" + whitespace4 + ")" + className + "(" + whitespace4 + "|$)")) && classCache(
              className,
              function(elem) {
                return pattern4.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              }
            );
          },
          "ATTR": function(name2, operator, check) {
            return function(elem) {
              var result = Sizzle2.attr(elem, name2);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          "CHILD": function(type4, what, _argument, first, last3) {
            var simple = type4.slice(0, 3) !== "nth", forward = type4.slice(-4) !== "last", ofType = what === "of-type";
            return first === 1 && last3 === 0 ? function(elem) {
              return !!elem.parentNode;
            } : function(elem, _context, xml) {
              var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent2 = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache2 = !xml && !ofType, diff2 = false;
              if (parent2) {
                if (simple) {
                  while (dir2) {
                    node = elem;
                    while (node = node[dir2]) {
                      if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                        return false;
                      }
                    }
                    start = dir2 = type4 === "only" && !start && "nextSibling";
                  }
                  return true;
                }
                start = [forward ? parent2.firstChild : parent2.lastChild];
                if (forward && useCache2) {
                  node = parent2;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type4] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff2 = nodeIndex && cache[2];
                  node = nodeIndex && parent2.childNodes[nodeIndex];
                  while (node = ++nodeIndex && node && node[dir2] || (diff2 = nodeIndex = 0) || start.pop()) {
                    if (node.nodeType === 1 && ++diff2 && node === elem) {
                      uniqueCache[type4] = [dirruns, nodeIndex, diff2];
                      break;
                    }
                  }
                } else {
                  if (useCache2) {
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type4] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff2 = nodeIndex;
                  }
                  if (diff2 === false) {
                    while (node = ++nodeIndex && node && node[dir2] || (diff2 = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff2) {
                        if (useCache2) {
                          outerCache = node[expando] || (node[expando] = {});
                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type4] = [dirruns, diff2];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                }
                diff2 -= last3;
                return diff2 === first || diff2 % first === 0 && diff2 / first >= 0;
              }
            };
          },
          "PSEUDO": function(pseudo, argument) {
            var args2, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args2 = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed2, matches3) {
                var idx, matched = fn(seed2, argument), i3 = matched.length;
                while (i3--) {
                  idx = indexOf3(seed2, matched[i3]);
                  seed2[idx] = !(matches3[idx] = matched[i3]);
                }
              }) : function(elem) {
                return fn(elem, 0, args2);
              };
            }
            return fn;
          }
        },
        pseudos: {
          "not": markFunction(function(selector) {
            var input = [], results = [], matcher = compile2(selector.replace(rtrim2, "$1"));
            return matcher[expando] ? markFunction(function(seed2, matches3, _context, xml) {
              var elem, unmatched = matcher(seed2, null, xml, []), i3 = seed2.length;
              while (i3--) {
                if (elem = unmatched[i3]) {
                  seed2[i3] = !(matches3[i3] = elem);
                }
              }
            }) : function(elem, _context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function(selector) {
            return function(elem) {
              return Sizzle2(selector, elem).length > 0;
            };
          }),
          "contains": markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || getText(elem)).indexOf(text) > -1;
            };
          }),
          "lang": markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle2.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          "target": function(elem) {
            var hash = window3.location && window3.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function(elem) {
            return elem === docElem;
          },
          "focus": function(elem) {
            return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function(elem) {
            var nodeName2 = elem.nodeName.toLowerCase();
            return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
          },
          "selected": function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          "empty": function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          "parent": function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          "header": function(elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function(elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return name2 === "input" && elem.type === "button" || name2 === "button";
          },
          "text": function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          "first": createPositionalPseudo(function() {
            return [0];
          }),
          "last": createPositionalPseudo(function(_matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function(matchIndexes, length) {
            var i3 = 0;
            for (; i3 < length; i3 += 2) {
              matchIndexes.push(i3);
            }
            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function(matchIndexes, length) {
            var i3 = 1;
            for (; i3 < length; i3 += 2) {
              matchIndexes.push(i3);
            }
            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i3 = argument < 0 ? argument + length : argument > length ? length : argument;
            for (; --i3 >= 0; ) {
              matchIndexes.push(i3);
            }
            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
            var i3 = argument < 0 ? argument + length : argument;
            for (; ++i3 < length; ) {
              matchIndexes.push(i3);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
        Expr.pseudos[i2] = createInputPseudo(i2);
      }
      for (i2 in { submit: true, reset: true }) {
        Expr.pseudos[i2] = createButtonPseudo(i2);
      }
      function setFilters() {
      }
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
        var matched, match2, tokens, type4, soFar, groups, preFilters, cached2 = tokenCache[selector + " "];
        if (cached2) {
          return parseOnly ? 0 : cached2.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match2 = rcomma.exec(soFar))) {
            if (match2) {
              soFar = soFar.slice(match2[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          if (match2 = rcombinators.exec(soFar)) {
            matched = match2.shift();
            tokens.push({
              value: matched,
              type: match2[0].replace(rtrim2, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type4 in Expr.filter) {
            if ((match2 = matchExpr[type4].exec(soFar)) && (!preFilters[type4] || (match2 = preFilters[type4](match2)))) {
              matched = match2.shift();
              tokens.push({
                value: matched,
                type: type4,
                matches: match2
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
      };
      function toSelector(tokens) {
        var i3 = 0, len = tokens.length, selector = "";
        for (; i3 < len; i3++) {
          selector += tokens[i3].value;
        }
        return selector;
      }
      function addCombinator(matcher, combinator, base2) {
        var dir2 = combinator.dir, skip = combinator.next, key2 = skip || dir2, checkNonElements = base2 && key2 === "parentNode", doneName = done++;
        return combinator.first ? function(elem, context2, xml) {
          while (elem = elem[dir2]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context2, xml);
            }
          }
          return false;
        } : function(elem, context2, xml) {
          var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
          if (xml) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context2, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir2] || elem;
                } else if ((oldCache = uniqueCache[key2]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  uniqueCache[key2] = newCache;
                  if (newCache[2] = matcher(elem, context2, xml)) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        };
      }
      function elementMatcher(matchers2) {
        return matchers2.length > 1 ? function(elem, context2, xml) {
          var i3 = matchers2.length;
          while (i3--) {
            if (!matchers2[i3](elem, context2, xml)) {
              return false;
            }
          }
          return true;
        } : matchers2[0];
      }
      function multipleContexts(selector, contexts, results) {
        var i3 = 0, len = contexts.length;
        for (; i3 < len; i3++) {
          Sizzle2(selector, contexts[i3], results);
        }
        return results;
      }
      function condense(unmatched, map, filter, context2, xml) {
        var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
        for (; i3 < len; i3++) {
          if (elem = unmatched[i3]) {
            if (!filter || filter(elem, context2, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i3);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed2, results, context2, xml) {
          var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed2 || multipleContexts(
            selector || "*",
            context2.nodeType ? [context2] : context2,
            []
          ), matcherIn = preFilter && (seed2 || !selector) ? condense(elems, preMap, preFilter, context2, xml) : elems, matcherOut = matcher ? postFinder || (seed2 ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context2, xml);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context2, xml);
            i3 = temp.length;
            while (i3--) {
              if (elem = temp[i3]) {
                matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
              }
            }
          }
          if (seed2) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i3 = matcherOut.length;
                while (i3--) {
                  if (elem = matcherOut[i3]) {
                    temp.push(matcherIn[i3] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml);
              }
              i3 = matcherOut.length;
              while (i3--) {
                if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf3(seed2, elem) : preMap[i3]) > -1) {
                  seed2[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(
              matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push3.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
          return indexOf3(checkContext, elem) > -1;
        }, implicitRelative, true), matchers2 = [function(elem, context2, xml) {
          var ret = !leadingRelative && (xml || context2 !== outermostContext) || ((checkContext = context2).nodeType ? matchContext(elem, context2, xml) : matchAnyContext(elem, context2, xml));
          checkContext = null;
          return ret;
        }];
        for (; i3 < len; i3++) {
          if (matcher = Expr.relative[tokens[i3].type]) {
            matchers2 = [addCombinator(elementMatcher(matchers2), matcher)];
          } else {
            matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
            if (matcher[expando]) {
              j2 = ++i3;
              for (; j2 < len; j2++) {
                if (Expr.relative[tokens[j2].type]) {
                  break;
                }
              }
              return setMatcher(
                i3 > 1 && elementMatcher(matchers2),
                i3 > 1 && toSelector(
                  tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                ).replace(rtrim2, "$1"),
                matcher,
                i3 < j2 && matcherFromTokens(tokens.slice(i3, j2)),
                j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                j2 < len && toSelector(tokens)
              );
            }
            matchers2.push(matcher);
          }
        }
        return elementMatcher(matchers2);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed2, context2, xml, results, outermost) {
          var elem, j2, matcher, matchedCount = 0, i3 = "0", unmatched = seed2 && [], setMatched = [], contextBackup = outermostContext, elems = seed2 || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            outermostContext = context2 == document3 || context2 || outermost;
          }
          for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
            if (byElement && elem) {
              j2 = 0;
              if (!context2 && elem.ownerDocument != document3) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher = elementMatchers[j2++]) {
                if (matcher(elem, context2 || document3, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed2) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i3;
          if (bySet && i3 !== matchedCount) {
            j2 = 0;
            while (matcher = setMatchers[j2++]) {
              matcher(unmatched, setMatched, context2, xml);
            }
            if (seed2) {
              if (matchedCount > 0) {
                while (i3--) {
                  if (!(unmatched[i3] || setMatched[i3])) {
                    setMatched[i3] = pop2.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push3.apply(results, setMatched);
            if (outermost && !seed2 && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle2.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      compile2 = Sizzle2.compile = function(selector, match2) {
        var i3, setMatchers = [], elementMatchers = [], cached2 = compilerCache[selector + " "];
        if (!cached2) {
          if (!match2) {
            match2 = tokenize(selector);
          }
          i3 = match2.length;
          while (i3--) {
            cached2 = matcherFromTokens(match2[i3]);
            if (cached2[expando]) {
              setMatchers.push(cached2);
            } else {
              elementMatchers.push(cached2);
            }
          }
          cached2 = compilerCache(
            selector,
            matcherFromGroupMatchers(elementMatchers, setMatchers)
          );
          cached2.selector = selector;
        }
        return cached2;
      };
      select = Sizzle2.select = function(selector, context2, results, seed2) {
        var i3, tokens, token2, type4, find2, compiled = typeof selector === "function" && selector, match2 = !seed2 && tokenize(selector = compiled.selector || selector);
        results = results || [];
        if (match2.length === 1) {
          tokens = match2[0] = match2[0].slice(0);
          if (tokens.length > 2 && (token2 = tokens[0]).type === "ID" && context2.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context2 = (Expr.find["ID"](token2.matches[0].replace(runescape, funescape), context2) || [])[0];
            if (!context2) {
              return results;
            } else if (compiled) {
              context2 = context2.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i3--) {
            token2 = tokens[i3];
            if (Expr.relative[type4 = token2.type]) {
              break;
            }
            if (find2 = Expr.find[type4]) {
              if (seed2 = find2(
                token2.matches[0].replace(runescape, funescape),
                rsibling.test(tokens[0].type) && testContext(context2.parentNode) || context2
              )) {
                tokens.splice(i3, 1);
                selector = seed2.length && toSelector(tokens);
                if (!selector) {
                  push3.apply(results, seed2);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile2(selector, match2))(
          seed2,
          context2,
          !documentIsHTML,
          results,
          !context2 || rsibling.test(selector) && testContext(context2.parentNode) || context2
        );
        return results;
      };
      support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support2.detectDuplicates = !!hasDuplicate;
      setDocument();
      support2.sortDetached = assert(function(el) {
        return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
      });
      if (!assert(function(el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function(elem, name2, isXML2) {
          if (!isXML2) {
            return elem.getAttribute(name2, name2.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support2.attributes || !assert(function(el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function(elem, _name, isXML2) {
          if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function(elem, name2, isXML2) {
          var val;
          if (!isXML2) {
            return elem[name2] === true ? name2.toLowerCase() : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
          }
        });
      }
      return Sizzle2;
    }(window2);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n2, elem) {
      var matched = [];
      for (; n2; n2 = n2.nextSibling) {
        if (n2.nodeType === 1 && n2 !== elem) {
          matched.push(n2);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name2) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction3(qualifier)) {
        return jQuery.grep(elements, function(elem, i2) {
          return !!qualifier.call(elem, i2, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function(elem) {
          return indexOf2.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery.fn.extend({
      find: function(selector) {
        var i2, ret, len = this.length, self2 = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function() {
            for (i2 = 0; i2 < len; i2++) {
              if (jQuery.contains(self2[i2], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i2 = 0; i2 < len; i2++) {
          jQuery.find(selector, self2[i2], ret);
        }
        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context2, root2) {
      var match2, elem;
      if (!selector) {
        return this;
      }
      root2 = root2 || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match2 = [null, selector, null];
        } else {
          match2 = rquickExpr.exec(selector);
        }
        if (match2 && (match2[1] || !context2)) {
          if (match2[1]) {
            context2 = context2 instanceof jQuery ? context2[0] : context2;
            jQuery.merge(this, jQuery.parseHTML(
              match2[1],
              context2 && context2.nodeType ? context2.ownerDocument || context2 : document2,
              true
            ));
            if (rsingleTag.test(match2[1]) && jQuery.isPlainObject(context2)) {
              for (match2 in context2) {
                if (isFunction3(this[match2])) {
                  this[match2](context2[match2]);
                } else {
                  this.attr(match2, context2[match2]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match2[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context2 || context2.jquery) {
          return (context2 || root2).find(selector);
        } else {
          return this.constructor(context2).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction3(selector)) {
        return root2.ready !== void 0 ? root2.ready(selector) : selector(jQuery);
      }
      return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function(target) {
        var targets = jQuery(target, this), l2 = targets.length;
        return this.filter(function() {
          var i2 = 0;
          for (; i2 < l2; i2++) {
            if (jQuery.contains(this, targets[i2])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context2) {
        var cur, i2 = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i2 < l2; i2++) {
            for (cur = this[i2]; cur && cur !== context2; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf2.call(jQuery(elem), this[0]);
        }
        return indexOf2.call(
          this,
          elem.jquery ? elem[0] : elem
        );
      },
      add: function(selector, context2) {
        return this.pushStack(
          jQuery.uniqueSort(
            jQuery.merge(this.get(), jQuery(selector, context2))
          )
        );
      },
      addBack: function(selector) {
        return this.add(
          selector == null ? this.prevObject : this.prevObject.filter(selector)
        );
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery.each({
      parent: function(elem) {
        var parent2 = elem.parentNode;
        return parent2 && parent2.nodeType !== 11 ? parent2 : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && getProto2(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery.merge([], elem.childNodes);
      }
    }, function(name2, fn) {
      jQuery.fn[name2] = function(until, selector) {
        var matched = jQuery.map(this, fn, until);
        if (name2.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name2]) {
            jQuery.uniqueSort(matched);
          }
          if (rparentsprev.test(name2)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object4 = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
        object4[flag] = true;
      });
      return object4;
    }
    jQuery.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
      var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue2.length; firingIndex = -1) {
          memory = queue2.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue2.push(memory);
            }
            (function add2(args2) {
              jQuery.each(args2, function(_2, arg) {
                if (isFunction3(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add2(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        remove: function() {
          jQuery.each(arguments, function(_2, arg) {
            var index2;
            while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
              list.splice(index2, 1);
              if (index2 <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        disable: function() {
          locked = queue2 = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        lock: function() {
          locked = queue2 = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        fireWith: function(context2, args2) {
          if (!locked) {
            args2 = args2 || [];
            args2 = [context2, args2.slice ? args2.slice() : args2];
            queue2.push(args2);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v2) {
      return v2;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve2, reject, noValue) {
      var method4;
      try {
        if (value && isFunction3(method4 = value.promise)) {
          method4.call(value).done(resolve2).fail(reject);
        } else if (value && isFunction3(method4 = value.then)) {
          method4.call(value, resolve2, reject);
        } else {
          resolve2.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject.apply(void 0, [value2]);
      }
    }
    jQuery.extend({
      Deferred: function(func) {
        var tuples = [
          [
            "notify",
            "progress",
            jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn) {
            return promise.then(null, fn);
          },
          pipe: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(_i, tuple4) {
                var fn = isFunction3(fns[tuple4[4]]) && fns[tuple4[4]];
                deferred[tuple4[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction3(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple4[0] + "With"](
                      this,
                      fn ? [returned] : arguments
                    );
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve2(depth, deferred2, handler5, special) {
              return function() {
                var that = this, args2 = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler5.apply(that, args2);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction3(then)) {
                    if (special) {
                      then.call(
                        returned,
                        resolve2(maxDepth, deferred2, Identity, special),
                        resolve2(maxDepth, deferred2, Thrower, special)
                      );
                    } else {
                      maxDepth++;
                      then.call(
                        returned,
                        resolve2(maxDepth, deferred2, Identity, special),
                        resolve2(maxDepth, deferred2, Thrower, special),
                        resolve2(
                          maxDepth,
                          deferred2,
                          Identity,
                          deferred2.notifyWith
                        )
                      );
                    }
                  } else {
                    if (handler5 !== Identity) {
                      that = void 0;
                      args2 = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args2);
                  }
                }, process2 = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e2) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(
                        e2,
                        process2.stackTrace
                      );
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler5 !== Thrower) {
                        that = void 0;
                        args2 = [e2];
                      }
                      deferred2.rejectWith(that, args2);
                    }
                  }
                };
                if (depth) {
                  process2();
                } else {
                  if (jQuery.Deferred.getStackHook) {
                    process2.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window2.setTimeout(process2);
                }
              };
            }
            return jQuery.Deferred(function(newDefer) {
              tuples[0][3].add(
                resolve2(
                  0,
                  newDefer,
                  isFunction3(onProgress) ? onProgress : Identity,
                  newDefer.notifyWith
                )
              );
              tuples[1][3].add(
                resolve2(
                  0,
                  newDefer,
                  isFunction3(onFulfilled) ? onFulfilled : Identity
                )
              );
              tuples[2][3].add(
                resolve2(
                  0,
                  newDefer,
                  isFunction3(onRejected) ? onRejected : Thrower
                )
              );
            }).promise();
          },
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery.each(tuples, function(i2, tuple4) {
          var list = tuple4[2], stateString = tuple4[5];
          promise[tuple4[1]] = list.add;
          if (stateString) {
            list.add(
              function() {
                state = stateString;
              },
              tuples[3 - i2][2].disable,
              tuples[3 - i2][3].disable,
              tuples[0][2].lock,
              tuples[0][3].lock
            );
          }
          list.add(tuple4[3].fire);
          deferred[tuple4[0]] = function() {
            deferred[tuple4[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple4[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      when: function(singleValue) {
        var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice2.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i3) {
          return function(value) {
            resolveContexts[i3] = this;
            resolveValues[i3] = arguments.length > 1 ? slice2.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(
            singleValue,
            primary.done(updateFunc(i2)).resolve,
            primary.reject,
            !remaining
          );
          if (primary.state() === "pending" || isFunction3(resolveValues[i2] && resolveValues[i2].then)) {
            return primary.then();
          }
        }
        while (i2--) {
          adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack2) {
      if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
        window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack2);
      }
    };
    jQuery.readyException = function(error) {
      window2.setTimeout(function() {
        throw error;
      });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error) {
        jQuery.readyException(error);
      });
      return this;
    };
    jQuery.extend({
      isReady: false,
      readyWait: 1,
      ready: function(wait) {
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }
        jQuery.isReady = true;
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn, key2, value, chainable, emptyGet, raw) {
      var i2 = 0, len = elems.length, bulk = key2 == null;
      if (toType(key2) === "object") {
        chainable = true;
        for (i2 in key2) {
          access(elems, fn, i2, key2[i2], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction3(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, _key, value2) {
              return bulk.call(jQuery(elem), value2);
            };
          }
        }
        if (fn) {
          for (; i2 < len; i2++) {
            fn(
              elems[i2],
              key2,
              raw ? value : value.call(elems[i2], i2, fn(elems[i2], key2))
            );
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key2) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string3) {
      return string3.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data9, value) {
        var prop, cache = this.cache(owner);
        if (typeof data9 === "string") {
          cache[camelCase(data9)] = value;
        } else {
          for (prop in data9) {
            cache[camelCase(prop)] = data9[prop];
          }
        }
        return cache;
      },
      get: function(owner, key2) {
        return key2 === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key2)];
      },
      access: function(owner, key2, value) {
        if (key2 === void 0 || key2 && typeof key2 === "string" && value === void 0) {
          return this.get(owner, key2);
        }
        this.set(owner, key2, value);
        return value !== void 0 ? value : key2;
      },
      remove: function(owner, key2) {
        var i2, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key2 !== void 0) {
          if (Array.isArray(key2)) {
            key2 = key2.map(camelCase);
          } else {
            key2 = camelCase(key2);
            key2 = key2 in cache ? [key2] : key2.match(rnothtmlwhite) || [];
          }
          i2 = key2.length;
          while (i2--) {
            delete cache[key2[i2]];
          }
        }
        if (key2 === void 0 || jQuery.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data9) {
      if (data9 === "true") {
        return true;
      }
      if (data9 === "false") {
        return false;
      }
      if (data9 === "null") {
        return null;
      }
      if (data9 === +data9 + "") {
        return +data9;
      }
      if (rbrace.test(data9)) {
        return JSON.parse(data9);
      }
      return data9;
    }
    function dataAttr(elem, key2, data9) {
      var name2;
      if (data9 === void 0 && elem.nodeType === 1) {
        name2 = "data-" + key2.replace(rmultiDash, "-$&").toLowerCase();
        data9 = elem.getAttribute(name2);
        if (typeof data9 === "string") {
          try {
            data9 = getData(data9);
          } catch (e2) {
          }
          dataUser.set(elem, key2, data9);
        } else {
          data9 = void 0;
        }
      }
      return data9;
    }
    jQuery.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name2, data9) {
        return dataUser.access(elem, name2, data9);
      },
      removeData: function(elem, name2) {
        dataUser.remove(elem, name2);
      },
      _data: function(elem, name2, data9) {
        return dataPriv.access(elem, name2, data9);
      },
      _removeData: function(elem, name2) {
        dataPriv.remove(elem, name2);
      }
    });
    jQuery.fn.extend({
      data: function(key2, value) {
        var i2, name2, data9, elem = this[0], attrs = elem && elem.attributes;
        if (key2 === void 0) {
          if (this.length) {
            data9 = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i2 = attrs.length;
              while (i2--) {
                if (attrs[i2]) {
                  name2 = attrs[i2].name;
                  if (name2.indexOf("data-") === 0) {
                    name2 = camelCase(name2.slice(5));
                    dataAttr(elem, name2, data9[name2]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data9;
        }
        if (typeof key2 === "object") {
          return this.each(function() {
            dataUser.set(this, key2);
          });
        }
        return access(this, function(value2) {
          var data10;
          if (elem && value2 === void 0) {
            data10 = dataUser.get(elem, key2);
            if (data10 !== void 0) {
              return data10;
            }
            data10 = dataAttr(elem, key2);
            if (data10 !== void 0) {
              return data10;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key2, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key2) {
        return this.each(function() {
          dataUser.remove(this, key2);
        });
      }
    });
    jQuery.extend({
      queue: function(elem, type4, data9) {
        var queue2;
        if (elem) {
          type4 = (type4 || "fx") + "queue";
          queue2 = dataPriv.get(elem, type4);
          if (data9) {
            if (!queue2 || Array.isArray(data9)) {
              queue2 = dataPriv.access(elem, type4, jQuery.makeArray(data9));
            } else {
              queue2.push(data9);
            }
          }
          return queue2 || [];
        }
      },
      dequeue: function(elem, type4) {
        type4 = type4 || "fx";
        var queue2 = jQuery.queue(elem, type4), startLength = queue2.length, fn = queue2.shift(), hooks = jQuery._queueHooks(elem, type4), next2 = function() {
          jQuery.dequeue(elem, type4);
        };
        if (fn === "inprogress") {
          fn = queue2.shift();
          startLength--;
        }
        if (fn) {
          if (type4 === "fx") {
            queue2.unshift("inprogress");
          }
          delete hooks.stop;
          fn.call(elem, next2, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      _queueHooks: function(elem, type4) {
        var key2 = type4 + "queueHooks";
        return dataPriv.get(elem, key2) || dataPriv.access(elem, key2, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type4 + "queue", key2]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function(type4, data9) {
        var setter = 2;
        if (typeof type4 !== "string") {
          data9 = type4;
          type4 = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery.queue(this[0], type4);
        }
        return data9 === void 0 ? this : this.each(function() {
          var queue2 = jQuery.queue(this, type4, data9);
          jQuery._queueHooks(this, type4);
          if (type4 === "fx" && queue2[0] !== "inprogress") {
            jQuery.dequeue(this, type4);
          }
        });
      },
      dequeue: function(type4) {
        return this.each(function() {
          jQuery.dequeue(this, type4);
        });
      },
      clearQueue: function(type4) {
        return this.queue(type4 || "fx", []);
      },
      promise: function(type4, obj) {
        var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i2 = this.length, resolve2 = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
        if (typeof type4 !== "string") {
          obj = type4;
          type4 = void 0;
        }
        type4 = type4 || "fx";
        while (i2--) {
          tmp = dataPriv.get(elements[i2], type4 + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve2);
          }
        }
        resolve2();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached = function(elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc2.body.appendChild(doc2.createElement(nodeName2));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values = [], index2 = 0, length = elements.length;
      for (; index2 < length; index2++) {
        elem = elements[index2];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values[index2] = dataPriv.get(elem, "display") || null;
            if (!values[index2]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index2] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index2] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index2 = 0; index2 < length; index2++) {
        if (values[index2] != null) {
          elements[index2].style.display = values[index2];
        }
      }
      return elements;
    }
    jQuery.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context2, tag) {
      var ret;
      if (typeof context2.getElementsByTagName !== "undefined") {
        ret = context2.getElementsByTagName(tag || "*");
      } else if (typeof context2.querySelectorAll !== "undefined") {
        ret = context2.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context2, tag)) {
        return jQuery.merge([context2], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i2 = 0, l2 = elems.length;
      for (; i2 < l2; i2++) {
        dataPriv.set(
          elems[i2],
          "globalEval",
          !refElements || dataPriv.get(refElements[i2], "globalEval")
        );
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context2, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j2, fragment = context2.createDocumentFragment(), nodes = [], i2 = 0, l2 = elems.length;
      for (; i2 < l2; i2++) {
        elem = elems[i2];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context2.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context2.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
            j2 = wrap[0];
            while (j2--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i2 = 0;
      while (elem = nodes[i2++]) {
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j2 = 0;
          while (elem = tmp[j2++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function expectSync(elem, type4) {
      return elem === safeActiveElement() === (type4 === "focus");
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on(elem, types2, selector, data9, fn, one) {
      var origFn, type4;
      if (typeof types2 === "object") {
        if (typeof selector !== "string") {
          data9 = data9 || selector;
          selector = void 0;
        }
        for (type4 in types2) {
          on(elem, type4, selector, data9, types2[type4], one);
        }
        return elem;
      }
      if (data9 == null && fn == null) {
        fn = selector;
        data9 = selector = void 0;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data9;
          data9 = void 0;
        } else {
          fn = data9;
          data9 = selector;
          selector = void 0;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event2) {
          jQuery().off(event2);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function() {
        jQuery.event.add(this, types2, fn, data9, selector);
      });
    }
    jQuery.event = {
      global: {},
      add: function(elem, types2, handler5, data9, selector) {
        var handleObjIn, eventHandle, tmp, events2, t2, handleObj, special, handlers, type4, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler5.handler) {
          handleObjIn = handler5;
          handler5 = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        }
        if (!handler5.guid) {
          handler5.guid = jQuery.guid++;
        }
        if (!(events2 = elemData.events)) {
          events2 = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e2) {
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e2.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types2 = (types2 || "").match(rnothtmlwhite) || [""];
        t2 = types2.length;
        while (t2--) {
          tmp = rtypenamespace.exec(types2[t2]) || [];
          type4 = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type4) {
            continue;
          }
          special = jQuery.event.special[type4] || {};
          type4 = (selector ? special.delegateType : special.bindType) || type4;
          special = jQuery.event.special[type4] || {};
          handleObj = jQuery.extend({
            type: type4,
            origType,
            data: data9,
            handler: handler5,
            guid: handler5.guid,
            selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events2[type4])) {
            handlers = events2[type4] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data9, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type4, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler5.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery.event.global[type4] = true;
        }
      },
      remove: function(elem, types2, handler5, selector, mappedTypes) {
        var j2, origCount, tmp, events2, t2, handleObj, special, handlers, type4, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events2 = elemData.events)) {
          return;
        }
        types2 = (types2 || "").match(rnothtmlwhite) || [""];
        t2 = types2.length;
        while (t2--) {
          tmp = rtypenamespace.exec(types2[t2]) || [];
          type4 = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type4) {
            for (type4 in events2) {
              jQuery.event.remove(elem, type4 + types2[t2], handler5, selector, true);
            }
            continue;
          }
          special = jQuery.event.special[type4] || {};
          type4 = (selector ? special.delegateType : special.bindType) || type4;
          handlers = events2[type4] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j2 = handlers.length;
          while (j2--) {
            handleObj = handlers[j2];
            if ((mappedTypes || origType === handleObj.origType) && (!handler5 || handler5.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j2, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type4, elemData.handle);
            }
            delete events2[type4];
          }
        }
        if (jQuery.isEmptyObject(events2)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i2, j2, ret, matched, handleObj, handlerQueue, args2 = new Array(arguments.length), event2 = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event2.type] || [], special = jQuery.event.special[event2.type] || {};
        args2[0] = event2;
        for (i2 = 1; i2 < arguments.length; i2++) {
          args2[i2] = arguments[i2];
        }
        event2.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event2) === false) {
          return;
        }
        handlerQueue = jQuery.event.handlers.call(this, event2, handlers);
        i2 = 0;
        while ((matched = handlerQueue[i2++]) && !event2.isPropagationStopped()) {
          event2.currentTarget = matched.elem;
          j2 = 0;
          while ((handleObj = matched.handlers[j2++]) && !event2.isImmediatePropagationStopped()) {
            if (!event2.rnamespace || handleObj.namespace === false || event2.rnamespace.test(handleObj.namespace)) {
              event2.handleObj = handleObj;
              event2.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args2);
              if (ret !== void 0) {
                if ((event2.result = ret) === false) {
                  event2.preventDefault();
                  event2.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event2);
        }
        return event2.result;
      },
      handlers: function(event2, handlers) {
        var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event2.target;
        if (delegateCount && cur.nodeType && !(event2.type === "click" && event2.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event2.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i2 = 0; i2 < delegateCount; i2++) {
                handleObj = handlers[i2];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name2, hook) {
        Object.defineProperty(jQuery.Event.prototype, name2, {
          enumerable: true,
          configurable: true,
          get: isFunction3(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name2];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name2, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          noBubble: true
        },
        click: {
          setup: function(data9) {
            var el = this || data9;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", returnTrue);
            }
            return false;
          },
          trigger: function(data9) {
            var el = this || data9;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          _default: function(event2) {
            var target = event2.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event2) {
            if (event2.result !== void 0 && event2.originalEvent) {
              event2.originalEvent.returnValue = event2.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type4, expectSync2) {
      if (!expectSync2) {
        if (dataPriv.get(el, type4) === void 0) {
          jQuery.event.add(el, type4, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type4, false);
      jQuery.event.add(el, type4, {
        namespace: false,
        handler: function(event2) {
          var notAsync, result, saved = dataPriv.get(this, type4);
          if (event2.isTrigger & 1 && this[type4]) {
            if (!saved.length) {
              saved = slice2.call(arguments);
              dataPriv.set(this, type4, saved);
              notAsync = expectSync2(this, type4);
              this[type4]();
              result = dataPriv.get(this, type4);
              if (saved !== result || notAsync) {
                dataPriv.set(this, type4, false);
              } else {
                result = {};
              }
              if (saved !== result) {
                event2.stopImmediatePropagation();
                event2.preventDefault();
                return result && result.value;
              }
            } else if ((jQuery.event.special[type4] || {}).delegateType) {
              event2.stopPropagation();
            }
          } else if (saved.length) {
            dataPriv.set(this, type4, {
              value: jQuery.event.trigger(
                jQuery.extend(saved[0], jQuery.Event.prototype),
                saved.slice(1),
                this
              )
            });
            event2.stopImmediatePropagation();
          }
        }
      });
    }
    jQuery.removeEvent = function(elem, type4, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type4, handle);
      }
    };
    jQuery.Event = function(src2, props3) {
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src2, props3);
      }
      if (src2 && src2.type) {
        this.originalEvent = src2;
        this.type = src2.type;
        this.isDefaultPrevented = src2.defaultPrevented || src2.defaultPrevented === void 0 && src2.returnValue === false ? returnTrue : returnFalse;
        this.target = src2.target && src2.target.nodeType === 3 ? src2.target.parentNode : src2.target;
        this.currentTarget = src2.currentTarget;
        this.relatedTarget = src2.relatedTarget;
      } else {
        this.type = src2;
      }
      if (props3) {
        jQuery.extend(this, props3);
      }
      this.timeStamp = src2 && src2.timeStamp || Date.now();
      this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e2 = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e2 && !this.isSimulated) {
          e2.preventDefault();
        }
      },
      stopPropagation: function() {
        var e2 = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e2 && !this.isSimulated) {
          e2.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e2 = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e2 && !this.isSimulated) {
          e2.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(type4, delegateType) {
      jQuery.event.special[type4] = {
        setup: function() {
          leverageNative(this, type4, expectSync);
          return false;
        },
        trigger: function() {
          leverageNative(this, type4);
          return true;
        },
        _default: function(event2) {
          return dataPriv.get(event2.target, type4);
        },
        delegateType
      };
    });
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event2) {
          var ret, target = this, related = event2.relatedTarget, handleObj = event2.handleObj;
          if (!related || related !== target && !jQuery.contains(target, related)) {
            event2.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event2.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function(types2, selector, data9, fn) {
        return on(this, types2, selector, data9, fn);
      },
      one: function(types2, selector, data9, fn) {
        return on(this, types2, selector, data9, fn, 1);
      },
      off: function(types2, selector, fn) {
        var handleObj, type4;
        if (types2 && types2.preventDefault && types2.handleObj) {
          handleObj = types2.handleObj;
          jQuery(types2.delegateTarget).off(
            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types2 === "object") {
          for (type4 in types2) {
            this.off(type4, selector, types2[type4]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn = selector;
          selector = void 0;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery.event.remove(this, types2, fn, selector);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src2, dest) {
      var i2, l2, type4, pdataOld, udataOld, udataCur, events2;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src2)) {
        pdataOld = dataPriv.get(src2);
        events2 = pdataOld.events;
        if (events2) {
          dataPriv.remove(dest, "handle events");
          for (type4 in events2) {
            for (i2 = 0, l2 = events2[type4].length; i2 < l2; i2++) {
              jQuery.event.add(dest, type4, events2[type4][i2]);
            }
          }
        }
      }
      if (dataUser.hasData(src2)) {
        udataOld = dataUser.access(src2);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src2, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src2.type)) {
        dest.checked = src2.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src2.defaultValue;
      }
    }
    function domManip(collection, args2, callback, ignored) {
      args2 = flat(args2);
      var fragment, first, scripts, hasScripts, node, doc2, i2 = 0, l2 = collection.length, iNoClone = l2 - 1, value = args2[0], valueIsFunction = isFunction3(value);
      if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index2) {
          var self2 = collection.eq(index2);
          if (valueIsFunction) {
            args2[0] = value.call(this, index2, self2.html());
          }
          domManip(self2, args2, callback, ignored);
        });
      }
      if (l2) {
        fragment = buildFragment(args2, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i2 < l2; i2++) {
            node = fragment;
            if (i2 !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i2], node, i2);
          }
          if (hasScripts) {
            doc2 = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i2 = 0; i2 < hasScripts; i2++) {
              node = scripts[i2];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc2, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery._evalUrl && !node.noModule) {
                    jQuery._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc2);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove2(elem, selector, keepData) {
      var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i2 = 0;
      for (; (node = nodes[i2]) != null; i2++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery.extend({
      htmlPrefilter: function(html2) {
        return html2;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i2, l2, srcElements, destElements, clone3 = elem.cloneNode(true), inPage = isAttached(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          destElements = getAll(clone3);
          srcElements = getAll(elem);
          for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
            fixInput(srcElements[i2], destElements[i2]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone3);
            for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
              cloneCopyEvent(srcElements[i2], destElements[i2]);
            }
          } else {
            cloneCopyEvent(elem, clone3);
          }
        }
        destElements = getAll(clone3, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone3;
      },
      cleanData: function(elems) {
        var data9, elem, type4, special = jQuery.event.special, i2 = 0;
        for (; (elem = elems[i2]) !== void 0; i2++) {
          if (acceptData(elem)) {
            if (data9 = elem[dataPriv.expando]) {
              if (data9.events) {
                for (type4 in data9.events) {
                  if (special[type4]) {
                    jQuery.event.remove(elem, type4);
                  } else {
                    jQuery.removeEvent(elem, type4, data9.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function(selector) {
        return remove2(this, selector, true);
      },
      remove: function(selector) {
        return remove2(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i2 = 0;
        for (; (elem = this[i2]) != null; i2++) {
          if (elem.nodeType === 1) {
            jQuery.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i2 = 0, l2 = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery.htmlPrefilter(value2);
            try {
              for (; i2 < l2; i2++) {
                elem = this[i2] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e2) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent2 = this.parentNode;
          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent2) {
              parent2.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name2, original) {
      jQuery.fn[name2] = function(selector) {
        var elems, ret = [], insert = jQuery(selector), last3 = insert.length - 1, i2 = 0;
        for (; i2 <= last3; i2++) {
          elems = i2 === last3 ? this : this.clone(true);
          jQuery(insert[i2])[original](elems);
          push2.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap2 = function(elem, options, callback) {
      var ret, name2, old = {};
      for (name2 in options) {
        old[name2] = elem.style[name2];
        elem.style[name2] = options[name2];
      }
      ret = callback.call(elem);
      for (name2 in options) {
        elem.style[name2] = old[name2];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    var whitespace3 = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp(
      "^" + whitespace3 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace3 + "+$",
      "g"
    );
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure2) {
        return Math.round(parseFloat(measure2));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name2, computed2) {
      var width, minWidth, maxWidth2, ret, isCustomProp = rcustomProp.test(name2), style2 = elem.style;
      computed2 = computed2 || getStyles(elem);
      if (computed2) {
        ret = computed2.getPropertyValue(name2) || computed2[name2];
        if (isCustomProp) {
          ret = ret.replace(rtrimCSS, "$1");
        }
        if (ret === "" && !isAttached(elem)) {
          ret = jQuery.style(elem, name2);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
          width = style2.width;
          minWidth = style2.minWidth;
          maxWidth2 = style2.maxWidth;
          style2.minWidth = style2.maxWidth = style2.width = ret;
          ret = computed2.width;
          style2.width = width;
          style2.minWidth = minWidth;
          style2.maxWidth = maxWidth2;
        }
      }
      return ret !== void 0 ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name2) {
      var capName = name2[0].toUpperCase() + name2.slice(1), i2 = cssPrefixes.length;
      while (i2--) {
        name2 = cssPrefixes[i2] + capName;
        if (name2 in emptyStyle) {
          return name2;
        }
      }
    }
    function finalPropName(name2) {
      var final = jQuery.cssProps[name2] || vendorProps[name2];
      if (final) {
        return final;
      }
      if (name2 in emptyStyle) {
        return name2;
      }
      return vendorProps[name2] = vendorPropName(name2) || name2;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow2 = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
      var matches2 = rcssNum.exec(value);
      return matches2 ? Math.max(0, matches2[2] - (subtract || 0)) + (matches2[3] || "px") : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i2 < 4; i2 += 2) {
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i2], true, styles);
        }
        if (!isBorderBox) {
          delta += jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i2], true, styles);
          }
          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
        )) || 0;
      }
      return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(
        elem,
        dimension,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles,
        val
      ) + "px";
    }
    jQuery.extend({
      cssHooks: {
        opacity: {
          get: function(elem, computed2) {
            if (computed2) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      cssProps: {},
      style: function(elem, name2, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type4, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style2 = elem.style;
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
        if (value !== void 0) {
          type4 = typeof value;
          if (type4 === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name2, ret);
            type4 = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type4 === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
            style2[name2] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style2.setProperty(name2, value);
            } else {
              style2[name2] = value;
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style2[name2];
        }
      },
      css: function(elem, name2, extra, styles) {
        var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name2, styles);
        }
        if (val === "normal" && name2 in cssNormalTransform) {
          val = cssNormalTransform[name2];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery.each(["height", "width"], function(_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function(elem, computed2, extra) {
          if (computed2) {
            return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap2(elem, cssShow2, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches2, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles
          ) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
            );
          }
          if (subtract && (matches2 = rcssNum.exec(value)) && (matches2[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(
      support.reliableMarginLeft,
      function(elem, computed2) {
        if (computed2) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap2(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }
    );
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i2 < 4; i2++) {
            expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function(name2, value) {
        return access(this, function(elem, name3, value2) {
          var styles, len, map = {}, i2 = 0;
          if (Array.isArray(name3)) {
            styles = getStyles(elem);
            len = name3.length;
            for (; i2 < len; i2++) {
              map[name3[i2]] = jQuery.css(elem, name3[i2], false, styles);
            }
            return map;
          }
          return value2 !== void 0 ? jQuery.style(elem, name3, value2) : jQuery.css(elem, name3);
        }, name2, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](
            percent,
            this.options.duration * percent,
            0,
            1,
            this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function(p2) {
        return p2;
      },
      swing: function(p2) {
        return 0.5 - Math.cos(p2 * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery.fx.interval);
        }
        jQuery.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type4, includeWidth) {
      var which, i2 = 0, attrs = { height: type4 };
      includeWidth = includeWidth ? 1 : 0;
      for (; i2 < 4; i2 += 2 - includeWidth) {
        which = cssExpand[i2];
        attrs["margin" + which] = attrs["padding" + which] = type4;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type4;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index2 = 0, length = collection.length;
      for (; index2 < length; index2++) {
        if (tween = collection[index2].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props3, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props3 || "height" in props3, anim = this, orig = {}, style2 = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      for (prop in props3) {
        value = props3[prop];
        if (rfxtypes.test(value)) {
          delete props3[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }
      propTween = !jQuery.isEmptyObject(props3);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style2.overflow, style2.overflowX, style2.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style2.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style2.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style2.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style2.overflow = "hidden";
        anim.always(function() {
          style2.overflow = opts.overflow[0];
          style2.overflowX = opts.overflow[1];
          style2.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props3, specialEasing) {
      var index2, name2, easing, value, hooks;
      for (index2 in props3) {
        name2 = camelCase(index2);
        easing = specialEasing[name2];
        value = props3[index2];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props3[index2] = value[0];
        }
        if (index2 !== name2) {
          props3[name2] = value;
          delete props3[index2];
        }
        hooks = jQuery.cssHooks[name2];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props3[name2];
          for (index2 in value) {
            if (!(index2 in props3)) {
              props3[index2] = value[index2];
              specialEasing[index2] = easing;
            }
          }
        } else {
          specialEasing[name2] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result, stopped, index2 = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index3 = 0, length2 = animation.tweens.length;
        for (; index3 < length2; index3++) {
          animation.tweens[index3].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        }
        if (!length2) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index3 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index3 < length2; index3++) {
            animation.tweens[index3].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props3 = animation.props;
      propFilter(props3, animation.opts.specialEasing);
      for (; index2 < length; index2++) {
        result = Animation.prefilters[index2].call(animation, elem, props3, animation.opts);
        if (result) {
          if (isFunction3(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery.map(props3, createTween, animation);
      if (isFunction3(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(
        jQuery.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );
      return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props3, callback) {
        if (isFunction3(props3)) {
          callback = props3;
          props3 = ["*"];
        } else {
          props3 = props3.match(rnothtmlwhite);
        }
        var prop, index2 = 0, length = props3.length;
        for (; index2 < length; index2++) {
          prop = props3[index2];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery.speed = function(speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction3(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction3(easing) && easing
      };
      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction3(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty2 = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty2 || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty2 || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type4, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop2 = hooks.stop;
          delete hooks.stop;
          stop2(gotoEnd);
        };
        if (typeof type4 !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type4;
          type4 = void 0;
        }
        if (clearQueue) {
          this.queue(type4 || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index2 = type4 != null && type4 + "queueHooks", timers = jQuery.timers, data9 = dataPriv.get(this);
          if (index2) {
            if (data9[index2] && data9[index2].stop) {
              stopQueue(data9[index2]);
            }
          } else {
            for (index2 in data9) {
              if (data9[index2] && data9[index2].stop && rrun.test(index2)) {
                stopQueue(data9[index2]);
              }
            }
          }
          for (index2 = timers.length; index2--; ) {
            if (timers[index2].elem === this && (type4 == null || timers[index2].queue === type4)) {
              timers[index2].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index2, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type4);
          }
        });
      },
      finish: function(type4) {
        if (type4 !== false) {
          type4 = type4 || "fx";
        }
        return this.each(function() {
          var index2, data9 = dataPriv.get(this), queue2 = data9[type4 + "queue"], hooks = data9[type4 + "queueHooks"], timers = jQuery.timers, length = queue2 ? queue2.length : 0;
          data9.finish = true;
          jQuery.queue(this, type4, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index2 = timers.length; index2--; ) {
            if (timers[index2].elem === this && timers[index2].queue === type4) {
              timers[index2].anim.stop(true);
              timers.splice(index2, 1);
            }
          }
          for (index2 = 0; index2 < length; index2++) {
            if (queue2[index2] && queue2[index2].finish) {
              queue2[index2].finish.call(this);
            }
          }
          delete data9.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function(_i, name2) {
      var cssFn = jQuery.fn[name2];
      jQuery.fn[name2] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
      };
    });
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name2, props3) {
      jQuery.fn[name2] = function(speed, easing, callback) {
        return this.animate(props3, speed, easing, callback);
      };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
      var timer, i2 = 0, timers = jQuery.timers;
      fxNow = Date.now();
      for (; i2 < timers.length; i2++) {
        timer = timers[i2];
        if (!timer() && timers[i2] === timer) {
          timers.splice(i2--, 1);
        }
      }
      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery.fx.timer = function(timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery.fx.stop = function() {
      inProgress = null;
    };
    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    };
    jQuery.fn.delay = function(time, type4) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type4 = type4 || "fx";
      return this.queue(type4, function(next2, hooks) {
        var timeout = window2.setTimeout(next2, time);
        hooks.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function(name2, value) {
        return access(this, jQuery.attr, name2, value, arguments.length > 1);
      },
      removeAttr: function(name2) {
        return this.each(function() {
          jQuery.removeAttr(this, name2);
        });
      }
    });
    jQuery.extend({
      attr: function(elem, name2, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name2, value);
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name2.toLowerCase()] || (jQuery.expr.match.bool.test(name2) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery.removeAttr(elem, name2);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name2, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
          return ret;
        }
        ret = jQuery.find.attr(elem, name2);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name2, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name2 = attrNames[i2++]) {
            elem.removeAttribute(name2);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name2) {
        if (value === false) {
          jQuery.removeAttr(elem, name2);
        } else {
          elem.setAttribute(name2, name2);
        }
        return name2;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
      var getter = attrHandle[name2] || jQuery.find.attr;
      attrHandle[name2] = function(elem, name3, isXML) {
        var ret, handle, lowercaseName = name3.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function(name2, value) {
        return access(this, jQuery.prop, name2, value, arguments.length > 1);
      },
      removeProp: function(name2) {
        return this.each(function() {
          delete this[jQuery.propFix[name2] || name2];
        });
      }
    });
    jQuery.extend({
      prop: function(elem, name2, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          name2 = jQuery.propFix[name2] || name2;
          hooks = jQuery.propHooks[name2];
        }
        if (value !== void 0) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          return elem[name2] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
          return ret;
        }
        return elem[name2];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2 && parent2.parentNode) {
            parent2.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent2 = elem.parentNode;
          if (parent2) {
            parent2.selectedIndex;
            if (parent2.parentNode) {
              parent2.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass2(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery.fn.extend({
      addClass: function(value) {
        var classNames2, cur, curValue, className, i2, finalValue;
        if (isFunction3(value)) {
          return this.each(function(j2) {
            jQuery(this).addClass(value.call(this, j2, getClass2(this)));
          });
        }
        classNames2 = classesToArray(value);
        if (classNames2.length) {
          return this.each(function() {
            curValue = getClass2(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i2 = 0; i2 < classNames2.length; i2++) {
                className = classNames2[i2];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      removeClass: function(value) {
        var classNames2, cur, curValue, className, i2, finalValue;
        if (isFunction3(value)) {
          return this.each(function(j2) {
            jQuery(this).removeClass(value.call(this, j2, getClass2(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classNames2 = classesToArray(value);
        if (classNames2.length) {
          return this.each(function() {
            curValue = getClass2(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i2 = 0; i2 < classNames2.length; i2++) {
                className = classNames2[i2];
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var classNames2, className, i2, self2, type4 = typeof value, isValidValue2 = type4 === "string" || Array.isArray(value);
        if (isFunction3(value)) {
          return this.each(function(i3) {
            jQuery(this).toggleClass(
              value.call(this, i3, getClass2(this), stateVal),
              stateVal
            );
          });
        }
        if (typeof stateVal === "boolean" && isValidValue2) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        classNames2 = classesToArray(value);
        return this.each(function() {
          if (isValidValue2) {
            self2 = jQuery(this);
            for (i2 = 0; i2 < classNames2.length; i2++) {
              className = classNames2[i2];
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type4 === "boolean") {
            className = getClass2(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute(
                "class",
                className || value === false ? "" : dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i2 = 0;
        className = " " + selector + " ";
        while (elem = this[i2++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass2(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function(value) {
        var hooks, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction3(value);
        return this.each(function(i2) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i2, jQuery(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function(elem) {
            var value, option, i2, options = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max3 = one ? index2 + 1 : options.length;
            if (index2 < 0) {
              i2 = max3;
            } else {
              i2 = one ? index2 : 0;
            }
            for (; i2 < max3; i2++) {
              option = options[i2];
              if ((option.selected || i2 === index2) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                value = jQuery(option).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i2 = options.length;
            while (i2--) {
              option = options[i2];
              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });
    jQuery.each(["radio", "checkbox"], function() {
      jQuery.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window2;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
      e2.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
      trigger: function(event2, data9, elem, onlyHandlers) {
        var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type4 = hasOwn3.call(event2, "type") ? event2.type : event2, namespaces = hasOwn3.call(event2, "namespace") ? event2.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type4 + jQuery.event.triggered)) {
          return;
        }
        if (type4.indexOf(".") > -1) {
          namespaces = type4.split(".");
          type4 = namespaces.shift();
          namespaces.sort();
        }
        ontype = type4.indexOf(":") < 0 && "on" + type4;
        event2 = event2[jQuery.expando] ? event2 : new jQuery.Event(type4, typeof event2 === "object" && event2);
        event2.isTrigger = onlyHandlers ? 2 : 3;
        event2.namespace = namespaces.join(".");
        event2.rnamespace = event2.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event2.result = void 0;
        if (!event2.target) {
          event2.target = elem;
        }
        data9 = data9 == null ? [event2] : jQuery.makeArray(data9, [event2]);
        special = jQuery.event.special[type4] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data9) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow2(elem)) {
          bubbleType = special.delegateType || type4;
          if (!rfocusMorph.test(bubbleType + type4)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i2 = 0;
        while ((cur = eventPath[i2++]) && !event2.isPropagationStopped()) {
          lastElement = cur;
          event2.type = i2 > 1 ? bubbleType : special.bindType || type4;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event2.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data9);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event2.result = handle.apply(cur, data9);
            if (event2.result === false) {
              event2.preventDefault();
            }
          }
        }
        event2.type = type4;
        if (!onlyHandlers && !event2.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data9) === false) && acceptData(elem)) {
            if (ontype && isFunction3(elem[type4]) && !isWindow2(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery.event.triggered = type4;
              if (event2.isPropagationStopped()) {
                lastElement.addEventListener(type4, stopPropagationCallback);
              }
              elem[type4]();
              if (event2.isPropagationStopped()) {
                lastElement.removeEventListener(type4, stopPropagationCallback);
              }
              jQuery.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event2.result;
      },
      simulate: function(type4, elem, event2) {
        var e2 = jQuery.extend(
          new jQuery.Event(),
          event2,
          {
            type: type4,
            isSimulated: true
          }
        );
        jQuery.event.trigger(e2, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function(type4, data9) {
        return this.each(function() {
          jQuery.event.trigger(type4, data9, this);
        });
      },
      triggerHandler: function(type4, data9) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type4, data9, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
        var handler5 = function(event2) {
          jQuery.event.simulate(fix, event2.target, jQuery.event.fix(event2));
        };
        jQuery.event.special[fix] = {
          setup: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix);
            if (!attaches) {
              doc2.addEventListener(orig, handler5, true);
            }
            dataPriv.access(doc2, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix) - 1;
            if (!attaches) {
              doc2.removeEventListener(orig, handler5, true);
              dataPriv.remove(doc2, fix);
            } else {
              dataPriv.access(doc2, fix, attaches);
            }
          }
        };
      });
    }
    var location2 = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery.parseXML = function(data9) {
      var xml, parserErrorElem;
      if (!data9 || typeof data9 !== "string") {
        return null;
      }
      try {
        xml = new window2.DOMParser().parseFromString(data9, "text/xml");
      } catch (e2) {
      }
      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data9));
      }
      return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add2) {
      var name2;
      if (Array.isArray(obj)) {
        jQuery.each(obj, function(i2, v2) {
          if (traditional || rbracket.test(prefix)) {
            add2(prefix, v2);
          } else {
            buildParams(
              prefix + "[" + (typeof v2 === "object" && v2 != null ? i2 : "") + "]",
              v2,
              traditional,
              add2
            );
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name2 in obj) {
          buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add2);
        }
      } else {
        add2(prefix, obj);
      }
    }
    jQuery.param = function(a2, traditional) {
      var prefix, s2 = [], add2 = function(key2, valueOrFunction) {
        var value = isFunction3(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s2[s2.length] = encodeURIComponent(key2) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a2 == null) {
        return "";
      }
      if (Array.isArray(a2) || a2.jquery && !jQuery.isPlainObject(a2)) {
        jQuery.each(a2, function() {
          add2(this.name, this.value);
        });
      } else {
        for (prefix in a2) {
          buildParams(prefix, a2[prefix], traditional, add2);
        }
      }
      return s2.join("&");
    };
    jQuery.fn.extend({
      serialize: function() {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function() {
          var type4 = this.type;
          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type4) && (this.checked || !rcheckableType.test(type4));
        }).map(function(_i, elem) {
          var val = jQuery(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location2.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction3(func)) {
          while (dataType = dataTypes[i2++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect2(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect2(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect2(options.dataTypes[0]) || !inspected["*"] && inspect2("*");
    }
    function ajaxExtend(target, src2) {
      var key2, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
      for (key2 in src2) {
        if (src2[key2] !== void 0) {
          (flatOptions[key2] ? target : deep || (deep = {}))[key2] = src2[key2];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s2, jqXHR, responses) {
      var ct, type4, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type4 in contents) {
          if (contents[type4] && contents[type4].test(ct)) {
            dataTypes.unshift(type4);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type4 in responses) {
          if (!dataTypes[0] || s2.converters[type4 + " " + dataTypes[0]]) {
            finalDataType = type4;
            break;
          }
          if (!firstDataType) {
            firstDataType = type4;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s2, response, jqXHR, isSuccess) {
      var conv2, current2, conv, tmp, prev2, converters = {}, dataTypes = s2.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s2.converters) {
          converters[conv.toLowerCase()] = s2.converters[conv];
        }
      }
      current2 = dataTypes.shift();
      while (current2) {
        if (s2.responseFields[current2]) {
          jqXHR[s2.responseFields[current2]] = response;
        }
        if (!prev2 && isSuccess && s2.dataFilter) {
          response = s2.dataFilter(response, s2.dataType);
        }
        prev2 = current2;
        current2 = dataTypes.shift();
        if (current2) {
          if (current2 === "*") {
            current2 = prev2;
          } else if (prev2 !== "*" && prev2 !== current2) {
            conv = converters[prev2 + " " + current2] || converters["* " + current2];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current2) {
                  conv = converters[prev2 + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current2 = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s2.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e2) {
                  return {
                    state: "parsererror",
                    error: conv ? e2 : "No conversion from " + prev2 + " to " + current2
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery.extend({
      active: 0,
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location2.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location2.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        converters: {
          "* text": String,
          "text html": true,
          "text json": JSON.parse,
          "text xml": jQuery.parseXML
        },
        flatOptions: {
          url: true,
          context: true
        }
      },
      ajaxSetup: function(target, settings) {
        return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      ajax: function(url2, options) {
        if (typeof url2 === "object") {
          options = url2;
          url2 = void 0;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s2 = jQuery.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          getResponseHeader: function(key2) {
            var match2;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match2 = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match2[1].toLowerCase() + " "] = (responseHeaders[match2[1].toLowerCase() + " "] || []).concat(match2[2]);
                }
              }
              match2 = responseHeaders[key2.toLowerCase() + " "];
            }
            return match2 == null ? null : match2.join(", ");
          },
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          setRequestHeader: function(name2, value) {
            if (completed2 == null) {
              name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
              requestHeaders[name2] = value;
            }
            return this;
          },
          overrideMimeType: function(type4) {
            if (completed2 == null) {
              s2.mimeType = type4;
            }
            return this;
          },
          statusCode: function(map) {
            var code;
            if (map) {
              if (completed2) {
                jqXHR.always(map[jqXHR.status]);
              } else {
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              }
            }
            return this;
          },
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s2.url = ((url2 || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
        s2.type = options.method || options.type || s2.method || s2.type;
        s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s2.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s2.url;
            urlAnchor.href = urlAnchor.href;
            s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e2) {
            s2.crossDomain = true;
          }
        }
        if (s2.data && s2.processData && typeof s2.data !== "string") {
          s2.data = jQuery.param(s2.data, s2.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery.event && s2.global;
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }
        s2.type = s2.type.toUpperCase();
        s2.hasContent = !rnoContent.test(s2.type);
        cacheURL = s2.url.replace(rhash, "");
        if (!s2.hasContent) {
          uncached = s2.url.slice(cacheURL.length);
          if (s2.data && (s2.processData || typeof s2.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
            delete s2.data;
          }
          if (s2.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s2.url = cacheURL + uncached;
        } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s2.data = s2.data.replace(r20, "+");
        }
        if (s2.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }
        if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s2.contentType);
        }
        jqXHR.setRequestHeader(
          "Accept",
          s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
        );
        for (i2 in s2.headers) {
          jqXHR.setRequestHeader(i2, s2.headers[i2]);
        }
        if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s2.complete);
        jqXHR.done(s2.success);
        jqXHR.fail(s2.error);
        transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s2.async && s2.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s2.timeout);
          }
          try {
            completed2 = false;
            transport.send(requestHeaders, done);
          } catch (e2) {
            if (completed2) {
              throw e2;
            }
            done(-1, e2);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified2, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s2, jqXHR, responses);
          }
          if (!isSuccess && jQuery.inArray("script", s2.dataTypes) > -1 && jQuery.inArray("json", s2.dataTypes) < 0) {
            s2.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s2, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s2.ifModified) {
              modified2 = jqXHR.getResponseHeader("Last-Modified");
              if (modified2) {
                jQuery.lastModified[cacheURL] = modified2;
              }
              modified2 = jqXHR.getResponseHeader("etag");
              if (modified2) {
                jQuery.etag[cacheURL] = modified2;
              }
            }
            if (status === 204 || s2.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(
              isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s2, isSuccess ? success : error]
            );
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
            if (!--jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url2, data9, callback) {
        return jQuery.get(url2, data9, callback, "json");
      },
      getScript: function(url2, callback) {
        return jQuery.get(url2, void 0, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function(_i, method4) {
      jQuery[method4] = function(url2, data9, callback, type4) {
        if (isFunction3(data9)) {
          type4 = type4 || callback;
          callback = data9;
          data9 = void 0;
        }
        return jQuery.ajax(jQuery.extend({
          url: url2,
          type: method4,
          dataType: type4,
          data: data9,
          success: callback
        }, jQuery.isPlainObject(url2) && url2));
      };
    });
    jQuery.ajaxPrefilter(function(s2) {
      var i2;
      for (i2 in s2.headers) {
        if (i2.toLowerCase() === "content-type") {
          s2.contentType = s2.headers[i2] || "";
        }
      }
    });
    jQuery._evalUrl = function(url2, options, doc2) {
      return jQuery.ajax({
        url: url2,
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery.globalEval(response, options, doc2);
        }
      });
    };
    jQuery.fn.extend({
      wrapAll: function(html2) {
        var wrap;
        if (this[0]) {
          if (isFunction3(html2)) {
            html2 = html2.call(this[0]);
          }
          wrap = jQuery(html2, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html2) {
        if (isFunction3(html2)) {
          return this.each(function(i2) {
            jQuery(this).wrapInner(html2.call(this, i2));
          });
        }
        return this.each(function() {
          var self2 = jQuery(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html2);
          } else {
            self2.append(html2);
          }
        });
      },
      wrap: function(html2) {
        var htmlIsFunction = isFunction3(html2);
        return this.each(function(i2) {
          jQuery(this).wrapAll(htmlIsFunction ? html2.call(this, i2) : html2);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e2) {
      }
    };
    var xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i2, xhr2 = options.xhr();
            xhr2.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );
            if (options.xhrFields) {
              for (i2 in options.xhrFields) {
                xhr2[i2] = options.xhrFields[i2];
              }
            }
            if (options.mimeType && xhr2.overrideMimeType) {
              xhr2.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i2 in headers) {
              xhr2.setRequestHeader(i2, headers[i2]);
            }
            callback = function(type4) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr2.onload = xhr2.onerror = xhr2.onabort = xhr2.ontimeout = xhr2.onreadystatechange = null;
                  if (type4 === "abort") {
                    xhr2.abort();
                  } else if (type4 === "error") {
                    if (typeof xhr2.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(
                        xhr2.status,
                        xhr2.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr2.status] || xhr2.status,
                      xhr2.statusText,
                      (xhr2.responseType || "text") !== "text" || typeof xhr2.responseText !== "string" ? { binary: xhr2.response } : { text: xhr2.responseText },
                      xhr2.getAllResponseHeaders()
                    );
                  }
                }
              };
            };
            xhr2.onload = callback();
            errorCallback = xhr2.onerror = xhr2.ontimeout = callback("error");
            if (xhr2.onabort !== void 0) {
              xhr2.onabort = errorCallback;
            } else {
              xhr2.onreadystatechange = function() {
                if (xhr2.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr2.send(options.hasContent && options.data || null);
            } catch (e2) {
              if (callback) {
                throw e2;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery.ajaxPrefilter(function(s2) {
      if (s2.crossDomain) {
        s2.contents.script = false;
      }
    });
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });
    jQuery.ajaxPrefilter("script", function(s2) {
      if (s2.cache === void 0) {
        s2.cache = false;
      }
      if (s2.crossDomain) {
        s2.type = "GET";
      }
    });
    jQuery.ajaxTransport("script", function(s2) {
      if (s2.crossDomain || s2.scriptAttrs) {
        var script, callback;
        return {
          send: function(_2, complete) {
            script = jQuery("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
      if (jsonProp || s2.dataTypes[0] === "jsonp") {
        callbackName = s2.jsonpCallback = isFunction3(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
        if (jsonProp) {
          s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s2.jsonp !== false) {
          s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
        }
        s2.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s2.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s2[callbackName]) {
            s2.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction3(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function(data9, context2, keepScripts) {
      if (typeof data9 !== "string") {
        return [];
      }
      if (typeof context2 === "boolean") {
        keepScripts = context2;
        context2 = false;
      }
      var base2, parsed, scripts;
      if (!context2) {
        if (support.createHTMLDocument) {
          context2 = document2.implementation.createHTMLDocument("");
          base2 = context2.createElement("base");
          base2.href = document2.location.href;
          context2.head.appendChild(base2);
        } else {
          context2 = document2;
        }
      }
      parsed = rsingleTag.exec(data9);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context2.createElement(parsed[1])];
      }
      parsed = buildFragment([data9], context2, scripts);
      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function(url2, params, callback) {
      var selector, type4, response, self2 = this, off = url2.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url2.slice(off));
        url2 = url2.slice(0, off);
      }
      if (isFunction3(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type4 = "POST";
      }
      if (self2.length > 0) {
        jQuery.ajax({
          url: url2,
          type: type4 || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
      return jQuery.grep(jQuery.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery.offset = {
      setOffset: function(elem, options, i2) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props3 = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction3(options)) {
          options = options.call(elem, i2, jQuery.extend({}, curOffset));
        }
        if (options.top != null) {
          props3.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props3.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props3);
        } else {
          curElem.css(props3);
        }
      }
    };
    jQuery.fn.extend({
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i2) {
            jQuery.offset.setOffset(this, options, i2);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset3, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery.css(elem, "position") === "fixed") {
          offset3 = elem.getBoundingClientRect();
        } else {
          offset3 = this.offset();
          doc2 = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc2.documentElement;
          while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset3.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset3.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method4, prop) {
      var top = "pageYOffset" === prop;
      jQuery.fn[method4] = function(val) {
        return access(this, function(elem, method5, val2) {
          var win;
          if (isWindow2(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method5];
          }
          if (win) {
            win.scrollTo(
              !top ? val2 : win.pageXOffset,
              top ? val2 : win.pageYOffset
            );
          } else {
            elem[method5] = val2;
          }
        }, method4, val, arguments.length);
      };
    });
    jQuery.each(["top", "left"], function(_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(
        support.pixelPosition,
        function(elem, computed2) {
          if (computed2) {
            computed2 = curCSS(elem, prop);
            return rnumnonpx.test(computed2) ? jQuery(elem).position()[prop] + "px" : computed2;
          }
        }
      );
    });
    jQuery.each({ Height: "height", Width: "width" }, function(name2, type4) {
      jQuery.each({
        padding: "inner" + name2,
        content: type4,
        "": "outer" + name2
      }, function(defaultExtra, funcName) {
        jQuery.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type5, value2) {
            var doc2;
            if (isWindow2(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
            }
            if (elem.nodeType === 9) {
              doc2 = elem.documentElement;
              return Math.max(
                elem.body["scroll" + name2],
                doc2["scroll" + name2],
                elem.body["offset" + name2],
                doc2["offset" + name2],
                doc2["client" + name2]
              );
            }
            return value2 === void 0 ? jQuery.css(elem, type5, extra) : jQuery.style(elem, type5, value2, extra);
          }, type4, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type4) {
      jQuery.fn[type4] = function(fn) {
        return this.on(type4, fn);
      };
    });
    jQuery.fn.extend({
      bind: function(types2, data9, fn) {
        return this.on(types2, null, data9, fn);
      },
      unbind: function(types2, fn) {
        return this.off(types2, null, fn);
      },
      delegate: function(selector, types2, data9, fn) {
        return this.on(types2, selector, data9, fn);
      },
      undelegate: function(selector, types2, fn) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types2, selector || "**", fn);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(_i, name2) {
        jQuery.fn[name2] = function(data9, fn) {
          return arguments.length > 0 ? this.on(name2, null, data9, fn) : this.trigger(name2);
        };
      }
    );
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    jQuery.proxy = function(fn, context2) {
      var tmp, args2, proxy;
      if (typeof context2 === "string") {
        tmp = fn[context2];
        context2 = fn;
        fn = tmp;
      }
      if (!isFunction3(fn)) {
        return void 0;
      }
      args2 = slice2.call(arguments, 2);
      proxy = function() {
        return fn.apply(context2 || this, args2.concat(slice2.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };
    jQuery.holdReady = function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction3;
    jQuery.isWindow = isWindow2;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
      var type4 = jQuery.type(obj);
      return (type4 === "number" || type4 === "string") && !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "$1");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery.noConflict = function(deep) {
      if (window2.$ === jQuery) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery) {
        window2.jQuery = _jQuery;
      }
      return jQuery;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery;
    }
    return jQuery;
  });
})(jquery);
const $$1 = jquery.exports;
const xRender = defineComponent(markRaw({
  name: "xRender",
  props: {
    render: {
      type: Function,
      required: true
    }
  },
  render() {
    return h$1(this.render, {
      vm: this,
      props: this.$props,
      attrs: this.$attrs
    });
  }
}));
const ReadonlyItem = defineComponent({
  props: ["value"],
  render() {
    return createVNode("div", {
      "class": "ant-input cursor-not-allowed xItem_readonly"
    }, [this.value]);
  }
});
const Input = ({
  properties,
  slots,
  listeners,
  propsWillDeleteFromConfigs
}) => {
  if (properties.readonly) {
    return createVNode(ReadonlyItem, {
      "value": properties.value
    }, null);
  }
  let component = resolveComponent("aInput");
  if (properties.isPassword) {
    component = resolveComponent("aInputPassword");
  } else if (properties.isNumber) {
    component = resolveComponent("aInputNumber");
  } else if (properties.isTextarea) {
    component = resolveComponent("aTextarea");
    properties.autoSize = properties.autoSize || {
      minRows: 4,
      maxRows: 6
    };
  } else if (properties.isSearch) {
    component = resolveComponent("aInputSearch");
  }
  return createVNode(component, mergeProps(xU.omit(properties, propsWillDeleteFromConfigs), listeners), slots);
};
var locale$2 = {
  locale: "zh_CN",
  today: "\u4ECA\u5929",
  now: "\u6B64\u523B",
  backToToday: "\u8FD4\u56DE\u4ECA\u5929",
  ok: "\u786E\u5B9A",
  timeSelect: "\u9009\u62E9\u65F6\u95F4",
  dateSelect: "\u9009\u62E9\u65E5\u671F",
  weekSelect: "\u9009\u62E9\u5468",
  clear: "\u6E05\u9664",
  month: "\u6708",
  year: "\u5E74",
  previousMonth: "\u4E0A\u4E2A\u6708 (\u7FFB\u9875\u4E0A\u952E)",
  nextMonth: "\u4E0B\u4E2A\u6708 (\u7FFB\u9875\u4E0B\u952E)",
  monthSelect: "\u9009\u62E9\u6708\u4EFD",
  yearSelect: "\u9009\u62E9\u5E74\u4EFD",
  decadeSelect: "\u9009\u62E9\u5E74\u4EE3",
  yearFormat: "YYYY\u5E74",
  dayFormat: "D\u65E5",
  dateFormat: "YYYY\u5E74M\u6708D\u65E5",
  dateTimeFormat: "YYYY\u5E74M\u6708D\u65E5 HH\u65F6mm\u5206ss\u79D2",
  previousYear: "\u4E0A\u4E00\u5E74 (Control\u952E\u52A0\u5DE6\u65B9\u5411\u952E)",
  nextYear: "\u4E0B\u4E00\u5E74 (Control\u952E\u52A0\u53F3\u65B9\u5411\u952E)",
  previousDecade: "\u4E0A\u4E00\u5E74\u4EE3",
  nextDecade: "\u4E0B\u4E00\u5E74\u4EE3",
  previousCentury: "\u4E0A\u4E00\u4E16\u7EAA",
  nextCentury: "\u4E0B\u4E00\u4E16\u7EAA"
};
const CalendarLocale = locale$2;
var locale$1 = {
  placeholder: "\u8BF7\u9009\u62E9\u65F6\u95F4",
  rangePlaceholder: ["\u5F00\u59CB\u65F6\u95F4", "\u7ED3\u675F\u65F6\u95F4"]
};
const TimePicker = locale$1;
var locale = {
  lang: _objectSpread2$1({
    placeholder: "\u8BF7\u9009\u62E9\u65E5\u671F",
    yearPlaceholder: "\u8BF7\u9009\u62E9\u5E74\u4EFD",
    quarterPlaceholder: "\u8BF7\u9009\u62E9\u5B63\u5EA6",
    monthPlaceholder: "\u8BF7\u9009\u62E9\u6708\u4EFD",
    weekPlaceholder: "\u8BF7\u9009\u62E9\u5468",
    rangePlaceholder: ["\u5F00\u59CB\u65E5\u671F", "\u7ED3\u675F\u65E5\u671F"],
    rangeYearPlaceholder: ["\u5F00\u59CB\u5E74\u4EFD", "\u7ED3\u675F\u5E74\u4EFD"],
    rangeMonthPlaceholder: ["\u5F00\u59CB\u6708\u4EFD", "\u7ED3\u675F\u6708\u4EFD"],
    rangeQuarterPlaceholder: ["\u5F00\u59CB\u5B63\u5EA6", "\u7ED3\u675F\u5B63\u5EA6"],
    rangeWeekPlaceholder: ["\u5F00\u59CB\u5468", "\u7ED3\u675F\u5468"]
  }, CalendarLocale),
  timePickerLocale: _objectSpread2$1({}, TimePicker)
};
locale.lang.ok = "\u786E\u5B9A";
const DatePicker$1 = locale;
var typeTemplate = "${label}\u4E0D\u662F\u4E00\u4E2A\u6709\u6548\u7684${type}";
var localeValues = {
  locale: "zh-cn",
  Pagination: Pagination$2,
  DatePicker: DatePicker$1,
  TimePicker,
  Calendar: DatePicker$1,
  global: {
    placeholder: "\u8BF7\u9009\u62E9"
  },
  Table: {
    filterTitle: "\u7B5B\u9009",
    filterConfirm: "\u786E\u5B9A",
    filterReset: "\u91CD\u7F6E",
    filterEmptyText: "\u65E0\u7B5B\u9009\u9879",
    filterCheckall: "\u5168\u9009",
    filterSearchPlaceholder: "\u5728\u7B5B\u9009\u9879\u4E2D\u641C\u7D22",
    selectAll: "\u5168\u9009\u5F53\u9875",
    selectInvert: "\u53CD\u9009\u5F53\u9875",
    selectNone: "\u6E05\u7A7A\u6240\u6709",
    selectionAll: "\u5168\u9009\u6240\u6709",
    sortTitle: "\u6392\u5E8F",
    expand: "\u5C55\u5F00\u884C",
    collapse: "\u5173\u95ED\u884C",
    triggerDesc: "\u70B9\u51FB\u964D\u5E8F",
    triggerAsc: "\u70B9\u51FB\u5347\u5E8F",
    cancelSort: "\u53D6\u6D88\u6392\u5E8F"
  },
  Modal: {
    okText: "\u786E\u5B9A",
    cancelText: "\u53D6\u6D88",
    justOkText: "\u77E5\u9053\u4E86"
  },
  Popconfirm: {
    cancelText: "\u53D6\u6D88",
    okText: "\u786E\u5B9A"
  },
  Transfer: {
    searchPlaceholder: "\u8BF7\u8F93\u5165\u641C\u7D22\u5185\u5BB9",
    itemUnit: "\u9879",
    itemsUnit: "\u9879",
    remove: "\u5220\u9664",
    selectCurrent: "\u5168\u9009\u5F53\u9875",
    removeCurrent: "\u5220\u9664\u5F53\u9875",
    selectAll: "\u5168\u9009\u6240\u6709",
    removeAll: "\u5220\u9664\u5168\u90E8",
    selectInvert: "\u53CD\u9009\u5F53\u9875"
  },
  Upload: {
    uploading: "\u6587\u4EF6\u4E0A\u4F20\u4E2D",
    removeFile: "\u5220\u9664\u6587\u4EF6",
    uploadError: "\u4E0A\u4F20\u9519\u8BEF",
    previewFile: "\u9884\u89C8\u6587\u4EF6",
    downloadFile: "\u4E0B\u8F7D\u6587\u4EF6"
  },
  Empty: {
    description: "\u6682\u65E0\u6570\u636E"
  },
  Icon: {
    icon: "\u56FE\u6807"
  },
  Text: {
    edit: "\u7F16\u8F91",
    copy: "\u590D\u5236",
    copied: "\u590D\u5236\u6210\u529F",
    expand: "\u5C55\u5F00"
  },
  PageHeader: {
    back: "\u8FD4\u56DE"
  },
  Form: {
    optional: "\uFF08\u53EF\u9009\uFF09",
    defaultValidateMessages: {
      default: "\u5B57\u6BB5\u9A8C\u8BC1\u9519\u8BEF${label}",
      required: "\u8BF7\u8F93\u5165${label}",
      enum: "${label}\u5FC5\u987B\u662F\u5176\u4E2D\u4E00\u4E2A[${enum}]",
      whitespace: "${label}\u4E0D\u80FD\u4E3A\u7A7A\u5B57\u7B26",
      date: {
        format: "${label}\u65E5\u671F\u683C\u5F0F\u65E0\u6548",
        parse: "${label}\u4E0D\u80FD\u8F6C\u6362\u4E3A\u65E5\u671F",
        invalid: "${label}\u662F\u4E00\u4E2A\u65E0\u6548\u65E5\u671F"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label}\u987B\u4E3A${len}\u4E2A\u5B57\u7B26",
        min: "${label}\u6700\u5C11${min}\u4E2A\u5B57\u7B26",
        max: "${label}\u6700\u591A${max}\u4E2A\u5B57\u7B26",
        range: "${label}\u987B\u5728${min}-${max}\u5B57\u7B26\u4E4B\u95F4"
      },
      number: {
        len: "${label}\u5FC5\u987B\u7B49\u4E8E${len}",
        min: "${label}\u6700\u5C0F\u503C\u4E3A${min}",
        max: "${label}\u6700\u5927\u503C\u4E3A${max}",
        range: "${label}\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      array: {
        len: "\u987B\u4E3A${len}\u4E2A${label}",
        min: "\u6700\u5C11${min}\u4E2A${label}",
        max: "\u6700\u591A${max}\u4E2A${label}",
        range: "${label}\u6570\u91CF\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      pattern: {
        mismatch: "${label}\u4E0E\u6A21\u5F0F\u4E0D\u5339\u914D${pattern}"
      }
    }
  },
  Image: {
    preview: "\u9884\u89C8"
  }
};
const zhCn$1 = localeValues;
var zhCn = { exports: {} };
(function(module2, exports2) {
  !function(e2, _2) {
    module2.exports = _2(dayjs_min.exports);
  }(commonjsGlobal, function(e2) {
    function _2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = _2(e2), d2 = { name: "zh-cn", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e3, _3) {
      return "W" === _3 ? e3 + "\u5468" : e3 + "\u65E5";
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206", LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5185", past: "%s\u524D", s: "\u51E0\u79D2", m: "1 \u5206\u949F", mm: "%d \u5206\u949F", h: "1 \u5C0F\u65F6", hh: "%d \u5C0F\u65F6", d: "1 \u5929", dd: "%d \u5929", M: "1 \u4E2A\u6708", MM: "%d \u4E2A\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(e3, _3) {
      var t3 = 100 * e3 + _3;
      return t3 < 600 ? "\u51CC\u6668" : t3 < 900 ? "\u65E9\u4E0A" : t3 < 1100 ? "\u4E0A\u5348" : t3 < 1300 ? "\u4E2D\u5348" : t3 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
    } };
    return t2.default.locale(d2, null, true), d2;
  });
})(zhCn);
var enAu = { exports: {} };
(function(module2, exports2) {
  !function(e2, a2) {
    module2.exports = a2(dayjs_min.exports);
  }(commonjsGlobal, function(e2) {
    function a2(e3) {
      return e3 && "object" == typeof e3 && "default" in e3 ? e3 : { default: e3 };
    }
    var t2 = a2(e2), _2 = { name: "en-au", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), weekStart: 1, weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), ordinal: function(e3) {
      return e3;
    }, formats: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" } };
    return t2.default.locale(_2, null, true), _2;
  });
})(enAu);
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports2) {
  (function() {
    var undefined$12;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE2 = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE2 = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
    var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER2 = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart2 = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags2 = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange2 = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral2 = "[" + rsAstralRange2 + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo2 = "[" + rsComboRange2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz2 = "\\ud83c[\\udffb-\\udfff]", rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")", rsNonAstral2 = "[^" + rsAstralRange2 + "]", rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ2 = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod2 = rsModifier2 + "?", rsOptVar2 = "[" + rsVarRange2 + "]?", rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2, rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2, rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo2, "g");
    var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode2 = RegExp("[" + rsZWJ2 + rsAstralRange2 + rsComboRange2 + rsVarRange2 + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var cloneableTags2 = {};
    cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
    cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports2 = exports2 && !exports2.nodeType && exports2;
    var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
    var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
    var freeProcess2 = moduleExports2 && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    function apply2(func, thisArg, args2) {
      switch (args2.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args2[0]);
        case 2:
          return func.call(thisArg, args2[0], args2[1]);
        case 3:
          return func.call(thisArg, args2[0], args2[1], args2[2]);
      }
      return func.apply(thisArg, args2);
    }
    function arrayAggregator2(array4, setter, iteratee, accumulator) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        var value = array4[index2];
        setter(accumulator, value, iteratee(value), array4);
      }
      return accumulator;
    }
    function arrayEach2(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (iteratee(array4[index2], index2, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEachRight(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      while (length--) {
        if (iteratee(array4[length], length, array4) === false) {
          break;
        }
      }
      return array4;
    }
    function arrayEvery(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (!predicate(array4[index2], index2, array4)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter2(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (predicate(value, index2, array4)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes2(array4, value) {
      var length = array4 == null ? 0 : array4.length;
      return !!length && baseIndexOf2(array4, value, 0) > -1;
    }
    function arrayIncludesWith2(array4, value, comparator2) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (comparator2(value, array4[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap2(array4, iteratee) {
      var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array4[index2], index2, array4);
      }
      return result;
    }
    function arrayPush2(array4, values) {
      var index2 = -1, length = values.length, offset3 = array4.length;
      while (++index2 < length) {
        array4[offset3 + index2] = values[index2];
      }
      return array4;
    }
    function arrayReduce(array4, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array4[index2], index2, array4);
      }
      return accumulator;
    }
    function arrayReduceRight(array4, iteratee, accumulator, initAccum) {
      var length = array4 == null ? 0 : array4.length;
      if (initAccum && length) {
        accumulator = array4[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array4[length], length, array4);
      }
      return accumulator;
    }
    function arraySome2(array4, predicate) {
      var index2 = -1, length = array4 == null ? 0 : array4.length;
      while (++index2 < length) {
        if (predicate(array4[index2], index2, array4)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize2 = baseProperty2("length");
    function asciiToArray2(string3) {
      return string3.split("");
    }
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2)) {
          result = key2;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex2(array4, predicate, fromIndex, fromRight) {
      var length = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array4[index2], index2, array4)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf2(array4, value, fromIndex) {
      return value === value ? strictIndexOf2(array4, value, fromIndex) : baseFindIndex2(array4, baseIsNaN2, fromIndex);
    }
    function baseIndexOfWith(array4, value, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (comparator2(array4[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN2(value) {
      return value !== value;
    }
    function baseMean(array4, iteratee) {
      var length = array4 == null ? 0 : array4.length;
      return length ? baseSum(array4, iteratee) / length : NAN2;
    }
    function baseProperty2(key2) {
      return function(object4) {
        return object4 == null ? undefined$12 : object4[key2];
      };
    }
    function basePropertyOf(object4) {
      return function(key2) {
        return object4 == null ? undefined$12 : object4[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array4, comparer) {
      var length = array4.length;
      array4.sort(comparer);
      while (length--) {
        array4[length] = array4[length].value;
      }
      return array4;
    }
    function baseSum(array4, iteratee) {
      var result, index2 = -1, length = array4.length;
      while (++index2 < length) {
        var current2 = iteratee(array4[index2]);
        if (current2 !== undefined$12) {
          result = result === undefined$12 ? current2 : result + current2;
        }
      }
      return result;
    }
    function baseTimes2(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object4, props3) {
      return arrayMap2(props3, function(key2) {
        return [key2, object4[key2]];
      });
    }
    function baseTrim2(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex2(string3) + 1).replace(reTrimStart2, "") : string3;
    }
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object4, props3) {
      return arrayMap2(props3, function(key2) {
        return object4[key2];
      });
    }
    function cacheHas2(cache, key2) {
      return cache.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf2(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf2(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array4, placeholder) {
      var length = array4.length, result = 0;
      while (length--) {
        if (array4[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object4, key2) {
      return object4 == null ? undefined$12 : object4[key2];
    }
    function hasUnicode2(string3) {
      return reHasUnicode2.test(string3);
    }
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    function iteratorToArray(iterator) {
      var data9, result = [];
      while (!(data9 = iterator.next()).done) {
        result.push(data9.value);
      }
      return result;
    }
    function mapToArray2(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg2(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array4, placeholder) {
      var index2 = -1, length = array4.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array4[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array4[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray2(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf2(array4, value, fromIndex) {
      var index2 = fromIndex - 1, length = array4.length;
      while (++index2 < length) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array4, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array4[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize2(string3) {
      return hasUnicode2(string3) ? unicodeSize2(string3) : asciiSize2(string3);
    }
    function stringToArray2(string3) {
      return hasUnicode2(string3) ? unicodeToArray2(string3) : asciiToArray2(string3);
    }
    function trimmedEndIndex2(string3) {
      var index2 = string3.length;
      while (index2-- && reWhitespace2.test(string3.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize2(string3) {
      var result = reUnicode2.lastIndex = 0;
      while (reUnicode2.test(string3)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray2(string3) {
      return string3.match(reUnicode2) || [];
    }
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root2 : _2.defaults(root2.Object(), context2, _2.pick(root2, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData2 = context2["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey2 = function() {
        var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString2 = funcToString2.call(Object2);
      var oldDash = root2._;
      var reIsNative2 = RegExp2(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer3 = moduleExports2 ? context2.Buffer : undefined$12, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : undefined$12, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol2 ? Symbol2.isConcatSpreadable : undefined$12, symIterator = Symbol2 ? Symbol2.iterator : undefined$12, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$12;
      var defineProperty2 = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root2.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root2.setTimeout && context2.setTimeout;
      var nativeCeil2 = Math2.ceil, nativeFloor2 = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : undefined$12, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView2 = getNative2(context2, "DataView"), Map2 = getNative2(context2, "Map"), Promise2 = getNative2(context2, "Promise"), Set2 = getNative2(context2, "Set"), WeakMap2 = getNative2(context2, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$12, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$12, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$12;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate2 = function() {
        function object4() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto);
          }
          object4.prototype = proto;
          var result2 = new object4();
          object4.prototype = undefined$12;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$12;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray2(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray2(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray2(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array4 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array4), isRight = dir < 0, arrLength = isArr ? array4.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array4, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array4[index2];
            while (++iterIndex < iterLength) {
              var data9 = iteratees[iterIndex], iteratee2 = data9.iteratee, type4 = data9.type, computed2 = iteratee2(value);
              if (type4 == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type4 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet2(key2) {
        var data9 = this.__data__;
        if (nativeCreate2) {
          var result2 = data9[key2];
          return result2 === HASH_UNDEFINED2 ? undefined$12 : result2;
        }
        return hasOwnProperty2.call(data9, key2) ? data9[key2] : undefined$12;
      }
      function hashHas2(key2) {
        var data9 = this.__data__;
        return nativeCreate2 ? data9[key2] !== undefined$12 : hasOwnProperty2.call(data9, key2);
      }
      function hashSet2(key2, value) {
        var data9 = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data9[key2] = nativeCreate2 && value === undefined$12 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key2) {
        var data9 = this.__data__, index2 = assocIndexOf2(data9, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data9.length - 1;
        if (index2 == lastIndex) {
          data9.pop();
        } else {
          splice2.call(data9, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key2) {
        var data9 = this.__data__, index2 = assocIndexOf2(data9, key2);
        return index2 < 0 ? undefined$12 : data9[index2][1];
      }
      function listCacheHas2(key2) {
        return assocIndexOf2(this.__data__, key2) > -1;
      }
      function listCacheSet2(key2, value) {
        var data9 = this.__data__, index2 = assocIndexOf2(data9, key2);
        if (index2 < 0) {
          ++this.size;
          data9.push([key2, value]);
        } else {
          data9[index2][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key2) {
        var result2 = getMapData2(this, key2)["delete"](key2);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet2(key2) {
        return getMapData2(this, key2).get(key2);
      }
      function mapCacheHas2(key2) {
        return getMapData2(this, key2).has(key2);
      }
      function mapCacheSet2(key2, value) {
        var data9 = getMapData2(this, key2), size3 = data9.size;
        data9.set(key2, value);
        this.size += data9.size == size3 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache2(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache2();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd2(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas2(value) {
        return this.__data__.has(value);
      }
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      function Stack2(entries) {
        var data9 = this.__data__ = new ListCache2(entries);
        this.size = data9.size;
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete2(key2) {
        var data9 = this.__data__, result2 = data9["delete"](key2);
        this.size = data9.size;
        return result2;
      }
      function stackGet2(key2) {
        return this.__data__.get(key2);
      }
      function stackHas2(key2) {
        return this.__data__.has(key2);
      }
      function stackSet2(key2, value) {
        var data9 = this.__data__;
        if (data9 instanceof ListCache2) {
          var pairs = data9.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key2, value]);
            this.size = ++data9.size;
            return this;
          }
          data9 = this.__data__ = new MapCache2(pairs);
        }
        data9.set(key2, value);
        this.size = data9.size;
        return this;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex2(key2, length)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function arraySample(array4) {
        var length = array4.length;
        return length ? array4[baseRandom(0, length - 1)] : undefined$12;
      }
      function arraySampleSize(array4, n2) {
        return shuffleSelf(copyArray2(array4), baseClamp(n2, 0, array4.length));
      }
      function arrayShuffle(array4) {
        return shuffleSelf(copyArray2(array4));
      }
      function assignMergeValue(object4, key2, value) {
        if (value !== undefined$12 && !eq2(object4[key2], value) || value === undefined$12 && !(key2 in object4)) {
          baseAssignValue2(object4, key2, value);
        }
      }
      function assignValue2(object4, key2, value) {
        var objValue = object4[key2];
        if (!(hasOwnProperty2.call(object4, key2) && eq2(objValue, value)) || value === undefined$12 && !(key2 in object4)) {
          baseAssignValue2(object4, key2, value);
        }
      }
      function assocIndexOf2(array4, key2) {
        var length = array4.length;
        while (length--) {
          if (eq2(array4[length][0], key2)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator2(collection, setter, iteratee2, accumulator) {
        baseEach2(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign2(object4, source2) {
        return object4 && copyObject2(source2, keys2(source2), object4);
      }
      function baseAssignIn2(object4, source2) {
        return object4 && copyObject2(source2, keysIn2(source2), object4);
      }
      function baseAssignValue2(object4, key2, value) {
        if (key2 == "__proto__" && defineProperty2) {
          defineProperty2(object4, key2, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object4[key2] = value;
        }
      }
      function baseAt(object4, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object4 == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$12 : get4(object4, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number4, lower2, upper) {
        if (number4 === number4) {
          if (upper !== undefined$12) {
            number4 = number4 <= upper ? number4 : upper;
          }
          if (lower2 !== undefined$12) {
            number4 = number4 >= lower2 ? number4 : lower2;
          }
        }
        return number4;
      }
      function baseClone2(value, bitmask, customizer, key2, object4, stack2) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
        if (customizer) {
          result2 = object4 ? customizer(value, key2, object4, stack2) : customizer(value);
        }
        if (result2 !== undefined$12) {
          return result2;
        }
        if (!isObject3(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray2(value);
          if (!isDeep) {
            return copyArray2(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
          if (isBuffer3(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag2 || isFunc && !object4) {
            result2 = isFlat || isFunc ? {} : initCloneObject2(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn2(value, baseAssignIn2(result2, value)) : copySymbols2(value, baseAssign2(result2, value));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object4 ? value : {};
            }
            result2 = initCloneByTag2(value, tag, isDeep);
          }
        }
        stack2 || (stack2 = new Stack2());
        var stacked = stack2.get(value);
        if (stacked) {
          return stacked;
        }
        stack2.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack2));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone2(subValue, bitmask, customizer, key3, value, stack2));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
        var props3 = isArr ? undefined$12 : keysFunc(value);
        arrayEach2(props3 || value, function(subValue, key3) {
          if (props3) {
            key3 = subValue;
            subValue = value[key3];
          }
          assignValue2(result2, key3, baseClone2(subValue, bitmask, customizer, key3, value, stack2));
        });
        return result2;
      }
      function baseConforms(source2) {
        var props3 = keys2(source2);
        return function(object4) {
          return baseConformsTo(object4, source2, props3);
        };
      }
      function baseConformsTo(object4, source2, props3) {
        var length = props3.length;
        if (object4 == null) {
          return !length;
        }
        object4 = Object2(object4);
        while (length--) {
          var key2 = props3[length], predicate = source2[key2], value = object4[key2];
          if (value === undefined$12 && !(key2 in object4) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$12, args2);
        }, wait);
      }
      function baseDifference(array4, values2, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes2, isCommon = true, length = array4.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap2(values2, baseUnary2(iteratee2));
        }
        if (comparator2) {
          includes3 = arrayIncludesWith2;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE2) {
          includes3 = cacheHas2;
          isCommon = false;
          values2 = new SetCache2(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values2, computed2, comparator2)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach2 = createBaseEach2(baseForOwn2);
      var baseEachRight = createBaseEach2(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach2(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array4, iteratee2, comparator2) {
        var index2 = -1, length = array4.length;
        while (++index2 < length) {
          var value = array4[index2], current2 = iteratee2(value);
          if (current2 != null && (computed2 === undefined$12 ? current2 === current2 && !isSymbol2(current2) : comparator2(current2, computed2))) {
            var computed2 = current2, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array4, value, start, end) {
        var length = array4.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$12 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array4[start++] = value;
        }
        return array4;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach2(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten2(array4, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array4.length;
        predicate || (predicate = isFlattenable2);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array4[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten2(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush2(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor2 = createBaseFor2();
      var baseForRight = createBaseFor2(true);
      function baseForOwn2(object4, iteratee2) {
        return object4 && baseFor2(object4, iteratee2, keys2);
      }
      function baseForOwnRight(object4, iteratee2) {
        return object4 && baseForRight(object4, iteratee2, keys2);
      }
      function baseFunctions(object4, props3) {
        return arrayFilter2(props3, function(key2) {
          return isFunction3(object4[key2]);
        });
      }
      function baseGet2(object4, path2) {
        path2 = castPath2(path2, object4);
        var index2 = 0, length = path2.length;
        while (object4 != null && index2 < length) {
          object4 = object4[toKey2(path2[index2++])];
        }
        return index2 && index2 == length ? object4 : undefined$12;
      }
      function baseGetAllKeys2(object4, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object4);
        return isArray2(object4) ? result2 : arrayPush2(result2, symbolsFunc(object4));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$12 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object4, key2) {
        return object4 != null && hasOwnProperty2.call(object4, key2);
      }
      function baseHasIn2(object4, key2) {
        return object4 != null && key2 in Object2(object4);
      }
      function baseInRange(number4, start, end) {
        return number4 >= nativeMin2(start, end) && number4 < nativeMax2(start, end);
      }
      function baseIntersection2(arrays, iteratee2, comparator2) {
        var includes3 = comparator2 ? arrayIncludesWith2 : arrayIncludes2, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array4 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array4 = arrayMap2(array4, baseUnary2(iteratee2));
          }
          maxLength = nativeMin2(array4.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array4.length >= 120) ? new SetCache2(othIndex && array4) : undefined$12;
        }
        array4 = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas2(seen2, computed2) : includes3(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas2(cache, computed2) : includes3(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object4, setter, iteratee2, accumulator) {
        baseForOwn2(object4, function(value, key2, object5) {
          setter(accumulator, iteratee2(value), key2, object5);
        });
        return accumulator;
      }
      function baseInvoke(object4, path2, args2) {
        path2 = castPath2(path2, object4);
        object4 = parent2(object4, path2);
        var func = object4 == null ? object4 : object4[toKey2(last3(path2))];
        return func == null ? undefined$12 : apply2(func, object4, args2);
      }
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
      }
      function baseIsEqual2(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack2);
      }
      function baseIsEqualDeep2(object4, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray2(object4), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object4), othTag = othIsArr ? arrayTag2 : getTag2(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer3(object4)) {
          if (!isBuffer3(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack2());
          return objIsArr || isTypedArray2(object4) ? equalArrays2(object4, other, bitmask, customizer, equalFunc, stack2) : equalByTag2(object4, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack2());
        return equalObjects2(object4, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsMap2(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag2;
      }
      function baseIsMatch2(object4, source2, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object4 == null) {
          return !length;
        }
        object4 = Object2(object4);
        while (index2--) {
          var data9 = matchData[index2];
          if (noCustomizer && data9[2] ? data9[1] !== object4[data9[0]] : !(data9[0] in object4)) {
            return false;
          }
        }
        while (++index2 < length) {
          data9 = matchData[index2];
          var key2 = data9[0], objValue = object4[key2], srcValue = data9[1];
          if (noCustomizer && data9[2]) {
            if (objValue === undefined$12 && !(key2 in object4)) {
              return false;
            }
          } else {
            var stack2 = new Stack2();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key2, object4, source2, stack2);
            }
            if (!(result2 === undefined$12 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack2) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject3(value) || isMasked2(value)) {
          return false;
        }
        var pattern4 = isFunction3(value) ? reIsNative2 : reIsHostCtor2;
        return pattern4.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
      }
      function baseIsSet2(value) {
        return isObjectLike2(value) && getTag2(value) == setTag2;
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      function baseIteratee2(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
        }
        return property2(value);
      }
      function baseKeys2(object4) {
        if (!isPrototype2(object4)) {
          return nativeKeys2(object4);
        }
        var result2 = [];
        for (var key2 in Object2(object4)) {
          if (hasOwnProperty2.call(object4, key2) && key2 != "constructor") {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseKeysIn2(object4) {
        if (!isObject3(object4)) {
          return nativeKeysIn2(object4);
        }
        var isProto = isPrototype2(object4), result2 = [];
        for (var key2 in object4) {
          if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object4, key2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value, key2, collection2) {
          result2[++index2] = iteratee2(value, key2, collection2);
        });
        return result2;
      }
      function baseMatches2(source2) {
        var matchData = getMatchData2(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
        }
        return function(object4) {
          return object4 === source2 || baseIsMatch2(object4, source2, matchData);
        };
      }
      function baseMatchesProperty2(path2, srcValue) {
        if (isKey2(path2) && isStrictComparable2(srcValue)) {
          return matchesStrictComparable2(toKey2(path2), srcValue);
        }
        return function(object4) {
          var objValue = get4(object4, path2);
          return objValue === undefined$12 && objValue === srcValue ? hasIn2(object4, path2) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
        };
      }
      function baseMerge(object4, source2, srcIndex, customizer, stack2) {
        if (object4 === source2) {
          return;
        }
        baseFor2(source2, function(srcValue, key2) {
          stack2 || (stack2 = new Stack2());
          if (isObject3(srcValue)) {
            baseMergeDeep(object4, source2, key2, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object4, key2), srcValue, key2 + "", object4, source2, stack2) : undefined$12;
            if (newValue === undefined$12) {
              newValue = srcValue;
            }
            assignMergeValue(object4, key2, newValue);
          }
        }, keysIn2);
      }
      function baseMergeDeep(object4, source2, key2, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object4, key2), srcValue = safeGet(source2, key2), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object4, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object4, source2, stack2) : undefined$12;
        var isCommon = newValue === undefined$12;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject2(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer2(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray2(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction3(objValue)) {
              newValue = initCloneObject2(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object4, key2, newValue);
      }
      function baseNth(array4, n2) {
        var length = array4.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex2(n2, length) ? array4[n2] : undefined$12;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap2(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap2(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object4, other) {
          return compareMultiple(object4, other, orders);
        });
      }
      function basePick2(object4, paths) {
        return basePickBy2(object4, paths, function(value, path2) {
          return hasIn2(object4, path2);
        });
      }
      function basePickBy2(object4, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path2 = paths[index2], value = baseGet2(object4, path2);
          if (predicate(value, path2)) {
            baseSet2(result2, castPath2(path2, object4), value);
          }
        }
        return result2;
      }
      function basePropertyDeep2(path2) {
        return function(object4) {
          return baseGet2(object4, path2);
        };
      }
      function basePullAll(array4, values2, iteratee2, comparator2) {
        var indexOf3 = comparator2 ? baseIndexOfWith : baseIndexOf2, index2 = -1, length = values2.length, seen2 = array4;
        if (array4 === values2) {
          values2 = copyArray2(values2);
        }
        if (iteratee2) {
          seen2 = arrayMap2(array4, baseUnary2(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array4) {
              splice2.call(seen2, fromIndex, 1);
            }
            splice2.call(array4, fromIndex, 1);
          }
        }
        return array4;
      }
      function basePullAt(array4, indexes) {
        var length = array4 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex2(index2)) {
              splice2.call(array4, index2, 1);
            } else {
              baseUnset2(array4, index2);
            }
          }
        }
        return array4;
      }
      function baseRandom(lower2, upper) {
        return lower2 + nativeFloor2(nativeRandom() * (upper - lower2 + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax2(nativeCeil2((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat2(string3, n2) {
        var result2 = "";
        if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string3;
          }
          n2 = nativeFloor2(n2 / 2);
          if (n2) {
            string3 += string3;
          }
        } while (n2);
        return result2;
      }
      function baseRest2(func, start) {
        return setToString2(overRest2(func, start, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array4 = values(collection);
        return shuffleSelf(array4, baseClamp(n2, 0, array4.length));
      }
      function baseSet2(object4, path2, value, customizer) {
        if (!isObject3(object4)) {
          return object4;
        }
        path2 = castPath2(path2, object4);
        var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object4;
        while (nested != null && ++index2 < length) {
          var key2 = toKey2(path2[index2]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
            return object4;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$12;
            if (newValue === undefined$12) {
              newValue = isObject3(objValue) ? objValue : isIndex2(path2[index2 + 1]) ? [] : {};
            }
          }
          assignValue2(nested, key2, newValue);
          nested = nested[key2];
        }
        return object4;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data9) {
        metaMap.set(func, data9);
        return func;
      };
      var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string3) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant2(string3),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice2(array4, start, end) {
        var index2 = -1, length = array4.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array4[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach2(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array4, value, retHighest) {
        var low = 0, high = array4 == null ? low : array4.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array4[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array4, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array4, value, iteratee2, retHighest) {
        var low = 0, high = array4 == null ? 0 : array4.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$12;
        while (low < high) {
          var mid = nativeFloor2((low + high) / 2), computed2 = iteratee2(array4[mid]), othIsDefined = computed2 !== undefined$12, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin2(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array4, iteratee2) {
        var index2 = -1, length = array4.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq2(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap2(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq2(array4, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes2, length = array4.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes3 = arrayIncludesWith2;
        } else if (length >= LARGE_ARRAY_SIZE2) {
          var set3 = iteratee2 ? null : createSet2(array4);
          if (set3) {
            return setToArray2(set3);
          }
          isCommon = false;
          includes3 = cacheHas2;
          seen2 = new SetCache2();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array4[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value);
            } else if (!includes3(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset2(object4, path2) {
        path2 = castPath2(path2, object4);
        object4 = parent2(object4, path2);
        return object4 == null || delete object4[toKey2(last3(path2))];
      }
      function baseUpdate(object4, path2, updater, customizer) {
        return baseSet2(object4, path2, updater(baseGet2(object4, path2)), customizer);
      }
      function baseWhile(array4, predicate, isDrop, fromRight) {
        var length = array4.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array4[index2], index2, array4)) {
        }
        return isDrop ? baseSlice2(array4, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice2(array4, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq2(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array4 = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array4, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq2(baseFlatten2(result2, 1), iteratee2, comparator2);
      }
      function baseZipObject(props3, values2, assignFunc) {
        var index2 = -1, length = props3.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$12;
          assignFunc(result2, props3[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject2(value) {
        return isArrayLikeObject2(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath2(value, object4) {
        if (isArray2(value)) {
          return value;
        }
        return isKey2(value, object4) ? [value] : stringToPath3(toString3(value));
      }
      var castRest = baseRest2;
      function castSlice2(array4, start, end) {
        var length = array4.length;
        end = end === undefined$12 ? length : end;
        return !start && end >= length ? array4 : baseSlice2(array4, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer2(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer2(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView2(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp2(regexp4) {
        var result2 = new regexp4.constructor(regexp4.source, reFlags2.exec(regexp4));
        result2.lastIndex = regexp4.lastIndex;
        return result2;
      }
      function cloneSymbol2(symbol) {
        return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
      }
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$12, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$12, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object4, other, orders) {
        var index2 = -1, objCriteria = object4.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object4.index - other.index;
      }
      function composeArgs(args2, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args2.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args2[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args2[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args2, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args2.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args2[argsIndex];
        }
        var offset3 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset3 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset3 + holders[holdersIndex]] = args2[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray2(source2, array4) {
        var index2 = -1, length = source2.length;
        array4 || (array4 = Array2(length));
        while (++index2 < length) {
          array4[index2] = source2[index2];
        }
        return array4;
      }
      function copyObject2(source2, props3, object4, customizer) {
        var isNew = !object4;
        object4 || (object4 = {});
        var index2 = -1, length = props3.length;
        while (++index2 < length) {
          var key2 = props3[index2];
          var newValue = customizer ? customizer(object4[key2], source2[key2], key2, object4, source2) : undefined$12;
          if (newValue === undefined$12) {
            newValue = source2[key2];
          }
          if (isNew) {
            baseAssignValue2(object4, key2, newValue);
          } else {
            assignValue2(object4, key2, newValue);
          }
        }
        return object4;
      }
      function copySymbols2(source2, object4) {
        return copyObject2(source2, getSymbols2(source2), object4);
      }
      function copySymbolsIn2(source2, object4) {
        return copyObject2(source2, getSymbolsIn2(source2), object4);
      }
      function createAggregator2(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator2 : baseAggregator2, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest2(function(object4, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$12, guard = length > 2 ? sources[2] : undefined$12;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$12;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$12 : customizer;
            length = 1;
          }
          object4 = Object2(object4);
          while (++index2 < length) {
            var source2 = sources[index2];
            if (source2) {
              assigner(object4, source2, index2, customizer);
            }
          }
          return object4;
        });
      }
      function createBaseEach2(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object4, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object4), props3 = keysFunc(object4), length = props3.length;
          while (length--) {
            var key2 = props3[fromRight ? length : ++index2];
            if (iteratee2(iterable[key2], key2, iterable) === false) {
              break;
            }
          }
          return object4;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string3) {
          string3 = toString3(string3);
          var strSymbols = hasUnicode2(string3) ? stringToArray2(string3) : undefined$12;
          var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
          var trailing = strSymbols ? castSlice2(strSymbols, 1).join("") : string3.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string3) {
          return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args2 = arguments;
          switch (args2.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args2[0]);
            case 2:
              return new Ctor(args2[0], args2[1]);
            case 3:
              return new Ctor(args2[0], args2[1], args2[2]);
            case 4:
              return new Ctor(args2[0], args2[1], args2[2], args2[3]);
            case 5:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4]);
            case 6:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5]);
            case 7:
              return new Ctor(args2[0], args2[1], args2[2], args2[3], args2[4], args2[5], args2[6]);
          }
          var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args2);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args2 = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args2[index2] = arguments[index2];
          }
          var holders = length < 3 && args2[0] !== placeholder && args2[length - 1] !== placeholder ? [] : replaceHolders(args2, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$12,
              args2,
              holders,
              undefined$12,
              undefined$12,
              arity - length
            );
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply2(fn, this, args2);
        }
        return wrapper;
      }
      function createFind2(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$12;
        };
      }
      function createFlow(fromRight) {
        return flatRest2(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data9 = funcName == "wrapper" ? getData(func) : undefined$12;
            if (data9 && isLaziable(data9[0]) && data9[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data9[4].length && data9[9] == 1) {
              wrapper = wrapper[getFuncName(data9[0])].apply(wrapper, data9[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args2 = arguments, value = args2[0];
            if (wrapper && args2.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args2) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$12 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args2 = Array2(length), index2 = length;
          while (index2--) {
            args2[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args2, placeholder);
          }
          if (partials) {
            args2 = composeArgs(args2, partials, holders, isCurried);
          }
          if (partialsRight) {
            args2 = composeArgsRight(args2, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args2, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args2,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args2.length;
          if (argPos) {
            args2 = reorder(args2, argPos);
          } else if (isFlip && length > 1) {
            args2.reverse();
          }
          if (isAry && ary2 < length) {
            args2.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args2);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object4, iteratee2) {
          return baseInverter(object4, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$12 && other === undefined$12) {
            return defaultValue;
          }
          if (value !== undefined$12) {
            result2 = value;
          }
          if (other !== undefined$12) {
            if (result2 === undefined$12) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest2(function(iteratees) {
          iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
          return baseRest2(function(args2) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args2);
            });
          });
        });
      }
      function createPadding2(length, chars) {
        chars = chars === undefined$12 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat2(chars, length) : chars;
        }
        var result2 = baseRepeat2(chars, nativeCeil2(length / stringSize2(chars)));
        return hasUnicode2(chars) ? castSlice2(stringToArray2(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args2 = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args2[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args2[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn, isBind ? thisArg : this, args2);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$12;
          }
          start = toFinite2(start);
          if (end === undefined$12) {
            end = start;
            start = 0;
          } else {
            end = toFinite2(end);
          }
          step = step === undefined$12 ? start < end ? 1 : -1 : toFinite2(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$12, newHoldersRight = isCurry ? undefined$12 : holders, newPartials = isCurry ? partials : undefined$12, newPartialsRight = isCurry ? undefined$12 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$12, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number4, precision) {
          number4 = toNumber2(number4);
          precision = precision == null ? 0 : nativeMin2(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number4)) {
            var pair = (toString3(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number4);
        };
      }
      var createSet2 = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY2) ? noop3 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object4) {
          var tag = getTag2(object4);
          if (tag == mapTag2) {
            return mapToArray2(object4);
          }
          if (tag == setTag2) {
            return setToPairs(object4);
          }
          return baseToPairs(object4, keysFunc(object4));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$12;
        }
        ary2 = ary2 === undefined$12 ? ary2 : nativeMax2(toInteger2(ary2), 0);
        arity = arity === undefined$12 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$12;
        }
        var data9 = isBindKey ? undefined$12 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data9) {
          mergeData(newData, data9);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$12 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$12, newData);
        }
        var setter = data9 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object4) {
        if (objValue === undefined$12 || eq2(objValue, objectProto2[key2]) && !hasOwnProperty2.call(object4, key2)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object4, source2, stack2) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack2.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$12, customDefaultsMerge, stack2);
          stack2["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone2(value) {
        return isPlainObject2(value) ? undefined$12 : value;
      }
      function equalArrays2(array4, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array4.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array4);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array4;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : undefined$12;
        stack2.set(array4, other);
        stack2.set(other, array4);
        while (++index2 < arrLength) {
          var arrValue = array4[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack2) : customizer(arrValue, othValue, index2, array4, other, stack2);
          }
          if (compared !== undefined$12) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result2 = false;
            break;
          }
        }
        stack2["delete"](array4);
        stack2["delete"](other);
        return result2;
      }
      function equalByTag2(object4, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag2:
            if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
              return false;
            }
            object4 = object4.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object4), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object4, +other);
          case errorTag2:
            return object4.name == other.name && object4.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object4 == other + "";
          case mapTag2:
            var convert2 = mapToArray2;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
            convert2 || (convert2 = setToArray2);
            if (object4.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object4);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG2;
            stack2.set(object4, other);
            var result2 = equalArrays2(convert2(object4), convert2(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object4);
            return result2;
          case symbolTag2:
            if (symbolValueOf2) {
              return symbolValueOf2.call(object4) == symbolValueOf2.call(other);
            }
        }
        return false;
      }
      function equalObjects2(object4, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object4), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
            return false;
          }
        }
        var objStacked = stack2.get(object4);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object4;
        }
        var result2 = true;
        stack2.set(object4, other);
        stack2.set(other, object4);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object4[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack2) : customizer(objValue, othValue, key2, object4, other, stack2);
          }
          if (!(compared === undefined$12 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object4.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack2["delete"](object4);
        stack2["delete"](other);
        return result2;
      }
      function flatRest2(func) {
        return setToString2(overRest2(func, undefined$12, flatten2), func + "");
      }
      function getAllKeys2(object4) {
        return baseGetAllKeys2(object4, keys2, getSymbols2);
      }
      function getAllKeysIn2(object4) {
        return baseGetAllKeys2(object4, keysIn2, getSymbolsIn2);
      }
      var getData = !metaMap ? noop3 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array4 = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array4.length : 0;
        while (length--) {
          var data9 = array4[length], otherFunc = data9.func;
          if (otherFunc == null || otherFunc == func) {
            return data9.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object4 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object4.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee2 : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData2(map2, key2) {
        var data9 = map2.__data__;
        return isKeyable2(key2) ? data9[typeof key2 == "string" ? "string" : "hash"] : data9.map;
      }
      function getMatchData2(object4) {
        var result2 = keys2(object4), length = result2.length;
        while (length--) {
          var key2 = result2[length], value = object4[key2];
          result2[length] = [key2, value, isStrictComparable2(value)];
        }
        return result2;
      }
      function getNative2(object4, key2) {
        var value = getValue2(object4, key2);
        return baseIsNative2(value) ? value : undefined$12;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$12;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object4) {
        if (object4 == null) {
          return [];
        }
        object4 = Object2(object4);
        return arrayFilter2(nativeGetSymbols2(object4), function(symbol) {
          return propertyIsEnumerable2.call(object4, symbol);
        });
      };
      var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object4) {
        var result2 = [];
        while (object4) {
          arrayPush2(result2, getSymbols2(object4));
          object4 = getPrototype2(object4);
        }
        return result2;
      };
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$12, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data9 = transforms[index2], size3 = data9.size;
          switch (data9.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin2(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax2(start, end - size3);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source2) {
        var match2 = source2.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath2(object4, path2, hasFunc) {
        path2 = castPath2(path2, object4);
        var index2 = -1, length = path2.length, result2 = false;
        while (++index2 < length) {
          var key2 = toKey2(path2[index2]);
          if (!(result2 = object4 != null && hasFunc(object4, key2))) {
            break;
          }
          object4 = object4[key2];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object4 == null ? 0 : object4.length;
        return !!length && isLength2(length) && isIndex2(key2, length) && (isArray2(object4) || isArguments2(object4));
      }
      function initCloneArray2(array4) {
        var length = array4.length, result2 = new array4.constructor(length);
        if (length && typeof array4[0] == "string" && hasOwnProperty2.call(array4, "index")) {
          result2.index = array4.index;
          result2.input = array4.input;
        }
        return result2;
      }
      function initCloneObject2(object4) {
        return typeof object4.constructor == "function" && !isPrototype2(object4) ? baseCreate2(getPrototype2(object4)) : {};
      }
      function initCloneByTag2(object4, tag, isDeep) {
        var Ctor = object4.constructor;
        switch (tag) {
          case arrayBufferTag2:
            return cloneArrayBuffer2(object4);
          case boolTag2:
          case dateTag2:
            return new Ctor(+object4);
          case dataViewTag2:
            return cloneDataView2(object4, isDeep);
          case float32Tag2:
          case float64Tag2:
          case int8Tag2:
          case int16Tag2:
          case int32Tag2:
          case uint8Tag2:
          case uint8ClampedTag2:
          case uint16Tag2:
          case uint32Tag2:
            return cloneTypedArray2(object4, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag2:
          case stringTag2:
            return new Ctor(object4);
          case regexpTag2:
            return cloneRegExp2(object4);
          case setTag2:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol2(object4);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable2(value) {
        return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
      }
      function isIndex2(value, length) {
        var type4 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type4 == "number" || type4 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object4) {
        if (!isObject3(object4)) {
          return false;
        }
        var type4 = typeof index2;
        if (type4 == "number" ? isArrayLike2(object4) && isIndex2(index2, object4.length) : type4 == "string" && index2 in object4) {
          return eq2(object4[index2], value);
        }
        return false;
      }
      function isKey2(value, object4) {
        if (isArray2(value)) {
          return false;
        }
        var type4 = typeof value;
        if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object4 != null && value in Object2(object4);
      }
      function isKeyable2(value) {
        var type4 = typeof value;
        return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data9 = getData(other);
        return !!data9 && func === data9[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction3 : stubFalse2;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable2(value) {
        return value === value && !isObject3(value);
      }
      function matchesStrictComparable2(key2, srcValue) {
        return function(object4) {
          if (object4 == null) {
            return false;
          }
          return object4[key2] === srcValue && (srcValue !== undefined$12 || key2 in Object2(object4));
        };
      }
      function memoizeCapped2(func) {
        var result2 = memoize2(func, function(key2) {
          if (cache.size === MAX_MEMOIZE_SIZE2) {
            cache.clear();
          }
          return key2;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data9, source2) {
        var bitmask = data9[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data9[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data9;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data9[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data9[3];
          data9[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data9[4] = partials ? replaceHolders(data9[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data9[5];
          data9[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data9[6] = partials ? replaceHolders(data9[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data9[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data9[8] = data9[8] == null ? source2[8] : nativeMin2(data9[8], source2[8]);
        }
        if (data9[9] == null) {
          data9[9] = source2[9];
        }
        data9[0] = source2[0];
        data9[1] = newBitmask;
        return data9;
      }
      function nativeKeysIn2(object4) {
        var result2 = [];
        if (object4 != null) {
          for (var key2 in Object2(object4)) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest2(func, start, transform3) {
        start = nativeMax2(start === undefined$12 ? func.length - 1 : start, 0);
        return function() {
          var args2 = arguments, index2 = -1, length = nativeMax2(args2.length - start, 0), array4 = Array2(length);
          while (++index2 < length) {
            array4[index2] = args2[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args2[index2];
          }
          otherArgs[start] = transform3(array4);
          return apply2(func, this, otherArgs);
        };
      }
      function parent2(object4, path2) {
        return path2.length < 2 ? object4 : baseGet2(object4, baseSlice2(path2, 0, -1));
      }
      function reorder(array4, indexes) {
        var arrLength = array4.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array4);
        while (length--) {
          var index2 = indexes[length];
          array4[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$12;
        }
        return array4;
      }
      function safeGet(object4, key2) {
        if (key2 === "constructor" && typeof object4[key2] === "function") {
          return;
        }
        if (key2 == "__proto__") {
          return;
        }
        return object4[key2];
      }
      var setData = shortOut2(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString2 = shortOut2(baseSetToString2);
      function setWrapToString(wrapper, reference, bitmask) {
        var source2 = reference + "";
        return setToString2(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut2(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT2) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$12, arguments);
        };
      }
      function shuffleSelf(array4, size3) {
        var index2 = -1, length = array4.length, lastIndex = length - 1;
        size3 = size3 === undefined$12 ? length : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value = array4[rand];
          array4[rand] = array4[index2];
          array4[index2] = value;
        }
        array4.length = size3;
        return array4;
      }
      var stringToPath3 = memoizeCapped2(function(string3) {
        var result2 = [];
        if (string3.charCodeAt(0) === 46) {
          result2.push("");
        }
        string3.replace(rePropName2, function(match2, number4, quote2, subString) {
          result2.push(quote2 ? subString.replace(reEscapeChar2, "$1") : number4 || match2);
        });
        return result2;
      });
      function toKey2(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach2(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes2(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray2(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array4, size3, guard) {
        if (guard ? isIterateeCall(array4, size3, guard) : size3 === undefined$12) {
          size3 = 1;
        } else {
          size3 = nativeMax2(toInteger2(size3), 0);
        }
        var length = array4 == null ? 0 : array4.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil2(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice2(array4, index2, index2 += size3);
        }
        return result2;
      }
      function compact3(array4) {
        var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array4[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args2 = Array2(length - 1), array4 = arguments[0], index2 = length;
        while (index2--) {
          args2[index2 - 1] = arguments[index2];
        }
        return arrayPush2(isArray2(array4) ? copyArray2(array4) : [array4], baseFlatten2(args2, 1));
      }
      var difference = baseRest2(function(array4, values2) {
        return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten2(values2, 1, isArrayLikeObject2, true)) : [];
      });
      var differenceBy = baseRest2(function(array4, values2) {
        var iteratee2 = last3(values2);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten2(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest2(function(array4, values2) {
        var comparator2 = last3(values2);
        if (isArrayLikeObject2(comparator2)) {
          comparator2 = undefined$12;
        }
        return isArrayLikeObject2(array4) ? baseDifference(array4, baseFlatten2(values2, 1, isArrayLikeObject2, true), undefined$12, comparator2) : [];
      });
      function drop(array4, n2, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger2(n2);
        return baseSlice2(array4, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array4, n2, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice2(array4, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), true) : [];
      }
      function fill(array4, value, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array4, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array4, value, start, end);
      }
      function findIndex2(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseFindIndex2(array4, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array4, predicate, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$12) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
        }
        return baseFindIndex2(array4, getIteratee(predicate, 3), index2, true);
      }
      function flatten2(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten2(array4, 1) : [];
      }
      function flattenDeep(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseFlatten2(array4, INFINITY2) : [];
      }
      function flattenDepth(array4, depth) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten2(array4, depth);
      }
      function fromPairs2(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array4) {
        return array4 && array4.length ? array4[0] : undefined$12;
      }
      function indexOf2(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseIndexOf2(array4, value, index2);
      }
      function initial(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice2(array4, 0, -1) : [];
      }
      var intersection2 = baseRest2(function(arrays) {
        var mapped = arrayMap2(arrays, castArrayLikeObject2);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection2(mapped) : [];
      });
      var intersectionBy = baseRest2(function(arrays) {
        var iteratee2 = last3(arrays), mapped = arrayMap2(arrays, castArrayLikeObject2);
        if (iteratee2 === last3(mapped)) {
          iteratee2 = undefined$12;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection2(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest2(function(arrays) {
        var comparator2 = last3(arrays), mapped = arrayMap2(arrays, castArrayLikeObject2);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection2(mapped, undefined$12, comparator2) : [];
      });
      function join(array4, separator) {
        return array4 == null ? "" : nativeJoin.call(array4, separator);
      }
      function last3(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? array4[length - 1] : undefined$12;
      }
      function lastIndexOf(array4, value, fromIndex) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$12) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax2(length + index2, 0) : nativeMin2(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array4, value, index2) : baseFindIndex2(array4, baseIsNaN2, index2, true);
      }
      function nth(array4, n2) {
        return array4 && array4.length ? baseNth(array4, toInteger2(n2)) : undefined$12;
      }
      var pull = baseRest2(pullAll);
      function pullAll(array4, values2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2) : array4;
      }
      function pullAllBy(array4, values2, iteratee2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, getIteratee(iteratee2, 2)) : array4;
      }
      function pullAllWith(array4, values2, comparator2) {
        return array4 && array4.length && values2 && values2.length ? basePullAll(array4, values2, undefined$12, comparator2) : array4;
      }
      var pullAt = flatRest2(function(array4, indexes) {
        var length = array4 == null ? 0 : array4.length, result2 = baseAt(array4, indexes);
        basePullAt(array4, arrayMap2(indexes, function(index2) {
          return isIndex2(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array4, predicate) {
        var result2 = [];
        if (!(array4 && array4.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array4.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array4[index2];
          if (predicate(value, index2, array4)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array4, indexes);
        return result2;
      }
      function reverse2(array4) {
        return array4 == null ? array4 : nativeReverse.call(array4);
      }
      function slice2(array4, start, end) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array4, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$12 ? length : toInteger2(end);
        }
        return baseSlice2(array4, start, end);
      }
      function sortedIndex(array4, value) {
        return baseSortedIndex(array4, value);
      }
      function sortedIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value);
          if (index2 < length && eq2(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array4, value) {
        return baseSortedIndex(array4, value, true);
      }
      function sortedLastIndexBy(array4, value, iteratee2) {
        return baseSortedIndexBy(array4, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array4, value) {
        var length = array4 == null ? 0 : array4.length;
        if (length) {
          var index2 = baseSortedIndex(array4, value, true) - 1;
          if (eq2(array4[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array4) {
        return array4 && array4.length ? baseSortedUniq(array4) : [];
      }
      function sortedUniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseSortedUniq(array4, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array4) {
        var length = array4 == null ? 0 : array4.length;
        return length ? baseSlice2(array4, 1, length) : [];
      }
      function take(array4, n2, guard) {
        if (!(array4 && array4.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger2(n2);
        return baseSlice2(array4, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array4, n2, guard) {
        var length = array4 == null ? 0 : array4.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$12 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice2(array4, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array4, predicate) {
        return array4 && array4.length ? baseWhile(array4, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest2(function(arrays) {
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
      });
      var unionBy = baseRest2(function(arrays) {
        var iteratee2 = last3(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest2(function(arrays) {
        var comparator2 = last3(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true), undefined$12, comparator2);
      });
      function uniq2(array4) {
        return array4 && array4.length ? baseUniq2(array4) : [];
      }
      function uniqBy(array4, iteratee2) {
        return array4 && array4.length ? baseUniq2(array4, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array4, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return array4 && array4.length ? baseUniq2(array4, undefined$12, comparator2) : [];
      }
      function unzip(array4) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var length = 0;
        array4 = arrayFilter2(array4, function(group2) {
          if (isArrayLikeObject2(group2)) {
            length = nativeMax2(group2.length, length);
            return true;
          }
        });
        return baseTimes2(length, function(index2) {
          return arrayMap2(array4, baseProperty2(index2));
        });
      }
      function unzipWith(array4, iteratee2) {
        if (!(array4 && array4.length)) {
          return [];
        }
        var result2 = unzip(array4);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap2(result2, function(group2) {
          return apply2(iteratee2, undefined$12, group2);
        });
      }
      var without = baseRest2(function(array4, values2) {
        return isArrayLikeObject2(array4) ? baseDifference(array4, values2) : [];
      });
      var xor = baseRest2(function(arrays) {
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
      });
      var xorBy = baseRest2(function(arrays) {
        var iteratee2 = last3(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$12;
        }
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest2(function(arrays) {
        var comparator2 = last3(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$12;
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$12, comparator2);
      });
      var zip = baseRest2(unzip);
      function zipObject(props3, values2) {
        return baseZipObject(props3 || [], values2 || [], assignValue2);
      }
      function zipObjectDeep(props3, values2) {
        return baseZipObject(props3 || [], values2 || [], baseSet2);
      }
      var zipWith = baseRest2(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$12;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$12;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest2(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object4) {
          return baseAt(object4, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$12
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array4) {
          if (length && !array4.length) {
            array4.push(undefined$12);
          }
          return array4;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$12) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$12 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent3 = this;
        while (parent3 instanceof baseLodash) {
          var clone4 = wrapperClone(parent3);
          clone4.__index__ = 0;
          clone4.__values__ = undefined$12;
          if (result2) {
            previous.__wrapped__ = clone4;
          } else {
            result2 = clone4;
          }
          var previous = clone4;
          parent3 = parent3.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse2],
            "thisArg": undefined$12
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse2);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator2(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          ++result2[key2];
        } else {
          baseAssignValue2(result2, key2, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind2(findIndex2);
      var findLast = createFind2(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten2(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten2(map(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$12 ? 1 : toInteger2(depth);
        return baseFlatten2(map(collection, iteratee2), depth);
      }
      function forEach3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach2 : baseEach2;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator2(function(result2, value, key2) {
        if (hasOwnProperty2.call(result2, key2)) {
          result2[key2].push(value);
        } else {
          baseAssignValue2(result2, key2, [value]);
        }
      });
      function includes2(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length + fromIndex, 0);
        }
        return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf2(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest2(function(collection, path2, args2) {
        var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value) {
          result2[++index2] = isFunc ? apply2(path2, value, args2) : baseInvoke(value, path2, args2);
        });
        return result2;
      });
      var keyBy = createAggregator2(function(result2, value, key2) {
        baseAssignValue2(result2, key2, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap2 : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$12 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition2 = createAggregator2(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$12) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString3(collection) ? stringSize2(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag2 || tag == setTag2) {
          return collection.size;
        }
        return baseKeys2(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome2 : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$12;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy3 = baseRest2(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten2(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$12 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$12;
          }
          return result2;
        };
      }
      var bind4 = baseRest2(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind4));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest2(function(object4, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object4, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$12 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$12, undefined$12, undefined$12, undefined$12, undefined$12, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args2 = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$12;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args2);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$12 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$12;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$12;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$12) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$12;
        }
        function flush() {
          return timerId === undefined$12 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$12) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$12) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest2(function(func, args2) {
        return baseDelay(func, 1, args2);
      });
      var delay = baseRest2(function(func, wait, args2) {
        return baseDelay(func, toNumber2(wait) || 0, args2);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args2 = arguments, key2 = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
          if (cache.has(key2)) {
            return cache.get(key2);
          }
          var result2 = func.apply(this, args2);
          memoized.cache = cache.set(key2, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args2 = arguments;
          switch (args2.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args2[0]);
            case 2:
              return !predicate.call(this, args2[0], args2[1]);
            case 3:
              return !predicate.call(this, args2[0], args2[1], args2[2]);
          }
          return !predicate.apply(this, args2);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest2(function(args2) {
          var index2 = -1, length = nativeMin2(args2.length, funcsLength);
          while (++index2 < length) {
            args2[index2] = transforms[index2].call(this, args2[index2]);
          }
          return apply2(func, this, args2);
        });
      });
      var partial = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$12, partials, holders);
      });
      var partialRight = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$12, partials, holders);
      });
      var rearg = flatRest2(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$12, undefined$12, undefined$12, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start = start === undefined$12 ? start : toInteger2(start);
        return baseRest2(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start = start == null ? 0 : nativeMax2(toInteger2(start), 0);
        return baseRest2(function(args2) {
          var array4 = args2[start], otherArgs = castSlice2(args2, 0, start);
          if (array4) {
            arrayPush2(otherArgs, array4);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone3(value) {
        return baseClone2(value, CLONE_SYMBOLS_FLAG2);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone2(value, CLONE_SYMBOLS_FLAG2, customizer);
      }
      function cloneDeep2(value) {
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2, customizer);
      }
      function conformsTo(object4, source2) {
        return source2 == null || baseConformsTo(object4, source2, keys2(source2));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments2(function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction3(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
      }
      var isBuffer3 = nativeIsBuffer2 || stubFalse2;
      var isDate2 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag2 || tag == setTag2) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys2(value).length;
        }
        for (var key2 in value) {
          if (hasOwnProperty2.call(value, key2)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual2(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        var result2 = customizer ? customizer(value, other) : undefined$12;
        return result2 === undefined$12 ? baseIsEqual2(value, other, undefined$12, customizer) : !!result2;
      }
      function isError2(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction3(value) {
        if (!isObject3(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject3(value) {
        var type4 = typeof value;
        return value != null && (type4 == "object" || type4 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
      function isMatch(object4, source2) {
        return object4 === source2 || baseIsMatch2(object4, source2, getMatchData2(source2));
      }
      function isMatchWith(object4, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return baseIsMatch2(object4, source2, getMatchData2(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil2(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto = getPrototype2(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp3 = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
      function isString3(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function isUndefined2(value) {
        return value === undefined$12;
      }
      function isWeakMap2(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag2;
      }
      function isWeakSet2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString3(value) ? stringToArray2(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values;
        return func(value);
      }
      function toFinite2(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER2;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite2(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim2(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject(value) {
        return copyObject2(value, keysIn2(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign2 = createAssigner(function(object4, source2) {
        if (isPrototype2(source2) || isArrayLike2(source2)) {
          copyObject2(source2, keys2(source2), object4);
          return;
        }
        for (var key2 in source2) {
          if (hasOwnProperty2.call(source2, key2)) {
            assignValue2(object4, key2, source2[key2]);
          }
        }
      });
      var assignIn = createAssigner(function(object4, source2) {
        copyObject2(source2, keysIn2(source2), object4);
      });
      var assignInWith = createAssigner(function(object4, source2, srcIndex, customizer) {
        copyObject2(source2, keysIn2(source2), object4, customizer);
      });
      var assignWith = createAssigner(function(object4, source2, srcIndex, customizer) {
        copyObject2(source2, keys2(source2), object4, customizer);
      });
      var at = flatRest2(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate2(prototype);
        return properties == null ? result2 : baseAssign2(result2, properties);
      }
      var defaults2 = baseRest2(function(object4, sources) {
        object4 = Object2(object4);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$12;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source2 = sources[index2];
          var props3 = keysIn2(source2);
          var propsIndex = -1;
          var propsLength = props3.length;
          while (++propsIndex < propsLength) {
            var key2 = props3[propsIndex];
            var value = object4[key2];
            if (value === undefined$12 || eq2(value, objectProto2[key2]) && !hasOwnProperty2.call(object4, key2)) {
              object4[key2] = source2[key2];
            }
          }
        }
        return object4;
      });
      var defaultsDeep = baseRest2(function(args2) {
        args2.push(undefined$12, customDefaultsMerge);
        return apply2(mergeWith, undefined$12, args2);
      });
      function findKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwn2);
      }
      function findLastKey(object4, predicate) {
        return baseFindKey(object4, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object4, iteratee2) {
        return object4 == null ? object4 : baseFor2(object4, getIteratee(iteratee2, 3), keysIn2);
      }
      function forInRight(object4, iteratee2) {
        return object4 == null ? object4 : baseForRight(object4, getIteratee(iteratee2, 3), keysIn2);
      }
      function forOwn(object4, iteratee2) {
        return object4 && baseForOwn2(object4, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object4, iteratee2) {
        return object4 && baseForOwnRight(object4, getIteratee(iteratee2, 3));
      }
      function functions(object4) {
        return object4 == null ? [] : baseFunctions(object4, keys2(object4));
      }
      function functionsIn(object4) {
        return object4 == null ? [] : baseFunctions(object4, keysIn2(object4));
      }
      function get4(object4, path2, defaultValue) {
        var result2 = object4 == null ? undefined$12 : baseGet2(object4, path2);
        return result2 === undefined$12 ? defaultValue : result2;
      }
      function has2(object4, path2) {
        return object4 != null && hasPath2(object4, path2, baseHas);
      }
      function hasIn2(object4, path2) {
        return object4 != null && hasPath2(object4, path2, baseHasIn2);
      }
      var invert = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key2;
      }, constant2(identity2));
      var invertBy = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key2);
        } else {
          result2[value] = [key2];
        }
      }, getIteratee);
      var invoke = baseRest2(baseInvoke);
      function keys2(object4) {
        return isArrayLike2(object4) ? arrayLikeKeys2(object4) : baseKeys2(object4);
      }
      function keysIn2(object4) {
        return isArrayLike2(object4) ? arrayLikeKeys2(object4, true) : baseKeysIn2(object4);
      }
      function mapKeys(object4, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object4, function(value, key2, object5) {
          baseAssignValue2(result2, iteratee2(value, key2, object5), value);
        });
        return result2;
      }
      function mapValues(object4, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object4, function(value, key2, object5) {
          baseAssignValue2(result2, key2, iteratee2(value, key2, object5));
        });
        return result2;
      }
      var merge4 = createAssigner(function(object4, source2, srcIndex) {
        baseMerge(object4, source2, srcIndex);
      });
      var mergeWith = createAssigner(function(object4, source2, srcIndex, customizer) {
        baseMerge(object4, source2, srcIndex, customizer);
      });
      var omit2 = flatRest2(function(object4, paths) {
        var result2 = {};
        if (object4 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap2(paths, function(path2) {
          path2 = castPath2(path2, object4);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject2(object4, getAllKeysIn2(object4), result2);
        if (isDeep) {
          result2 = baseClone2(result2, CLONE_DEEP_FLAG2 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG2, customOmitClone2);
        }
        var length = paths.length;
        while (length--) {
          baseUnset2(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object4, predicate) {
        return pickBy(object4, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest2(function(object4, paths) {
        return object4 == null ? {} : basePick2(object4, paths);
      });
      function pickBy(object4, predicate) {
        if (object4 == null) {
          return {};
        }
        var props3 = arrayMap2(getAllKeysIn2(object4), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy2(object4, props3, function(value, path2) {
          return predicate(value, path2[0]);
        });
      }
      function result(object4, path2, defaultValue) {
        path2 = castPath2(path2, object4);
        var index2 = -1, length = path2.length;
        if (!length) {
          length = 1;
          object4 = undefined$12;
        }
        while (++index2 < length) {
          var value = object4 == null ? undefined$12 : object4[toKey2(path2[index2])];
          if (value === undefined$12) {
            index2 = length;
            value = defaultValue;
          }
          object4 = isFunction3(value) ? value.call(object4) : value;
        }
        return object4;
      }
      function set2(object4, path2, value) {
        return object4 == null ? object4 : baseSet2(object4, path2, value);
      }
      function setWith(object4, path2, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object4 == null ? object4 : baseSet2(object4, path2, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn2);
      function transform2(object4, iteratee2, accumulator) {
        var isArr = isArray2(object4), isArrLike = isArr || isBuffer3(object4) || isTypedArray2(object4);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object4 && object4.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject3(object4)) {
            accumulator = isFunction3(Ctor) ? baseCreate2(getPrototype2(object4)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach2 : baseForOwn2)(object4, function(value, index2, object5) {
          return iteratee2(accumulator, value, index2, object5);
        });
        return accumulator;
      }
      function unset(object4, path2) {
        return object4 == null ? true : baseUnset2(object4, path2);
      }
      function update(object4, path2, updater) {
        return object4 == null ? object4 : baseUpdate(object4, path2, castFunction(updater));
      }
      function updateWith(object4, path2, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$12;
        return object4 == null ? object4 : baseUpdate(object4, path2, castFunction(updater), customizer);
      }
      function values(object4) {
        return object4 == null ? [] : baseValues(object4, keys2(object4));
      }
      function valuesIn(object4) {
        return object4 == null ? [] : baseValues(object4, keysIn2(object4));
      }
      function clamp2(number4, lower2, upper) {
        if (upper === undefined$12) {
          upper = lower2;
          lower2 = undefined$12;
        }
        if (upper !== undefined$12) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower2 !== undefined$12) {
          lower2 = toNumber2(lower2);
          lower2 = lower2 === lower2 ? lower2 : 0;
        }
        return baseClamp(toNumber2(number4), lower2, upper);
      }
      function inRange(number4, start, end) {
        start = toFinite2(start);
        if (end === undefined$12) {
          end = start;
          start = 0;
        } else {
          end = toFinite2(end);
        }
        number4 = toNumber2(number4);
        return baseInRange(number4, start, end);
      }
      function random(lower2, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
          upper = floating = undefined$12;
        }
        if (floating === undefined$12) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$12;
          } else if (typeof lower2 == "boolean") {
            floating = lower2;
            lower2 = undefined$12;
          }
        }
        if (lower2 === undefined$12 && upper === undefined$12) {
          lower2 = 0;
          upper = 1;
        } else {
          lower2 = toFinite2(lower2);
          if (upper === undefined$12) {
            upper = lower2;
            lower2 = 0;
          } else {
            upper = toFinite2(upper);
          }
        }
        if (lower2 > upper) {
          var temp = lower2;
          lower2 = upper;
          upper = temp;
        }
        if (floating || lower2 % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin2(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower2, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string3) {
        return upperFirst(toString3(string3).toLowerCase());
      }
      function deburr(string3) {
        string3 = toString3(string3);
        return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string3, target, position) {
        string3 = toString3(string3);
        target = baseToString2(target);
        var length = string3.length;
        position = position === undefined$12 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string3.slice(position, end) == target;
      }
      function escape2(string3) {
        string3 = toString3(string3);
        return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
      }
      function escapeRegExp(string3) {
        string3 = toString3(string3);
        return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar2, "\\$&") : string3;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string3, length, chars) {
        string3 = toString3(string3);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string3) : 0;
        if (!length || strLength >= length) {
          return string3;
        }
        var mid = (length - strLength) / 2;
        return createPadding2(nativeFloor2(mid), chars) + string3 + createPadding2(nativeCeil2(mid), chars);
      }
      function padEnd2(string3, length, chars) {
        string3 = toString3(string3);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string3) : 0;
        return length && strLength < length ? string3 + createPadding2(length - strLength, chars) : string3;
      }
      function padStart2(string3, length, chars) {
        string3 = toString3(string3);
        length = toInteger2(length);
        var strLength = length ? stringSize2(string3) : 0;
        return length && strLength < length ? createPadding2(length - strLength, chars) + string3 : string3;
      }
      function parseInt2(string3, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string3).replace(reTrimStart2, ""), radix || 0);
      }
      function repeat2(string3, n2, guard) {
        if (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined$12) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        return baseRepeat2(toString3(string3), n2);
      }
      function replace2() {
        var args2 = arguments, string3 = toString3(args2[0]);
        return args2.length < 3 ? string3 : string3.replace(args2[1], args2[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split2(string3, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
          separator = limit = undefined$12;
        }
        limit = limit === undefined$12 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string3 = toString3(string3);
        if (string3 && (typeof separator == "string" || separator != null && !isRegExp3(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode2(string3)) {
            return castSlice2(stringToArray2(string3), 0, limit);
          }
        }
        return string3.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith2(string3, target, position) {
        string3 = toString3(string3);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string3.length);
        target = baseToString2(target);
        return string3.slice(position, position + target.length) == target;
      }
      function template(string3, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string3, options, guard)) {
          options = undefined$12;
        }
        string3 = toString3(string3);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string3.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset3) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string3.slice(index2, offset3).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset3 + match2.length;
          return match2;
        });
        source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$12, importsValues);
        });
        result2.source = source2;
        if (isError2(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string3, chars, guard) {
        string3 = toString3(string3);
        if (string3 && (guard || chars === undefined$12)) {
          return baseTrim2(string3);
        }
        if (!string3 || !(chars = baseToString2(chars))) {
          return string3;
        }
        var strSymbols = stringToArray2(string3), chrSymbols = stringToArray2(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice2(strSymbols, start, end).join("");
      }
      function trimEnd(string3, chars, guard) {
        string3 = toString3(string3);
        if (string3 && (guard || chars === undefined$12)) {
          return string3.slice(0, trimmedEndIndex2(string3) + 1);
        }
        if (!string3 || !(chars = baseToString2(chars))) {
          return string3;
        }
        var strSymbols = stringToArray2(string3), end = charsEndIndex(strSymbols, stringToArray2(chars)) + 1;
        return castSlice2(strSymbols, 0, end).join("");
      }
      function trimStart(string3, chars, guard) {
        string3 = toString3(string3);
        if (string3 && (guard || chars === undefined$12)) {
          return string3.replace(reTrimStart2, "");
        }
        if (!string3 || !(chars = baseToString2(chars))) {
          return string3;
        }
        var strSymbols = stringToArray2(string3), start = charsStartIndex(strSymbols, stringToArray2(chars));
        return castSlice2(strSymbols, start).join("");
      }
      function truncate(string3, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString2(options.omission) : omission;
        }
        string3 = toString3(string3);
        var strLength = string3.length;
        if (hasUnicode2(string3)) {
          var strSymbols = stringToArray2(string3);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string3;
        }
        var end = length - stringSize2(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice2(strSymbols, 0, end).join("") : string3.slice(0, end);
        if (separator === undefined$12) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp3(separator)) {
          if (string3.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags2.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$12 ? end : newEnd);
          }
        } else if (string3.indexOf(baseToString2(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string3) {
        string3 = toString3(string3);
        return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string3, pattern4, guard) {
        string3 = toString3(string3);
        pattern4 = guard ? undefined$12 : pattern4;
        if (pattern4 === undefined$12) {
          return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
        }
        return string3.match(pattern4) || [];
      }
      var attempt = baseRest2(function(func, args2) {
        try {
          return apply2(func, undefined$12, args2);
        } catch (e2) {
          return isError2(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest2(function(object4, methodNames) {
        arrayEach2(methodNames, function(key2) {
          key2 = toKey2(key2);
          baseAssignValue2(object4, key2, bind4(object4[key2], object4));
        });
        return object4;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap2(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest2(function(args2) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args2)) {
              return apply2(pair[1], this, args2);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone2(source2, CLONE_DEEP_FLAG2));
      }
      function constant2(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee2(typeof func == "function" ? func : baseClone2(func, CLONE_DEEP_FLAG2));
      }
      function matches2(source2) {
        return baseMatches2(baseClone2(source2, CLONE_DEEP_FLAG2));
      }
      function matchesProperty(path2, srcValue) {
        return baseMatchesProperty2(path2, baseClone2(srcValue, CLONE_DEEP_FLAG2));
      }
      var method4 = baseRest2(function(path2, args2) {
        return function(object4) {
          return baseInvoke(object4, path2, args2);
        };
      });
      var methodOf = baseRest2(function(object4, args2) {
        return function(path2) {
          return baseInvoke(object4, path2, args2);
        };
      });
      function mixin(object4, source2, options) {
        var props3 = keys2(source2), methodNames = baseFunctions(source2, props3);
        if (options == null && !(isObject3(source2) && (methodNames.length || !props3.length))) {
          options = source2;
          source2 = object4;
          object4 = this;
          methodNames = baseFunctions(source2, keys2(source2));
        }
        var chain2 = !(isObject3(options) && "chain" in options) || !!options.chain, isFunc = isFunction3(object4);
        arrayEach2(methodNames, function(methodName) {
          var func = source2[methodName];
          object4[methodName] = func;
          if (isFunc) {
            object4.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object4(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object4 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object4, arrayPush2([this.value()], arguments));
            };
          }
        });
        return object4;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop3() {
      }
      function nthArg(n2) {
        n2 = toInteger2(n2);
        return baseRest2(function(args2) {
          return baseNth(args2, n2);
        });
      }
      var over = createOver(arrayMap2);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome2);
      function property2(path2) {
        return isKey2(path2) ? baseProperty2(toKey2(path2)) : basePropertyDeep2(path2);
      }
      function propertyOf(object4) {
        return function(path2) {
          return object4 == null ? undefined$12 : baseGet2(object4, path2);
        };
      }
      var range3 = createRange();
      var rangeRight = createRange(true);
      function stubArray2() {
        return [];
      }
      function stubFalse2() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger2(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin2(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes2(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap2(value, toKey2);
        }
        return isSymbol2(value) ? [value] : copyArray2(stringToPath3(toString3(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString3(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max3(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity2, baseGt) : undefined$12;
      }
      function maxBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseGt) : undefined$12;
      }
      function mean(array4) {
        return baseMean(array4, identity2);
      }
      function meanBy(array4, iteratee2) {
        return baseMean(array4, getIteratee(iteratee2, 2));
      }
      function min3(array4) {
        return array4 && array4.length ? baseExtremum(array4, identity2, baseLt) : undefined$12;
      }
      function minBy(array4, iteratee2) {
        return array4 && array4.length ? baseExtremum(array4, getIteratee(iteratee2, 2), baseLt) : undefined$12;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array4) {
        return array4 && array4.length ? baseSum(array4, identity2) : 0;
      }
      function sumBy(array4, iteratee2) {
        return array4 && array4.length ? baseSum(array4, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind4;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact3;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant2;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten2;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs2;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection2;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn2;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge4;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method4;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition2;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property2;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range3;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse2;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy3;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split2;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq2;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone3;
      lodash2.cloneDeep = cloneDeep2;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq2;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach3;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get4;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn2;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes2;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments2;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject2;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer3;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction3;
      lodash2.isInteger = isInteger2;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil2;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject3;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp3;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString3;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap2;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last3;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max3;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min3;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray2;
      lodash2.stubFalse = stubFalse2;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop3;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd2;
      lodash2.padStart = padStart2;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite2;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach3;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source2 = {};
        baseForOwn2(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach2(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$12 ? 1 : nativeMax2(toInteger2(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin2(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin2(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach2(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type4 = index2 + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type4
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach2(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach2(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest2(function(path2, args2) {
        if (typeof path2 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path2, args2);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$12) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args2 = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args2[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush2([value2], args2));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args2);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$12 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args2);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args2 = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args2);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args2);
          });
        };
      });
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key2)) {
            realNames[key2] = [];
          }
          realNames[key2].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$12, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$12
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule2) {
      (freeModule2.exports = _2)._ = _2;
      freeExports2._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
const _ = lodash.exports;
const onRE = /^on[^a-z]/;
const VueComponents = {};
const privateLodash = {
  WORDS: {
    INVALID_DATE: "Invalid Date",
    format_ymd: "YYYY-MM-DD"
  },
  launchFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullScreen();
    }
  },
  exitFullscreen() {
    document.exitFullscreen();
  },
  hashCode(str) {
    var hash = 0, i2, chr;
    if (str.length === 0) {
      return "0";
    }
    for (i2 = 0; i2 < str.length; i2++) {
      chr = str.charCodeAt(i2);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return String(hash);
  },
  getLeftTopFromAbsolute($ele) {
    const _top = $ele.css("top");
    const _left = $ele.css("left");
    const getNum = (x2) => {
      const match2 = String(x2).match(/^(.*)px$/);
      if (match2 && match2[1]) {
        return Number(match2[1]);
      } else {
        return 0;
      }
    };
    const top = getNum(_top);
    const left = getNum(_left);
    return { top, left };
  },
  getLeftTopFromTranslate($ele) {
    const transform2 = $ele.css("transform");
    const match2 = String(transform2).match(/^matrix\((.*)\)$/);
    if (!match2) {
      return { top: 0, left: 0 };
    }
    if (match2 && match2[1]) {
      const [a2, b2, c2, d2, e2, f2] = String(match2[1]).split(",").map((i2) => Number(_.trim(i2)));
      return {
        left: a2 + c2 + e2,
        top: b2 + d2 + f2
      };
    }
  },
  async asyncImportSFC(url2, __Vue) {
    if (VueComponents[url2]) {
      return VueComponents[url2];
    }
    const scfSourceCode = await privateLodash.asyncLoadText(url2);
    const scfObjSourceCode = privateLodash.VueLoader(scfSourceCode);
    VueComponents[url2] = await privateLodash.getVueComponentBySourceCode(
      url2,
      scfObjSourceCode,
      __Vue
    );
    return VueComponents[url2];
  },
  async getVueComponentBySourceCode(url2, scfObjSourceCode, __Vue) {
    const scfObjAsyncFn = new Function(
      "argVue",
      "argPayload",
      `console.log(\`${url2}\`)
return (${scfObjSourceCode})(argVue,argPayload);`
    );
    const scfObj = await scfObjAsyncFn(__Vue, {
      url: url2
    });
    return scfObj;
  },
  parseContent: (returnSentence) => {
    if (!returnSentence)
      return;
    return new Function(`${returnSentence} return module();`);
  },
  payloadIdCount: 1,
  payloadIdCountMax: 4e4,
  payloadDateNow: Date.now(),
  genId: (category) => {
    const { payloadIdCount, payloadIdCountMax, payloadDateNow } = privateLodash;
    if (payloadIdCount > payloadIdCountMax) {
      privateLodash.payloadIdCount = 1;
      privateLodash.payloadDateNow = Date.now();
    }
    return `${category}_${payloadDateNow}_${privateLodash.payloadIdCount++}`;
  },
  VueLoader: (code) => {
    function getSource(source2, type4) {
      var regex = new RegExp("<" + type4 + "[^>]*>");
      var openingTag = source2.match(regex);
      if (!openingTag)
        return "";
      else
        openingTag = openingTag[0];
      var targetSource = source2.slice(
        source2.indexOf(openingTag) + openingTag.length,
        source2.lastIndexOf("</" + type4 + ">")
      );
      return type4 === "template" ? targetSource.replace(/`/g, "\\`") : targetSource;
    }
    function splitCode() {
      if (!/TEMPLATE_PLACEHOLDER/.test(code)) {
        alert("SFC miss TEMPLATE_PLACEHOLDER");
        console.error(code);
      }
      return getSource(code, "script").replace(
        /TEMPLATE_PLACEHOLDER/,
        `template: \`${getSource(code, "template")}\``
      );
    }
    return splitCode();
  },
  async asyncExecFnString(url2) {
    const data9 = await privateLodash.asyncLoadText(url2);
    return privateLodash.parseContent(data9);
  },
  doNothing: (...args2) => {
    var _a2;
    if (localStorage.isShowDevLog) {
      const e2 = new Error();
      console.log("\u{1F680}:", (_a2 = e2 == null ? void 0 : e2.stack) == null ? void 0 : _a2.split("\n")[2].replace("    at ", ""));
      console.log.apply(console, args2);
    }
  },
  sleep: (t2) => new Promise((r2) => setTimeout(r2, t2)),
  isOn: (key2) => onRE.test(key2),
  isModelListener: (key2) => {
    key2 = String(key2);
    if (!key2) {
      return false;
    }
    return key2.startsWith("onUpdate:");
  },
  isListener: (key2) => {
    key2 = String(key2);
    if (!key2) {
      return false;
    }
    return privateLodash.isOn(key2) || privateLodash.isModelListener(key2);
  },
  isArrayFill: (arr) => {
    if (Array.isArray(arr)) {
      if (arr.length > 0) {
        return true;
      }
    }
    return false;
  },
  isObjectFill: (obj) => _.isPlainObject(obj) && Object.keys(obj).length > 0,
  safeFirst: (arr, fnCheck) => {
    fnCheck = fnCheck || ((value) => privateLodash.isInput(value));
    const obj = _.first(arr);
    return fnCheck(obj) ? obj : false;
  },
  safeToString: (val, isBeautiful = false) => {
    try {
      if (isBeautiful) {
        return JSON.stringify(val, null, 2);
      } else {
        return JSON.stringify(val);
      }
    } catch (error) {
      return "";
    }
  },
  safeParse: (val, defaultObj) => {
    let obj = defaultObj;
    try {
      obj = JSON.parse(val);
      if (!val) {
        obj = defaultObj;
        throw new Error("json parse error");
      }
    } catch (error) {
      privateLodash.doNothing(error);
    }
    return obj;
  },
  safeSplit: (target, sp = "") => {
    return (target == null ? void 0 : target.split) ? target.split(sp) : [];
  },
  safeDate: (val) => {
    if (!val) {
      return "";
    }
    let date4 = dayjs(val);
    if (date4 === privateLodash.WORDS.INVALID_DATE) {
      return "";
    } else {
      return date4;
    }
  },
  isInput: (val) => {
    if (val === void 0) {
      return false;
    }
    try {
      val = JSON.parse(JSON.stringify(val));
    } catch (error) {
      console.log(val, "JSON.parse failed");
    }
    if (val === 0) {
      return true;
    }
    if (val === false) {
      return true;
    }
    if (_.isArray(val)) {
      return val.length > 0;
    } else if (val) {
      return true;
    }
    return false;
  },
  is$Selected: ($ele) => $ele && $ele.jquery && $ele.length > 0,
  getObjectFirstKeyValue: (obj, defaultValue) => {
    if (!obj) {
      return defaultValue;
    }
    const keyArray = Object.keys(obj);
    if (!privateLodash.isArrayFill(keyArray))
      return defaultValue;
    const prop = keyArray[0];
    return privateLodash.isInput(prop) && obj[prop] ? obj[prop] : defaultValue;
  },
  loadCss(cssname) {
    const cssPath = `${cssname}`;
    let $link = $$1("<link/>", { rel: "stylesheet", type: "text/css" });
    $link.appendTo($$1("head"));
    $link[0].href = `${cssPath}?_t=${Date.now()}`;
    return () => {
      $link.remove();
      $link = null;
    };
  },
  async asyncLoadStyle(cssURL, options) {
    let { isReplace, id } = options || { isReplace: false, id: "" };
    id = id || _.camelCase(cssURL);
    let content;
    let $style = $$1(`#${id}`);
    if ($style.length == 0) {
      $style = $$1("<style/>", { id });
      $$1("body").append($style);
      content = await privateLodash.asyncLoadText(cssURL);
      $style.html(content);
    } else if (isReplace) {
      content = await privateLodash.asyncLoadText(cssURL);
      $style.html(content);
    }
  },
  asyncLoadText: async function(url2) {
    if (!State_UI.isDev) {
      const res = await iStorage(url2);
      if (res) {
        return res;
      }
    }
    return new Promise(
      (resolve2, reject) => $$1.ajax({
        type: "GET",
        async: true,
        url: url2,
        dataType: "text",
        success(...args2) {
          if (!State_UI.isDev) {
            iStorage(url2, args2[0]);
          }
          resolve2.apply(null, args2);
        },
        error: reject
      })
    );
  },
  asyncLoadJS: async (url2, globalName) => {
    if (window[globalName]) {
      return window[globalName];
    }
    const $style = $$1("<style/>").attr("id", `asyncLoadJS_${globalName}`);
    $style.appendTo($$1("body")).on("load", function() {
      return window[globalName];
    });
    $style.attr("src", url2);
  },
  asyncGlobalJS: async (globalName, url2) => {
    if (window[globalName]) {
      return window[globalName];
    }
    if (!url2) {
      alert("asyncGlobalJS miss url " + globalName);
      return {};
    }
    const jsString = await privateLodash.asyncLoadText(url2);
    const fn = new Function(`with(window){${jsString}}`);
    fn();
    return window[globalName];
  },
  ensureValueDone: async (fnGetValue) => {
    return new Promise(async (resolve2) => {
      let exeFnGetValue = async function() {
        const value = await fnGetValue();
        if (value) {
          exeFnGetValue = null;
          resolve2(value);
        } else {
          setTimeout(exeFnGetValue, 1e3 * exeFnGetValue.count++);
        }
      };
      exeFnGetValue.count = 1;
      exeFnGetValue();
    });
  },
  genProp: (someString) => {
    return `k${_.camelCase(someString)}`;
  },
  dateFormat: (date4, format5 = "YYYY-MM-DD") => {
    if (typeof date4 === "number") {
      date4 = dayjs.unix(date4);
    }
    if (format5 === 1) {
      format5 = "YYYY-MM-DD HH:mm:ss";
    }
    const label = dayjs(date4).format(format5);
    return label === privateLodash.WORDS.INVALID_DATE ? "--" : label;
  },
  keepDecimals: function(val, fractionDigits) {
    let num = Number(val * 100 / 1024 / 100).toFixed(fractionDigits);
    if (num === "NaN") {
      num = "-";
    }
    return num;
  },
  valueToLabel: function(value, options) {
    const target = _.find(options, {
      value
    });
    if (target) {
      return target.label;
    } else {
      return "--";
    }
  },
  timego: function(timestamp) {
    let minutes, hours, days, seconds, mouth, year;
    const timeNow = parseInt(new Date().getTime() / 1e3);
    seconds = timeNow - timestamp;
    if (seconds > 86400 * 30 * 12) {
      year = parseInt(seconds / (86400 * 30 * 12));
    } else {
      year = 0;
    }
    if (seconds > 86400 * 30) {
      mouth = parseInt(seconds / (86400 * 30));
    } else {
      mouth = 0;
    }
    if (seconds > 86400) {
      days = parseInt(seconds / 86400);
    } else {
      days = 0;
    }
    if (seconds > 3600) {
      hours = parseInt(seconds / 3600);
    } else {
      hours = 0;
    }
    minutes = parseInt(seconds / 60);
    if (year > 0) {
      return year + "\u5E74\u524D";
    } else if (mouth > 0 && year <= 0) {
      return mouth + "\u6708\u524D";
    } else if (days > 0 && mouth <= 0) {
      return days + "\u5929\u524D";
    } else if (days <= 0 && hours > 0) {
      return hours + "\u5C0F\u65F6\u524D";
    } else if (hours <= 0 && minutes > 0) {
      return minutes + "\u5206\u949F\u524D";
    } else if (minutes <= 0 && seconds > 0) {
      if (seconds < 30) {
        return "\u521A\u521A";
      } else {
        return seconds + "\u79D2\u524D";
      }
    } else {
      return "\u521A\u521A";
    }
  },
  htmlFilter: (html2) => {
    if (!html2)
      return;
    let reg = /<\/?.+?\/?>/g;
    return html2.replace(reg, "") || "";
  },
  MutatingProps: (item, prop, val = null, isDelete = false) => {
    item = item || {};
    if (/^\./.test(prop)) {
      prop = String(prop).substring(1);
    }
    const propArray = prop.split(".");
    let key2 = "";
    let nextItem = item;
    const setVal = () => {
      while (key2 = propArray.shift()) {
        if (!key2) {
          debugger;
        }
        if (propArray.length === 0) {
          if (val === "never" && isDelete) {
            delete nextItem[key2];
          } else {
            nextItem[key2] = val;
          }
          return;
        } else {
          const _nextItem = nextItem[key2];
          if (!_nextItem) {
            nextItem[key2] = {};
          }
          nextItem = nextItem[key2];
        }
      }
    };
    const getVal = () => {
      while (key2 = propArray.shift()) {
        const _nextItem = nextItem[key2];
        if (!_nextItem) {
          return nextItem[key2];
        } else {
          if (propArray.length === 0) {
            return _nextItem;
          } else {
            nextItem = nextItem[key2];
          }
        }
      }
      return nextItem;
    };
    if (val || _.isString(val) || _.isBoolean(val) || _.isNumber(val) && !_.isNaN(val)) {
      setVal();
    } else {
      return getVal();
    }
    return item;
  }
};
const xU = new Proxy(
  function(...args2) {
    if (State_UI.isDev) {
      try {
        throw new Error("");
      } catch (error) {
        args2.unshift(String(error.stack).split("\n")[2], "\n");
        console.log.apply(console, args2);
      }
    }
  },
  {
    get(fn, prop) {
      if (privateLodash[prop]) {
        return privateLodash[prop];
      }
      if (_[prop]) {
        return _[prop];
      }
      return fn[prop];
    },
    set(fn, prop, val) {
      privateLodash[prop] = val;
      return true;
    }
  }
);
function promisifyRequest(request2) {
  return new Promise((resolve2, reject) => {
    request2.oncomplete = request2.onsuccess = () => resolve2(request2.result);
    request2.onabort = request2.onerror = () => reject(request2.error);
  });
}
function createStore(dbName, storeName) {
  const request2 = indexedDB.open(dbName);
  request2.onupgradeneeded = () => request2.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request2);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get$2(key2, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
}
function set(key2, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key2);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
const lStorage = new Proxy(localStorage, {
  set(_localStorage, prop, value) {
    if (xU.isPlainObject(value)) {
      _localStorage[prop] = JSON.stringify(value);
    } else {
      _localStorage[prop] = value;
    }
    return true;
  },
  get(_localStorage, prop) {
    const objString = _localStorage[prop];
    try {
      return JSON.parse(objString);
    } catch (error) {
      if (objString === "undefined") {
        return false;
      }
      return objString || false;
    }
  }
});
if (String(window.__APP_VERSION) !== String(lStorage.__APP_VERSION)) {
  clear();
  lStorage.__APP_VERSION = window.__APP_VERSION || Date.now();
}
lStorage.appConfigs = lStorage.appConfigs || {
  pagination: {
    page: "page",
    size: "size",
    total: "total"
  }
};
const iStorage = async function(key2, val) {
  const keyPrefix = window.location.hostname;
  key2 = xU.camelCase(keyPrefix + key2);
  let res;
  try {
    if (xU.isInput(val)) {
      await set(key2, String(val));
      res = true;
    } else {
      res = await get$2(key2);
      if (!res) {
        console.log("get", key2, res);
      }
    }
  } catch (error) {
    console.error(error);
  } finally {
    return res;
  }
};
iStorage.clear = clear;
function $t$9(prop, payload = {}, i18nMessage = false) {
  const result = {
    label: prop,
    prop
  };
  xU.templateSettings.interpolate = /{([\s\S]+?)}/g;
  if (State_UI.i18nMessage) {
    const temp = i18nMessage ? i18nMessage[prop] : State_UI.i18nMessage[prop];
    if (temp) {
      result.label = xU.template(temp)(payload);
      if (!result.label) {
        result.label = prop;
        console.error(`i18n:${prop} "NOT_FOUND"`);
      }
    }
  }
  return result;
}
let _State_UI = {
  language: lStorage["language"] || "zh-CN",
  onLanguageChange: false,
  LANGUAGE: {
    enUs: defaultLocale,
    zhCn: zhCn$1
  },
  i18nMessage: {},
  assetsSvgPath: "",
  assetsPath: "",
  bashPath: "",
  setAssetsBaseById(eleId) {
    var _a2;
    const img = document.getElementById(eleId);
    if (img) {
      const src2 = String(img.href);
      const index2 = ((_a2 = src2.match(/assets(.*)/)) == null ? void 0 : _a2.index) || 0;
      this.assetsSvgPath = src2.substring(0, index2) + "assets/svg";
      this.assetsPath = src2.substring(0, index2) + "assets";
      this.bashPath = src2.substring(0, index2);
    }
  },
  $t: $t$9,
  isDev: localStorage.___VENTOSE_UI_IS_DEV_MODE === "VENTOSE_UI_IS_DEV_MODE",
  dev(isDev) {
    if (isDev) {
      localStorage.___VENTOSE_UI_IS_DEV_MODE = "VENTOSE_UI_IS_DEV_MODE";
    } else {
      localStorage.removeItem("___VENTOSE_UI_IS_DEV_MODE");
    }
  }
};
const State_UI = reactive(_State_UI);
watch(() => State_UI.language, (language) => {
  lStorage["language"] = language;
  dayjs.locale(language === "zh-CN" ? "zh-cn" : "en");
  if (State_UI.onLanguageChange) {
    State_UI.onLanguageChange(language, State_UI);
  }
}, {
  immediate: true
});
const Cpt_UI_locale = computed(() => {
  const currentLanguage = xU.camelCase(State_UI.language);
  const locale2 = State_UI.LANGUAGE[currentLanguage];
  return locale2;
});
const DatePicker = ({
  properties,
  slots,
  listeners
}) => {
  let value = "";
  if (properties.value) {
    value = dayjs(properties.value);
    xU.doNothing(value, properties.value);
    if (value === "Invalid Date") {
      xU.doNothing("properties.value", properties.value);
      value = "";
    }
  }
  return createVNode(DatePicker$3, mergeProps(properties, listeners, {
    "value": value,
    "locale": Cpt_UI_locale.value.DatePicker
  }), slots);
};
const RangePicker = ({
  properties,
  slots,
  listeners
}) => {
  const RangePicker2 = resolveComponent("aRangePicker");
  console.log("properties", properties.value);
  return createVNode(RangePicker2, mergeProps(properties, listeners, {
    "locale": Cpt_UI_locale.value.DatePicker
  }), slots);
};
const Checkbox = defineComponent({
  props: ["properties", "slots", "listeners", "propsWillDeleteFromConfigs"],
  computed: {
    checked: {
      get() {
        var _a2;
        return ((_a2 = this.properties) == null ? void 0 : _a2.value) || false;
      },
      set(val) {
        this.listeners["onUpdate:value"](val);
      }
    }
  },
  render(vm) {
    const _properties = xU.omit(this.properties, [...this.propsWillDeleteFromConfigs]);
    return createVNode(resolveComponent("aCheckbox"), mergeProps({
      "checked": this.checked,
      "onUpdate:checked": ($event) => this.checked = $event
    }, this.listeners, _properties), this.slots);
  }
});
const Select = ({
  properties,
  slots,
  listeners,
  propsWillDeleteFromConfigs
}) => {
  const _property = xU.omit(properties, [...propsWillDeleteFromConfigs, "options", "renderOptions"]);
  const renderOptions = () => {
    if (properties.renderOptions) {
      return properties.renderOptions();
    } else {
      return xU.map(properties.options, (option) => {
        return createVNode(resolveComponent("aSelectOption"), {
          "value": option.value
        }, {
          default: () => [option.label]
        });
      });
    }
  };
  return createVNode(resolveComponent("aSelect"), mergeProps(listeners, _property), {
    default: renderOptions
  });
};
const RadioGroup = ({
  properties,
  slots,
  listeners,
  propsWillDeleteFromConfigs
}) => {
  const Radio2 = resolveComponent("aRadio");
  const RadioGroup2 = resolveComponent("aRadioGroup");
  const RadioButton = resolveComponent("aRadioButton");
  const PROPERTY_OPTIONS = properties.options;
  const componentPropertyOmitOptions = xU.omit(properties, ["options"]);
  const renderOptions = () => {
    if (properties.isButton) {
      return xU.map(PROPERTY_OPTIONS, (option) => {
        return createVNode(RadioButton, {
          "value": option.value
        }, {
          default: () => [option.label]
        });
      });
    }
    return xU.map(PROPERTY_OPTIONS, (option) => {
      return createVNode(Radio2, {
        "value": option.value
      }, {
        default: () => [option.label]
      });
    });
  };
  return createVNode(RadioGroup2, mergeProps(componentPropertyOmitOptions, listeners), {
    default: renderOptions
  });
};
const CheckboxGroup = ({
  properties,
  slots,
  listeners
}) => {
  return createVNode(resolveComponent("aCheckboxGroup"), mergeProps(properties, listeners), slots);
};
const Switch = ({
  properties,
  slots,
  listeners,
  propsWillDeleteFromConfigs
}) => {
  const _property = xU.merge({}, properties, {
    checked: properties.value,
    onClick() {
      listeners["onUpdate:value"](!_property.value);
    }
  });
  return createVNode("div", {
    "class": "x-item_switch"
  }, [createVNode(resolveComponent("aSwitch"), xU.omit(_property, ["value"]), null)]);
};
const itemRenders = {
  Input,
  Checkbox,
  Select,
  Switch,
  DatePicker,
  RangePicker,
  RadioGroup,
  CheckboxGroup
};
const getValueNeedVarigy = ({
  value,
  xItemConfigs
}) => {
  if (value !== void 0) {
    return value;
  } else if (xItemConfigs.modelValue !== void 0) {
    return xItemConfigs.modelValue;
  } else if (xItemConfigs.value !== void 0) {
    return xItemConfigs.value;
  } else {
    const error = new Error("miss value");
    console.error(error);
    return xItemConfigs.defaultValue;
  }
};
const EVENT_TYPE = {
  validateForm: "validateForm",
  update: "update",
  change: "change",
  input: "input",
  blur: "blur",
  focus: "focus"
};
const TIPS_TYPE = {
  success: "success",
  error: "error"
};
async function validateForm(configsForm, valuesCollection) {
  let propsArray = Object.keys(configsForm);
  if (valuesCollection) {
    propsArray = Object.keys(valuesCollection);
  }
  return Promise.all(xU.map(propsArray, (prop) => {
    const configs = configsForm[prop];
    const valueNeedVarify = getValueNeedVarigy({
      value: valuesCollection && valuesCollection[prop],
      xItemConfigs: configs
    });
    return new Promise((resolve2) => {
      try {
        (() => {
          const isFalse = !configs.isShow;
          if (isFalse) {
            return resolve2("");
          }
          const isResFalse = xU.isFunction(configs.isShow) && !configs.isShow();
          if (isResFalse) {
            return resolve2("");
          }
        })();
        if (configs.validate) {
          configs.__onAfterValidate = markRaw(function(result) {
            delete configs.__onAfterValidate;
            resolve2(result);
          });
          configs.validate(EVENT_TYPE.validateForm, valueNeedVarify);
        } else {
          resolve2("");
        }
      } catch (error) {
        console.error(error);
      }
    });
  })).then((results) => {
    results = results.filter((res) => res && res[0] && res[1]);
    return results;
  }).catch((error) => {
    return error;
  });
}
const AllWasWell = (res) => {
  return xU.isArray(res) && res.length === 0;
};
const checkXItem = async ({
  xItemConfigs,
  fnCheckedCallback,
  value,
  FormItemId
}) => {
  const valueNeedVarify = getValueNeedVarigy({
    value,
    xItemConfigs
  });
  xItemConfigs.checking = true;
  fnCheckedCallback = fnCheckedCallback || xU.doNothing;
  FormItemId = FormItemId || xItemConfigs.FormItemId;
  let result;
  try {
    const {
      rules: rules2,
      prop
    } = xItemConfigs;
    result = await (async () => {
      let dontCheck = 0;
      for (const element of rules2) {
        const rule = element;
        const trigger2 = rule.trigger || [];
        let isFail = await (async () => {
          let trigBy;
          const isNeedVerify = (() => {
            if (xItemConfigs.validate.triggerEventsObj[EVENT_TYPE.validateForm]) {
              trigBy = "validateForm";
              return true;
            }
            const isInTrigger = (eventName) => xItemConfigs.validate.triggerEventsObj[eventName];
            if (xU.some(trigger2, isInTrigger)) {
              trigBy = `triggerEvent ${trigger2.toString()}`;
              return true;
            }
            if (trigger2.includes(EVENT_TYPE.update)) {
              const updateTrigger = [EVENT_TYPE.change, EVENT_TYPE.input, EVENT_TYPE.blur];
              if (xU.some(updateTrigger, isInTrigger)) {
                trigBy = "update";
                return true;
              }
            }
            return false;
          })();
          trigBy && xU.doNothing(`%cValidate trigger off by [${trigBy}]`, "color:yellow;background:green;");
          if (isNeedVerify) {
            const currentValue = (() => {
              try {
                return JSON.parse(JSON.stringify(valueNeedVarify));
              } catch (e2) {
                return "";
              }
            })();
            const validateResult = await rule.validator(currentValue, {
              configs: xItemConfigs,
              rule
            });
            if (validateResult) {
              return validateResult;
            }
          } else {
            dontCheck++;
          }
          return false;
        })();
        if (isFail) {
          return [prop, rule.msg, FormItemId];
        }
      }
      if (dontCheck === rules2.length) {
        return [false, false];
      } else {
        return [prop, false];
      }
    })();
    fnCheckedCallback(result);
  } catch (error) {
    console.error(error);
  } finally {
    if (xU.isFunction(xItemConfigs.__onAfterValidate)) {
      xItemConfigs.__onAfterValidate.call(xItemConfigs, result);
    }
    xItemConfigs.validate.triggerEventsObj = {};
    return result;
  }
};
const {
  MutatingProps
} = xU;
const domClass = {
  tipsError: "ant-form-item-explain ant-form-item-explain-error"
};
const xItem$1 = defineComponent({
  name: "XItem",
  props: {
    modelValue: {
      type: [Object, String, Number, Boolean],
      default: void 0
    },
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  emits: ["update:modelValue"],
  setup(props3, {
    attrs,
    slots,
    emit,
    expose
  }) {
    let Cpt_isShowXItem = true;
    let Cpt_isDisabled = false;
    if (xU.isFunction(props3.configs.isShow)) {
      Cpt_isShowXItem = computed(props3.configs.isShow);
    } else if (xU.isBoolean(props3.configs.isShow)) {
      Cpt_isShowXItem = computed(() => props3.configs.isShow);
    } else {
      props3.configs.isShow = true;
      Cpt_isShowXItem = computed(() => props3.configs.isShow);
    }
    if (xU.isFunction(props3.configs.disabled)) {
      Cpt_isDisabled = computed(props3.configs.disabled);
    } else if (xU.isBoolean(props3.configs.disabled)) {
      Cpt_isDisabled = computed(() => props3.configs.disabled);
    }
    const {
      listeners,
      propsWillDeleteFromConfigs
    } = (() => {
      const {
        configs
      } = props3;
      const propsSet = /* @__PURE__ */ new Set();
      const triggerValidate = (eventType) => {
        configs.validate && configs.validate(eventType);
      };
      const listeners2 = {
        "onUpdate:value": (val) => {
          if (configs.value !== void 0) {
            if (configs.modelValue === val) {
              return;
            } else {
              configs.value = val;
            }
          }
          configs.modelValue = val;
          emit("update:modelValue", val);
          if (xU.isFunction(listeners2.onAfterValueEmit)) {
            listeners2.onAfterValueEmit(val);
          }
          triggerValidate(EVENT_TYPE.update);
        },
        onChange: () => {
          triggerValidate(EVENT_TYPE.change);
        },
        onInput: () => {
          triggerValidate(EVENT_TYPE.input);
        },
        onBlur: () => {
          triggerValidate(EVENT_TYPE.blur);
        },
        onFocus: () => {
          triggerValidate(EVENT_TYPE.focus);
        }
      };
      function makeEventHandlerSupportMultiple(prop, xItemInnerEventHandler) {
        propsSet.add(prop);
        if (typeof listeners2[prop] === "object" && xU.isArray(listeners2[prop].handlerArray)) {
          listeners2[prop].handlerArray.push(xItemInnerEventHandler);
        } else {
          listeners2[prop] = (...args2) => {
            xU.each(listeners2[prop].handlerArray, (listener) => {
              listener == null ? void 0 : listener.apply(configs, args2);
            });
          };
          listeners2[prop].handlerArray = [xItemInnerEventHandler];
        }
      }
      xU.each(listeners2, (value, prop) => makeEventHandlerSupportMultiple(prop, value));
      xU.each(configs, (value, prop) => {
        if (xU.isListener(prop)) {
          makeEventHandlerSupportMultiple(prop, value);
        }
      });
      xU.each(attrs, (value, prop) => {
        if (xU.isListener(prop)) {
          makeEventHandlerSupportMultiple(prop, value);
        }
      });
      return {
        listeners: listeners2,
        propsWillDeleteFromConfigs: [...propsSet]
      };
    })();
    return {
      Cpt_isShowXItem,
      Cpt_isDisabled,
      listeners,
      propsWillDeleteFromConfigs
    };
  },
  data() {
    return {
      isRequired: false,
      properties: {},
      itemSlots: {}
    };
  },
  computed: {
    itemTypeName() {
      if (xU.isString(this.configs.itemType)) {
        return String(this.configs.itemType);
      }
      return "";
    },
    isChecking() {
      return Boolean(this.configs.checking);
    },
    FormItemId() {
      return `xItem_${this._.uid}`;
    },
    itemTips() {
      var _a2, _b;
      const _itemTips = {
        type: "",
        msg: ""
      };
      if ((_b = (_a2 = this.configs) == null ? void 0 : _a2.itemTips) == null ? void 0 : _b.type) {
        return {
          type: this.configs.itemTips.type,
          msg: xU.isFunction(this.configs.itemTips.msg) ? this.configs.itemTips.msg() : this.configs.itemTips.msg
        };
      } else {
        this.configs.itemTips = _itemTips;
        return _itemTips;
      }
    },
    itemWrapperClass() {
      return [
        this.configs.itemWrapperClass,
        "ant-form-item ant-form-item-with-help x-item flex",
        this.itemTips.type === TIPS_TYPE.error ? "ant-form-item-has-error" : ""
      ].join(" ");
    },
    tipsVNode() {
      if (this.isChecking) {
        return createVNode("div", null, [createVNode("div", {
          "data-type": "checking"
        }, [createTextVNode("checking...")])]);
      }
      if (this.configs.tipsVNodeRender) {
        return this.configs.tipsVNodeRender({
          xItem: this,
          configs: this.configs,
          itemTips: this.itemTips
        });
      }
      if (this.itemTips.msg) {
        if (this.itemTips.type === TIPS_TYPE.error) {
          return createVNode("div", {
            "class": domClass.tipsError
          }, [createVNode("div", {
            "data-type": "error"
          }, [this.itemTips.msg])]);
        }
      }
      return null;
    },
    labelVNode() {
      const classString = this.isRequired ? "ant-form-item-required" : "";
      if (this.configs.labelVNodeRender) {
        return this.configs.labelVNodeRender(this.configs, classString);
      }
      let label = (() => {
        const _label = this.configs.label;
        if (_label) {
          if (xU.isFunction(_label)) {
            return _label();
          }
          if (xU.isString(_label) || _label.__v_isVNode) {
            return _label;
          }
        }
        return false;
      })();
      if (label === false) {
        return null;
      }
      return createVNode("div", {
        "class": "ant-form-item-label"
      }, [createVNode("label", {
        "for": this.configs.prop,
        "class": classString
      }, [label])]);
    }
  },
  watch: {
    configs: {
      handler(configs, oldConfigs) {
        this.setProperties();
      }
    },
    $attrs: {
      handler() {
        this.setProperties();
      }
    },
    "configs.value": {
      handler() {
        this.updateValue();
      }
    },
    modelValue: {
      handler() {
        this.updateValue();
      }
    },
    "configs.rules": {
      immediate: true,
      handler(rules2) {
        if (rules2) {
          this.setValidateInfo(rules2);
        }
      }
    },
    "configs.slots": {
      immediate: true,
      handler(slots) {
        if (slots) {
          this.setItemSlots();
        }
      }
    }
  },
  created() {
    const vm = this;
    vm.configs.FormItemId = vm.FormItemId;
    (() => {
      vm.updateValue = xU.debounce(function() {
        const value = (() => {
          if (vm.modelValue !== void 0) {
            return vm.modelValue;
          }
          if (vm.configs.value == void 0) {
            if (vm.configs.defaultValue !== void 0) {
              return vm.configs.defaultValue;
            } else {
              xU("either configs.value or modelValue");
            }
          }
          return vm.configs.value;
        })();
        if (vm.properties.value !== value) {
          vm.properties.value = value;
          vm.listeners["onUpdate:value"](value);
        }
      }, 32);
      vm.updateValue();
    })();
    (() => {
      vm.setProperties = xU.debounce(function() {
        xU("setProperties", vm._.uid);
        const __properties = {};
        const pickProps = (originConfigs) => {
          xU.each(originConfigs, (item, prop) => {
            if (["placeholder"].includes(prop) && xU.isFunction(item)) {
              __properties[prop] = item(this);
              return;
            }
            if (["itemTips", "rules", "labelVNodeRender", "slots"].includes(prop)) {
              return;
            }
            __properties[prop] = item;
          });
        };
        xU.each([this.configs, this.$attrs], pickProps);
        this.properties = __properties;
        this.updateValue();
      }, 32);
      vm.setProperties();
    })();
  },
  mounted() {
    var _a2;
    if ((_a2 = this.configs) == null ? void 0 : _a2.once) {
      this.configs.once.call(this.configs, this);
    }
  },
  methods: {
    setTips(type4 = "", msg = "") {
      MutatingProps(this, "configs.itemTips", {
        type: type4,
        msg
      });
    },
    setItemSlots() {
      this.itemSlots = this.configs.slots || {};
    },
    setValidateInfo(rules2) {
      let isRequired2 = false;
      if (xU.isArrayFill(rules2)) {
        isRequired2 = xU.some(rules2, {
          name: "required"
        });
        const fnCheckedCallback = ([prop, msg]) => {
          MutatingProps(this, "configs.checking", false);
          if (prop) {
            if (msg) {
              this.setTips(TIPS_TYPE.error, msg);
              if (xU.isFunction(this.configs.onValidateFail)) {
                this.configs.onValidateFail(this.configs);
              }
            } else {
              this.setTips();
            }
          }
        };
        const debounceCheckXItem = xU.debounce(checkXItem, 300);
        const fnConfigsValidate = (eventType, value) => {
          const prop = `configs.validate.triggerEventsObj.${eventType}`;
          MutatingProps(this, prop, true);
          debounceCheckXItem({
            FormItemId: this.FormItemId,
            xItemConfigs: this.configs,
            fnCheckedCallback,
            value
          });
        };
        MutatingProps(this, "configs.validate", fnConfigsValidate);
        MutatingProps(this, "configs.validate.triggerEventsObj", {});
      } else {
        if (xU.isFunction(this.configs.validate)) {
          delete this.configs.validate;
        }
      }
      this.isRequired = isRequired2;
    }
  },
  render(h2) {
    if (!this.Cpt_isShowXItem || !this.properties) {
      return null;
    }
    const CurrentXItem = (() => {
      if (xU.isObject(this.configs.itemType)) {
        return this.configs.itemType;
      }
      return itemRenders[this.configs.itemType] || itemRenders.Input;
    })();
    return createVNode("div", {
      "id": this.FormItemId,
      "class": this.itemWrapperClass
    }, [this.labelVNode, createVNode("div", {
      "class": "ant-form-item-control",
      "type": this.itemTypeName
    }, [createVNode(CurrentXItem, {
      "propsWillDeleteFromConfigs": this.propsWillDeleteFromConfigs,
      "properties": {
        ...this.properties,
        disabled: this.Cpt_isDisabled
      },
      "listeners": this.listeners,
      "slots": this.itemSlots
    }, null), this.tipsVNode]), this.$slots.afterControll && this.$slots.afterControll()]);
  }
});
const _sfc_main$d = defineComponent({
  name: "xForm",
  props: {
    col: {
      type: Number,
      default: 1
    },
    labelStyle: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  emits: [],
  data() {
    return {};
  },
  computed: {
    xFormId() {
      return `xForm_${this._.uid}`;
    },
    labelStyleText() {
      return xU.map(xU.merge({
        width: "120px",
        "text-align": "right"
      }, this.labelStyle), (value, prop) => `${prop}: ${value}`).join(";");
    },
    styleContent() {
      return [`#${this.xFormId} { width:100%; padding:0 16px; display: grid;grid-template-columns: repeat(${this.col},1fr);}`, `#${this.xFormId} div.ant-form-item-label { ${this.labelStyleText} }`].join("\n");
    }
  },
  mounted() {
    const $form = $$1(`#${this.xFormId}`);
    const $style = $$1("<style/>", {
      id: `style_${this.xFormId}`
    }).append(this.styleContent);
    $form.prepend($style);
  },
  watch: {
    styleContent() {
      this.updateStyle(this.styleContent);
    }
  },
  methods: {
    updateStyle(styleContent) {
      const $style = $$1(`#style_${this.xFormId}`);
      $style.html(styleContent);
    }
  }
});
const _export_sfc = (sfc, props3) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props3) {
    target[key2] = val;
  }
  return target;
};
const _hoisted_1$g = ["id"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", { id: _ctx.xFormId }, [
    renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$g);
}
const xForm = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$b]]);
const BTN_PRESET_MAP = {
  query: () => ({
    icon: createVNode(resolveComponent("xIcon"), {
      "class": "x-button_icon-wrapper",
      "icon": "InsideSearchOutlined"
    }, null),
    text: State_UI.$t("\u67E5\u8BE2").label
  }),
  refresh: () => ({
    icon: createVNode(resolveComponent("xIcon"), {
      "class": "x-button_icon-wrapper",
      "icon": "InsideSyncOutlined"
    }, null),
    text: State_UI.$t("\u5237\u65B0").label
  }),
  cancel: () => ({
    text: State_UI.$t("\u53D6\u6D88").label
  }),
  save: () => ({
    icon: createVNode(resolveComponent("xIcon"), {
      "class": "x-button_icon-wrapper",
      "icon": "InsideSaveOutlined"
    }, null),
    text: State_UI.$t("\u4FDD\u5B58").label
  }),
  upload: () => ({
    icon: createVNode(resolveComponent("xIcon"), {
      "class": "x-button_icon-wrapper",
      "icon": "InsideUploadOutlined"
    }, null),
    text: State_UI.$t("\u4E0A\u4F20").label
  }),
  delete: (configs) => {
    configs.type = "danger";
    configs.ghost = true;
    return {
      icon: createVNode(resolveComponent("xIcon"), {
        "class": "x-button_icon-wrapper",
        "icon": "InsideDeleteOutlined"
      }, null),
      text: State_UI.$t("\u5220\u9664").label
    };
  }
};
const xButton = defineComponent({
  name: "xButton",
  props: {
    payload: {
      type: Object,
      default() {
        return {};
      }
    },
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  beforeMount() {
    if (!this.configs) {
      debugger;
      return;
    }
    const presetFn = BTN_PRESET_MAP[this.configs.preset];
    if (presetFn) {
      const preset = presetFn(this.configs);
      this.configs.text = createVNode(Fragment, null, [preset.icon, createVNode("span", {
        "class": "ml4"
      }, [preset.text])]);
    }
  },
  data() {
    return {
      loading: true
    };
  },
  computed: {
    isClickHandlerOnAttrs() {
      var _a2;
      return !!((_a2 = this.$attrs) == null ? void 0 : _a2.onClick);
    },
    type() {
      if (["query", "save"].includes(this.configs.preset)) {
        return "primary";
      }
      return this.configs.type;
    },
    title() {
      if (xU.isString(this.disabled) && this.disabled.length > 0) {
        return this.disabled;
      }
      if (xU.isString(this.configs.title) && this.configs.title.length > 0) {
        return this.configs.title;
      }
      return false;
    },
    disabled() {
      if (xU.isBoolean(this.configs.disabled)) {
        return this.configs.disabled;
      }
      if (xU.isFunction(this.configs.disabled)) {
        return this.configs.disabled(this);
      }
      return false;
    },
    text() {
      if (xU.isFunction(this.configs.text)) {
        return this.configs.text(this) || "";
      }
      return this.configs.text || "";
    }
  },
  watch: {
    configs: {
      immediate: true,
      handler(configs) {
        this.loading = !!configs.loading;
      }
    }
  },
  created() {
  },
  methods: {
    async handleButtonClick() {
      var _a2, _b;
      if (xU.isFunction((_a2 = this == null ? void 0 : this.configs) == null ? void 0 : _a2.onClick)) {
        this.loading = true;
        try {
          await ((_b = this == null ? void 0 : this.configs) == null ? void 0 : _b.onClick.call(this.configs, this));
        } catch (e2) {
          console.error(e2);
        } finally {
          this.loading = false;
        }
      }
    }
  },
  render() {
    const propsWillDeleteFromProperty = ["text", "loading", "disabled", "title", "onClick"];
    const _properties = xU.omit(this.configs, propsWillDeleteFromProperty);
    if (!this.isClickHandlerOnAttrs) {
      _properties.onClick = this.handleButtonClick;
    }
    if (this.title) {
      _properties.title = this.title;
    }
    return createVNode(resolveComponent("aButton"), mergeProps({
      "class": "x-button antdv-button",
      "loading": this.loading,
      "disabled": !!this.disabled,
      "type": this.type
    }, _properties), {
      default: () => {
        const vDomDefautl = this.$slots.default && this.$slots.default();
        return createVNode(Fragment, null, [this.text, vDomDefautl]);
      }
    });
  }
});
const _sfc_main$c = defineComponent({
  name: "XButtonCountDown",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    const vm = this;
    return {
      state: {
        captchaCount: 0
      },
      btnConfigs: {
        disabled: false,
        size: "large",
        style: {
          minWidth: "112px"
        },
        class: "center",
        text: vm.configs.text.normal,
        async onClick() {
          if (xU.isFunction(vm.configs.onClick)) {
            await vm.configs.onClick({
              countDown: vm.countDown
            });
          }
        }
      }
    };
  },
  watch: {
    "state.captchaCount"(captchaCount) {
      this.handleCaptchaCountChange(captchaCount);
    }
  },
  methods: {
    countDown() {
      this.state.captchaCount++;
      if (this.state.captchaCount <= this.configs.countMax) {
        setTimeout(this.countDown, 1e3);
      } else {
        this.state.captchaCount = 0;
      }
    },
    handleCaptchaCountChange(captchaCount) {
      if (captchaCount === 0) {
        this.btnConfigs.text = this.configs.text.normal;
        this.btnConfigs.disabled = false;
        return;
      }
      const setCounDownText = () => {
        return this.btnConfigs.text = `${this.configs.countMax - captchaCount} s`;
      };
      if (captchaCount === 1) {
        setCounDownText();
        this.btnConfigs.disabled = true;
        return;
      }
      if (captchaCount && captchaCount <= this.configs.countMax) {
        setCounDownText();
        return;
      }
    }
  }
});
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xButton = resolveComponent("xButton");
  return openBlock(), createBlock(_component_xButton, { configs: _ctx.btnConfigs }, null, 8, ["configs"]);
}
const xButtonCountDown = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$a]]);
const xGap = defineComponent({
  name: "xGap",
  props: ["t", "l", "r", "b", "a", "f"],
  computed: {
    gapClass: {
      get() {
        let basic = "x-gap";
        if (this.f) {
          basic += ` flex${this.f}`;
        }
        return basic;
      }
    },
    gapStyle: {
      get() {
        const POSITION_MAP = {
          t: "top",
          r: "right",
          b: "bottom",
          l: "left"
        };
        const gapStyle = {};
        if (this.a) {
          gapStyle.margin = `${this.a}px`;
        } else {
          xU.map(POSITION_MAP, (prop, key2) => {
            const value = this[key2];
            if (value) {
              gapStyle[`margin-${prop}`] = `${value}px`;
            }
          });
        }
        return gapStyle;
      }
    }
  },
  render(h2) {
    return createVNode("div", {
      "style": this.gapStyle,
      "class": this.gapClass
    }, null);
  }
});
const line$1 = {};
const CONFIGS_MAP = {
  line: line$1
};
const _sfc_main$b = defineComponent({
  name: "xCharts",
  props: {
    payload: {
      type: Object,
      default: ""
    },
    configs: {
      type: [String, Object],
      required: true
    },
    dataset: {
      type: [Array, Object],
      default() {
        return [];
      }
    }
  },
  data() {
    const id = xU.genId("xChart");
    return {
      id
    };
  },
  computed: {
    helper() {
      if (xU.isPlainObject(this.configs)) {
        return this.configs;
      }
      return CONFIGS_MAP[this.configs];
    }
  },
  mounted() {
    this.init();
  },
  methods: {
    init() {
      this.updateOptions();
      this.observe();
    },
    updateOptions() {
      if (this.myChart) {
        this.myChart.dispose();
      }
      const options = this.helper.initOptions(this.$props);
      this.options = this.helper.updateOptions(options, this.dataset);
      const dom = document.querySelector(`#${this.id}`);
      this.myChart = this.$echarts.init(dom);
      this.myChart.showLoading();
      this.myChart.setOption(this.options);
      this.myChart.hideLoading();
    },
    observe() {
      this.resizeObserver = new ResizeObserver(() => {
        var _a2;
        if (this.myChart) {
          ((_a2 = this.myChart) == null ? void 0 : _a2.resize) && this.myChart.resize();
        }
      });
      this.resizeObserver.observe(this.$el);
    }
  }
});
const _hoisted_1$f = ["id"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: _ctx.id,
    class: "x-charts flex flex1 center middle"
  }, null, 8, _hoisted_1$f);
}
const xCharts = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$9]]);
const _sfc_main$a = defineComponent({
  name: "xView",
  props: {
    isShow: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {};
  },
  computed: {
    id() {
      return `xView_${this._.uid}`;
    }
  }
});
const _hoisted_1$e = ["id"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("div", { id: _ctx.id }, [
    renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$e)), [
    [vShow, !!_ctx.isShow]
  ]);
}
const xView = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$8]]);
const _hoisted_1$d = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", { d: "M338.261 137.045h-9.13a9.16 9.16 0 0 0 9.13-9.159v9.16h347.45v-9.16c0 5.035 4.095 9.16 9.101 9.16h-9.102v82.26h82.262v-91.42a73.216 73.216 0 0 0-73.131-73.13H329.102a73.216 73.216 0 0 0-73.159 73.13v91.45h82.29v-82.29zm576 82.29h-804.55c-20.253 0-36.58 16.327-36.58 36.551v36.58c0 5.034 4.096 9.159 9.13 9.159h69.063l28.217 597.703a73.216 73.216 0 0 0 73.046 69.689h518.826a73.045 73.045 0 0 0 73.046-69.689l28.245-597.732h69.006a9.16 9.16 0 0 0 9.16-9.102v-36.636c0-20.196-16.356-36.551-36.58-36.551zm-151.665 667.42h-501.22l-27.648-585.159H790.3l-27.676 585.16z" }, null, -1);
const _hoisted_3$a = [
  _hoisted_2$a
];
function render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$a);
}
const InsideDeleteOutlined = { name: "DeleteOutlined", render: render$9 };
const _hoisted_1$c = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", { d: "M512 628c17.6 0 32-14.4 32-32V308c0-17.6-14.4-32-32-32s-32 14.4-32 32v288c0 17.6 14.4 32 32 32zm-44 76a44 44 0 1 0 88 0 44 44 0 1 0-88 0Zm44-640C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm271.5 719.5c-35.3 35.3-76.4 63-122.1 82.3-47.3 20-97.6 30.2-149.5 30.2s-102.2-10.1-149.5-30.2c-45.7-19.3-86.8-47-122.1-82.3s-63-76.4-82.3-122.1c-20-47.3-30.2-97.6-30.2-149.5s10.1-102.2 30.2-149.5c19.3-45.7 47-86.8 82.3-122.1s76.4-63 122.1-82.3c47.3-20 97.6-30.2 149.5-30.2s102.2 10.1 149.5 30.2c45.7 19.3 86.8 47 122.1 82.3s63 76.4 82.3 122.1c20 47.3 30.2 97.6 30.2 149.5s-10.1 102.2-30.2 149.5c-19.3 45.8-47 86.8-82.3 122.1z" }, null, -1);
const _hoisted_3$9 = [
  _hoisted_2$9
];
function render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$9);
}
const InsideExclamationCircleOutlined = { name: "ExclamationCircleOutlined", render: render$8 };
const _hoisted_1$b = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", { d: "M448 128a64 64 0 1 0 128 0 64 64 0 1 0-128 0ZM257.1 180.5a61.3 61.3 0 1 0 122.6 0 61.3 61.3 0 1 0-122.6 0ZM121.8 318.4a58.7 58.7 0 1 0 117.4 0 58.7 58.7 0 1 0-117.4 0ZM72 512a56 56 0 1 0 112 0 56 56 0 1 0-112 0Zm55.2 193.6a53.3 53.3 0 1 0 106.6 0 53.3 53.3 0 1 0-106.6 0Zm140.5 137.9a50.7 50.7 0 1 0 101.4 0 50.7 50.7 0 1 0-101.4 0ZM464 896a48 48 0 1 0 96 0 48 48 0 1 0-96 0Zm196.3-52.5a45.3 45.3 0 1 0 90.6 0 45.3 45.3 0 1 0-90.6 0Zm140.5-137.9a42.7 42.7 0 1 0 85.4 0 42.7 42.7 0 1 0-85.4 0ZM856 512a40 40 0 1 0 80 0 40 40 0 1 0-80 0ZM837.9 377.7a33.8 33.8 0 1 0 67.6 0 33.8 33.8 0 1 0-67.6 0Zm-61.5-113.5a28.3 28.3 0 1 0 56.6 0 28.3 28.3 0 1 0-56.6 0ZM680 180a24 24 0 1 0 48 0 24 24 0 1 0-48 0Z" }, null, -1);
const _hoisted_3$8 = /* @__PURE__ */ createBaseVNode("animateTransform", {
  additive: "sum",
  attributeName: "transform",
  attributeType: "XML",
  begin: "0s",
  dur: "4s",
  from: "0",
  repeatCount: "indefinite",
  to: "360",
  type: "rotate"
}, null, -1);
const _hoisted_4 = [
  _hoisted_2$8,
  _hoisted_3$8
];
function render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_4);
}
const InsideLoadingOutlined = { name: "LoadingOutlined", render: render$7 };
const _hoisted_1$a = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", { d: "M144 928a48 48 0 0 1-48-48V144a48 48 0 0 1 48-48h592v.448a48 48 0 0 1 27.328 13.6l150.624 150.624A48 48 0 0 1 928 294.624V880a48 48 0 0 1-48 48H144zm144-768H160v704h128V496a48 48 0 0 1 43.392-47.776L336 448h352a48 48 0 0 1 48 48v368h128V301.248l-128-128V272a48 48 0 0 1-48 48H336a48 48 0 0 1-48-48V160zm384 352H352v352h320V512zm0-352H352v96h320v-96z" }, null, -1);
const _hoisted_3$7 = [
  _hoisted_2$7
];
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
}
const InsideSaveOutlined = { name: "SaveOutlined", render: render$6 };
const _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("path", { d: "M479.04 128c176.16 0 318.976 142.848 318.976 319.04a317.984 317.984 0 0 1-86.976 218.976l175.616 175.552c11.52 11.52 12.384 29.568 2.656 42.08l-2.656 3.008a31.872 31.872 0 0 1-45.088 0L662.784 707.904a317.504 317.504 0 0 1-183.776 58.24C302.816 766.144 160 623.296 160 447.04S302.816 128 479.04 128zm0 63.808a255.232 255.232 0 0 0-255.232 255.264 255.232 255.232 0 1 0 510.4 0 255.232 255.232 0 0 0-255.2-255.264z" }, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$6
];
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$6);
}
const InsideSearchOutlined = { name: "SearchOutlined", render: render$5 };
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", { d: "M168 504.2c1-43.7 10-86.1 26.9-126 17.3-41 42.1-77.7 73.7-109.4S337 212.3 378 195c42.4-17.9 87.4-27 133.9-27s91.5 9.1 133.8 27c40.9 17.3 77.7 42.1 109.3 73.8 9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47c-5.3 4.1-3.5 12.5 3 14.1l175.7 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c0-6.7-7.7-10.5-12.9-6.3l-56.4 44.1C765.8 155.1 646.2 92 511.8 92 282.7 92 96.3 275.6 92 503.8c-.1 4.5 3.5 8.2 8 8.2h60c4.4 0 7.9-3.5 8-7.8zm756 7.8h-60c-4.4 0-7.9 3.5-8 7.8-1 43.7-10 86.1-26.9 126-17.3 41-42.1 77.8-73.7 109.4S687 811.7 646 829c-42.4 17.9-87.4 27-133.9 27s-91.5-9.1-133.9-27c-40.9-17.3-77.7-42.1-109.3-73.8-9.9-9.9-19.2-20.4-27.8-31.4l60.2-47c5.3-4.1 3.5-12.5-3-14.1l-175.7-43c-5-1.2-9.9 2.6-9.9 7.7l-.7 181c0 6.7 7.7 10.5 12.9 6.3l56.4-44.1C258.2 868.9 377.8 932 512.2 932c229.2 0 415.5-183.7 419.8-411.8.1-4.5-3.5-8.2-8-8.2z" }, null, -1);
const _hoisted_3$5 = [
  _hoisted_2$5
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$5);
}
const InsideSyncOutlined = { name: "SyncOutlined", render: render$4 };
const _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", { d: "M512 85.333A426.667 426.667 0 1 0 938.667 512 426.667 426.667 0 0 0 512 85.333zm0 768A341.333 341.333 0 1 1 853.333 512 341.333 341.333 0 0 1 512 853.333zm30.72-587.946A32.853 32.853 0 0 0 520.107 256h-16.214a32 32 0 0 0-22.613 9.387L347.733 399.36a21.333 21.333 0 0 0 0 30.293l29.867 30.294a21.333 21.333 0 0 0 30.293 0l61.44-61.867v348.587A21.333 21.333 0 0 0 490.667 768h42.666a21.333 21.333 0 0 0 21.334-21.333V398.08l61.44 61.44a20.907 20.907 0 0 0 29.866 0l30.294-30.293a21.333 21.333 0 0 0 0-30.294z" }, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$4
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_3$4);
}
const InsideUploadOutlined = { name: "UploadOutlined", render: render$3 };
const _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", { d: "M512 128c212 0 384 172 384 384S724 896 512 896 128 724 128 512s172-384 384-384m0-64C264.8 64 64 264.8 64 512s200.8 448 448 448 448-200.8 448-448S759.2 64 512 64zm32 704h-64v-64h64v64zm11.2-203.2-5.6 4.8c-3.2 2.4-5.6 8-5.6 12.8v58.4h-64v-58.4c0-24.8 11.2-48 29.6-63.2l5.6-4.8c56-44.8 83.2-68 83.2-108 0-48-38.4-86.4-86.4-86.4-49.6 0-86.4 36.8-86.4 86.4h-64c0-84 66.4-150.4 150.4-150.4 83.2 0 150.4 67.2 150.4 150.4 0 72.8-49.6 112.8-107.2 158.4z" }, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$3
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$3);
}
const Insidetips = { name: "tips", render: render$2 };
const _hoisted_1$5 = {
  width: "64",
  height: "41",
  class: "ant-empty-img-simple"
};
const _hoisted_2$2 = /* @__PURE__ */ createStaticVNode('<g fill="none" fill-rule="evenodd" transform="translate(0 1)"><ellipse cx="32" cy="33" fill="#F5F5F5" class="ant-empty-img-simple-ellipse" rx="32" ry="7"></ellipse><g fill-rule="nonzero" stroke="#D9D9D9" class="ant-empty-img-simple-g"><path d="M55 12.76 44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"></path><path fill="#FAFAFA" d="M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z" class="ant-empty-img-simple-path"></path></g></g>', 1);
const _hoisted_3$2 = [
  _hoisted_2$2
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$2);
}
const InsideEmpty = { name: "empty", render: render$1 };
const _hoisted_1$4 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "icon",
  style: { "width": "1em", "height": "1em", "vertical-align": "middle", "fill": "currentColor", "overflow": "hidden" },
  viewBox: "0 0 1024 1024"
};
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "#5A626A",
  d: "M439.264 208a16 16 0 0 0-16 16v67.968a239.744 239.744 0 0 0-46.496 26.896l-58.912-34A16 16 0 0 0 296 290.72l-80 138.56a16 16 0 0 0 5.856 21.856l58.896 34a242.624 242.624 0 0 0 0 53.728l-58.88 34a16 16 0 0 0-6.72 20.176l.848 1.68 80 138.56a16 16 0 0 0 21.856 5.856l58.912-34a239.744 239.744 0 0 0 46.496 26.88V800a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16v-67.968a239.744 239.744 0 0 0 46.512-26.896l58.912 34a16 16 0 0 0 21.856-5.856l80-138.56a16 16 0 0 0-4.288-20.832l-1.568-1.024-58.896-34a242.624 242.624 0 0 0 0-53.728l58.88-34a16 16 0 0 0 6.72-20.176l-.848-1.68-80-138.56a16 16 0 0 0-21.856-5.856l-58.912 34a239.744 239.744 0 0 0-46.496-26.88V224a16 16 0 0 0-16-16h-160zm32 48h96v67.376l28.8 12.576a192.21 192.21 0 0 1 37.184 21.52l25.28 18.688 58.448-33.728 48 83.136-58.368 33.68 3.472 31.2a194.624 194.624 0 0 1 0 43.104l-3.472 31.2 58.368 33.68-48 83.136-58.432-33.728-25.296 18.688a192.21 192.21 0 0 1-37.184 21.52l-28.8 12.576V768h-96v-67.376l-28.784-12.576a192.21 192.21 0 0 1-37.184-21.52l-25.28-18.688-58.448 33.728-48-83.136 58.368-33.68-3.472-31.2a194.624 194.624 0 0 1 0-43.104l3.472-31.2-58.368-33.68 48-83.136L380 376.16l25.296-18.688a191.744 191.744 0 0 1 37.184-21.52l28.8-12.576V256zm47.28 144a112 112 0 1 0 0 224 112 112 0 0 0 0-224zm0 48a64 64 0 1 1 0 128 64 64 0 0 1 0-128z"
}, null, -1);
const _hoisted_3$1 = [
  _hoisted_2$1
];
function render13(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$1);
}
const insideSettingOutlined = { name: "SettingOutlined", render: render13 };
const insideIcons = {
  InsideDeleteOutlined,
  InsideExclamationCircleOutlined,
  InsideLoadingOutlined,
  InsideSaveOutlined,
  InsideSearchOutlined,
  InsideSyncOutlined,
  InsideUploadOutlined,
  Insidetips,
  InsideEmpty,
  insideSettingOutlined
};
const _sfc_main$9 = defineComponent(markRaw({
  name: "xIcon",
  props: ["icon"],
  data() {
    const id = "lazy-svg_" + this._.uid;
    return {
      id,
      svgIcon: null
    };
  },
  computed: {
    baseAttrs() {
      return {
        id: this.id,
        role: "img",
        ariaLabel: this.icon,
        class: "xIcon anticon"
      };
    },
    iconKey() {
      const _iconKey = xU.camelCase(this.getIconPath()).replace(/\s/, "");
      return _iconKey;
    }
  },
  methods: {
    getIconPath() {
      return `${State_UI.assetsSvgPath}/${this.icon}.svg`;
    },
    async setIcon() {
      if (!this.icon)
        return;
      try {
        let SvgIconAny = await (async () => {
          let _SvgIconAny = insideIcons[this.icon];
          if (_SvgIconAny) {
            return _SvgIconAny;
          }
          _SvgIconAny = await iStorage(this.iconKey);
          if (_SvgIconAny) {
            return _SvgIconAny;
          }
          try {
            _SvgIconAny = await xU.asyncLoadText(this.getIconPath());
          } catch (error) {
          }
          return _SvgIconAny;
        })();
        if (xU.isString(SvgIconAny) && SvgIconAny.length > 0) {
          const SvgComponentByString = {
            name: this.icon,
            template: SvgIconAny
          };
          await iStorage(this.iconKey, SvgIconAny);
          insideIcons[this.icon] = SvgComponentByString;
          this.svgIcon = createVNode(SvgComponentByString, this.baseAttrs, null);
        } else if ((SvgIconAny == null ? void 0 : SvgIconAny.render) || (SvgIconAny == null ? void 0 : SvgIconAny.template)) {
          this.svgIcon = createVNode(SvgIconAny, this.baseAttrs, null);
        } else {
          console.error("component xIcon miss svg: " + this.icon);
        }
      } catch (error) {
        console.error(error);
      }
    }
  },
  render() {
    if (this.svgIcon) {
      return this.svgIcon;
    }
    return createVNode(InsideLoadingOutlined, this.baseAttrs, null);
  },
  watch: {
    icon: {
      immediate: true,
      handler() {
        this.setIcon();
      }
    }
  }
}));
const xIcon_vue_vue_type_style_index_0_lang = "";
function defDataGridOption(options) {
  options.pagination = options.pagination || defPagination();
  options.isLoading = Boolean(options.isLoading);
  if (options.queryTableList) {
    options._queryTableList_origin = options.queryTableList;
    options.queryTableList = async function(...args2) {
      this.isLoading = true;
      await this._queryTableList_origin.apply(this, args2);
      this.isLoading = false;
    };
  }
  options.onPaginationChange = options.onPaginationChange || async function(pagination) {
    await this.queryTableList({
      pagination
    });
  };
  return options;
}
function defPagination(num_page = 1, num_size = 10, num_total = 0) {
  const {
    page: page2,
    size: size2,
    total: total3
  } = lStorage.appConfigs.pagination;
  return {
    [page2]: num_page || 1,
    [size2]: num_size || 10,
    [total3]: num_total || 0
  };
}
function setPagination(StateTable, pagination) {
  const PAGINATION_MAP = lStorage.appConfigs.pagination;
  xU.each(pagination, (value, prop) => {
    StateTable.pagination[PAGINATION_MAP[prop]] = value;
  });
}
function defCol(options) {
  return {
    [options.prop]: {
      ...options,
      key: options.prop,
      title: options.label,
      dataIndex: options.prop
    }
  };
}
function filterColIsShow(isShow, prop) {
  if (xU.isBoolean(isShow)) {
    return isShow;
  } else {
    return true;
  }
}
const PAGE_SIZE_OPTIONS = ["10", "20", "30"];
const {
  page,
  size,
  total: total2
} = lStorage.appConfigs.pagination;
const xPagination = defineComponent({
  name: "xPagination",
  setup() {
    return {
      State_UI
    };
  },
  props: {
    onPaginationChange: {
      type: Function,
      default: false
    },
    pagination: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    const {
      page: page2,
      size: size2,
      total: total3
    } = lStorage.appConfigs.pagination;
    return {
      pageSizeOptions: PAGE_SIZE_OPTIONS,
      page: page2,
      size: size2,
      total: total3
    };
  },
  methods: {
    onShowSizeChange: xU.debounce(function(page2, size2) {
      setPagination(this, {
        page: page2,
        size: size2
      });
      if (this.onPaginationChange) {
        this.onPaginationChange(this.pagination);
      }
    }, 30)
  },
  computed: {
    i18nMessage() {
      return {
        \u603B\u6761\u6570: "\u603B\u6761\u6570 {total}",
        \u6761\u9875: "{size}\u6761/\u9875",
        ...this.State_UI.i18nMessage
      };
    }
  },
  render() {
    return createVNode(resolveComponent("aPagination"), {
      "current": this.pagination[page],
      "onUpdate:current": ($event) => this.pagination[page] = $event,
      "pageSizeOptions": this.pageSizeOptions,
      "total": this.pagination[total2],
      "pageSize": this.pagination[size],
      "show-size-changer": true,
      "showTotal": (total3) => this.$t("\u603B\u6761\u6570", {
        total: total3
      }, this.i18nMessage).label,
      "onShowSizeChange": this.onShowSizeChange,
      "onChange": this.onShowSizeChange
    }, {
      buildOptionText: (props3) => {
        return createVNode("span", null, [this.$t("\u6761\u9875", {
          size: props3.value
        }, this.i18nMessage).label]);
      }
    });
  }
});
const _sfc_main$8 = defineComponent({
  name: "XDataGrid",
  components: {
    xPagination
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  setup() {
    return {
      Cpt_UI_locale
    };
  },
  data() {
    return {
      State: {
        id: xU.genId("xDataGrid")
      }
    };
  },
  computed: {
    Cpt_Columns() {
      if (this.configs.isGroupingColumns) {
        return this.configs.columns;
      }
      let columns = null;
      columns = xU.map(this.Cpt_ColumnsOrder, (prop) => xU.find(this.configs.columns, {
        prop
      }));
      columns = xU.filter(columns, (i2) => filterColIsShow(i2 == null ? void 0 : i2.isShow, i2 == null ? void 0 : i2.prop));
      return columns;
    },
    Cpt_ColumnsOrder() {
      const order = (() => {
        if (this.configs.columns_order) {
          return this.configs.columns_order;
        } else {
          return xU.map(this.configs.columns, (i2) => i2.prop);
        }
      })();
      return xU.filter(order, (i2) => !!i2);
    },
    Cpt_AntTableProperty() {
      if (this.configs.antTableProperty) {
        return this.configs.antTableProperty;
      } else {
        return {};
      }
    },
    Cpt_VNodeTable() {
      if (this.configs.renderTable) {
        return this.configs.renderTable({
          vm: this
        });
      } else {
        const slots = {
          emptyText: () => createVNode("div", {
            "class": "ant-empty ant-empty-normal"
          }, [createVNode("div", {
            "class": "ant-empty-image"
          }, [createVNode(resolveComponent("xIcon"), {
            "icon": "InsideEmpty",
            "style": "width:64px"
          }, null)]), createVNode("p", {
            "class": "ant-empty-description"
          }, [this.Cpt_UI_locale.Empty.description])]),
          bodyCell: (args2) => {
            const {
              column: column2
            } = args2;
            if (column2 && column2.renderCell) {
              const vNode = column2.renderCell(args2);
              if (xU.isNull(vNode) || xU.isUndefined(vNode)) {
                return "";
              }
              return vNode;
            }
          }
        };
        const scroll = (() => {
          if (this.configs.scroll) {
            return this.configs.scroll;
          }
          return {
            x: 300
          };
        })();
        return createVNode(Table, mergeProps({
          "loading": this.configs.isLoading,
          "dataSource": this.configs.dataSource,
          "columns": this.Cpt_Columns,
          "scroll": scroll,
          "pagination": false,
          "locale": this.Cpt_UI_locale.Table
        }, this.Cpt_AntTableProperty), slots);
      }
    },
    Cpt_VNodePagination() {
      if (this.configs.isHidePagination) {
        return null;
      }
      return createVNode(xPagination, {
        "class": "table-pagination",
        "pagination": this.configs.pagination,
        "onPaginationChange": this.handlePaginationChange
      }, null);
    }
  },
  mounted() {
    if (this.configs.onMounted) {
      this.configs.onMounted({
        id: this.State.id
      });
    }
  },
  methods: {
    async handlePaginationChange(pagination) {
      var _a2;
      if ((_a2 = this == null ? void 0 : this.configs) == null ? void 0 : _a2.onPaginationChange) {
        this.configs.isLoading = true;
        await this.configs.onPaginationChange(pagination);
        this.configs.isLoading = false;
      }
    }
  },
  render() {
    return createVNode("div", {
      "id": this.State.id
    }, [this.Cpt_VNodeTable, this.Cpt_VNodePagination]);
  }
});
const xDataGrid_vue_vue_type_style_index_0_lang = "";
const _sfc_main$7 = defineComponent({
  name: "xColFilter",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  methods: {
    handleChecked(col) {
      const target = xU.find(this.configs.columns, {
        key: col.key
      });
      target.isShow = xU.isBoolean(target.isShow) ? !target.isShow : false;
    }
  },
  computed: {
    Cpt_ColumnsOrder() {
      const order = (() => {
        if (this.configs.columns_order) {
          return this.configs.columns_order;
        } else {
          return xU.map(this.configs.columns, (i2) => i2.prop);
        }
      })();
      return xU.filter(order, (i2) => !!i2);
    },
    Cpt_Columns() {
      return xU.map(this.Cpt_ColumnsOrder, (prop) => xU.find(this.configs.columns, {
        prop
      }));
    },
    checkedList() {
      return xU.filter(this.Cpt_ColumnsOrder, (prop) => {
        const {
          isShow
        } = this.configs.columns[prop];
        return filterColIsShow(isShow);
      });
    }
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_aCheckbox = resolveComponent("aCheckbox");
  const _component_xIcon = resolveComponent("xIcon");
  const _component_aButton = resolveComponent("aButton");
  const _component_aPopover = resolveComponent("aPopover");
  return openBlock(), createBlock(_component_aPopover, {
    placement: "leftTop",
    trigger: "click"
  }, {
    content: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.Cpt_Columns, (col) => {
        return openBlock(), createElementBlock("p", {
          key: col.key
        }, [
          createVNode(_component_aCheckbox, {
            checked: _ctx.checkedList.includes(col.key),
            onChange: ($event) => _ctx.handleChecked(col)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(col.title), 1)
            ]),
            _: 2
          }, 1032, ["checked", "onChange"])
        ]);
      }), 128))
    ]),
    default: withCtx(() => [
      createVNode(_component_aButton, null, {
        icon: withCtx(() => [
          createVNode(_component_xIcon, {
            icon: "insideSettingOutlined",
            style: { "height": "100%", "width": "100%" }
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const xColFilter = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = defineComponent({
  name: "xDataGridToolbar",
  components: {
    xColFilter
  },
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  computed: {
    Cpt_btn_query() {
      return {
        preset: "query",
        onClick: async () => {
          if (this.configs.queryTableList) {
            setPagination(this.configs, {
              page: 1
            });
            await this.configs.queryTableList({
              pagination: {
                page: 1
              }
            });
          }
        }
      };
    },
    Cpt_btn_refresh() {
      return {
        preset: "refresh",
        onClick: async () => {
          if (this.configs.queryTableList) {
            await this.configs.queryTableList();
          }
        }
      };
    },
    Cpt_isShowQuery() {
      if (!this.configs.queryTableList) {
        return false;
      }
      return !this.configs.isHideQuery;
    },
    Cpt_isShowRefresh() {
      if (!this.configs.queryTableList) {
        return false;
      }
      return !this.configs.isHideRefresh;
    },
    Cpt_isShowFilter() {
      if (this.configs.isGroupingColumns) {
        return false;
      }
      if (this.configs.isHideFilter) {
        return false;
      }
      return true;
    },
    Cpt_isSetConfigs() {
      return this.configs && this.configs.pagination;
    }
  }
});
const _hoisted_1$3 = { class: "table-options" };
const _hoisted_2 = { class: "table-option-left flex flex1" };
const _hoisted_3 = {
  key: 0,
  class: "table-filter flex"
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xButton = resolveComponent("xButton");
  const _component_xGap = resolveComponent("xGap");
  const _component_xColFilter = resolveComponent("xColFilter");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.Cpt_isSetConfigs ? (openBlock(), createElementBlock("div", _hoisted_3, [
      _ctx.Cpt_isShowQuery ? (openBlock(), createBlock(_component_xButton, {
        key: 0,
        configs: _ctx.Cpt_btn_query
      }, null, 8, ["configs"])) : createCommentVNode("", true),
      createVNode(_component_xGap, { l: "4" }),
      _ctx.Cpt_isShowRefresh ? (openBlock(), createBlock(_component_xButton, {
        key: 1,
        configs: _ctx.Cpt_btn_refresh
      }, null, 8, ["configs"])) : createCommentVNode("", true),
      createVNode(_component_xGap, { l: "4" }),
      _ctx.Cpt_isShowFilter ? (openBlock(), createBlock(_component_xColFilter, {
        key: 2,
        configs: _ctx.configs
      }, null, 8, ["configs"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true)
  ]);
}
const xDataGridToolbar = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _sfc_main$5 = defineComponent({
  name: "xCellLabel",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      loading: false,
      title: ""
    };
  },
  computed: {
    id() {
      return `xLabel_${this._.uid}`;
    }
  },
  watch: {
    configs: {
      immediate: true,
      handler(configs) {
        this.loading = !!configs.loading;
      }
    }
  },
  methods: {
    updateTitle(title) {
      if (this.title !== title) {
        this.title = title;
      }
    }
  },
  updated() {
    const $dom = $$1(`#${this.id}`);
    const domWidth = $dom.width();
    const $span = $$1(`#${this.id} > span`);
    const spanWidth = $span.width();
    if (domWidth < spanWidth) {
      const text = $dom.text();
      this.updateTitle(text);
    } else {
      this.updateTitle("");
    }
  }
});
const _hoisted_1$2 = ["title", "id"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "ellipsis",
    title: _ctx.title,
    id: _ctx.id
  }, [
    createBaseVNode("span", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 8, _hoisted_1$2);
}
const xCellLabel = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const xVirScroll_vue_vue_type_style_index_0_lang = "";
const itemHeight = 48;
const oneBlockHeight = 580;
const _sfc_main$4 = defineComponent({
  name: "XVirScroll",
  props: {
    configs: {
      type: Object,
      default() {
        return {};
      }
    },
    top: {
      type: Number,
      default: 0
    },
    height: {
      type: Number,
      default: 0
    },
    scrollHeight: {
      type: Number,
      default: 0
    }
  },
  emits: ["update:top", "update:height", "update:scrollHeight"],
  setup() {
    return {};
  },
  data() {
    return {
      itemComponent: this.$slots.item,
      blockCount: 0,
      isLoading: false,
      styleWrapperAll: {
        height: 0
      }
    };
  },
  computed: {
    allItems() {
      return this.configs.items || [];
    },
    positionBlock() {
      return this.blockCount % 3;
    },
    virs1() {
      const position = Number(this.styleWrapper1.match(/(\d)/g).join("")) / 580;
      const start = position * 10;
      const end = start + 10;
      return this.allItems.slice(start, end).map((i2, index2) => ({
        ...i2,
        index: start + 1 + index2
      }));
    },
    virs2() {
      const position = Number(this.styleWrapper2.match(/(\d)/g).join("")) / 580;
      const start = position * 10;
      const end = start + 10;
      return this.allItems.slice(start, end).map((i2, index2) => ({
        ...i2,
        index: start + 1 + index2
      }));
    },
    virs3() {
      const position = Number(this.styleWrapper3.match(/(\d)/g).join("")) / 580;
      const start = position * 10;
      const end = start + 10;
      return this.allItems.slice(start, end).map((i2, index2) => ({
        ...i2,
        index: start + 1 + index2
      }));
    },
    styleWrapper1() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${this.blockCount * 580}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${(this.blockCount + 2) * 580}px)`;
      }
      return `transform:translateY(${(this.blockCount + 1) * 580}px)`;
    },
    styleWrapper2() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${(this.blockCount + 1) * 580}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${this.blockCount * 580}px)`;
      }
      return `transform:translateY(${(this.blockCount - 1) * 580}px)`;
    },
    styleWrapper3() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${(this.blockCount + 2) * 580}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${(this.blockCount + 1) * 580}px)`;
      }
      return `transform:translateY(${this.blockCount * 580}px)`;
    }
  },
  watch: {
    top() {
      this.setTop();
    },
    "allItems.length": {
      immediate: true,
      handler() {
        this.updateTop();
        this.setHeight();
      }
    }
  },
  updated() {
    var _a2, _b;
    const height = (_a2 = this.$wrapperEle) == null ? void 0 : _a2.height();
    if (height !== this.height) {
      this.$emit("update:height", ((_b = this.$wrapperEle) == null ? void 0 : _b.height()) || 0);
    }
  },
  mounted() {
    this.init();
  },
  beforeUnmount() {
    this.$wrapperEle.off("scroll");
  },
  methods: {
    setTop: xU.debounce(function() {
      if (this.$refs.refWrapper) {
        this.$refs.refWrapper.scrollTo({
          top: this.top,
          behavior: "smooth"
        });
      }
    }, 1e3),
    init() {
      this.$wrapperEle = $$1(this.$refs.refWrapper);
      this.$wrapperEle.on("scroll", () => this.updateTop());
    },
    updateTop(event2) {
      if (this.$refs.refWrapper) {
        const top = this.$refs.refWrapper.scrollTop;
        this.blockCount = Math.floor(top / oneBlockHeight);
        this.$emit("update:top", top);
      }
    },
    setHeight() {
      const height = this.allItems.length * itemHeight;
      this.styleWrapperAll.height = `${height}px`;
      this.$emit("update:scrollHeight", height);
    }
  }
});
const _hoisted_1$1 = {
  ref: "refWrapper",
  class: "wrapper vir-item-component"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createBaseVNode("div", {
      style: normalizeStyle(_ctx.styleWrapperAll)
    }, [
      createBaseVNode("div", {
        class: "vir-item-wrapper item1",
        style: normalizeStyle(_ctx.styleWrapper1)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.virs1, (vir) => {
          return openBlock(), createElementBlock("div", {
            key: vir.id,
            class: "vir-item"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.itemComponent), { item: vir }, null, 8, ["item"]))
          ]);
        }), 128))
      ], 4),
      createBaseVNode("div", {
        class: "vir-item-wrapper item2",
        style: normalizeStyle(_ctx.styleWrapper2)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.virs2, (vir) => {
          return openBlock(), createElementBlock("div", {
            key: vir.id,
            class: "vir-item"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.itemComponent), { item: vir }, null, 8, ["item"]))
          ]);
        }), 128))
      ], 4),
      createBaseVNode("div", {
        class: "vir-item-wrapper item3",
        style: normalizeStyle(_ctx.styleWrapper3)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.virs3, (vir) => {
          return openBlock(), createElementBlock("div", {
            key: vir.id,
            class: "vir-item"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.itemComponent), { item: vir }, null, 8, ["item"]))
          ]);
        }), 128))
      ], 4)
    ], 4)
  ], 512);
}
const xVirScroll = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const xVirTableTh = defineComponent({
  props: ["column", "index"],
  computed: {
    prop() {
      var _a2;
      return (_a2 = this.column) == null ? void 0 : _a2.prop;
    },
    label() {
      var _a2;
      return (_a2 = this.column) == null ? void 0 : _a2.label;
    },
    renderHeader() {
      var _a2;
      return ((_a2 = this.column) == null ? void 0 : _a2.renderHeader) || false;
    },
    vDomCellContent() {
      if (this.renderHeader) {
        return this.renderHeader({
          label: this.label,
          prop: this.prop,
          index: this.index
        });
      }
      return this.label;
    }
  },
  render() {
    return createVNode("div", {
      "role": "th",
      "class": "xVirTable-cell",
      "data-prop": this.prop,
      "data-index": this.index
    }, [this.vDomCellContent]);
  }
});
const usefnObserveDomResize = () => {
  function fnObserveDomResize($el, callback) {
    this.resizeObserver = new ResizeObserver(callback);
    this.resizeObserver.observe($el);
  }
  function fnUnobserveDomResize($el) {
    this.resizeObserver.unobserve($el);
  }
  return {
    fnObserveDomResize,
    fnUnobserveDomResize
  };
};
$$1(window).on("click.virTableTdId", function(e2) {
  const virTableTdId = (() => {
    let $ele = $$1(e2.target);
    let _virTableTdId = $ele.attr("id");
    if (/^virTableTdId_/.test(_virTableTdId)) {
      return _virTableTdId;
    } else {
      $ele = $ele.parents("[id^=virTableTdId_]");
      _virTableTdId = $ele.attr("id");
      return _virTableTdId;
    }
  })();
  $$1(window).trigger({
    type: "onAllCell",
    virTableTdId
  });
});
const xVirTableTd = defineComponent({
  props: ["column", "data"],
  emits: ["update:data"],
  setup() {
    return {
      configs: inject("configs")
    };
  },
  computed: {
    record() {
      const vm = this;
      return new Proxy(vm.data, {
        get(obj, prop) {
          return vm.data[prop];
        },
        set(obj, prop, val) {
          vm.data[prop] = val;
          vm.configs.dataSource[vm.data.__virRowIndex][prop] = val;
          return true;
        }
      });
    },
    id() {
      return `virTableTdId_${this._.uid}`;
    },
    prop() {
      var _a2;
      return (_a2 = this.column) == null ? void 0 : _a2.prop;
    },
    cell() {
      return this.data[this.prop];
    },
    renderEditor() {
      var _a2, _b;
      if ((_a2 = this.column) == null ? void 0 : _a2.renderEditor) {
        return (_b = this.column) == null ? void 0 : _b.renderEditor;
      }
      return false;
    },
    renderCell() {
      var _a2, _b;
      if ((_a2 = this.column) == null ? void 0 : _a2.renderCell) {
        return (_b = this.column) == null ? void 0 : _b.renderCell;
      }
      return false;
    }
  },
  data(vm) {
    return {
      isFocus: false,
      count: 0
    };
  },
  methods: {
    handleAllCell(e2) {
      if (e2.virTableTdId === this.id) {
        if (!this.isFocus) {
          this.isFocus = true;
          setTimeout(() => {
            $$1(this.$refs.cell).find("input").trigger("focus");
          }, 64);
        }
      } else {
        if (this.isFocus) {
          this.isFocus = false;
        }
      }
    }
  },
  mounted() {
    $$1(window).on("onAllCell", this.handleAllCell);
    if (this.renderEditor) {
      $$1(this.$refs.cell).addClass("cursor-editor");
    }
  },
  beforeUnmount() {
    $$1(window).off("onAllCell", this.handleAllCell);
  },
  render() {
    return createVNode("div", {
      "id": this.id,
      "ref": "cell",
      "role": "td",
      "class": "xVirTable-cell",
      "data-count": this.count,
      "data-prop": this.prop,
      "data-row-index": this.data.__virRowIndex
    }, [(() => {
      if (this.renderEditor && this.renderCell) {
        if (this.isFocus) {
          return this.renderEditor({
            configs: this.configs,
            record: this.record,
            cell: this.cell,
            index: this.data.__virRowIndex
          });
        } else {
          return this.renderCell({
            configs: this.configs,
            record: this.record,
            cell: this.cell,
            index: this.data.__virRowIndex
          });
        }
      }
      if (!this.renderEditor && this.renderCell) {
        return this.renderCell({
          configs: this.configs,
          record: this.record,
          cell: this.cell,
          index: this.data.__virRowIndex
        });
      }
      if (this.renderEditor && !this.renderCell) {
        if (this.isFocus) {
          return this.renderEditor({
            configs: this.configs,
            record: this.record,
            cell: this.cell,
            index: this.data.__virRowIndex
          });
        } else {
          return this.cell;
        }
      }
      return this.cell;
    })()]);
  }
});
const xVirTableBody = defineComponent({
  props: ["columnOrder", "columns", "rowHeight", "selectedConfigs", "selected"],
  emits: ["selectedChange", "update:scrollHeight"],
  components: {
    xVirTableTd
  },
  setup() {
    const {
      fnObserveDomResize,
      fnUnobserveDomResize
    } = usefnObserveDomResize();
    return {
      uniqBy: inject("uniqBy"),
      configs: inject("configs"),
      rowCache: {},
      fnObserveDomResize,
      fnUnobserveDomResize
    };
  },
  data(vm) {
    return {
      isLoading: false,
      perBlockHeight: 1,
      perBlockRowCount: 0,
      blockInViewCount: 0,
      styleWrapperAll: {
        height: 0,
        position: "relative"
      },
      virs1: [],
      virs2: [],
      virs3: []
    };
  },
  mounted() {
    this.fnObserveDomResize(this.$refs.wrapper, () => {
      this.setPerBlockHeight(this.$refs.wrapper.offsetHeight);
    });
    this.$watch(() => {
      return `${this.configs.dataSource.length}_${this.perBlockHeight}_${this.perBlockRowCount}_${this.styleWrapper1}`;
    }, () => {
      this.setVirs1();
    });
    this.$watch(() => `${this.configs.dataSource.length}_${this.perBlockHeight}_${this.perBlockRowCount}_${this.styleWrapper2}`, () => {
      this.setVirs2();
    });
    this.$watch(() => `${this.configs.dataSource.length}_${this.perBlockHeight}_${this.perBlockRowCount}_${this.styleWrapper3}`, () => {
      this.setVirs3();
    });
  },
  beforeUnmount() {
    this.fnUnobserveDomResize(this.$refs.wrapper);
  },
  computed: {
    fnIsSelected() {
      const {
        isSelect,
        prop
      } = this.selectedConfigs || {};
      if (xU.isFunction(isSelect)) {
        return (args2) => {
          return isSelect.call(this, args2);
        };
      } else {
        return ({
          rowData
        }) => {
          const id = rowData[prop];
          return this.selected.includes(id);
        };
      }
    },
    fnIsDisabled() {
      const {
        isDisabled
      } = this.selectedConfigs || {};
      if (xU.isFunction(isDisabled)) {
        return () => {
          return isDisabled.call(this, args);
        };
      } else {
        return () => {
          return false;
        };
      }
    },
    positionBlock() {
      return this.blockInViewCount % 3;
    },
    styleWrapper1() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${this.blockInViewCount * this.perBlockHeight}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${(this.blockInViewCount + 2) * this.perBlockHeight}px)`;
      }
      return `transform:translateY(${(this.blockInViewCount + 1) * this.perBlockHeight}px)`;
    },
    styleWrapper2() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${(this.blockInViewCount + 1) * this.perBlockHeight}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${this.blockInViewCount * this.perBlockHeight}px)`;
      }
      return `transform:translateY(${(this.blockInViewCount - 1) * this.perBlockHeight}px)`;
    },
    styleWrapper3() {
      if (this.positionBlock === 0) {
        return `transform:translateY(${(this.blockInViewCount + 2) * this.perBlockHeight}px)`;
      }
      if (this.positionBlock === 1) {
        return `transform:translateY(${(this.blockInViewCount + 1) * this.perBlockHeight}px)`;
      }
      return `transform:translateY(${this.blockInViewCount * this.perBlockHeight}px)`;
    },
    vDomBodyTr1() {
      return this.genTr(this.virs1);
    },
    vDomBodyTr2() {
      return this.genTr(this.virs2);
    },
    vDomBodyTr3() {
      return this.genTr(this.virs3);
    }
  },
  methods: {
    clearCacheRow() {
      const props3 = xU.filter(this.rowCache, (value, prop) => /^blockId/.test(prop));
      xU.each(props3, (prop) => delete this.rowCache[prop]);
    },
    genTr(rows) {
      const vDomBlock = (() => {
        if (!this.uniqBy) {
          return xU.map(rows, (data9, rowIndex) => {
            const {
              __virRowIndex
            } = data9;
            return createVNode("div", {
              "role": "tr",
              "class": "xVirTable-row flex horizon",
              "data-row-key": __virRowIndex
            }, [this.genSelectedVDom({
              rowIndex,
              rowData: data9
            }), xU.map(this.columnOrder, (prop, index2) => {
              return createVNode(xVirTableTd, {
                "column": this.columns[prop],
                "data-index": index2,
                "data": data9,
                "onUpdate:data": ($event) => data9 = $event
              }, null);
            })]);
          });
        } else {
          const blockId = xU.reduce(rows, (id, row) => {
            id += row[this.uniqBy];
            return id;
          }, "blockId");
          if (!this.rowCache[blockId]) {
            this.rowCache[blockId] = xU.map(rows, (data9, rowIndex) => {
              if (!this.rowCache[data9[this.uniqBy]]) {
                const {
                  __virRowIndex
                } = data9;
                this.rowCache[data9[this.uniqBy]] = createVNode("div", {
                  "role": "tr",
                  "class": "xVirTable-row flex horizon",
                  "data-row-key": __virRowIndex
                }, [this.genSelectedVDom({
                  rowIndex,
                  rowData: data9
                }), xU.map(this.columnOrder, (prop, index2) => {
                  return createVNode(xVirTableTd, {
                    "column": this.columns[prop],
                    "data-col-index": index2,
                    "data": data9,
                    "onUpdate:data": ($event) => data9 = $event
                  }, null);
                })]);
              }
              return this.rowCache[data9._id];
            });
          }
          return this.rowCache[blockId];
        }
      })();
      return vDomBlock;
    },
    setVirs1() {
      const position = Number(this.styleWrapper1.match(/(\d)/g).join("")) / this.perBlockHeight;
      const start = position * this.perBlockRowCount;
      const end = start + this.perBlockRowCount;
      this.virs1 = this.fragment(start, end);
    },
    setVirs2() {
      const position = Number(this.styleWrapper2.match(/(\d)/g).join("")) / this.perBlockHeight;
      const start = position * this.perBlockRowCount;
      const end = start + this.perBlockRowCount;
      this.virs2 = this.fragment(start, end);
    },
    setVirs3() {
      const position = Number(this.styleWrapper3.match(/(\d)/g).join("")) / this.perBlockHeight;
      const start = position * this.perBlockRowCount;
      const end = start + this.perBlockRowCount;
      this.virs3 = this.fragment(start, end);
    },
    fragment(start, end) {
      const targetRecords = this.configs.dataSource.slice(start, end).map((i2, index2) => {
        i2.__virRowIndex = start + index2;
        return i2;
      });
      return targetRecords;
    },
    genSelectedVDom(rowInfo) {
      if (!this.selectedConfigs) {
        return null;
      }
      const isSelected = this.fnIsSelected(rowInfo);
      let isDisabled = this.fnIsDisabled(rowInfo);
      const handleChange2 = (e2) => {
        const {
          prop
        } = this.selectedConfigs;
        this.emitSelectedChange(e2.target.checked, rowInfo.rowData[prop]);
      };
      let vDomChecked;
      if (xU.isString(isDisabled)) {
        isDisabled = true;
        const uiPopoverConfigs = {
          content: isDisabled
        };
        vDomChecked = withDirectives(createVNode(resolveComponent("aCheckbox"), {
          "checked": isSelected,
          "onChange": handleChange2,
          "disabled": true
        }, null), [[resolveDirective("uiPopover"), uiPopoverConfigs]]);
      } else {
        vDomChecked = createVNode(resolveComponent("aCheckbox"), {
          "checked": isSelected,
          "onChange": handleChange2,
          "disabled": isDisabled
        }, null);
      }
      return createVNode("div", {
        "role": "td",
        "data-prop": "xVirSelected",
        "class": "flex middle center xVirTable-cell xVirSelected_inner_element xVirSelected_inner_element_check"
      }, [vDomChecked]);
    },
    emitSelectedChange(checked, id) {
      this.$emit("selectedChange", {
        checked,
        id
      });
    },
    setPerBlockHeight: xU.debounce(function(viewportHeight) {
      this.viewportHeight = viewportHeight;
      this.perBlockRowCount = Math.ceil(viewportHeight / this.rowHeight);
      this.perBlockHeight = this.perBlockRowCount * this.rowHeight;
      this.setHeight();
    }, 64),
    setTop: xU.debounce(function() {
      if (this.$refs.refWrapper) {
        this.$refs.refWrapper.scrollTo({
          top: this.top,
          behavior: "smooth"
        });
      }
    }, 1e3),
    updateTop(event2) {
      if (event2) {
        const top = event2.target.scrollTop;
        this.blockInViewCount = Math.floor(top / this.perBlockHeight);
      }
    },
    setHeight() {
      const height = this.configs.dataSource.length * this.rowHeight;
      if (this.viewportHeight && height < this.viewportHeight) {
        this.styleWrapperAll.width = `calc(100% - 6px)`;
      } else {
        delete this.styleWrapperAll.width;
      }
      this.styleWrapperAll.height = `${height}px`;
    }
  },
  watch: {
    rowHeight() {
      this.setPerBlockHeight(this.$refs.wrapper.offsetHeight);
    },
    top() {
      this.setTop();
    },
    "configs.dataSource.length": {
      immediate: true,
      handler() {
        this.clearCacheRow();
        this.updateTop(false);
        this.setHeight();
      }
    }
  },
  render() {
    const vDomTableBody = createVNode("div", {
      "role": "body",
      "class": "xVirTable-body-wrapper flex1",
      "ref": "wrapper",
      "onScroll": this.updateTop
    }, [createVNode("div", {
      "style": this.styleWrapperAll
    }, [createVNode("div", {
      "class": "xVirTable-body-item item1",
      "style": this.styleWrapper1
    }, [this.vDomBodyTr1]), createVNode("div", {
      "class": "xVirTable-body-item item2",
      "style": this.styleWrapper2
    }, [this.vDomBodyTr2]), createVNode("div", {
      "class": "xVirTable-body-item item3",
      "style": this.styleWrapper3
    }, [this.vDomBodyTr3])])]);
    return vDomTableBody;
  }
});
function defXVirTableConfigs(options) {
  const required4 = ["rowHeight", "columns"];
  if (xU.some(required4, (prop) => {
    if (!options[prop]) {
      alert("defXVirTableConfigs miss required " + prop);
      return true;
    }
    return false;
  })) {
    throw new Error("defXVirTableConfigs miss required");
  }
  if (options.selectedConfigs) {
    options.selected = options.selected || [];
  }
  return options;
}
defXVirTableConfigs.type = {
  many: "many",
  one: "one"
};
const xVirTable = defineComponent({
  props: ["configs", "uniqBy"],
  components: {
    xVirTableTh,
    xVirTableBody
  },
  setup(props3) {
    provide("uniqBy", props3.uniqBy);
    provide("configs", props3.configs);
  },
  mounted() {
    this.initStyle();
  },
  data() {
    return {
      selectedAll: false,
      dataSource: []
    };
  },
  computed: {
    selectedIndeterminate() {
      var _a2, _b;
      const dataLength = ((_b = (_a2 = this.configs) == null ? void 0 : _a2.dataSource) == null ? void 0 : _b.length) || 0;
      const selectedLength = this.selected.length;
      if (dataLength == 0 || selectedLength == 0 || dataLength == selectedLength) {
        return false;
      }
      return true;
    },
    selected() {
      var _a2;
      return ((_a2 = this.configs) == null ? void 0 : _a2.selected) || [];
    },
    selectedType() {
      var _a2, _b, _c;
      if (!((_a2 = this.configs) == null ? void 0 : _a2.selectedConfigs)) {
        return false;
      }
      return ((_c = (_b = this.configs) == null ? void 0 : _b.selectedConfigs) == null ? void 0 : _c.type) || defXVirTableConfigs.type.many;
    },
    selectedProp() {
      var _a2, _b, _c, _d;
      if (!this.selectedType) {
        return false;
      }
      if (!((_b = (_a2 = this.configs) == null ? void 0 : _a2.selectedConfigs) == null ? void 0 : _b.prop)) {
        alert("vVirTable miss this.selected id prop");
      }
      return (_d = (_c = this.configs) == null ? void 0 : _c.selectedConfigs) == null ? void 0 : _d.prop;
    },
    selectedBy() {
      var _a2, _b, _c, _d;
      if (!this.selectedType) {
        return false;
      }
      if (xU.isFunction((_b = (_a2 = this.configs) == null ? void 0 : _a2.selectedConfigs) == null ? void 0 : _b.fn)) {
        return (_d = (_c = this.configs) == null ? void 0 : _c.selectedConfigs) == null ? void 0 : _d.fn;
      } else {
        return false;
      }
    },
    customClass() {
      var _a2, _b;
      if (xU.isFunction((_a2 = this.configs) == null ? void 0 : _a2.customClass)) {
        return (_b = this.configs) == null ? void 0 : _b.customClass(this.xVirTableId);
      } else {
        return "";
      }
    },
    rowHeight() {
      var _a2;
      return ((_a2 = this.configs) == null ? void 0 : _a2.rowHeight) || 32;
    },
    xVirTableId() {
      return `xVirTableId_${this._.uid}`;
    },
    columnOrder() {
      var _a2, _b, _c;
      if ((_a2 = this.configs) == null ? void 0 : _a2.columnOrder) {
        return (_b = this.configs) == null ? void 0 : _b.columnOrder;
      }
      return Object.keys(((_c = this.configs) == null ? void 0 : _c.columns) || {});
    },
    columnWidthArray() {
      const _columnWidthArray = xU.reduce(this.columnOrder, (columnStyle, prop) => {
        const configsColumn = this.configs.columns[prop] || {};
        const {
          width
        } = configsColumn;
        if (width) {
          columnStyle.push(`#${this.xVirTableId} div[role=tr] div[role=th][data-prop=${prop}]{ width:${width}; min-width:${width}; max-width:${width}; }`);
          columnStyle.push(`#${this.xVirTableId} div[role=tr] div[role=td][data-prop=${prop}]{ width:${width}; min-width:${width}; max-width:${width}; }`);
        }
        return columnStyle;
      }, []);
      return _columnWidthArray;
    },
    vDomTheadSelect() {
      if (!this.selectedType) {
        return null;
      }
      let vDomTheadSelect = createVNode(resolveComponent("aCheckbox"), {
        "checked": this.selectedAll,
        "indeterminate": this.selectedIndeterminate,
        "onChange": this.handleSelectedChangeTh
      }, null);
      if (this.selectedType == "one") {
        vDomTheadSelect = null;
      }
      return createVNode("div", {
        "role": "th",
        "class": "flex middle center xVirTable-cell xVirSelected_inner_element xVirSelected_inner_element_check",
        "data-prop": "xVirSelected"
      }, [vDomTheadSelect]);
    },
    vDomThead() {
      return createVNode("div", {
        "role": "thead",
        "class": "xVirTable-thead"
      }, [createVNode("div", {
        "role": "tr",
        "class": "flex horizon"
      }, [this.vDomTheadSelect, xU.map(this.columnOrder, (prop, index2) => {
        var _a2;
        const column2 = (_a2 = this.configs) == null ? void 0 : _a2.columns[prop];
        return createVNode(xVirTableTh, {
          "column": column2,
          "index": index2,
          "key": prop
        }, null);
      })])]);
    },
    styleContent() {
      const allStyleArray = [
        `#${this.xVirTableId} div[role=tr] >div{flex:1; }`,
        `#${this.xVirTableId} div[role=tr] div[role=th]{ width:300px;overflow:hidden;text-align:center; }`,
        `#${this.xVirTableId} div[role=tr] div[role=td]{ width:300px;overflow:hidden;height:${this.rowHeight}px;display: flex; justify-content: start; align-items: center;}`
      ].concat(this.columnWidthArray, this.customClass);
      return allStyleArray.join("\n");
    }
  },
  watch: {
    "configs.selected"(selected) {
      if ((selected == null ? void 0 : selected.length) === 0) {
        this.selectedAll = false;
      }
    },
    "configs.dataSource": {
      immediate: true,
      handler() {
        this.dataSource = this.configs.dataSource;
      }
    },
    styleContent() {
      this.updateStyle(this.styleContent);
    }
  },
  methods: {
    initStyle() {
      const $form = $$1(`#${this.xVirTableId}`);
      const $style = $$1("<style/>", {
        id: `style_${this.xVirTableId}`
      }).append(this.styleContent);
      $form.prepend($style);
    },
    updateStyle(styleContent) {
      const $style = $$1(`#style_${this.xVirTableId}`);
      $style.html(styleContent);
    },
    handleSelectedChange() {
    },
    handleSelectedChangeTh(e2) {
      const {
        checked
      } = e2.target;
      if (checked) {
        this.selectedAll = true;
        this.configs.selected = xU.map(this.configs.dataSource, (i2) => i2[this.selectedProp]);
      } else {
        this.configs.selected = [];
      }
    },
    handleSelectedChangeTd({
      id
    }) {
      var _a2;
      const isOnlyOne = this.selectedType === "one";
      const index2 = xU.findIndex((_a2 = this.configs) == null ? void 0 : _a2.selected, (i2) => i2 === id);
      if (index2 > -1) {
        if (isOnlyOne) {
          this.configs.selected = [];
        } else {
          this.configs.selected.splice(index2, 1);
        }
      } else {
        if (isOnlyOne) {
          this.configs.selected = [id];
        } else {
          this.configs.selected.push(id);
        }
      }
    }
  },
  render() {
    var _a2, _b, _c;
    console.time("virTable");
    const vDomTable = createVNode("div", {
      "id": this.xVirTableId,
      "class": "xVirTable-wrapper flex vertical"
    }, [createVNode("div", {
      "role": "table",
      "class": "xVirTable-header-wrapper",
      "style": "padding-right: 6px;"
    }, [this.vDomThead]), createVNode(xVirTableBody, {
      "columnOrder": this.columnOrder,
      "columns": (_a2 = this.configs) == null ? void 0 : _a2.columns,
      "rowHeight": this.rowHeight,
      "onSelectedChange": this.handleSelectedChangeTd,
      "selectedConfigs": (_b = this.configs) == null ? void 0 : _b.selectedConfigs,
      "selected": (_c = this.configs) == null ? void 0 : _c.selected
    }, null)]);
    console.timeEnd("virTable");
    return vDomTable;
  }
});
const {
  $t: $t$8
} = State_UI;
const SUCCESS = false;
const FAIL = true;
const RegexFn = {
  email: () => /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/,
  mobile: () => /^1[34578]\d{9}$/
};
const makeFormRules = (options) => {
  options.trigger = options.trigger || [EVENT_TYPE.update];
  options.msg = options.msg || "";
  return options;
};
const FormRules = {
  SUCCESS,
  FAIL,
  required(msg, trigger2 = [EVENT_TYPE.update]) {
    return makeFormRules({
      name: "required",
      msg: msg || $t$8("\u5FC5\u586B\u9879").label,
      async validator(value) {
        if (value) {
          if (xU.isArray(value)) {
            if (value.length > 0) {
              return SUCCESS;
            } else {
              return FAIL;
            }
          }
          return SUCCESS;
        }
        if (xU.isBoolean(value))
          return SUCCESS;
        if (xU.isNumber(value) && !xU.isNaN(value))
          return SUCCESS;
        return FAIL;
      },
      trigger: trigger2
    });
  },
  demo() {
    return {
      name: "Demo",
      msg: "Demo",
      async validator(value) {
        await xU.sleep(1e3);
        return FAIL;
      },
      trigger: [EVENT_TYPE.update, EVENT_TYPE.input, EVENT_TYPE.change, EVENT_TYPE.blur]
    };
  },
  email() {
    return {
      name: "email",
      msg: () => $t$8("\u8BF7\u8F93\u5165email").label,
      async validator(value) {
        if (RegexFn.email().test(value)) {
          return SUCCESS;
        }
        return FAIL;
      },
      trigger: [EVENT_TYPE.update, EVENT_TYPE.input, EVENT_TYPE.change, EVENT_TYPE.blur]
    };
  },
  custom({
    name: name2,
    msg,
    validator: validator2,
    trigger: trigger2
  }) {
    return makeFormRules({
      name: name2,
      msg,
      validator: validator2,
      trigger: trigger2
    });
  }
};
const KEY = {
  right: 39,
  left: 37,
  esc: 27
};
const $win = $$1(window);
const $html = $$1("html");
const $document = $$1(document);
const $body = $$1("body");
const DATA_TIPS_FOLLOW_ID = "data-tips-follow-id";
const DATA_V_UI_MOVE = "data-directive-ui-move";
const TYPE_IFRAME = "iframe";
const TYPE_LOADING = "loading";
const TYPE_TIPS = "tips";
const LAYUI_LAYER = "layui-layer";
const LAYUI_LAYER_SHADE = "layui-layer-shade";
const LAYUI_LAYER_MOVE = "layui-layer-move";
const LAYUI_LAYER_CONTENT = "layui-layer-content";
const LAYUI_LAYER_CLOSE = "layui-layer-close";
const LAYUI_LAYER_IFRAME = "layui-layer-iframe";
const LAYUI_LAYER_TITLE = "layui-layer-title";
const DOMS_ANIM = [
  "layer-anim-00",
  "layer-anim-01",
  "layer-anim-02",
  "layer-anim-03",
  "layer-anim-04",
  "layer-anim-05",
  "layer-anim-06"
];
const $MoveMask = $$1(
  `<div class="${LAYUI_LAYER_MOVE}" id="${LAYUI_LAYER_MOVE}"></div>`
);
setTimeout(() => {
  $body.append($MoveMask);
}, 0);
const READY = {
  zIndex: 0,
  pointMousedown: [],
  basePath: function() {
    var jsPath = document.currentScript ? document.currentScript.src : function() {
      var js = document.scripts, last3 = js.length - 1, src2;
      for (var i2 = last3; i2 > 0; i2--) {
        if (js[i2].readyState === "interactive") {
          src2 = js[i2].src;
          break;
        }
      }
      return src2 || js[last3].src;
    }();
    const GLOBAL = {};
    return GLOBAL.layer_dir || jsPath.substring(0, jsPath.lastIndexOf("/") + 1);
  }(),
  config: {},
  end: {},
  minIndex: 0,
  minLeft: [],
  btn: ["&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;"],
  type: ["dialog", "page", "iframe", "loading", "tips"],
  getStyle: function(node, name2) {
    var style2 = node.currentStyle ? node.currentStyle : window.getComputedStyle(node, null);
    return style2[style2.getPropertyValue ? "getPropertyValue" : "getAttribute"](
      name2
    );
  },
  reselect() {
    $$1.each($$1("select"), function(index2, value) {
      var sthis = $$1(this);
      if (!sthis.parents("." + LAYUI_LAYER)[0]) {
        sthis.attr("layer") == 1 && $$1("." + LAYUI_LAYER).length < 1 && sthis.removeAttr("layer").show();
      }
      sthis = null;
    });
  },
  record($eleLayer) {
    const [windowHeight, windowWidth] = [$win.height(), $win.width()];
    const isLimit = $eleLayer.height() > windowHeight;
    const isLimitWidth = $eleLayer.width() > windowWidth;
    var area = [
      isLimitWidth ? windowWidth - 64 : $eleLayer.width(),
      isLimit ? windowHeight - 64 : $eleLayer.height(),
      isLimit ? 32 : $eleLayer.position().top,
      $eleLayer.position().left + parseFloat($eleLayer.css("margin-left"))
    ];
    $eleLayer.find(".layui-layer-max").addClass("layui-layer-maxmin");
    $eleLayer.attr({
      area
    });
  },
  rescollbar(index2) {
    if ($html.attr("layer-full") == index2) {
      if ($html[0].style.removeProperty) {
        $html[0].style.removeProperty("overflow");
      } else {
        $html[0].style.removeAttribute("overflow");
      }
      $html.removeAttr("layer-full");
    }
  }
};
const LayerUtils = {
  setZIndex(zIndex) {
    READY.zIndex = zIndex;
  },
  MSG: 0,
  DIALOG: 1,
  IFRAME: 2,
  LOADING: 3,
  TIPS: 4,
  UP: 1,
  RIGHT: 2,
  BOTTOM: 3,
  LEFT: 4,
  v: "3.5.1",
  ie: (() => {
    var agent = navigator.userAgent.toLowerCase();
    if ("ActiveXObject" in window) {
      let version2 = agent.match(/msie\s(\d+)/);
      if (version2) {
        return Number(version2[1]);
      } else {
        return 11;
      }
    }
    return 0;
  })(),
  path: READY.basePath,
  config: function(options, fn) {
    options = options || {};
    LayerUtils.cache = READY.config = $$1.extend({}, READY.config, options);
    LayerUtils.path = READY.config.path || LayerUtils.path;
    typeof options.extend === "string" && (options.extend = [options.extend]);
    if (!options.extend)
      return this;
    return this;
  },
  open(options) {
    const { _layerKey } = new ClassLayer(options);
    return _layerKey;
  },
  alert(content, options, yes) {
    var type22 = typeof options === "function";
    if (type22)
      yes = options;
    return LayerUtils.open(
      $$1.extend(
        {
          content,
          yes
        },
        type22 ? {} : options
      )
    );
  },
  confirm(content, options, yes, cancel) {
    if (xU.isFunction(options)) {
      cancel = yes;
      yes = options;
    }
    return LayerUtils.open(
      $$1.extend(
        {
          content,
          btn: READY.btn,
          yes,
          btn2: cancel
        },
        type ? {} : options
      )
    );
  },
  msg(content, options, end = () => null) {
    var isOptionsIsFunction = xU.isFunction(options), rskin = READY.config.skin;
    var skin = (rskin ? rskin + " " + rskin + "-msg" : "") || "layui-layer-msg";
    var anim = DOMS_ANIM.length - 1;
    if (isOptionsIsFunction)
      end = options;
    return LayerUtils.open(
      $$1.extend(
        {
          content,
          time: 3e3,
          shade: false,
          skin,
          title: false,
          closeBtn: false,
          btn: false,
          resize: false,
          end
        },
        isOptionsIsFunction && !READY.config.skin ? {
          skin: skin + " layui-layer-hui",
          anim
        } : function() {
          options = options || {};
          if (options.icon === -1 || options.icon === void 0 && !READY.config.skin) {
            options.skin = skin + " " + (options.skin || "layui-layer-hui");
          }
          return options;
        }()
      )
    );
  },
  load(icon, options) {
    return LayerUtils.open(
      $$1.extend(
        {
          type: 3,
          icon: icon || 0,
          resize: false,
          shade: 0.01
        },
        options
      )
    );
  },
  tips(content, followSelector, options) {
    return LayerUtils.open(
      $$1.extend(
        {
          type: LayerUtils.TIPS,
          content: [content, followSelector],
          closeBtn: false,
          time: 3e3,
          shade: false,
          resize: false,
          fixed: false,
          maxWidth: 260
        },
        options
      )
    );
  },
  close(layerKey) {
    if (!layerKey) {
      return Promise.reject();
    }
    return new Promise((resolve2, reject) => {
      try {
        let removeLayerDomFromHtml = function() {
          if (type22 === "dialog" && $eleLayer.attr("data-content-type") === "object") {
            $eleLayer.children(`:not(.${LAYUI_LAYER_IFRAME})`).remove();
          } else {
            if (type22 === TYPE_IFRAME) {
              try {
                var iframe = $$1(`#${LAYUI_LAYER_CONTENT}${layerKey}`)[0];
                iframe.contentWindow.document.write("");
                iframe.contentWindow.close();
                $eleLayer.find(`.${LAYUI_LAYER_IFRAME}`)[0].removeChild(iframe);
              } catch (e2) {
              }
            }
          }
          $eleLayer[0].innerHTML = "";
          $eleLayer.remove();
          try {
            READY.end[layerKey] && READY.end[layerKey]();
            delete READY.end[layerKey];
          } catch (e2) {
          }
        };
        var $eleLayer = $$1(`#${LAYUI_LAYER}${layerKey}`);
        var type22 = $eleLayer.attr("type");
        var closeAnim = "layer-anim-close";
        if ($eleLayer.length === 0) {
          return;
        }
        if ($eleLayer.data("isOutAnim")) {
          $eleLayer.addClass("layer-anim " + closeAnim);
        }
        $$1(`#layui-layer-moves, #${LAYUI_LAYER_SHADE}${layerKey}`).remove();
        LayerUtils.ie == 6 && READY.reselect();
        READY.rescollbar(layerKey);
        if ($eleLayer.attr("minLeft")) {
          READY.minIndex--;
          READY.minLeft.push($eleLayer.attr("minLeft"));
        }
        setTimeout(function() {
          removeLayerDomFromHtml();
          resolve2(true);
        }, 200);
      } catch (error) {
        console.error(error);
        reject(false);
      }
    });
  },
  getChildFrame(selector, index2) {
    index2 = index2 || $$1(`.${LAYUI_LAYER_CONTENT}`).attr("data-layer-key");
    return $$1("#" + LAYUI_LAYER + index2).find("iframe").contents().find(selector);
  },
  getFrameIndex(name2) {
    return $$1("#" + name2).parents(`.${LAYUI_LAYER_CONTENT}`).attr("data-layer-key");
  },
  iframeAuto(index2) {
    if (!index2)
      return;
    var heg = LayerUtils.getChildFrame("html", index2).outerHeight();
    var $eleLayer = $$1("#" + LAYUI_LAYER + index2);
    var titHeight = $eleLayer.find(`.${LAYUI_LAYER_TITLE}`).outerHeight() || 0;
    var btnHeight = $eleLayer.find(`.${LAYUI_LAYER_CONTENT}`).outerHeight() || 0;
    $eleLayer.css({
      height: heg + titHeight + btnHeight
    });
    $eleLayer.find("iframe").css({
      height: heg
    });
  },
  iframeSrc(index2, url2) {
    $$1("#" + LAYUI_LAYER + index2).find("iframe").attr("src", url2);
  },
  style(index2, options, limit) {
    var $eleLayer = $$1("#" + LAYUI_LAYER + index2);
    const $contentEle = $eleLayer.find(`.${LAYUI_LAYER_CONTENT}`);
    const type22 = $eleLayer.attr("type");
    const titHeight = $eleLayer.find(`.${LAYUI_LAYER_TITLE}`).outerHeight() || 0;
    let contentHeight = $eleLayer.find(`.${LAYUI_LAYER_CONTENT}`).outerHeight() || 0;
    const [windowHeight, windowWidth] = [$win.height(), $win.width()];
    $eleLayer.attr("minLeft");
    if (type22 === TYPE_LOADING || type22 === TYPE_TIPS) {
      return;
    }
    if (!limit) {
      if (parseFloat(options.width) <= 260) {
        options.width = 260;
      }
      if (parseFloat(options.height) - titHeight - contentHeight <= 64) {
        options.height = 64 + titHeight + contentHeight;
      }
    }
    if (options.height > windowHeight) {
      options.height = parseFloat(windowHeight);
    }
    $eleLayer.css(options);
    contentHeight = $contentEle.outerHeight();
    if (type22 === TYPE_IFRAME) {
      $eleLayer.find("iframe").addClass("flex1");
    } else {
      $contentEle.css({
        height: parseFloat(options.height) - titHeight - contentHeight - parseFloat($contentEle.css("padding-top")) - parseFloat($contentEle.css("padding-bottom"))
      });
    }
  },
  min(index2, options) {
    options = options || {};
    var $eleLayer = $$1("#" + LAYUI_LAYER + index2), shadeo = $$1("#" + LAYUI_LAYER_SHADE + index2), titHeight = $eleLayer.find(`.${LAYUI_LAYER_TITLE}`).outerHeight() || 0, left = $eleLayer.attr("minLeft") || 181 * READY.minIndex + "px", position = $eleLayer.css("position"), settings = {
      width: 180,
      height: titHeight,
      position: "fixed",
      overflow: "hidden"
    };
    READY.record($eleLayer);
    if (READY.minLeft[0]) {
      left = READY.minLeft[0];
      READY.minLeft.shift();
    }
    if (options.minStack) {
      settings.left = left;
      settings.top = $win.height() - titHeight;
      $eleLayer.attr("minLeft") || READY.minIndex++;
      $eleLayer.attr("minLeft", left);
    }
    $eleLayer.attr("position", position);
    LayerUtils.style(index2, settings, true);
    $eleLayer.find(".layui-layer-min").hide();
    $eleLayer.attr("type") === "page" && $eleLayer.find(LAYUI_LAYER_CONTENT).hide();
    READY.rescollbar(index2);
    shadeo.hide();
  },
  restore(index2) {
    var $eleLayer = $$1("#" + LAYUI_LAYER + index2), shadeo = $$1("#" + LAYUI_LAYER_SHADE + index2), area = $eleLayer.attr("area").split(",");
    $eleLayer.attr("type");
    LayerUtils.style(
      index2,
      {
        width: parseFloat(area[0]),
        height: parseFloat(area[1]),
        top: parseFloat(area[2]),
        left: parseFloat(area[3]),
        position: $eleLayer.attr("position"),
        overflow: "visible"
      },
      true
    );
    $eleLayer.find(".layui-layer-max").removeClass("layui-layer-maxmin");
    $eleLayer.find(".layui-layer-min").show();
    $eleLayer.attr("type") === "page" && $eleLayer.find(LAYUI_LAYER_CONTENT).show();
    READY.rescollbar(index2);
    shadeo.show();
  },
  full(index2) {
    var $eleLayer = $$1("#" + LAYUI_LAYER + index2), timer;
    READY.record($eleLayer);
    if (!$html.attr("layer-full")) {
      $html.css("overflow", "hidden").attr("layer-full", index2);
    }
    clearTimeout(timer);
    timer = setTimeout(function() {
      var isfix = $eleLayer.css("position") === "fixed";
      LayerUtils.style(
        index2,
        {
          top: isfix ? 0 : $win.scrollTop(),
          left: isfix ? 0 : $win.scrollLeft(),
          width: $win.width(),
          height: $win.height()
        },
        true
      );
      $eleLayer.find(".layui-layer-min").hide();
    }, 100);
  },
  title(name2, layerKey) {
    $$1(`#${LAYUI_LAYER}${layerKey}`).find(`.${LAYUI_LAYER_TITLE}`).html(name2);
  },
  async closeAll(type22) {
    const needClose = [];
    $$1(`.${LAYUI_LAYER}`).each(function() {
      const $ele = $$1(this);
      if (type22) {
        if ($ele.attr("type") === type22) {
          needClose.push($ele.attr("data-layer-key"));
        }
      } else {
        needClose.push($ele.attr("data-layer-key"));
      }
    });
    return await Promise.all(needClose.map(LayerUtils.close));
  },
  setLayerTop($current) {
    const type22 = $current.attr("type");
    if ($current.hasClass("set-layer-top")) {
      return;
    } else {
      const selector = `.set-layer-top[type=${type22}]`;
      $$1(selector).removeClass("set-layer-top");
      $current.addClass("set-layer-top").appendTo($body);
    }
  }
};
class ClassLayer {
  constructor(custumSettings) {
    __publicField(this, "_layerKey", 0);
    __publicField(this, "_IDLayer", LAYUI_LAYER);
    __publicField(this, "_IDShade", LAYUI_LAYER_SHADE);
    __publicField(this, "_IDContent", LAYUI_LAYER_CONTENT);
    __publicField(this, "zIndex", 0);
    __publicField(this, "typeName", "");
    __publicField(this, "ismax", false);
    __publicField(this, "isNeedTitle", false);
    __publicField(this, "isContentTypeObject", false);
    __publicField(this, "$eleLayer", null);
    __publicField(this, "$eleShade", null);
    __publicField(this, "config", {
      type: 0,
      title: "\u4FE1\u606F",
      content: "",
      skin: "",
      area: "auto",
      offset: "auto",
      icon: -1,
      btn: "\u786E\u8BA4",
      btnAlign: "r",
      closeBtn: "1",
      shade: "0.3",
      shadeClose: false,
      during: 0,
      id: "",
      anim: 0,
      isOutAnim: true,
      maxmin: false,
      fixed: true,
      resize: true,
      onResizing: false,
      scrollbar: true,
      maxWidth: 360,
      maxHeight: 0,
      zIndex: 1,
      move: ".layui-layer-title",
      moveOut: false,
      onMoveEnd: false,
      tips: 2,
      tipsMore: false,
      success: false,
      yes: false,
      onClickClose: false,
      end: false,
      full: false,
      minStack: true
    });
    this.initConfig(custumSettings).insertLayer().addLayerListener().handleAnimation();
  }
  get cptDomShade() {
    const { config, _IDShade } = this;
    if (!config.shade) {
      return "";
    }
    return `<div class="${LAYUI_LAYER_SHADE}" id="${_IDShade}" style="z-index:${this.zIndex - 1};"></div>`;
  }
  get cptDomTitle() {
    const { config, _IDLayer } = this;
    if (this.isContentTypeObject && !this.isNeedTitle) {
      return "";
    }
    var isTitleObject = typeof config.title === "object";
    if (!isTitleObject) {
      config.title = [String(config.title), ""];
    }
    const [title, styleString] = config.title || ["", ""];
    return `<div class="${LAYUI_LAYER_TITLE}" style="${styleString}" data-layer-id="${_IDLayer}"> ${title} </div >`;
  }
  get cptDomIcon() {
    if (this.config.type == LayerUtils.MSG && this.config.icon !== -1) {
      return `<i class="layui-layer-ico layui-layer-ico${this.config.icon}></i>`;
    }
    return "";
  }
  get cptDomContent() {
    if (this.config.type == LayerUtils.DIALOG && this.isContentTypeObject) {
      return "";
    }
    return this.config.content || "";
  }
  get cptDomSetDialogOperations() {
    const { config, ismax, _IDLayer } = this;
    return '<span class="layui-layer-setwin">' + function() {
      var closebtn = ismax ? '<a class="layui-layer-min" href="javascript:;"><cite></cite></a><a class="layui-layer-ico layui-layer-max" href="javascript:;"></a>' : "";
      if (config.closeBtn) {
        closebtn += `<a data-layer-id="${_IDLayer}" class="layui-layer-ico ${LAYUI_LAYER_CLOSE} ` + LAYUI_LAYER_CLOSE + (config.title ? config.closeBtn : config.type == LayerUtils.TIPS ? "1" : "2") + '" href="javascript:;"></a>';
      }
      return closebtn;
    }() + "</span>";
  }
  get cptDomFooterBtns() {
    const { config } = this;
    if (config.btn) {
      if (typeof config.btn === "string") {
        config.btn = [config.btn, ""];
      }
      if (xU.every(config.btn, (i2) => !i2)) {
        return "";
      }
      const domButtons = xU.reduce(
        config.btn,
        (domButtonString, label) => {
          if (label) {
            domButtonString += `<a class="${LAYUI_LAYER_CONTENT}">${label}</a>`;
          }
          return domButtonString;
        },
        ""
      );
      return `<div class="${LAYUI_LAYER_CONTENT} layui-layer-btn-${config.btnAlign || ""}">${domButtons}</div>`;
    }
    return "";
  }
  get cptDomResizeBar() {
    return this.config.resize ? '<span class="layui-layer-resize"></span>' : "";
  }
  get cptDomContainer() {
    const {
      config,
      typeName,
      isContentTypeObject,
      zIndex,
      _layerKey,
      _IDLayer,
      _IDContent
    } = this;
    const fnValid = (i2) => !!i2;
    const layerWrapperClassname = [
      "flex vertical",
      "elevation-4",
      `layui-layer-${typeName}`,
      LAYUI_LAYER,
      config.skin,
      (() => {
        if ([LayerUtils.IFRAME, LayerUtils.MSG].includes(config.type) && !config.shade) {
          return "layui-layer-border";
        }
        return "";
      })()
    ].filter(fnValid).join(" ");
    const classContent = [
      LAYUI_LAYER_CONTENT,
      config.contentClass,
      config.type == LayerUtils.MSG && config.icon !== -1 ? "layui-layer-padding" : "",
      config.type == LayerUtils.LOADING ? `layui-layer-loading${config.icon}` : ""
    ].filter(fnValid).join(" ");
    const [width, height] = config.area || [];
    return `
<div id="${_IDLayer}" layer-wrapper="${_IDLayer}" type="${typeName}"
		class="${layerWrapperClassname}" 
		data-z-index="${zIndex}"
		data-layer-key="${_layerKey}"
		data-during-time="${config.during}"
		data-content-type="${isContentTypeObject ? "object" : "string"}"
		style="position:fixed;
			z-index:${zIndex};
			width:${width}; 
			height:${height};"
		>
			${this.cptDomTitle}
			<div class="${classContent}" id="${_IDContent}">
				${this.cptDomIcon}
				${this.cptDomContent}
			</div>
			${this.cptDomSetDialogOperations}
			${this.cptDomFooterBtns}
			${this.cptDomResizeBar}
</div>`;
  }
  initConfig(custumSettings) {
    const layerInstance = this;
    layerInstance.config = Object.assign(layerInstance.config, custumSettings);
    layerInstance.config.icon = custumSettings.type === LayerUtils.LOADING ? 0 : -1;
    layerInstance.config.maxWidth = $win.width() - 15 * 2;
    layerInstance.config.custumSettings = custumSettings;
    const { config } = layerInstance;
    layerInstance._layerKey = xU.genId("");
    layerInstance._IDLayer = `${LAYUI_LAYER}${layerInstance._layerKey}`;
    layerInstance._IDShade = `${LAYUI_LAYER_SHADE}${layerInstance._layerKey}`;
    layerInstance._IDContent = `${LAYUI_LAYER_CONTENT}${layerInstance._layerKey}`;
    layerInstance.zIndex = READY.zIndex + layerInstance.config.zIndex;
    layerInstance.typeName = READY.type[config.type || 0];
    layerInstance.isNeedTitle = [LayerUtils.IFRAME, LayerUtils.DIALOG].includes(
      Number(config.type)
    );
    layerInstance.ismax = Boolean(config.maxmin && layerInstance.isNeedTitle);
    layerInstance.isContentTypeObject = typeof config.content === "object";
    layerInstance.config.onClickClose = async (params) => {
      const isFalse = (val) => xU.isBoolean(val) && !val;
      if (custumSettings.onClickClose) {
        if (isFalse(await custumSettings.onClickClose(params))) {
          return false;
        }
      } else if (custumSettings.onBeforeClose) {
        if (isFalse(await custumSettings.onBeforeClose(params))) {
          return false;
        }
      }
      return true;
    };
    const { isContentTypeObject } = layerInstance;
    if (typeof config.area === "string") {
      config.area = config.area === "auto" ? ["", ""] : [config.area, ""];
    }
    if (config.shift) {
      config.anim = config.shift;
    }
    if (LayerUtils.ie == 6) {
      config.fixed = false;
    }
    const processContentStrategy = {
      [LayerUtils.MSG]() {
        config.btn = "btn" in config ? config.btn : READY.btn[0];
        LayerUtils.closeAll("dialog");
      },
      [LayerUtils.IFRAME]() {
        let scrolling = "auto";
        let src2 = config.content;
        if (isContentTypeObject) {
          scrolling = config.content[1] || "auto";
          src2 = config.content[0] || "";
        }
        config.btn = [];
        config.content = `
<iframe class="layui-layer-load flex flex1" 
		scrolling="${scrolling}" 
		src="${src2}"
		allowtransparency="true"
		onload="this.className=''" 
		style="height:100%;" 
		frameborder="0">
</iframe>`;
      },
      [LayerUtils.LOADING]() {
        delete config.title;
        delete config.closeBtn;
        config.icon === -1 && config.icon === 0;
        LayerUtils.closeAll("loading");
      },
      [LayerUtils.TIPS]() {
        var _a2;
        if (!isContentTypeObject) {
          config.content = [config.content, "body"];
        }
        config.follow = config.content[1];
        const arrow = '<i class="layui-layer-TipsG"></i>';
        config.content = `<div style="max-width:${((_a2 = config == null ? void 0 : config.custumSettings) == null ? void 0 : _a2.maxWidth) || "300px"};overflow:auto;">${config.content[0]}<div>${arrow}`;
        delete config.title;
        config.btn = [];
        config.tips = typeof config.tips === "object" ? config.tips : [config.tips, true];
        config.tipsMore || LayerUtils.closeAll("tips");
      }
    };
    const processContentFn = processContentStrategy[config.type];
    processContentFn && processContentFn();
    return layerInstance;
  }
  async setLayerPosition() {
    await xU.sleep(34);
    const layerInstance = this;
    const { config, _layerKey } = layerInstance;
    layerInstance.offset();
    if (config.type === LayerUtils.TIPS) {
      layerInstance.setTips();
    }
    layerInstance.$eleLayer.css("visibility", "visible");
    if (config.fullscreen) {
      setTimeout(() => {
        LayerUtils.full(_layerKey);
      }, 500);
    }
    if (config.fixed) {
      $win.on("resize", function() {
        layerInstance.offset();
        if (/^\d+%$/.test(config.area[0]) || /^\d+%$/.test(config.area[1])) {
          layerInstance.setPosition();
        }
        if (config.type == LayerUtils.tips) {
          layerInstance.setTips();
        }
      });
    }
    if (typeof config.during === "number" && config.during > 0) {
      setTimeout(function() {
        LayerUtils.close(layerInstance._layerKey);
      }, config.during);
    }
    LayerUtils.setLayerTop(layerInstance.$eleLayer);
    return layerInstance;
  }
  handleAnimation() {
    const layerInstance = this;
    const { config } = layerInstance;
    if (DOMS_ANIM[config.anim]) {
      var animClass = "layer-anim " + DOMS_ANIM[config.anim];
      layerInstance.$eleLayer.addClass(animClass).one(
        "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend",
        function() {
          $$1(this).removeClass(animClass);
        }
      );
    }
    if (config.isOutAnim) {
      layerInstance.$eleLayer.data("isOutAnim", true);
    }
    return layerInstance;
  }
  insertLayer() {
    const layerInstance = this;
    const { config, _layerKey, _IDShade } = layerInstance;
    layerInstance.$eleLayer = $$1(layerInstance.cptDomContainer);
    if (xU.isObject(config.content) && (xU.isString(config.content) || xU.isString(config.content.jquery))) {
      const $content = $$1(config.content);
      layerInstance.$eleLayer.find(`.${LAYUI_LAYER_CONTENT}`).append($content);
    }
    layerInstance.$eleLayer.css({
      visibility: "hidden",
      top: "100%",
      left: "100%"
    });
    $body.append(layerInstance.$eleLayer);
    if (layerInstance.cptDomShade) {
      $body.append(layerInstance.cptDomShade);
      layerInstance.$eleShade = $$1(`#${_IDShade}`);
      layerInstance.$eleShade.css({
        "background-color": config.shade[1] || "#000",
        opacity: config.shade[0] || config.shade
      });
    }
    if (!config.scrollbar) {
      $html.css("overflow", "hidden").attr("layer-full", _layerKey);
    }
    layerInstance.setLayerPosition();
    return layerInstance;
  }
  offset() {
    var layerInstance = this, config = layerInstance.config, $eleLayer = layerInstance.$eleLayer;
    var area = [$eleLayer.outerWidth(), $eleLayer.outerHeight()];
    var whetherOffsetIsObject = typeof config.offset === "object";
    layerInstance.offsetTop = ($win.height() - area[1]) / 2;
    layerInstance.offsetLeft = ($win.width() - area[0]) / 2;
    if (whetherOffsetIsObject) {
      const [top, left] = config.offset;
      layerInstance.offsetTop = top;
      layerInstance.offsetLeft = left || layerInstance.offsetLeft;
    } else if (config.offset !== "auto") {
      if (config.offset === "t") {
        layerInstance.offsetTop = 0;
      } else if (config.offset === "r") {
        layerInstance.offsetLeft = $win.width() - area[0];
      } else if (config.offset === "b") {
        layerInstance.offsetTop = $win.height() - area[1];
      } else if (config.offset === "l") {
        layerInstance.offsetLeft = 0;
      } else if (config.offset === "lt") {
        layerInstance.offsetTop = 0;
        layerInstance.offsetLeft = 0;
      } else if (config.offset === "lb") {
        layerInstance.offsetTop = $win.height() - area[1];
        layerInstance.offsetLeft = 0;
      } else if (config.offset === "rt") {
        layerInstance.offsetTop = 0;
        layerInstance.offsetLeft = $win.width() - area[0];
      } else if (config.offset === "rb") {
        layerInstance.offsetTop = $win.height() - area[1];
        layerInstance.offsetLeft = $win.width() - area[0];
      } else {
        layerInstance.offsetTop = config.offset;
      }
    }
    if (!config.fixed) {
      layerInstance.offsetTop = /%$/.test(layerInstance.offsetTop) ? $win.height() * parseFloat(layerInstance.offsetTop) / 100 : parseFloat(layerInstance.offsetTop);
      layerInstance.offsetLeft = /%$/.test(layerInstance.offsetLeft) ? $win.width() * parseFloat(layerInstance.offsetLeft) / 100 : parseFloat(layerInstance.offsetLeft);
      layerInstance.offsetTop += $win.scrollTop();
      layerInstance.offsetLeft += $win.scrollLeft();
    }
    if ($eleLayer.attr("minLeft")) {
      layerInstance.offsetTop = $win.height() - ($eleLayer.find(`.${LAYUI_LAYER_TITLE}`).outerHeight() || 0);
      layerInstance.offsetLeft = $eleLayer.css("left");
    }
    $eleLayer.css({
      top: layerInstance.offsetTop,
      left: layerInstance.offsetLeft
    });
    return layerInstance;
  }
  async setTips() {
    const layerInstance = this;
    const { config, $eleLayer } = layerInstance;
    const [tipsDomWidth, tipsdomHeight] = [
      $eleLayer.outerWidth(),
      $eleLayer.outerHeight()
    ];
    let $eleFollow = $$1(config.follow);
    if ($eleFollow.length == 0) {
      $eleFollow = $body;
    }
    var followInfo = {
      width: $eleFollow.outerWidth(),
      height: $eleFollow.outerHeight(),
      top: $eleFollow.offset().top,
      left: $eleFollow.offset().left,
      tipTop: 0,
      tipLeft: 0
    };
    if (config.openAtPoint) {
      const { top, left } = config.openAtPoint;
      followInfo.top = top;
      followInfo.left = left;
    }
    var $tipsG = $eleLayer.find(".layui-layer-TipsG");
    const [direction, customColor] = config.tips || ["1", ""];
    function makeLeftAuto() {
      if (followInfo.left + tipsDomWidth - $win.width() > 0) {
        followInfo.tipLeft = followInfo.left + followInfo.width - tipsDomWidth;
        $tipsG.css({ right: 12, left: "auto" });
      } else {
        followInfo.tipLeft = followInfo.left;
      }
    }
    const direction_strategy = {
      [LayerUtils.UP]() {
        makeLeftAuto();
        followInfo.tipTop = followInfo.top - tipsdomHeight - 10;
        $tipsG.removeClass("layui-layer-TipsB").addClass("layui-layer-TipsT").css("border-right-color", customColor);
        followInfo.top - ($win.scrollTop() + tipsdomHeight + 8 * 2) < 0 && direction_strategy[2]();
      },
      [LayerUtils.RIGHT]() {
        followInfo.tipLeft = followInfo.left + followInfo.width + 10;
        followInfo.tipTop = followInfo.top;
        $tipsG.removeClass("layui-layer-TipsL").addClass("layui-layer-TipsR").css("border-bottom-color", customColor);
        $win.width() - (followInfo.left + followInfo.width + tipsDomWidth + 8 * 2) > 0 || direction_strategy[3]();
      },
      [LayerUtils.BOTTOM]() {
        makeLeftAuto();
        followInfo.tipTop = followInfo.top + followInfo.height + 10;
        $tipsG.removeClass("layui-layer-TipsT").addClass("layui-layer-TipsB").css("border-right-color", customColor);
        followInfo.top - $win.scrollTop() + followInfo.height + tipsdomHeight + 8 * 2 - $win.height() > 0 && direction_strategy[4]();
      },
      [LayerUtils.LEFT]() {
        followInfo.tipLeft = followInfo.left - tipsDomWidth - 10;
        followInfo.tipTop = followInfo.top;
        $tipsG.removeClass("layui-layer-TipsR").addClass("layui-layer-TipsL").css("border-bottom-color", customColor);
        tipsDomWidth + 8 * 2 - followInfo.left > 0 && direction_strategy[1]();
      }
    };
    direction_strategy[direction] && direction_strategy[direction]();
    $eleLayer.attr(DATA_TIPS_FOLLOW_ID, config.follow.substring(1));
    $eleLayer.find(`.${LAYUI_LAYER_CONTENT}`).css({
      "background-color": customColor,
      "padding-right": config.closeBtn ? "30px" : ""
    });
    $eleLayer.css({
      left: followInfo.tipLeft - $win.scrollLeft(),
      top: followInfo.tipTop - $win.scrollTop(),
      "transform-origin": [
        $tipsG.hasClass("layui-layer-TipsT") ? "top" : "bottem",
        $tipsG.hasClass("layui-layer-TipsL") ? "left" : "right"
      ].join(" ")
    });
    if (!customColor) {
      $tipsG.remove();
    }
  }
  onMoveOrResize() {
    var layerInstance = this;
    const { config, $eleLayer } = layerInstance;
    const $eleMove = $eleLayer.find(config.move);
    const $eleResize = $eleLayer.find(".layui-layer-resize");
    $eleMove.css("cursor", "move");
    $eleMove.on("mousedown", function(e2) {
      LayerUtils.setLayerTop($eleLayer);
      e2.preventDefault();
      if (config.move) {
        READY.moveOrResizeInstance = layerInstance;
        READY.moveOrResizeType = "move";
        READY.pointMousedown = [
          e2.clientX - parseFloat($eleLayer.css("left")),
          e2.clientY - parseFloat($eleLayer.css("top"))
        ];
        $MoveMask.css("cursor", "move").show();
      }
    });
    $eleResize.on("mousedown", function(e2) {
      LayerUtils.setLayerTop($eleLayer);
      e2.preventDefault();
      READY.moveOrResizeInstance = layerInstance;
      READY.moveOrResizeType = "resize";
      READY.pointMousedown = [e2.clientX, e2.clientY];
      READY.moveOrResizeWH = [$eleLayer.outerWidth(), $eleLayer.outerHeight()];
      $MoveMask.css("cursor", "se-resize").show();
    });
    return layerInstance;
  }
  addLayerListener() {
    const layerInstance = this;
    const { $eleLayer, config } = layerInstance;
    if (config.success) {
      if (config.type == LayerUtils.IFRAME) {
        $eleLayer.find("iframe").on("load", function() {
          config.success.call(this, $eleLayer, layerInstance._layerKey);
        });
      } else {
        config.success($eleLayer, layerInstance._layerKey);
      }
    }
    $eleLayer.find(`.${LAYUI_LAYER_CONTENT}`).children("a").on("click", function() {
      var index2 = $$1(this).index();
      if (index2 === 0) {
        if (config.yes) {
          config.yes(layerInstance._layerKey, $eleLayer);
        } else if (config["btn1"]) {
          config["btn1"](layerInstance._layerKey, $eleLayer);
        } else {
          LayerUtils.close(layerInstance._layerKey);
        }
      } else {
        var close3 = config["btn" + (index2 + 1)] && config["btn" + (index2 + 1)](layerInstance._layerKey, $eleLayer);
        close3 === false || LayerUtils.close(layerInstance._layerKey);
      }
    });
    $eleLayer.find(`.${LAYUI_LAYER_CLOSE}`).on("click", async function handleClickCloseBtn() {
      let isClosed = false;
      const isNeedClose = await config.onClickClose({
        _layerKey: layerInstance._layerKey,
        $eleLayer,
        dialogOptions: ""
      });
      if (isNeedClose) {
        if (!isClosed) {
          isClosed = await LayerUtils.close(layerInstance._layerKey);
        }
        if (!isClosed) {
          await LayerUtils.close($$1(this).attr("data-layer-id"));
        }
      }
    });
    if (config.shadeClose) {
      layerInstance.$eleShade.on("click", function() {
        LayerUtils.close(layerInstance._layerKey);
      });
    }
    $eleLayer.find(".layui-layer-min").on("click", function() {
      var min3 = config.min && config.min($eleLayer, layerInstance._layerKey);
      min3 === false || LayerUtils.min(layerInstance._layerKey, config);
    });
    $eleLayer.find(".layui-layer-max").on("click", function() {
      if ($$1(this).hasClass("layui-layer-maxmin")) {
        LayerUtils.restore(layerInstance._layerKey);
        config.restore && config.restore($eleLayer, layerInstance._layerKey);
      } else {
        LayerUtils.full(layerInstance._layerKey, config);
        setTimeout(function() {
          config.full && config.full($eleLayer, layerInstance._layerKey);
        }, 100);
      }
    });
    if (config.end) {
      READY.end[layerInstance._layerKey] = config.end;
    }
    if (![LayerUtils.TIPS, LayerUtils.MSG, LayerUtils.LOADING].includes(
      config.type
    )) {
      layerInstance.onMoveOrResize();
    }
    return layerInstance;
  }
}
LayerUtils.cache || {};
$document.on("click.setLayerTop", "[layer-wrapper]", (event2) => {
  const { currentTarget } = event2;
  const $currentTarget = $$1(currentTarget);
  LayerUtils.setLayerTop($currentTarget);
}).on(
  "mousemove",
  `.${LAYUI_LAYER_MOVE}`,
  function(e2) {
    const { moveOrResizeInstance, moveOrResizeType, onMoving } = READY;
    if (moveOrResizeInstance instanceof ClassLayer) {
      const { $eleLayer, config } = moveOrResizeInstance;
      if (moveOrResizeType === "move") {
        e2.preventDefault();
        let X = e2.clientX - READY.pointMousedown[0];
        let Y2 = e2.clientY - READY.pointMousedown[1];
        const fixed = $eleLayer.css("position") === "fixed";
        READY.stX = fixed ? 0 : $win.scrollLeft();
        READY.stY = fixed ? 0 : $win.scrollTop();
        if (!config.moveOut) {
          let setRig = $win.width() - $eleLayer.outerWidth() + READY.stX;
          let setBot = $win.height() - $eleLayer.outerHeight() + READY.stY;
          if (X < READY.stX) {
            X = READY.stX;
          }
          if (X > setRig) {
            X = setRig;
          }
          if (Y2 < READY.stY) {
            Y2 = READY.stY;
          }
          if (Y2 > setBot) {
            Y2 = setBot;
          }
        }
        $eleLayer.css({ left: X, top: Y2 });
      }
      if (config.resize) {
        if (READY.moveOrResizeType === "resize") {
          e2.preventDefault();
          const X = e2.clientX - READY.pointMousedown[0];
          const Y2 = e2.clientY - READY.pointMousedown[1];
          $eleLayer.css({
            width: READY.moveOrResizeWH[0] + X,
            height: READY.moveOrResizeWH[1] + Y2
          });
          config.onResizing && config.onResizing($eleLayer);
        }
      }
    } else if (typeof onMoving == "function") {
      event && onMoving(event);
    }
  }
).on("mouseup", function(e2) {
  if (READY.moveOrResizeInstance instanceof ClassLayer) {
    const { config } = READY.moveOrResizeInstance;
    if (config.onMoveEnd) {
      config.onMoveEnd(READY.moveOrResizeInstance);
    }
    READY.moveOrResizeInstance = false;
  }
  $MoveMask.hide();
});
const EcsPressHandler = xU.debounce(async function(event2, dialogOptions) {
  const $antModal = $$1(".ant-modal-root");
  if ($antModal.length > 0) {
    return;
  }
  if (event2.keyCode === KEY.esc) {
    await dialogOptions.closeDialog();
  }
}, 100);
const xDialogFooter = defineComponent({
  props: ["configs"],
  computed: {
    onCancel() {
      return this.configs.onCancel;
    },
    onOk() {
      return this.configs.onOk;
    },
    vDomOk() {
      var _a2;
      if ((_a2 = this.configs) == null ? void 0 : _a2.hideOk) {
        return null;
      }
      const configs = {
        text: xU.isInput(this.configs.textOk) ? this.configs.textOk : State_UI.$t("\u786E\u5B9A").label,
        disabled: xU.isInput(this.configs.disabledOk) ? this.configs.disabledOk : false,
        onClick: this.onOk || xU.doNothing
      };
      return createVNode(resolveComponent("xButton"), {
        "type": "primary",
        "class": "ml10",
        "configs": configs
      }, null);
    },
    vDomCancel() {
      var _a2;
      if ((_a2 = this.configs) == null ? void 0 : _a2.hideCancel) {
        return null;
      }
      const configs = {
        text: xU.isInput(this.configs.textCancel) ? this.configs.textCancel : State_UI.$t("\u53D6\u6D88").label,
        disabled: xU.isInput(this.configs.disabledCancel) ? this.configs.disabledCancel : false,
        onClick: this.onCancel || xU.doNothing
      };
      return createVNode(resolveComponent("xButton"), {
        "class": "ml10",
        "configs": configs
      }, null);
    },
    vDomContent() {
      if (this.$slots.default) {
        return this.$slots.default();
      } else {
        return createVNode(Fragment, null, [this.vDomCancel, this.vDomOk]);
      }
    }
  },
  render() {
    return createVNode("div", {
      "class": "flex middle end ant-modal-footer"
    }, [this.vDomContent]);
  }
});
const installUIDialogComponent = (UI2, {
  appPlugins: appPlugins2,
  dependState
}, app) => {
  app.component("xDialogFooter", xDialogFooter);
  UI2.dialog.component = async (dialogOptions) => new Promise((resolve2, reject) => {
    const {
      component: BussinessComponent,
      title,
      area
    } = dialogOptions;
    const id = `xDialog_${Date.now()}`;
    let $container = $$1("<div/>", {
      id
    });
    const _dialogId = `#${id}`;
    if (dialogOptions.yes) {
      dialogOptions._yes = dialogOptions.yes;
      delete dialogOptions.yes;
    }
    dialogOptions.closeDialog = async () => {
      let isCloseDialog = true;
      if (dialogOptions.onBeforeClose) {
        const res = await dialogOptions.onBeforeClose({
          dialogOptions,
          _layerKey: "",
          $eleLayer: ""
        });
        if (xU.isBoolean(res) && !res) {
          isCloseDialog = false;
        }
      }
      if (isCloseDialog) {
        LayerUtils.close(handleEcsPress._layerKey);
      }
    };
    let dialogVueApp = null;
    let handleEcsPress = {
      _layerKey: "",
      handler: (event2) => EcsPressHandler(event2, dialogOptions),
      on(_layerKey) {
        handleEcsPress._layerKey = _layerKey;
        if (!dialogOptions.isEcsCloseDialog) {
          return;
        }
        $$1(document).on(`keyup.${_dialogId}`, handleEcsPress.handler);
      },
      off() {
        $$1(document).off(`keyup.${_dialogId}`, handleEcsPress.handler);
        handleEcsPress = null;
      }
    };
    const layerOptions = xU.merge(dialogOptions, {
      contentClass: "flex1",
      type: LayerUtils.DIALOG,
      title: [title || ""],
      area: area || [],
      content: $container,
      offset: ["160px", null],
      btn: [],
      success($eleLayer, _layerKey) {
        handleEcsPress.on(_layerKey);
        dialogOptions._dialog$ele = $eleLayer;
        dialogOptions._layerKey = _layerKey;
        try {
          dialogVueApp = createApp(defineComponent({
            components: {
              BussinessComponent
            },
            created() {
              this.dialogOptions._contentInstance = this;
              resolve2(this.dialogOptions);
            },
            data() {
              return {
                dialogOptions
              };
            },
            render() {
              return createVNode("div", {
                "class": "ventose-dialog-content",
                "data-el-id": _dialogId
              }, [createVNode(BussinessComponent, {
                "propDialogOptions": this.dialogOptions
              }, null)]);
            }
          }));
          dialogVueApp.use(appPlugins2, {
            dependState
          });
          dialogVueApp.mount(_dialogId);
        } catch (e2) {
          console.error(e2);
        }
        dialogOptions.onAfterOpenDialoag && dialogOptions.onAfterOpenDialoag(dialogVueApp);
      },
      cancel() {
        dialogOptions.closeDialog();
        return false;
      },
      end() {
        handleEcsPress.off();
        $container.remove();
        $container = null;
        if (dialogVueApp) {
          dialogVueApp.unmount();
          dialogVueApp = null;
        }
        dialogOptions.payload = null;
        dialogOptions._contentInstance = null;
        dialogOptions = null;
      }
    }, xU.omit(dialogOptions, ["end", "cancel", "success", "content"]));
    LayerUtils.open(layerOptions);
  });
};
const appAddPlugin = {};
const appDependState = {};
const timer4CloseTips = {};
const visibleArea = {};
const DATA_APP_ID = "data-app-id";
const DATA_FOLLOW_ID = "data-follow-id";
const TIMEOUT_DELAY = 200;
const tipsOptionsCollection = {};
const tipsKeys = {};
function fnShowTips({
  $ele,
  followId,
  appId,
  event: event2
}) {
  const options = tipsOptionsCollection[followId] || {
    content: ""
  };
  if (!options.content) {
    if (options.onlyEllipsis) {
      const eleWidth = $ele.width() || 0;
      const text = $ele.text();
      const $div = $$1(`<span style="position:fixed;top:0;left:0;opacity: 0;height: 0;letter-spacing: normal;">${text}</span>`);
      $div.appendTo($$1("body"));
      const innerWidth2 = $div.width() || 0;
      $div.remove();
      if (innerWidth2 > eleWidth) {
        options.content = text;
      }
    } else {
      return;
    }
  }
  let tipsContent = options.content;
  if (!tipsContent) {
    return;
  }
  let app;
  const placement = (() => {
    const placement_strategy = {
      top: 1,
      right: 2,
      bottom: 3,
      left: 4
    };
    return placement_strategy[options.placement || "top"];
  })();
  let layerTipsOptions = {
    tips: [placement, "#fff"],
    during: 1e3 * 60 * 10
  };
  const isOpenAtPoint = $ele.attr("data-open-at-point");
  if (isOpenAtPoint) {
    layerTipsOptions.openAtPoint = {
      left: $ele.clientX,
      top: $ele.clientY
    };
  }
  if (xU.isPlainObject(options.content)) {
    const id = `${followId}_content`;
    tipsContent = `<div id="${id}"></div>`;
    layerTipsOptions.success = function success(indexPanel, layerIndex) {
      app = createApp(options.content);
      app.use(appAddPlugin[appId], {
        dependState: appDependState[appId]
      });
      app.mount(`#${id}`);
      options.afterOpenDialoag && options.afterOpenDialoag(app);
    };
    layerTipsOptions.end = function end() {
      if (app) {
        app.unmount();
        app = null;
      }
    };
  }
  if (options.maxWidth) {
    layerTipsOptions.maxWidth = maxWidth;
  }
  setTimeout(() => {
    if (visibleArea[followId]) {
      tipsKeys[followId] = LayerUtils.tips(tipsContent, `#${followId}`, layerTipsOptions);
    }
  }, options.delay || 32);
}
function installPopoverDirective(app, appSettings) {
  const appId = xU.genId("appId");
  appAddPlugin[appId] = appSettings.appPlugins;
  appDependState[appId] = appSettings.dependState;
  app.directive("uiPopover", {
    mounted(el, binding) {
      init();
      updateMounted(el, binding);
      function init() {
        const followId = xU.genId("xPopoverTarget");
        const $ele = $$1(el);
        $ele.addClass("x-ui-popover").attr("id", followId).attr(DATA_APP_ID, appId).attr(DATA_FOLLOW_ID, followId);
      }
    },
    beforeUpdate(el, binding) {
      updateMounted(el, binding);
    },
    unmounted(el) {
      const followId = $$1(el).attr(DATA_FOLLOW_ID);
      if (typeof tipsKeys[followId] == "string" && tipsKeys[followId]) {
        LayerUtils.close(tipsKeys[followId]);
      }
      delete tipsOptionsCollection[followId];
      delete visibleArea[followId];
    }
  });
  function updateMounted(el, binding) {
    var _a2, _b, _c, _d;
    const $ele = $$1(el);
    const followId = $ele.attr(DATA_FOLLOW_ID);
    if (binding.value) {
      tipsOptionsCollection[followId] = binding.value;
      if ((_a2 = binding.value) == null ? void 0 : _a2.trigger) {
        $ele.attr("data-trigger", (_b = binding.value) == null ? void 0 : _b.trigger);
        const classStrategy = {
          rightClick: "pointer-right-click"
        };
        const className = classStrategy[(_c = binding.value) == null ? void 0 : _c.trigger] || "pointer";
        if (!$ele.hasClass(className)) {
          $ele.addClass();
        }
      }
      if ((_d = binding.value) == null ? void 0 : _d.openAtPoint) {
        $ele.attr("data-open-at-point", true);
      }
    }
  }
}
function inVisibleArea(followId) {
  if (timer4CloseTips[followId]) {
    clearTimeout(timer4CloseTips[followId]);
    delete timer4CloseTips[followId];
  }
  visibleArea[followId] = true;
}
function closeTips(followId, options = {}) {
  delete visibleArea[followId];
  timer4CloseTips[followId] = setTimeout(() => {
    const layerIndex = tipsKeys[followId];
    if (layerIndex) {
      LayerUtils.close(layerIndex).then(() => {
        delete tipsKeys[followId];
        delete timer4CloseTips[followId];
      });
    }
  }, TIMEOUT_DELAY);
}
function handleClick(event2) {
  event2.preventDefault();
  const $ele = $$1(this);
  const followId = $ele.attr(DATA_FOLLOW_ID);
  const appId = $ele.attr(DATA_APP_ID);
  visibleArea[followId] = true;
  if (tipsKeys[followId]) {
    closeTips(followId);
  } else {
    fnShowTips({
      $ele,
      followId,
      appId,
      event: event2
    });
  }
}
$$1(document).on("click.uiPopver", `[${DATA_FOLLOW_ID}][data-trigger=click]`, handleClick);
$$1(document).on("contextmenu.uiPopver", `[${DATA_FOLLOW_ID}][data-trigger=rightClick]`, handleClick);
$$1(document).on("mouseenter.uiPopver", `[${DATA_FOLLOW_ID}]`, function(event2) {
  const $ele = $$1(this);
  const followId = $ele.attr(DATA_FOLLOW_ID);
  if (visibleArea[followId]) {
    return;
  } else {
    const appId = $ele.attr(DATA_APP_ID);
    inVisibleArea(followId);
    if (tipsKeys[followId]) {
      return;
    }
    if ($ele.attr("data-trigger") === "click") {
      return;
    }
    if ($ele.attr("data-trigger") === "rightClick") {
      return;
    }
    fnShowTips({
      $ele,
      followId,
      appId,
      event: event2
    });
  }
});
$$1(document).on("mouseleave.uiPopver", `[${DATA_FOLLOW_ID}]`, function(event2) {
  const followId = $$1(this).attr(DATA_FOLLOW_ID);
  closeTips(followId);
});
$$1(document).on("mouseenter.uiPopverTips", `[${DATA_TIPS_FOLLOW_ID}]`, function(event2) {
  const followId = $$1(this).attr(DATA_TIPS_FOLLOW_ID);
  inVisibleArea(followId);
});
$$1(document).on("mouseleave.uiPopverTips", `[${DATA_TIPS_FOLLOW_ID}]`, function(event2) {
  const followId = $$1(this).attr(DATA_TIPS_FOLLOW_ID);
  closeTips(followId);
});
function installLoading(app, options = {}) {
  app.directive("loading", {
    updated(el, binding) {
      if (binding.value) {
        $$1(el).addClass("x-loading");
      } else {
        $$1(el).removeClass("x-loading");
      }
    }
  });
}
function installMoveDirective(app) {
  app.directive("uiMove", {
    mounted(el, binding) {
      if (binding.value) {
        if (binding.value.onMoving) {
          const $ele = $$1(el);
          const id = xU.genId("xResize");
          $ele.attr(DATA_V_UI_MOVE, id);
          $ele.on("mousedown", function(event2) {
            $MoveMask.css("cursor", "move").show();
            const clickInfo = xU.getLeftTopFromAbsolute($ele);
            clickInfo.w = $ele.width();
            clickInfo.h = $ele.height();
            const {
              top,
              left
            } = xU.getLeftTopFromTranslate($ele);
            clickInfo.translateX = left;
            clickInfo.translateY = top;
            READY.onMoving = (movingEvent) => {
              binding.value.onMoving({
                $ele,
                clickInfo,
                clickEvent: event2,
                movingEvent
              });
            };
          });
        }
      }
    },
    unmounted(el) {
      const $ele = $$1(el);
      $ele.attr(DATA_V_UI_MOVE);
    }
  });
}
const installDirective = (app, options) => {
  installPopoverDirective(app, options);
  [installLoading, installMoveDirective].forEach((install14) => install14(app));
};
function _isSlot$7(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
let xItemNoPropCount = 0;
function defItem(options) {
  const configs = defItem.item(options);
  return {
    [configs.prop]: configs
  };
}
defItem.item = (options) => {
  let itemType = options.itemType || "Input";
  if (xU.isObject(itemType)) {
    itemType = markRaw(itemType);
  }
  return xU.merge({
    prop: `xItem${xItemNoPropCount++}`,
    itemTips: {
      type: "",
      msg: ""
    }
  }, options, {
    itemType: options.itemType || "Input"
  });
};
defItem.labelWithTips = ({
  label,
  tips,
  icon
}) => {
  return createVNode("span", {
    "class": "flex middle"
  }, [label, createVNode(resolveComponent("aTooltip"), {
    "title": tips
  }, _isSlot$7(icon) ? icon : {
    default: () => [icon]
  })]);
};
const get$head = () => {
  let $head = $$1("html head");
  if (!xU.is$Selected($head)) {
    $head = $$1("<head/>");
    $head.prependTo($$1("html"));
  }
  return $head;
};
const get$title = () => {
  let $head = get$head();
  let $title = $head.find("title");
  if (!xU.is$Selected($title)) {
    $title = $$1("<title/>");
    $title.prependTo($head);
  }
  return $title;
};
const setDocumentTitle = (title) => {
  get$title().text(title);
};
const pickValueFrom = (configs) => {
  return xU.reduce(
    configs,
    (target, config, prop) => {
      try {
        target[prop] = JSON.parse(JSON.stringify(config.value));
      } catch (error) {
      }
      return target;
    },
    {}
  );
};
const setValueTo = (configs, values) => {
  return xU.map(
    values,
    (value, prop) => {
      if (configs[prop]) {
        configs[prop].value = value;
        if (xU.isFunction(configs[prop].onChange)) {
          configs[prop].onChange(value);
        }
      }
    },
    {}
  );
};
const useModel = (type4) => {
  return ({
    title = "",
    content = ""
  }) => {
    return new Promise((resolve2, reject) => {
      title = ((isDefault) => {
        if (isDefault) {
          const title_map = {
            success: State_UI.$t("\u6210\u529F").label,
            info: State_UI.$t("\u63D0\u793A").label,
            error: State_UI.$t("\u9519\u8BEF").label,
            warning: State_UI.$t("\u8B66\u544A").label
          };
          return title_map[type4];
        } else {
          return title;
        }
      })(!title);
      Modal[type4]({
        title,
        icon: createVNode("link", {
          "rel": "icon",
          "type": "image/svg+xml",
          "href": "/ExclamationCircleOutlined.svg"
        }, null),
        content,
        onOk() {
          resolve2("ok");
        },
        onCancel() {
          reject();
        },
        okText: State_UI.$t("\u786E\u5B9A").label,
        class: "test"
      });
    });
  };
};
LayerUtils.loading = function(indexDelete) {
  this.loading.count = this.loading.count || 1;
  this.loading.deep = this.loading.deep || /* @__PURE__ */ new Set();
  $$1("body").trigger("click");
  if (indexDelete >= 0) {
    if (this.loading.deep.has(indexDelete)) {
      this.loading.deep.delete(indexDelete);
      if (this.loading.deep.size === 0) {
        LayerUtils.close(this.loading.index);
      }
    } else {
      console.error("loading", indexDelete);
    }
  } else {
    let indexAdd = this.loading.count++;
    if (this.loading.deep.size === 0) {
      this.loading.index = LayerUtils.load(1);
    }
    this.loading.deep.add(indexAdd);
    return indexAdd;
  }
};
const UI = {
  confirm(options) {
    options.okText = options.okText || State_UI.$t("\u786E\u5B9A").label;
    options.cancelText = options.cancelText || State_UI.$t("\u53D6\u6D88").label;
    Modal.confirm(options);
  },
  dialog: {
    component: async (options) => null,
    success: useModel("success"),
    info: useModel("info"),
    error: useModel("error"),
    warning: useModel("warning"),
    confirm: (options) => {
      return new Promise(async (resolve2, reject) => {
        options.okText = options.okText || State_UI.$t("\u786E\u5B9A").label;
        options.cancelText = options.cancelText || State_UI.$t("\u53D6\u6D88").label;
        if (options.onOk) {
          const onOk = options.onOk;
          options.onOk = () => {
            return onOk(resolve2, reject);
          };
        } else {
          options.onOk = () => resolve2("ok");
        }
        if (options.onCancel) {
          const onCancel = options.onCancel;
          options.onCancel = () => {
            onCancel(resolve2, reject);
          };
        } else {
          options.onCancel = () => reject();
        }
        Modal.confirm(options);
      });
    },
    delete({
      title,
      content
    } = {}) {
      title = title || State_UI.$t("\u5220\u9664").label;
      content = content || State_UI.$t("\u5220\u9664\u786E\u8BA4\u63D0\u793A").label;
      return new Promise((resolve2, reject) => {
        Modal.confirm({
          title,
          icon: createVNode(resolveComponent("ExclamationCircleOutlined"), {
            "style": "color:red"
          }, null),
          content,
          okType: "danger",
          okText: State_UI.$t("\u786E\u5B9A").label,
          cancelText: State_UI.$t("\u53D6\u6D88").label,
          onOk() {
            resolve2("ok");
          },
          onCancel() {
            reject();
          }
        });
      });
    }
  },
  message,
  notification: new Proxy(notification, {
    get(target, p2, receiver) {
      const m2 = target[p2];
      return new Proxy(m2, {
        apply(target2, thisArg, argArray) {
          if (typeof argArray[0] === "string") {
            argArray[0] = xU.merge({
              message: argArray[0]
            }, argArray[1] || {});
          }
          return target2.apply(thisArg, argArray);
        }
      });
    }
  }),
  layer: LayerUtils
};
const VNodeCollection = {
  labelTips: (popContent) => (configs, className) => {
    const {
      prop,
      label
    } = configs;
    return createVNode("div", {
      "class": "ant-form-item-label"
    }, [createVNode("label", {
      "for": prop,
      "class": className
    }, [label, createVNode(resolveComponent("aPopover"), {
      "trigger": "hover",
      "placement": "top"
    }, {
      content: () => popContent,
      default: () => createVNode(resolveComponent("xIcon"), {
        "icon": "Insidetips",
        "class": "pointer"
      }, null)
    })])]);
  }
};
const DELAY = 60 * 5;
const CACHE_V_NODE = {};
const WILL_DELETE_PROPS = {
  idCounts: {},
  add(prop) {
    const count = this.idCounts[prop] || 0;
    this.idCounts[prop] = count + 1;
  },
  remove(prop) {
    const count = this.idCounts[prop] || 0;
    const val = count - 1;
    this.idCounts[prop] = val < 0 ? 0 : val;
  }
};
const deleteUnmountedInstance = (prop) => {
  WILL_DELETE_PROPS.add(prop);
  delayDeleteUnmountedInstance();
};
const delayDeleteUnmountedInstance = xU.debounce(function() {
  xU.each(WILL_DELETE_PROPS.idCounts, (count, prop) => {
    if (count > 0) {
      delete CACHE_V_NODE[prop];
      delete WILL_DELETE_PROPS.idCounts[prop];
    }
    if (!Object.keys(CACHE_V_NODE).includes(prop)) {
      delete WILL_DELETE_PROPS.idCounts[prop];
    }
  });
}, 1e3 * DELAY);
function compileVNode(template, setupReturn, prop) {
  const no_cache = !prop;
  if (!no_cache && CACHE_V_NODE[prop]) {
    WILL_DELETE_PROPS.remove(prop);
    delayDeleteUnmountedInstance();
    return CACHE_V_NODE[prop];
  } else {
    return h$1(defineComponent({
      template,
      mounted() {
        if (no_cache) {
          return;
        }
        WILL_DELETE_PROPS.remove(prop);
        CACHE_V_NODE[prop] = this._.vnode;
      },
      unmounted() {
        if (no_cache) {
          return;
        }
        deleteUnmountedInstance(prop);
      },
      setup() {
        if (xU.isFunction(setupReturn)) {
          return setupReturn();
        } else {
          return setupReturn;
        }
      }
    }));
  }
}
const xLogObject = defineComponent({
  name: "xLogObject",
  props: ["obj"],
  computed: {
    objString: {
      get() {
        if (xU.isObject(this.obj)) {
          return JSON.stringify(this.obj, null, 2);
        } else {
          return "";
        }
      }
    }
  },
  render() {
    if (!State_UI.isDev || this.$attrs.hide) {
      return null;
    } else {
      return createVNode("pre", {
        "style": "width:500px;height:400px;"
      }, [createVNode("code", null, [createTextVNode(" "), this.objString, createTextVNode(" ")])]);
    }
  }
});
const useScopeStyle = () => {
  const scopeStyle = reactive({});
  function styleObject2String(styleObject) {
    return xU.map(xU.merge({
      width: "120px",
      "text-align": "right"
    }, styleObject), (value, prop) => `${prop}: ${value}`).join(";");
  }
  function updateStyle(vm, styleContent) {
    if (!vm.$styleEle) {
      vm.$styleEle = $(vm.ele);
    }
    vm.$styleEle.html(styleContent);
  }
  function setStyle2(styleObject) {
    const instance = getCurrentInstance();
    xU.each(styleObject, (value, prop) => {
      scopeStyle[prop] = value;
    });
    updateStyle(instance.ctx, styleObject2String(scopeStyle));
    debugger;
  }
  return {
    setStyle: setStyle2
  };
};
window.dayjs = dayjs;
window.moment = dayjs;
window.jquery = $$1;
const compositionAPI = {
  usefnObserveDomResize,
  useScopeStyle
};
const componentMyUI = {
  xButton,
  xRender,
  xItem: xItem$1,
  xForm,
  xButtonCountDown,
  xGap,
  xCharts,
  xView,
  xIcon: _sfc_main$9,
  xDataGrid: _sfc_main$8,
  xDataGridToolbar,
  xColFilter,
  xPagination,
  xCellLabel,
  xVirScroll,
  xVirTable,
  xLogObject
};
const components = {
  ...componentMyUI
};
const VentoseUIWithInstall = {
  install: (app, options) => {
    installDirective(app, options);
    installUIDialogComponent(UI, options, app);
    xU.each(components, (component, name2) => {
      if (component.name) {
        name2 = component.name;
      } else {
        xU.doNothing(name2, `miss name`);
      }
      app.component(component.name || name2, component);
    });
    app.use(Antd);
  }
};
const Footer = "";
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link3 = links[i2];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link2 = document.createElement("link");
    link2.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link2.as = "script";
      link2.crossOrigin = "";
    }
    link2.href = dep;
    document.head.appendChild(link2);
    if (isCss) {
      return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const Group = "";
var axios$3 = { exports: {} };
var axios$2 = { exports: {} };
var bind$4 = function bind(fn, thisArg) {
  return function wrap() {
    var args2 = new Array(arguments.length);
    for (var i2 = 0; i2 < args2.length; i2++) {
      args2[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args2);
  };
};
var bind$3 = bind$4;
var toString2 = Object.prototype.toString;
function isArray$8(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString2.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return toString2.call(val) === "[object FormData]";
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString2.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$1(val) {
  return toString2.call(val) === "[object Date]";
}
function isFile(val) {
  return toString2.call(val) === "[object File]";
}
function isBlob(val) {
  return toString2.call(val) === "[object Blob]";
}
function isFunction2(val) {
  return toString2.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject2(val) && isFunction2(val.pipe);
}
function isURLSearchParams(val) {
  return toString2.call(val) === "[object URLSearchParams]";
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$8(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        fn.call(null, obj[key2], key2, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue2(val, key2) {
    if (isPlainObject(result[key2]) && isPlainObject(val)) {
      result[key2] = merge$1(result[key2], val);
    } else if (isPlainObject(val)) {
      result[key2] = merge$1({}, val);
    } else if (isArray$8(val)) {
      result[key2] = val.slice();
    } else {
      result[key2] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue2);
  }
  return result;
}
function extend(a2, b2, thisArg) {
  forEach(b2, function assignValue2(val, key2) {
    if (thisArg && typeof val === "function") {
      a2[key2] = bind$3(val, thisArg);
    } else {
      a2[key2] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$c = {
  isArray: isArray$8,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$1,
  isObject: isObject2,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction2,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM
};
var utils$b = utils$c;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$b.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$b.forEach(params, function serialize(val, key2) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$b.isArray(val)) {
        key2 = key2 + "[]";
      } else {
        val = [val];
      }
      utils$b.forEach(val, function parseValue2(v2) {
        if (utils$b.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$b.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$1(key2) + "=" + encode$1(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$a = utils$c;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$a.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$9 = utils$c;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$9.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$1 = function enhanceError(error, config, code, request2, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var createError;
var hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var enhanceError3 = enhanceError$1;
  createError = function createError2(message2, config, code, request2, response) {
    var error = new Error(message2);
    return enhanceError3(error, config, code, request2, response);
  };
  return createError;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var createError2 = requireCreateError();
  settle = function settle2(resolve2, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(createError2(
        "Request failed with status code " + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$c;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path2, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path2)) {
          cookie.push("path=" + path2);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove2(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL;
var hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  if (hasRequiredIsAbsoluteURL)
    return isAbsoluteURL;
  hasRequiredIsAbsoluteURL = 1;
  isAbsoluteURL = function isAbsoluteURL2(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  };
  return isAbsoluteURL;
}
var combineURLs;
var hasRequiredCombineURLs;
function requireCombineURLs() {
  if (hasRequiredCombineURLs)
    return combineURLs;
  hasRequiredCombineURLs = 1;
  combineURLs = function combineURLs2(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
  return combineURLs;
}
var buildFullPath;
var hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var isAbsoluteURL2 = requireIsAbsoluteURL();
  var combineURLs2 = requireCombineURLs();
  buildFullPath = function buildFullPath2(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL2(requestedURL)) {
      return combineURLs2(baseURL, requestedURL);
    }
    return requestedURL;
  };
  return buildFullPath;
}
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$c;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key2;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line2) {
      i2 = line2.indexOf(":");
      key2 = utils2.trim(line2.substr(0, i2)).toLowerCase();
      val = utils2.trim(line2.substr(i2 + 1));
      if (key2) {
        if (parsed[key2] && ignoreDuplicateOf.indexOf(key2) >= 0) {
          return;
        }
        if (key2 === "set-cookie") {
          parsed[key2] = (parsed[key2] ? parsed[key2] : []).concat([val]);
        } else {
          parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$c;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url2) {
      var href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var Cancel_1;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function Cancel2(message2) {
    this.message = message2;
  }
  Cancel2.prototype.toString = function toString3() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel2.prototype.__CANCEL__ = true;
  Cancel_1 = Cancel2;
  return Cancel_1;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$c;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath2 = requireBuildFullPath();
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var createError2 = requireCreateError();
  var transitionalDefaults2 = transitional;
  var Cancel2 = requireCancel();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath2(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL3(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(function _resolve(value) {
          resolve2(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(createError2("Request aborted", config, "ECONNABORTED", request2));
        request2 = null;
      };
      request2.onerror = function handleError2() {
        reject(createError2("Network Error", config, null, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config.transitional || transitionalDefaults2;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError2(
          timeoutErrorMessage,
          config,
          transitional3.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key2) {
          if (typeof requestData === "undefined" && key2.toLowerCase() === "content-type") {
            delete requestHeaders[key2];
          } else {
            request2.setRequestHeader(key2, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new Cancel2("canceled") : cancel);
          request2.abort();
          request2 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var utils$8 = utils$c;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$1;
var transitionalDefaults = transitional;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$8.isUndefined(headers) && utils$8.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$8.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$8.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$5 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data9, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$8.isFormData(data9) || utils$8.isArrayBuffer(data9) || utils$8.isBuffer(data9) || utils$8.isStream(data9) || utils$8.isFile(data9) || utils$8.isBlob(data9)) {
      return data9;
    }
    if (utils$8.isArrayBufferView(data9)) {
      return data9.buffer;
    }
    if (utils$8.isURLSearchParams(data9)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data9.toString();
    }
    if (utils$8.isObject(data9) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data9);
    }
    return data9;
  }],
  transformResponse: [function transformResponse(data9) {
    var transitional3 = this.transitional || defaults$5.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$8.isString(data9) && data9.length) {
      try {
        return JSON.parse(data9);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data9;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$8.forEach(["delete", "get", "head"], function forEachMethodNoData(method4) {
  defaults$5.headers[method4] = {};
});
utils$8.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
  defaults$5.headers[method4] = utils$8.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5;
var utils$7 = utils$c;
var defaults$4 = defaults_1;
var transformData$1 = function transformData(data9, headers, fns) {
  var context2 = this || defaults$4;
  utils$7.forEach(fns, function transform2(fn) {
    data9 = fn.call(context2, data9, headers);
  });
  return data9;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value) {
    return !!(value && value.__CANCEL__);
  };
  return isCancel$1;
}
var utils$6 = utils$c;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$3 = defaults_1;
var Cancel = requireCancel();
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new Cancel("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$6.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$6.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method4) {
      delete config.headers[method4];
    }
  );
  var adapter = config.adapter || defaults$3.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$c;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source2) {
    if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source2)) {
      return utils$5.merge(target, source2);
    } else if (utils$5.isPlainObject(source2)) {
      return utils$5.merge({}, source2);
    } else if (utils$5.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$5.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge4 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge4(prop);
    utils$5.isUndefined(configValue) && merge4 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data8;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data8;
  hasRequiredData = 1;
  data8 = {
    "version": "0.26.1"
  };
  return data8;
}
var VERSION = requireData().version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type4, i2) {
  validators$1[type4] = function validator2(thing) {
    return typeof thing === type4 || "a" + (i2 < 1 ? "n " : " ") + type4;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$4 = utils$c;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional3 = config.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method4) {
  Axios$1.prototype[method4] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method4,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method4) {
  Axios$1.prototype[method4] = function(url2, data9, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method4,
      url: url2,
      data: data9
    }));
  };
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var Cancel2 = requireCancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2;
      var l2 = token2._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve2) {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message2) {
      if (token2.reason) {
        return;
      }
      token2.reason = new Cancel2(message2);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe2(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe2(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source2() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$c;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$3 = utils$c;
var bind$2 = bind$4;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$2 = defaults_1;
function createInstance(defaultConfig) {
  var context2 = new Axios(defaultConfig);
  var instance = bind$2(Axios.prototype.request, context2);
  utils$3.extend(instance, Axios.prototype, context2);
  utils$3.extend(instance, context2);
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults$2);
axios$1.Axios = Axios;
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
(function(module2) {
  module2.exports = axios$2.exports;
})(axios$3);
const axios = /* @__PURE__ */ getDefaultExportFromCjs(axios$3.exports);
const ajax = axios.create({
  timeout: 2e4
});
ajax.interceptors.request.use((config) => {
  config.url = `${_State_App.baseURL}${config.url}`;
  if (config.data) {
    xU.each(["name"], (prop) => {
      if (config.data[prop]) {
        config.data[prop] = xU.htmlFilter(config.data[prop]);
      }
    });
  }
  return config;
}, (error) => Promise.reject(error));
ajax.interceptors.response.use(async (response) => {
  var _a2, _b, _c;
  if (((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.errcode) == 40011) {
    _State_App.user.isLogin = false;
    window.location.hash = "/login";
  }
  if (response.config.url == "/api/interface/schema2json") {
    return Promise.resolve({
      data: response.data,
      response
    });
  }
  if (((_b = response == null ? void 0 : response.data) == null ? void 0 : _b.errcode) !== 0) {
    UI.message.error((_c = response == null ? void 0 : response.data) == null ? void 0 : _c.errmsg);
    return Promise.reject(response);
  }
  return Promise.resolve({
    data: response.data.data,
    response
  });
}, async (error) => {
  var _a2;
  const {
    response
  } = error;
  console.log(response);
  logError((_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.data);
  return Promise.reject(error);
});
function logError(msg) {
  if (!msg)
    return;
  UI.notification.error(msg);
  console.error(msg);
}
const user = {
  getUserStatus() {
    return ajax({
      method: "get",
      url: "/api/user/status"
    });
  },
  searchUser(params) {
    return ajax({
      method: "get",
      url: "/api/user/search",
      params
    });
  },
  loginActions(data9) {
    return ajax({
      method: "post",
      url: "/api/user/login",
      data: data9
    });
  },
  logoutActions() {
    return ajax({
      method: "get",
      url: "/api/user/logout"
    });
  },
  regActions(data9) {
    return ajax({
      method: "post",
      url: "/api/user/reg",
      data: data9
    });
  }
};
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args2 = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args2.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args2.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args2.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty4 = function Empty5() {
    };
    Empty4.prototype = target.prototype;
    bound.prototype = new Empty4();
    Empty4.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e2) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value;
  if (name2 === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind3 = functionBind;
var hasOwn$1 = src;
var $concat$1 = bind3.call(Function.call, Array.prototype.concat);
var $spliceApply = bind3.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind3.call(Function.call, String.prototype.replace);
var $strSlice = bind3.call(Function.call, String.prototype.slice);
var $exec = bind3.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string3) {
  var first = $strSlice(string3, 0, 1);
  var last3 = $strSlice(string3, -1);
  if (first === "%" && last3 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last3 === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string3, rePropName, function(match2, number4, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number4 || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name2) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last3 = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last3 === '"' || last3 === "'" || last3 === "`")) && first !== last3) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind4 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind4.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind4, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind4, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen2) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$7(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen2 === "undefined") {
    seen2 = [];
  } else if (indexOf(seen2, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen2 = $arrSlice.call(seen2);
      seen2.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen2);
    }
    return inspect_(value, opts, depth + 1, seen2);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name2 = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s2;
  }
  if (isArray$7(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key2) {
      mapParts.push(inspect2(key2, obj, true) + " => " + inspect2(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect2(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString2(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return $replace.call(String(s2), /"/g, "&quot;");
}
function isArray$7(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString2(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn2 = Object.prototype.hasOwnProperty || function(key2) {
  return key2 in this;
};
function has$3(obj, key2) {
  return hasOwn2.call(obj, key2);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2) {
      return i2;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s2) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m2) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type4) {
  return type4 + " { ? }";
}
function collectionOf(type4, size2, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type4 + " (" + size2 + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$7(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key2 in obj) {
    if (!has$3(obj, key2)) {
      continue;
    }
    if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key2)) {
      xs.push(inspect2(key2, obj) + ": " + inspect2(obj[key2], obj));
    } else {
      xs.push(key2 + ": " + inspect2(obj[key2], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key2) {
  for (var prev2 = list, curr; (curr = prev2.next) !== null; prev2 = curr) {
    if (curr.key === key2) {
      prev2.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key2) {
  var node = listGetNode(objects, key2);
  return node && node.value;
};
var listSet = function(objects, key2, value) {
  var node = listGetNode(objects, key2);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key: key2,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key2) {
  return !!listGetNode(objects, key2);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key2) {
      if (!channel.has(key2)) {
        throw new $TypeError("Side channel does not contain " + inspect(key2));
      }
    },
    get: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key2);
        }
      } else {
        if ($o) {
          return listGet($o, key2);
        }
      }
    },
    has: function(key2) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key2);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key2);
        }
      } else {
        if ($o) {
          return listHas($o, key2);
        }
      }
      return false;
    },
    set: function(key2, value) {
      if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key2, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key2, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$6 = Array.isArray;
var hexTable = function() {
  var array4 = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array4.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array4;
}();
var compactQueue = function compactQueue2(queue2) {
  while (queue2.length > 1) {
    var item = queue2.pop();
    var obj = item.obj[item.prop];
    if (isArray$6(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source2, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source2.length; ++i2) {
    if (typeof source2[i2] !== "undefined") {
      obj[i2] = source2[i2];
    }
  }
  return obj;
};
var merge2 = function merge3(target, source2, options) {
  if (!source2) {
    return target;
  }
  if (typeof source2 !== "object") {
    if (isArray$6(target)) {
      target.push(source2);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source2)) {
        target[source2] = true;
      }
    } else {
      return [target, source2];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source2);
  }
  var mergeTarget = target;
  if (isArray$6(target) && !isArray$6(source2)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$6(target) && isArray$6(source2)) {
    source2.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge3(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source2).reduce(function(acc, key2) {
    var value = source2[key2];
    if (has$2.call(acc, key2)) {
      acc[key2] = merge3(acc[key2], value, options);
    } else {
      acc[key2] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source2) {
  return Object.keys(source2).reduce(function(acc, key2) {
    acc[key2] = source2[key2];
    return acc;
  }, target);
};
var decode = function(str, decoder2, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format5) {
  if (str.length === 0) {
    return str;
  }
  var string3 = str;
  if (typeof str === "symbol") {
    string3 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string3 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string3).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string3.length; ++i2) {
    var c2 = string3.charCodeAt(i2);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format5 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string3.charAt(i2);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i2 += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string3.charCodeAt(i2) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue2 = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue2.length; ++i2) {
    var item = queue2[i2];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j2 = 0; j2 < keys2.length; ++j2) {
      var key2 = keys2[j2];
      var val = obj[key2];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue2.push({ obj, prop: key2 });
        refs.push(val);
      }
    }
  }
  compactQueue(queue2);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a2, b2) {
  return [].concat(a2, b2);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$6(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn(val[i2]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge: merge2
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key2) {
    return prefix + "[" + key2 + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$5 = Array.isArray;
var split = String.prototype.split;
var push$1 = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push$1.apply(arr, isArray$5(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date4) {
    return toISO.call(date4);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify(object4, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate2, format5, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object4;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos2 = tmpSc.get(object4);
    step += 1;
    if (typeof pos2 !== "undefined") {
      if (pos2 === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$5(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format5) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format5);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i2 = 0; i2 < valuesArray.length; ++i2) {
          valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$1.encoder, charset, "value", format5));
        }
        return [formatter(keyValue) + (commaRoundTrip && isArray$5(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format5))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$5(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$5(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort ? keys2.sort(sort) : keys2;
  }
  var adjustedPrefix = commaRoundTrip && isArray$5(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key2 = objKeys[j2];
    var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$5(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
    sideChannel2.set(object4, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      encoder,
      filter,
      sort,
      allowDots,
      serializeDate2,
      format5,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format5 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format5 = opts.format;
  }
  var formatter = formats$1.formatters[format5];
  var filter = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$5(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter,
    format: format5,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object4, opts) {
  var obj = object4;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$5(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key2 = objKeys[i2];
    if (options.skipNulls && obj[key2] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(
      obj[key2],
      key2,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$4 = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos2 = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key2, val;
    if (pos2 === -1) {
      key2 = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key2 = options.decoder(part.slice(0, pos2), defaults.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos2 + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$4(val) ? [val] : val;
    }
    if (has.call(obj, key2)) {
      obj[key2] = utils.combine(obj[key2], val);
    } else {
      obj[key2] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key2);
  var parent2 = segment ? key2.slice(0, segment.index) : key2;
  var keys2 = [];
  if (parent2) {
    if (!options.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent2);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key2)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key2.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$2 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys2.length; ++i2) {
    var key2 = keys2[i2];
    var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify$1 = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;
var lib$1 = {
  formats,
  parse: parse$1,
  stringify: stringify$1
};
const project = {
  interfaceSchema2json(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/schema2json",
      data: data9
    });
  },
  updateProxyEnv(data9) {
    return ajax({
      method: "post",
      url: "/api/project/up_env",
      data: data9
    });
  },
  updateTags(data9) {
    return ajax({
      method: "post",
      url: "/api/project/up_tag",
      data: data9
    });
  },
  addFollow(data9) {
    return ajax({
      method: "post",
      url: "/api/follow/add",
      data: data9
    });
  },
  delFollow(projectid) {
    return ajax({
      method: "post",
      url: "/api/follow/del",
      data: {
        projectid
      }
    });
  },
  addProject(data9) {
    return ajax({
      method: "post",
      url: "/api/project/add",
      data: data9
    });
  },
  getProjectById(id) {
    return ajax({
      method: "get",
      url: "/api/project/get",
      params: {
        id
      }
    });
  },
  copyProjectMsg(data9) {
    return ajax({
      method: "post",
      url: "/api/project/copy",
      data: data9
    });
  },
  fetchInterfaceList(params) {
    return ajax({
      method: "get",
      url: "/api/interface/list",
      params,
      paramsSerializer: (params2) => {
        return lib$1.stringify(params2, {
          indices: false
        });
      }
    });
  },
  list(groupId) {
    return ajax({
      method: "get",
      url: "/api/project/list",
      params: {
        group_id: Number(groupId)
      }
    });
  },
  addInterface(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/add",
      data: data9
    });
  },
  addInterfaceCategory(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/add_cat",
      data: data9
    });
  },
  updateInterface(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/up",
      data: data9
    });
  },
  deleteCategoryById(id) {
    return ajax({
      method: "post",
      url: "/api/interface/del_cat",
      data: {
        catid: id
      }
    });
  },
  deleteInterfaceById(id) {
    return ajax({
      method: "post",
      url: "/api/interface/del",
      data: {
        id
      }
    });
  },
  updateInterfaceCategory(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/up_cat",
      data: data9
    });
  },
  switchManyCategoryOrder(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/up_cat_index",
      data: data9
    });
  },
  switchManyInterfaceOrder(data9) {
    return ajax({
      method: "post",
      url: "/api/interface/up_index",
      data: data9
    });
  },
  fetchInterfaceListMenu(project_id) {
    return ajax({
      method: "get",
      url: "/api/interface/list_menu",
      params: {
        project_id: Number(project_id)
      }
    });
  },
  fetchInterfaceDetail(interfaceId) {
    return ajax({
      method: "get",
      url: "/api/interface/get",
      params: {
        id: Number(interfaceId)
      }
    });
  }
};
const group = {
  getMyGroup() {
    return ajax({
      method: "get",
      url: "/api/group/get_mygroup"
    });
  },
  delMember(data9) {
    return ajax({
      method: "post",
      url: "/api/group/del_member",
      data: data9
    });
  },
  deleteGroup(data9) {
    return ajax({
      method: "post",
      url: "/api/group/del",
      data: data9
    });
  },
  addMember(data9) {
    return ajax({
      method: "post",
      url: "/api/group/add_member",
      data: data9
    });
  },
  changeMemberRole(data9) {
    return ajax({
      method: "post",
      url: "/api/group/change_member_role",
      data: data9
    });
  },
  addGroup(data9) {
    return ajax({
      method: "post",
      url: "/api/group/add",
      data: data9
    });
  },
  updateGroup(data9) {
    return ajax({
      method: "post",
      url: "/api/group/up",
      data: data9
    });
  },
  getMyGroupList() {
    return ajax({
      method: "get",
      url: "/api/group/list"
    });
  },
  getMyGroupBy(groupId) {
    return ajax({
      method: "get",
      url: "/api/group/get",
      params: {
        id: Number(groupId)
      }
    });
  },
  getMemberListBy(groupId) {
    return ajax({
      method: "get",
      url: "/api/group/get_member_list",
      params: {
        id: Number(groupId)
      }
    });
  }
};
const news = {
  getLogList({
    typeid,
    type: type4,
    page: page2,
    limit,
    selectValue
  }) {
    return ajax({
      method: "get",
      url: "/api/log/list",
      params: {
        typeid,
        type: type4,
        page: page2,
        limit: limit ? limit : 10,
        selectValue
      }
    });
  }
};
const API = {
  user,
  group,
  news,
  project
};
const {
  xItem
} = components;
const {
  $t: $t$7
} = State_UI;
const DialogEditGroup = defineComponent({
  setup() {
    return {
      State_App: _State_App,
      Cpt_url
    };
  },
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  computed: {
    row() {
      var _a2;
      return ((_a2 = this.propDialogOptions) == null ? void 0 : _a2.row) || {};
    },
    vDomFormItems() {
      return xU.map(this.formItems, (item, prop) => {
        return createVNode(Fragment, null, [createVNode(resolveComponent("xGap"), {
          "t": "10"
        }, null), createVNode(xItem, {
          "configs": item
        }, null)]);
      });
    },
    vDomDeleteConfirmAuth() {
      return createVNode("div", null, [createVNode(Alert$1, {
        "message": $t$7("\u8B66\u544A\uFF1A\u6B64\u64CD\u4F5C\u975E\u5E38\u5371\u9669,\u4F1A\u5220\u9664\u8BE5\u5206\u7EC4\u4E0B\u9762\u6240\u6709\u9879\u76EE\u548C\u63A5\u53E3\uFF0C\u5E76\u4E14\u65E0\u6CD5\u6062\u590D!").label,
        "type": "warning"
      }, null), createVNode("div", {
        "style": {
          marginTop: "16px"
        }
      }, [createVNode(xItem, {
        "configs": this.formDelete.authText
      }, null)])]);
    },
    vDomDeleteGroup() {
      if (_State_App.user.role === "admin") {
        return createVNode(resolveComponent("aCard"), {
          "class": "mt20"
        }, {
          default: () => [createVNode(Alert$1, {
            "type": "warning",
            "message": $t$7("\u5220\u9664\u5206\u7EC4").label,
            "description": createVNode("div", null, [createVNode("div", {
              "className": "card-danger-content"
            }, [createVNode("p", null, [createTextVNode("\u5206\u7EC4\u4E00\u65E6\u5220\u9664\uFF0C\u5C06\u65E0\u6CD5\u6062\u590D\u6570\u636E\uFF0C\u8BF7\u614E\u91CD\u64CD\u4F5C\uFF01")]), createVNode("p", null, [createTextVNode("\u53EA\u6709\u8D85\u7EA7\u7BA1\u7406\u5458\u6709\u6743\u9650\u5220\u9664\u5206\u7EC4\u3002")])]), createVNode("div", {
              "class": "flex end"
            }, [createVNode(resolveComponent("xButton"), {
              "configs": {
                onClick: this.showDeleteGroupConfirm,
                preset: "delete"
              }
            }, null)])]),
            "show-icon": true
          }, null)]
        });
      }
      return null;
    }
  },
  render() {
    return createVNode(Fragment, null, [createVNode("div", {
      "class": "padding20 flex1 overflow-auto"
    }, [createVNode(resolveComponent("aCard"), null, {
      default: () => [createVNode(resolveComponent("xForm"), {
        "class": "flex vertical",
        "labelStyle": {
          "min-width": "170px",
          width: "unset"
        }
      }, {
        default: () => [this.vDomFormItems]
      })]
    }), this.vDomDeleteGroup]), createVNode(resolveComponent("xDialogFooter"), {
      "configs": {
        onCancel: this.propDialogOptions.closeDialog,
        onOk: () => {
          this.propDialogOptions.onOk({
            formItems: this.formItems,
            closeDialog: this.propDialogOptions.closeDialog
          });
        }
      }
    }, null)]);
  },
  data() {
    const vm = this;
    return {
      formDelete: {
        ...defItem({
          value: "",
          prop: "authText",
          placeholder: $t$7("\u8BF7\u8F93\u5165\u5206\u7EC4\u540D\u79F0\u786E\u8BA4\u6B64\u64CD\u4F5C").label,
          allowClear: true
        })
      },
      formItems: {
        ...defItem({
          prop: "currGroupName",
          value: "",
          label: $t$7("\u5206\u7EC4\u540D").label,
          placeholder: $t$7("\u8BF7\u8F93\u5165\u5206\u7EC4\u540D\u79F0").label,
          rules: [FormRules.required()]
        }),
        ...defItem({
          isTextarea: true,
          prop: "currGroupDesc",
          value: "",
          label: $t$7("\u7B80\u4ECB").label,
          placeholder: "\u8BF7\u8F93\u5165\u5206\u7EC4\u63CF\u8FF0",
          rules: [FormRules.required()]
        }),
        ...defItem({
          itemType: "Switch",
          prop: "custom_field1_enable",
          value: false,
          label: $t$7("\u542F\u7528\u63A5\u53E3\u81EA\u5B9A\u4E49\u5B57\u6BB5").label,
          placeholder: "\u8BF7\u8F93\u5165\u5206\u7EC4\u63CF\u8FF0",
          rules: [FormRules.required()]
        }),
        ...defItem({
          prop: "custom_field1_name",
          value: "",
          disabled() {
            return !vm.formItems.custom_field1_enable.value;
          },
          label: $t$7("\u63A5\u53E3\u81EA\u5B9A\u4E49\u5B57\u6BB5").label,
          labelVNodeRender: VNodeCollection.labelTips(createVNode("div", null, [$t$7("\u53EF\u4EE5\u5728\u63A5\u53E3\u4E2D\u6DFB\u52A0 \u989D\u5916\u5B57\u6BB5 \u6570\u636E").label])),
          placeholder: $t$7("\u989D\u5916\u5B57\u6BB5").label,
          rules: [FormRules.required()],
          once() {
            vm.$watch("formItems.custom_field1_enable.value", (isUse) => {
              if (isUse) {
                this.rules = [FormRules.required()];
              } else {
                this.rules = [];
              }
            }, {
              immediate: true
            });
          }
        })
      }
    };
  },
  methods: {
    init() {
      const {
        group_desc,
        group_name,
        custom_field1
      } = this.row;
      const {
        enable,
        name: name2
      } = custom_field1 || {};
      this.formItems.currGroupName.value = group_name;
      this.formItems.currGroupDesc.value = group_desc;
      this.formItems.custom_field1_enable.value = enable;
      this.formItems.custom_field1_name.value = name2;
    },
    showDeleteGroupConfirm() {
      const vm = this;
      vm.formDelete.authText.value = "";
      UI.confirm({
        title: "\u786E\u8BA4\u5220\u9664 " + vm.State_App.currGroup.group_name + " \u5206\u7EC4\u5417\uFF1F",
        content: vm.vDomDeleteConfirmAuth,
        onOk() {
          return new Promise(async (resolve2, reject) => {
            var _a2;
            const {
              authText
            } = pickValueFrom(vm.formDelete);
            if (authText !== vm.State_App.currGroup.group_name) {
              UI.message.error("\u5206\u7EC4\u540D\u79F0\u6709\u8BEF");
              return reject();
            } else {
              await vm.deleteGroup();
              (_a2 = vm.propDialogOptions) == null ? void 0 : _a2.close();
              return resolve2("");
            }
          });
        },
        iconType: "delete",
        onCancel() {
        }
      });
    },
    async deleteGroup() {
      const {
        currGroup
      } = this.State_App;
      await API.group.deleteGroup({
        id: currGroup._id
      });
      UI.notification.success("\u5220\u9664\u6210\u529F");
      await Methods_App.fetchGroupList();
      const firstGroup = xU.first(this.State_App.groupList);
      this.Cpt_url.go("/group", {
        group_id: firstGroup._id
      });
    }
  },
  mounted() {
    this.init();
    this.propDialogOptions.vm = this;
  }
});
const UsernameAutoComplete = defineComponent({
  props: ["callbackState"],
  data() {
    return {
      state: {
        dataSource: [],
        fetching: false
      }
    };
  },
  methods: {
    doSearch: xU.debounce(function(params) {
      API.user.searchUser(params).then(({
        data: data9
      }) => {
        let userList = [];
        if (xU.isArrayFill(data9)) {
          userList = xU.map(data9, (v2) => {
            return {
              username: v2.username,
              id: v2.uid
            };
          });
        }
        this.state.dataSource = userList;
      }).finally(() => {
        this.state.fetching = false;
      });
    }, 600),
    onSearch(value) {
      if (!value)
        return;
      const params = {
        q: value
      };
      this.state.fetching = true;
      this.doSearch(params);
    },
    handleChange(value) {
      this.state.dataSource = [];
      this.state.fetching = false;
      this.callbackState(value);
    }
  },
  computed: {
    children() {
      return xU.map(this.state.dataSource, (item, index2) => createVNode(resolveComponent("aSelectOption"), {
        "key": index2,
        "value": "" + item.id
      }, {
        default: () => [item.username]
      }));
    }
  },
  render() {
    let {
      fetching
    } = this.state;
    return createVNode(resolveComponent("aSelect"), {
      "mode": "multiple",
      "style": {
        width: "100%"
      },
      "placeholder": "\u8BF7\u8F93\u5165\u7528\u6237\u540D",
      "filterOption": false,
      "optionLabelProp": "children",
      "notFoundContent": fetching ? createVNode(Fragment, null, [createVNode(resolveComponent("aSpin"), null, null), createVNode("span", {
        "style": "color:gray;margin-left:4px;"
      }, [createTextVNode(" \u6B63\u5728\u83B7\u53D6\u7528\u6237\u5217\u8868")])]) : null,
      "onSearch": this.onSearch,
      "onChange": this.handleChange
    }, {
      default: () => [this.children]
    });
  }
});
const ItemUAC = ({
  listeners
}) => {
  return createVNode(UsernameAutoComplete, {
    "callbackState": (val) => listeners["onUpdate:value"](val)
  }, null);
};
const {
  $t: $t$6
} = State_UI;
const DialogAddGroup = defineComponent({
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  data() {
    return {
      formItems: {
        ...defItem({
          prop: "newGroupName",
          value: "",
          label: $t$6("\u5206\u7EC4\u540D").label,
          placeholder: $t$6("\u8BF7\u8F93\u5165\u5206\u7EC4\u540D\u79F0").label,
          rules: [FormRules.required()]
        }),
        ...defItem({
          isTextarea: true,
          prop: "newGroupDesc",
          value: "",
          label: $t$6("\u7B80\u4ECB").label,
          placeholder: "\u8BF7\u8F93\u5165\u5206\u7EC4\u63CF\u8FF0",
          rules: [FormRules.required()]
        }),
        ...defItem({
          itemType: ItemUAC,
          prop: "owner_uids",
          value: "",
          label: $t$6("\u7EC4\u957F").label,
          placeholder: "\u8BF7\u8F93\u5165\u5206\u7EC4\u63CF\u8FF0",
          rules: [FormRules.required()]
        })
      },
      styleLabel: {
        "min-width": "120px",
        width: "unset"
      }
    };
  },
  mounted() {
    this.propDialogOptions.vm = this;
  },
  computed: {
    vDomFormItems() {
      return xU.map(this.formItems, (item, prop) => {
        return createVNode(Fragment, null, [createVNode(resolveComponent("xGap"), {
          "t": "10"
        }, null), createVNode(resolveComponent("xItem"), {
          "configs": item
        }, null)]);
      });
    }
  },
  render() {
    return createVNode(Fragment, null, [createVNode(resolveComponent("aCard"), {
      "class": "flex1 overflow-auto"
    }, {
      default: () => [createVNode(resolveComponent("xForm"), {
        "class": "flex vertical",
        "labelStyle": this.styleLabel
      }, {
        default: () => [this.vDomFormItems]
      })]
    }), createVNode(resolveComponent("xDialogFooter"), {
      "configs": {
        onCancel: this.propDialogOptions.closeDialog,
        onOk: () => {
          this.propDialogOptions.onOk({
            formItems: this.formItems,
            closeDialog: this.propDialogOptions.closeDialog
          });
        }
      }
    }, null)]);
  }
});
function _isSlot$6(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const {
  $t: $t$5
} = State_UI;
async function fnUpsertGroupInfo(formData = {}) {
  const {
    id
  } = formData;
  if (id) {
    await API.group.updateGroup(formData);
  } else {
    await API.group.addGroup(formData);
  }
  await Methods_App.fetchGroupList();
  await Methods_App.setCurrGroup(_State_App.currGroup._id);
  await Methods_App.fetchNewsData({
    id: _State_App.currGroup._id,
    type: "group"
  });
}
function fnShowUpsertGroupDialog(row = {}) {
  const vm = this;
  const isUpdate = !!row._id;
  UI.dialog.component({
    title: isUpdate ? $t$5("\u4FEE\u6539\u5206\u7EC4\u4FE1\u606F").label : $t$5("\u6DFB\u52A0\u5206\u7EC4").label,
    component: isUpdate ? DialogEditGroup : DialogAddGroup,
    row,
    area: ["580px", "460px"],
    onOk: async ({
      formItems,
      closeDialog
    }) => {
      let formData = {};
      if (isUpdate) {
        const validateResults = await validateForm(formItems);
        if (AllWasWell(validateResults)) {
          const {
            currGroupName,
            currGroupDesc,
            custom_field1_enable,
            custom_field1_name
          } = pickValueFrom(formItems);
          formData = {
            ...row,
            group_name: currGroupName,
            group_desc: currGroupDesc,
            custom_field1: {
              enable: custom_field1_enable,
              name: custom_field1_name
            },
            id: row._id
          };
        } else {
          throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
        }
      } else {
        const validateResults = await validateForm(formItems);
        if (AllWasWell(validateResults)) {
          const {
            newGroupName,
            newGroupDesc,
            owner_uids
          } = pickValueFrom(formItems);
          formData = {
            group_name: newGroupName,
            group_desc: newGroupDesc,
            owner_uids
          };
        } else {
          throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
        }
      }
      await vm.fnUpsertGroupInfo(formData);
      closeDialog();
    }
  });
}
createVNode("div", {
  "class": "title-container"
}, [createVNode("h3", {
  "class": "title"
}, [createTextVNode("\u6B22\u8FCE\u4F7F\u7528 YApi ~")]), createVNode("p", null, [createTextVNode("\u8FD9\u91CC\u7684 "), createVNode("b", null, [createTextVNode("\u201C\u4E2A\u4EBA\u7A7A\u95F4\u201D")]), " ", createTextVNode("\u662F\u4F60\u81EA\u5DF1\u624D\u80FD\u770B\u5230\u7684\u5206\u7EC4\uFF0C\u4F60\u62E5\u6709\u8FD9\u4E2A\u5206\u7EC4\u7684\u5168\u90E8\u6743\u9650\uFF0C\u53EF\u4EE5\u5728\u8FD9\u4E2A\u5206\u7EC4\u91CC\u63A2\u7D22 YApi \u7684\u529F\u80FD\u3002")])]);
const GroupLeftSider = defineComponent({
  props: ["groupList", "currGroup", "fetchGroupList", "setCurrGroup", "setGroupList", "match", "history", "State_App.user.role", "State_App.user.roleInGroup", "studyTip", "study", "fetchNewsData", "setCurrGroup"],
  setup() {
    return {
      Cpt_url,
      State_App: _State_App,
      fnShowUpsertGroupDialog,
      fnUpsertGroupInfo
    };
  },
  data() {
    return {
      configsSearch: {
        isSearch: false,
        value: "",
        placeholder: "\u641C\u7D22\u5206\u7C7B",
        onAfterValueEmit: this.searchGroup,
        allowClear: true
      },
      groupListForShow: [],
      state: {
        addGroupModalVisible: false,
        newGroupName: "",
        newGroupDesc: "",
        currGroupName: "",
        currGroupDesc: "",
        groupList: [],
        owner_uids: []
      }
    };
  },
  async mounted() {
    await this.initGroupList();
  },
  methods: {
    async initGroupList() {
      try {
        await Methods_App.fetchGroupList();
        this.searchGroup();
      } catch (error) {
        console.error(error);
      }
    },
    async selectGroup({
      key: groupId
    }) {
      await Methods_App.setCurrGroup(groupId);
      this.Cpt_url.go("/group", {
        group_id: groupId
      });
      await Methods_App.fetchNewsData({
        id: groupId,
        type: "group"
      });
    },
    searchGroup: xU.debounce(function() {
      const {
        groupList
      } = this.State_App;
      const keywords = this.configsSearch.value;
      if (keywords === "") {
        this.groupListForShow = groupList;
      } else {
        this.groupListForShow = xU.filter(groupList, (group2) => new RegExp(keywords, "i").test(group2.group_name));
      }
    }, 300)
  },
  watch: {
    "State_App.groupList"() {
      this.searchGroup();
    }
  },
  computed: {
    vDomCurrentGroupPanel() {
      return createVNode("div", {
        "class": "curr-group"
      }, [createVNode("div", {
        "class": "curr-group-name"
      }, [createVNode("span", {
        "class": "curr-group-name_title name"
      }, [this.State_App.currGroup.group_name])]), createVNode("div", {
        "class": "curr-group-desc"
      }, [createTextVNode("\u7B80\u4ECB: "), this.State_App.currGroup.group_desc])]);
    },
    vDomSearchInput() {
      return createVNode("div", {
        "class": "group-operate flex center middle"
      }, [createVNode(resolveComponent("aTooltip"), {
        "title": "\u6DFB\u52A0\u5206\u7EC4"
      }, {
        default: () => [createVNode(resolveComponent("xIcon"), {
          "class": "btn editSet pointer",
          "icon": "addGroup",
          "onClick": () => this.fnShowUpsertGroupDialog(),
          "style": "width:32px;height:32px;transform:translate(-12px,-4px)"
        }, null)]
      }), createVNode("div", {
        "class": "search"
      }, [createVNode(resolveComponent("xItem"), {
        "configs": this.configsSearch
      }, null)])]);
    },
    vDomGroupList() {
      let _slot;
      const vm = this;
      return withDirectives(createVNode(resolveComponent("aMenu"), {
        "class": "group-list flex1",
        "mode": "inline",
        "onClick": this.selectGroup,
        "selectedKeys": [`${this.State_App.currGroup._id}`]
      }, _isSlot$6(_slot = xU.map(this.groupListForShow, (group2) => {
        let icon = "folderOpen";
        if (group2.type === "private") {
          icon = "user";
        }
        return createVNode(resolveComponent("aMenuItem"), {
          "key": `${group2._id}`,
          "class": "group-item flex"
        }, {
          default: () => [createVNode("div", {
            "class": "flex middle"
          }, [createVNode(resolveComponent("xIcon"), {
            "icon": icon,
            "style": "width:16px;"
          }, null), createVNode("span", {
            "class": "flex1"
          }, [group2.group_name]), withDirectives(createVNode(resolveComponent("xIcon"), {
            "class": "btn editSet pointer",
            "icon": "edit",
            "onClick": () => vm.fnShowUpsertGroupDialog(this.State_App.currGroup),
            "style": "width:16px;"
          }, null), [[resolveDirective("uiPopover"), {
            content: vm.$t("\u4FEE\u6539\u5206\u7EC4\u4FE1\u606F").label
          }]])])]
        });
      })) ? _slot : {
        default: () => [_slot]
      }), [[resolveDirective("loading"), this.groupListForShow.length === 0]]);
    }
  },
  render() {
    return createVNode("div", {
      "class": "m-group flex1 height100"
    }, [createVNode("div", {
      "class": "group-bar flex vertical"
    }, [this.vDomSearchInput, this.vDomGroupList])]);
  }
});
const ProjectCard$1 = "";
const Addproject = "";
const optionsXIcon = [
  "add",
  "addGroup",
  "allCategory",
  "arrow_left",
  "arrow_right",
  "back_group",
  "cached",
  "CaretDownOutlined",
  "CaretRightOutlined",
  "category",
  "CheckOutlined",
  "CloseOutlined",
  "cloud-o",
  "code-o",
  "column2",
  "column3",
  "configs",
  "copy",
  "delete",
  "edit",
  "feedback",
  "folderOpen",
  "follow",
  "github",
  "gohome",
  "home",
  "iconFilter",
  "lockStrok",
  "logout",
  "mail",
  "mobile",
  "music",
  "nextsong",
  "pausesong",
  "playlist",
  "playLoop",
  "playOrder",
  "playRandom",
  "playSingleLoop",
  "playsong",
  "PlusOutlined",
  "prevsong",
  "privateNet",
  "question",
  "refresh",
  "scroll",
  "search",
  "SettingOutlined",
  "smail",
  "solution",
  "sound",
  "soundMute",
  "star",
  "stopsong",
  "subCategory",
  "subCategoryInterface",
  "team",
  "type_array",
  "type_boolean",
  "type_int",
  "type_number",
  "type_object",
  "type_string",
  "unfollow",
  "unlock",
  "user",
  "yapi_logo"
];
const ALL = "ALL";
const GET = "GET";
const HEAD = "HEAD";
const OPTIONS = "OPTIONS";
const POST = "POST";
const PUT = "PUT";
const DELETE = "DELETE";
const PATCH = "PATCH";
const QUERY = "query";
const BODY = "body";
const DefaultInterfaceMenu = [{
  _id: ALL,
  title: State_UI.$t("\u5168\u90E8\u63A5\u53E3").label,
  menuType: ALL,
  list: []
}];
const NAME_LIMIT = 100;
const HTTP_METHOD = {
  [GET]: {
    color: "green",
    default_tab: QUERY
  },
  [HEAD]: {
    color: "purple",
    default_tab: QUERY
  },
  [OPTIONS]: {
    color: "default",
    default_tab: QUERY
  },
  [POST]: {
    color: "pink",
    request_body: true,
    default_tab: BODY
  },
  [PUT]: {
    color: "orange",
    request_body: true,
    default_tab: BODY
  },
  [DELETE]: {
    color: "red",
    request_body: true,
    default_tab: BODY
  },
  [PATCH]: {
    color: "blue",
    request_body: true,
    default_tab: BODY
  }
};
const LOG_TYPE = {
  project: "\u9879\u76EE",
  group: "\u5206\u7EC4",
  interface: "\u63A5\u53E3",
  interface_col: "\u63A5\u53E3\u96C6",
  user: "\u7528\u6237",
  other: "\u5176\u4ED6"
};
const PROJECT_COLOR = {
  notice: "#faad14",
  blue: "#2395f1",
  green: "#00a854",
  yellow: "#ffbf00",
  red: "#f56a00",
  pink: "#f5317f",
  cyan: "#00a2ae",
  gray: "#bfbfbf",
  purple: "#7265e6"
};
const HTTP_REQUEST_HEADER = ["Accept", "Accept-Charset", "Accept-Encoding", "Accept-Language", "Accept-Datetime", "Authorization", "Cache-Control", "Connection", "Cookie", "Content-Disposition", "Content-Length", "Content-MD5", "Content-Type", "Date", "Expect", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Max-Forwards", "Origin", "Pragma", "Proxy-Authorization", "Range", "Referer", "TE", "User-Agent", "Upgrade", "Via", "Warning", "X-Requested-With", "DNT", "X-Forwarded-For", "X-Forwarded-Host", "X-Forwarded-Proto", "Front-End-Https", "X-Http-Method-Override", "X-ATT-DeviceId", "X-Wap-Profile", "Proxy-Connection", "X-UIDH", "X-Csrf-Token"];
const METHOD_COLOR = {
  post: {
    bac: "#d2eafb",
    color: "#108ee9"
  },
  get: {
    bac: "#cfefdf",
    color: "#00a854"
  },
  put: {
    bac: "#fff3cf",
    color: "#ffbf00"
  },
  delete: {
    bac: "#fcdbd9",
    color: "#f04134"
  },
  head: {
    bac: "#fff3cf",
    color: "#ffbf00"
  },
  patch: {
    bac: "#fff3cf",
    color: "#ffbf00"
  },
  options: {
    bac: "#fff3cf",
    color: "#ffbf00"
  }
};
FormRules.nameLength = ({
  label,
  max: max3,
  min: min3
}) => {
  max3 = max3 || NAME_LIMIT;
  return FormRules.custom({
    msg: "",
    name: "",
    trigger: "",
    validator(value, {
      configs,
      rule
    }) {
      const strLength = (str) => {
        let length = 0;
        for (let i2 = 0; i2 < str.length; i2++) {
          str.charCodeAt(i2) > 255 ? length += 2 : length++;
        }
        return length;
      };
      const len = value ? strLength(value) : 0;
      if (len > max3) {
        rule.msg = `\u8BF7\u8F93\u5165${label}\u540D\u79F0\uFF0C\u957F\u5EA6\u4E0D\u8D85\u8FC7${max3}\u5B57\u7B26(\u4E2D\u6587\u7B97\u4F5C2\u5B57\u7B26)!`;
        return FormRules.FAIL;
      }
      if (xU.isInput(min3) && len < min3) {
        rule.msg = `\u8BF7\u8F93\u5165${label}\u540D\u79F0\uFF0C\u957F\u5EA6\u4E0D\u77ED\u4E8E${max3}\u5B57\u7B26(\u4E2D\u6587\u7B97\u4F5C2\u5B57\u7B26)!`;
        return FormRules.FAIL;
      }
      return FormRules.SUCCESS;
    }
  });
};
FormRules.apiPath = () => {
  return FormRules.custom({
    msg: State_UI.$t("\u8BF7\u8F93\u5165\u5408\u6CD5\u8DEF\u5F84").label,
    name: "",
    trigger: [EVENT_TYPE.blur],
    validator(path2) {
      if (path2[0] !== "/") {
        return FormRules.FAIL;
      } else {
        return FormRules.SUCCESS;
      }
    }
  });
};
const ViewNotFound = defineComponent({
  props: ["pathname"],
  setup() {
    return {
      Cpt_url
    };
  },
  methods: {
    goHome() {
      this.Cpt_url.go("/group");
    }
  },
  mounted() {
    if (this.Cpt_url.pathname === "/") {
      this.goHome();
    }
  },
  data(vm) {
    return {};
  },
  render() {
    return createVNode(resolveComponent("aResult"), {
      "status": "404",
      "title": "404",
      "subTitle": this.pathname,
      "class": "flex1"
    }, {
      extra: () => createVNode(resolveComponent("aButton"), {
        "type": "primary",
        "onClick": this.goHome
      }, {
        default: () => [this.$t("BackHome").label]
      })
    });
  }
});
var nprogress$1 = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(module2, exports2) {
  (function(root2, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    var NProgress2 = {};
    NProgress2.version = "0.2.0";
    var Settings = NProgress2.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: true,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: true,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    NProgress2.configure = function(options) {
      var key2, value;
      for (key2 in options) {
        value = options[key2];
        if (value !== void 0 && options.hasOwnProperty(key2))
          Settings[key2] = value;
      }
      return this;
    };
    NProgress2.status = null;
    NProgress2.set = function(n2) {
      var started = NProgress2.isStarted();
      n2 = clamp2(n2, Settings.minimum, 1);
      NProgress2.status = n2 === 1 ? null : n2;
      var progress = NProgress2.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
      progress.offsetWidth;
      queue2(function(next2) {
        if (Settings.positionUsing === "")
          Settings.positionUsing = NProgress2.getPositioningCSS();
        css2(bar, barPositionCSS(n2, speed, ease));
        if (n2 === 1) {
          css2(progress, {
            transition: "none",
            opacity: 1
          });
          progress.offsetWidth;
          setTimeout(function() {
            css2(progress, {
              transition: "all " + speed + "ms linear",
              opacity: 0
            });
            setTimeout(function() {
              NProgress2.remove();
              next2();
            }, speed);
          }, speed);
        } else {
          setTimeout(next2, speed);
        }
      });
      return this;
    };
    NProgress2.isStarted = function() {
      return typeof NProgress2.status === "number";
    };
    NProgress2.start = function() {
      if (!NProgress2.status)
        NProgress2.set(0);
      var work = function() {
        setTimeout(function() {
          if (!NProgress2.status)
            return;
          NProgress2.trickle();
          work();
        }, Settings.trickleSpeed);
      };
      if (Settings.trickle)
        work();
      return this;
    };
    NProgress2.done = function(force) {
      if (!force && !NProgress2.status)
        return this;
      return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
    };
    NProgress2.inc = function(amount) {
      var n2 = NProgress2.status;
      if (!n2) {
        return NProgress2.start();
      } else {
        if (typeof amount !== "number") {
          amount = (1 - n2) * clamp2(Math.random() * n2, 0.1, 0.95);
        }
        n2 = clamp2(n2 + amount, 0, 0.994);
        return NProgress2.set(n2);
      }
    };
    NProgress2.trickle = function() {
      return NProgress2.inc(Math.random() * Settings.trickleRate);
    };
    (function() {
      var initial = 0, current2 = 0;
      NProgress2.promise = function($promise) {
        if (!$promise || $promise.state() === "resolved") {
          return this;
        }
        if (current2 === 0) {
          NProgress2.start();
        }
        initial++;
        current2++;
        $promise.always(function() {
          current2--;
          if (current2 === 0) {
            initial = 0;
            NProgress2.done();
          } else {
            NProgress2.set((initial - current2) / initial);
          }
        });
        return this;
      };
    })();
    NProgress2.render = function(fromStart) {
      if (NProgress2.isRendered())
        return document.getElementById("nprogress");
      addClass2(document.documentElement, "nprogress-busy");
      var progress = document.createElement("div");
      progress.id = "nprogress";
      progress.innerHTML = Settings.template;
      var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent2 = document.querySelector(Settings.parent), spinner;
      css2(bar, {
        transition: "all 0 linear",
        transform: "translate3d(" + perc + "%,0,0)"
      });
      if (!Settings.showSpinner) {
        spinner = progress.querySelector(Settings.spinnerSelector);
        spinner && removeElement(spinner);
      }
      if (parent2 != document.body) {
        addClass2(parent2, "nprogress-custom-parent");
      }
      parent2.appendChild(progress);
      return progress;
    };
    NProgress2.remove = function() {
      removeClass2(document.documentElement, "nprogress-busy");
      removeClass2(document.querySelector(Settings.parent), "nprogress-custom-parent");
      var progress = document.getElementById("nprogress");
      progress && removeElement(progress);
    };
    NProgress2.isRendered = function() {
      return !!document.getElementById("nprogress");
    };
    NProgress2.getPositioningCSS = function() {
      var bodyStyle = document.body.style;
      var vendorPrefix2 = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
      if (vendorPrefix2 + "Perspective" in bodyStyle) {
        return "translate3d";
      } else if (vendorPrefix2 + "Transform" in bodyStyle) {
        return "translate";
      } else {
        return "margin";
      }
    };
    function clamp2(n2, min3, max3) {
      if (n2 < min3)
        return min3;
      if (n2 > max3)
        return max3;
      return n2;
    }
    function toBarPerc(n2) {
      return (-1 + n2) * 100;
    }
    function barPositionCSS(n2, speed, ease) {
      var barCSS;
      if (Settings.positionUsing === "translate3d") {
        barCSS = { transform: "translate3d(" + toBarPerc(n2) + "%,0,0)" };
      } else if (Settings.positionUsing === "translate") {
        barCSS = { transform: "translate(" + toBarPerc(n2) + "%,0)" };
      } else {
        barCSS = { "margin-left": toBarPerc(n2) + "%" };
      }
      barCSS.transition = "all " + speed + "ms " + ease;
      return barCSS;
    }
    var queue2 = function() {
      var pending = [];
      function next2() {
        var fn = pending.shift();
        if (fn) {
          fn(next2);
        }
      }
      return function(fn) {
        pending.push(fn);
        if (pending.length == 1)
          next2();
      };
    }();
    var css2 = function() {
      var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
      function camelCase(string3) {
        return string3.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match2, letter) {
          return letter.toUpperCase();
        });
      }
      function getVendorProp(name2) {
        var style2 = document.body.style;
        if (name2 in style2)
          return name2;
        var i2 = cssPrefixes.length, capName = name2.charAt(0).toUpperCase() + name2.slice(1), vendorName;
        while (i2--) {
          vendorName = cssPrefixes[i2] + capName;
          if (vendorName in style2)
            return vendorName;
        }
        return name2;
      }
      function getStyleProp(name2) {
        name2 = camelCase(name2);
        return cssProps[name2] || (cssProps[name2] = getVendorProp(name2));
      }
      function applyCss(element, prop, value) {
        prop = getStyleProp(prop);
        element.style[prop] = value;
      }
      return function(element, properties) {
        var args2 = arguments, prop, value;
        if (args2.length == 2) {
          for (prop in properties) {
            value = properties[prop];
            if (value !== void 0 && properties.hasOwnProperty(prop))
              applyCss(element, prop, value);
          }
        } else {
          applyCss(element, args2[1], args2[2]);
        }
      };
    }();
    function hasClass2(element, name2) {
      var list = typeof element == "string" ? element : classList(element);
      return list.indexOf(" " + name2 + " ") >= 0;
    }
    function addClass2(element, name2) {
      var oldList = classList(element), newList = oldList + name2;
      if (hasClass2(oldList, name2))
        return;
      element.className = newList.substring(1);
    }
    function removeClass2(element, name2) {
      var oldList = classList(element), newList;
      if (!hasClass2(element, name2))
        return;
      newList = oldList.replace(" " + name2 + " ", " ");
      element.className = newList.substring(1, newList.length - 1);
    }
    function classList(element) {
      return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
    }
    function removeElement(element) {
      element && element.parentNode && element.parentNode.removeChild(element);
    }
    return NProgress2;
  });
})(nprogress$1);
const NProgress = nprogress$1.exports;
const nprogress = "";
NProgress.configure({
  showSpinner: false
});
const makeAhref = (url2) => {
  console.log(State_UI.assetsPath);
  return `#${url2}`;
};
const RouterView = defineComponent({
  name: "RouterView",
  setup() {
    let ViewLength = inject("ViewLength");
    if (typeof ViewLength != "number") {
      ViewLength = 2;
    }
    provide("ViewLength", ViewLength + 1);
    return {
      Cpt_url,
      ViewLength
    };
  },
  data() {
    return {
      currentComponent: ""
    };
  },
  beforeUpdate() {
    NProgress.start();
  },
  updated() {
    NProgress.done();
  },
  watch: {
    "Cpt_url.pathname": {
      immediate: true,
      async handler(pathname) {
        this.currentComponent = markRaw(await this.getComponent(pathname.split("/")));
      }
    }
  },
  methods: {
    async getComponent(pathArray) {
      if (pathArray.length > this.ViewLength) {
        pathArray.pop();
        return await this.getComponent(pathArray);
      }
      if (pathArray.length == this.ViewLength) {
        const route2 = xU.find(routes, {
          path: pathArray.join("/")
        });
        if (route2 && route2.component) {
          if (xU.isFunction(route2.component)) {
            const modules = await route2.component();
            if (route2.componentName) {
              route2.component = modules[route2.componentName];
            } else {
              route2.component = xU.getObjectFirstKeyValue(modules);
            }
          }
          return route2.component;
        }
      }
      return ViewNotFound;
    }
  },
  computed: {
    vDomView() {
      if (!this.currentComponent) {
        return createVNode(resolveComponent("aSpin"), {
          "spinning": true,
          "class": "flex middle"
        }, null);
      } else {
        return h$1(this.currentComponent, {
          pathname: this.Cpt_url.pathname
        });
      }
    }
  },
  render() {
    return this.vDomView;
  }
});
const ErrMsg$1 = "";
const ErrMsg = defineComponent({
  name: "ErrMsg",
  props: ["type", "history", "title", "desc", "opration"],
  render() {
    let {
      type: type4,
      title,
      desc,
      opration
    } = this;
    let icon = "frown-o";
    if (type4) {
      switch (type4) {
        case "noFollow":
          title = "\u4F60\u8FD8\u6CA1\u6709\u5173\u6CE8\u9879\u76EE\u5462";
          desc = createVNode("span", null, [createTextVNode("\u5148\u53BB "), createVNode("a", {
            "onClick": () => Cpt_url.value.go("/group")
          }, [createTextVNode("\u201C\u9879\u76EE\u5E7F\u573A\u201D")]), " ", createTextVNode("\u901B\u901B\u5427, \u90A3\u91CC\u53EF\u4EE5\u6DFB\u52A0\u5173\u6CE8\u3002")]);
          break;
        case "noInterface":
          title = "\u8BE5\u9879\u76EE\u8FD8\u6CA1\u6709\u63A5\u53E3\u5462";
          desc = "\u5728\u5DE6\u4FA7 \u201C\u63A5\u53E3\u5217\u8868\u201D \u4E2D\u6DFB\u52A0\u63A5\u53E3";
          break;
        case "noMemberInProject":
          title = "\u8BE5\u9879\u76EE\u8FD8\u6CA1\u6709\u6210\u5458\u5462";
          break;
        case "noMemberInGroup":
          title = "\u8BE5\u5206\u7EC4\u8FD8\u6CA1\u6709\u6210\u5458\u5462";
          break;
        case "noProject":
          title = "\u8BE5\u5206\u7EC4\u8FD8\u6CA1\u6709\u9879\u76EE\u5462";
          desc = createVNode("span", null, [createTextVNode("\u8BF7\u70B9\u51FB\u53F3\u4E0A\u89D2\u6DFB\u52A0\u9879\u76EE\u6309\u94AE\u65B0\u5EFA\u9879\u76EE")]);
          break;
        case "noData":
          title = "\u6682\u65E0\u6570\u636E";
          desc = "\u5148\u53BB\u522B\u5904\u901B\u901B\u5427";
          break;
        case "noChange":
          title = "\u6CA1\u6709\u6539\u52A8";
          desc = "\u8BE5\u64CD\u4F5C\u672A\u6539\u52A8 Api \u6570\u636E";
          icon = "meh-o";
          break;
        default:
          console.log("default");
      }
    }
    return createVNode("div", {
      "class": "err-msg",
      "style": "margin:auto;"
    }, [createVNode(resolveComponent("aIcon"), {
      "type": icon,
      "class": "icon"
    }, null), createVNode("p", {
      "class": "title"
    }, [title]), createVNode("p", {
      "class": "desc"
    }, [desc]), createVNode("p", {
      "class": "opration"
    }, [opration])]);
  }
});
const InfoCard$1 = "";
const InfoCardCol = defineComponent({
  props: ["col"],
  computed: {
    isHide() {
      return this.col.isHide || false;
    },
    styleLabel() {
      return {};
    },
    vDomLabel() {
      return this.col.label;
    },
    vDomContent() {
      return this.col.value;
    }
  },
  render() {
    if (this.isHide) {
      return null;
    }
    return createVNode(Fragment, null, [createVNode("div", {
      "class": "ant-descriptions-item-label",
      "style": this.styleLabel
    }, [this.vDomLabel]), createVNode("div", {
      "class": "ant-descriptions-item-content flex1"
    }, [this.vDomContent])]);
  }
});
const InfoCardRow = defineComponent({
  props: ["row"],
  computed: {
    colArray() {
      var _a2;
      return ((_a2 = this == null ? void 0 : this.row) == null ? void 0 : _a2.colArray) || false;
    },
    vDomCol() {
      if (this.row) {
        return xU.map(this.colArray, (col) => {
          return createVNode(InfoCardCol, {
            "col": col
          }, null);
        });
      }
      return null;
    },
    styleRow() {
      var _a2;
      if ((_a2 = this == null ? void 0 : this.row) == null ? void 0 : _a2.style) {
        return this.row.style;
      }
      return "";
    }
  },
  render() {
    return createVNode("div", {
      "class": "InfoCardRow ant-descriptions-row flex middle",
      "style": this.styleRow
    }, [this.vDomCol]);
  }
});
const InfoCard = defineComponent({
  props: ["info", "title"],
  methods: {
    updateLableStyle(styleObject) {
      const styleString = xU.map(xU.merge({
        "min-width": "120px",
        "text-align": "right"
      }, styleObject), (value, prop) => `${prop}: ${value}`).join(";");
      const styleContent = `#${this.id} .ant-descriptions-item-label {${styleString}}`;
      if (!this.$styleEle) {
        const $form = $$1(`#${this.id}`);
        const $style = $$1("<style/>", {
          id: `style_${this.id}`
        });
        $form.prepend($style);
        this.$styleEle = $style;
      }
      this.$styleEle.html(styleContent);
    }
  },
  mounted() {
    this.$watch("info.colLabelWidth", (width) => {
      if (width) {
        console.log("width", width);
        this.updateLableStyle({
          width
        });
      }
    }, {
      immediate: true,
      deep: true
    });
  },
  computed: {
    id() {
      return `InfoCard_${this._.uid}`;
    },
    colLabelWidth() {
      var _a2;
      return ((_a2 = this == null ? void 0 : this.info) == null ? void 0 : _a2.colLabelWidth) || "120px";
    },
    rowArray() {
      var _a2;
      return ((_a2 = this == null ? void 0 : this.info) == null ? void 0 : _a2.rowArray) || false;
    },
    vDomTitle() {
      if (!this.title) {
        return null;
      }
      return createVNode("div", {
        "class": "ant-descriptions-header"
      }, [createVNode("div", {
        "class": "ant-descriptions-title"
      }, [this.title])]);
    },
    vDomDescriptions() {
      if (this.rowArray) {
        return createVNode("div", {
          "class": "ant-descriptions-view"
        }, [xU.map(this.rowArray, (row) => {
          return createVNode(InfoCardRow, {
            "row": row
          }, null);
        })]);
      }
      if (this.$slots.default) {
        return this.$slots.default();
      }
      return null;
    }
  },
  render() {
    return createVNode("div", {
      "class": "ant-descriptions ant-descriptions-middle ant-descriptions-bordered x-infomation-card",
      "id": this.id
    }, [this.vDomTitle, this.vDomDescriptions]);
  }
});
function _isSlot$5(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const ITEM_OPTIONS = {
  httpMethod: xU.map(HTTP_METHOD, (item, prop) => ({
    label: prop,
    value: prop,
    color: item.color
  })),
  interfaceBodyType: [{
    label: "form",
    value: "form",
    isForm: true
  }, {
    label: "json",
    value: "json"
  }, {
    label: "file",
    value: "file"
  }, {
    label: "raw",
    value: "raw"
  }],
  interfaceBodyFormType: [{
    label: "text",
    value: "text"
  }, {
    label: "file",
    value: "file"
  }],
  httpProtocol: [{
    label: "http://",
    value: "http://"
  }, {
    label: "https://",
    value: "https://"
  }],
  interfaceStatus: [{
    label: "\u5DF2\u5B8C\u6210",
    value: "done"
  }, {
    label: "\u672A\u5B8C\u6210",
    value: "undone"
  }],
  status: [{
    label: "\u5F00\u901A",
    value: "ACTIVATED"
  }, {
    label: "\u672A\u5F00\u901A",
    value: "NONACTIVATED"
  }],
  YesOrNo: [{
    label: "\u662F",
    value: "true"
  }, {
    label: "\u5426",
    value: "false"
  }],
  trueOrFalse: [{
    label: "\u662F",
    value: true
  }, {
    label: "\u5426",
    value: false
  }],
  required: [{
    label: "\u5FC5\u9700",
    value: "1",
    color: "red"
  }, {
    label: "\u975E\u5FC5\u9700",
    value: "0"
  }],
  statusFn(action) {
    if (action === "all") {
      return [{
        label: "\u6240\u6709\u72B6\u6001",
        value: ""
      }].concat(this.status);
    }
    return this.status;
  }
};
const ITEM_OPTIONS_VDOM = {
  interfaceBodyFormType(cell) {
    if (!xU.isInput(cell))
      return null;
    const i2 = xU.find(ITEM_OPTIONS.interfaceBodyFormType, {
      value: cell
    });
    return createVNode(resolveComponent("aTag"), null, {
      default: () => [i2.label]
    });
  },
  required(cell) {
    if (!xU.isInput(cell))
      return null;
    const i2 = xU.find(ITEM_OPTIONS.required, {
      value: String(cell).toLocaleUpperCase()
    });
    return createVNode(resolveComponent("aTag"), {
      "color": i2.color
    }, {
      default: () => [i2.label]
    });
  },
  httpMethod(cell) {
    if (!xU.isInput(cell))
      return null;
    const i2 = xU.find(ITEM_OPTIONS.httpMethod, {
      value: String(cell).toLocaleUpperCase()
    });
    return createVNode(resolveComponent("aTag"), {
      "color": i2.color
    }, {
      default: () => [i2.label]
    });
  },
  status: (status) => {
    if (!xU.isInput(status))
      return null;
    const item = xU.find(ITEM_OPTIONS.interfaceStatus, {
      value: status
    });
    return createVNode("span", {
      "class": "tag-status " + item.value
    }, [item.label]);
  },
  tags: (tags) => {
    if (!xU.isInput(tags))
      return null;
    if (typeof tags === "string") {
      tags = tags.split(",");
    }
    return xU.map(tags, (i2) => createVNode(resolveComponent("aTag"), {
      "color": "blue"
    }, _isSlot$5(i2) ? i2 : {
      default: () => [i2]
    }));
  }
};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent2 = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$4(message2) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message2.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  var debug, message2, reselectPrevious, range3, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent2();
    range3 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format5 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format5, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range3.selectNodeContents(mark);
    selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message2 = format$4("message" in options ? options.message : defaultMessage);
      window.prompt(message2, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
const _sfc_main$3 = {
  methods: {
    copyText() {
      if (copyToClipboard($$1(this.$refs.contents).text())) {
        UI.message.success(this.$t("\u5DF2\u7ECF\u6210\u529F\u590D\u5236\u5230\u526A\u5207\u677F").label);
      } else {
        UI.message.error(this.$t("\u590D\u5236\u5230\u526A\u5207\u677F\u5931\u8D25").label);
      }
    }
  }
};
const CopyContent_vue_vue_type_style_index_0_scoped_1b3c3d24_lang = "";
const _hoisted_1 = {
  class: "flex middle copy-content-wrapper",
  ref: "contents"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xIcon = resolveComponent("xIcon");
  const _directive_uiPopover = resolveDirective("uiPopover");
  return openBlock(), createElementBlock("span", _hoisted_1, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    withDirectives(createVNode(_component_xIcon, {
      icon: "copy",
      class: "ml10 copy-content-wrapper_icon",
      onClick: $options.copyText
    }, null, 8, ["onClick"]), [
      [_directive_uiPopover, { content: "copy" }]
    ])
  ], 512);
}
const CopyContent = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-1b3c3d24"]]);
const asyncGetMonaco = async () => {
  if (window.monaco) {
    return window.monaco;
  }
  await xU.asyncGlobalJS("require", `${State_UI.bashPath}monaco/vs/loader.js`);
  window.VentoseUtils = {
    iStorage,
    $: $$1,
    xU,
    vs: `${State_UI.bashPath}monaco/vs`
  };
  await xU.asyncGlobalJS(
    "monacoNls",
    `${State_UI.bashPath}monaco/vs/editor/editor.main.nls.js`
  );
  const monacoLoader = await xU.asyncGlobalJS(
    "monaco",
    `${State_UI.bashPath}monaco/vs/editor/editor.main.js`
  );
  return await monacoLoader();
};
const theme = ["vs", "vs-dark", "hc-black", "hc-light"];
const MonacoEditor = defineAsyncComponent(() => new Promise(async (resolve2) => {
  const monaco = await asyncGetMonaco();
  resolve2(defineComponent({
    props: ["code", "language", "theme", "readOnly"],
    emits: ["update:code"],
    data() {
      return {
        id: xU.genId("MonacoEditor")
      };
    },
    mounted() {
      this.init();
    },
    watch: {
      code(value) {
        if (value !== this.raw$Value) {
          this.raw$editor.setValue(value);
        }
      }
    },
    methods: {
      async init() {
        let vm = this;
        vm.$refs.container.innerHTML = "";
        this.raw$editor = monaco.editor.create(this.$refs.container, {
          value: this.code || "",
          language: this.language || "javascript",
          minimap: {
            enabled: false
          },
          fontSize: 12,
          readOnly: this.readOnly || false,
          fixedOverflowWidgets: true,
          theme: this.theme || theme[3],
          automaticLayout: true
        });
        this.raw$editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
          this.raw$editor.trigger("", "editor.action.formatDocument");
        });
        this.raw$editor.addCommand(monaco.KeyCode.F9, () => {
          xU.launchFullscreen(this.$refs.container);
        });
        this.raw$editor.onDidChangeModelContent(this.syncData);
      },
      syncData() {
        const newCode = this.raw$editor.getValue();
        if (newCode !== this.code) {
          this.raw$Value = newCode;
          this.$emit("update:code", newCode);
        }
      }
    },
    render() {
      return createVNode("div", {
        "id": this.id,
        "ref": "container",
        "class": "flex1",
        "style": "height:100%;width:100%"
      }, null);
    }
  }));
}));
dayjs.locale("zh-cn");
const appPlugins = {
  install: (app, options) => {
    app.use(VentoseUIWithInstall, {
      appPlugins,
      dependState: options.dependState
    });
    app.use({
      install: (app2, {
        watch: watch2
      } = {}) => {
        app2.component("InfoCard", InfoCard);
        app2.component("InfoCardRow", InfoCardRow);
        app2.component("InfoCardCol", InfoCardCol);
        app2.component("RouterView", RouterView);
        app2.component("ErrMsg", ErrMsg);
        app2.component("CopyContent", CopyContent);
        app2.component("MonacoEditor", MonacoEditor);
        app2.config.globalProperties.$t = State_UI.$t;
        State_UI.setAssetsBaseById("favicon-icon");
        $$1("html").attr("lang", State_UI.language);
        watch2 && watch2();
      }
    });
    return app;
  }
};
const _$randomValueAndProp = (obj) => {
  if (xU.isArray(obj) && obj.length > 0) {
    const start = 0;
    const end = obj.length;
    const key2 = Math.floor(Math.random() * end + start);
    return [obj[key2], key2];
  } else if (xU.isPlainObject(obj)) {
    const objArray = Object.keys(obj);
    const [prop] = _$randomValueAndProp(objArray);
    return [obj[prop], prop];
  } else {
    return ["", 0];
  }
};
const _$handlePath = (path2) => {
  path2 = xU.trim(path2);
  if (!path2) {
    return path2;
  }
  if (path2 === "/") {
    return "";
  }
  path2 = path2[0] !== "/" ? "/" + path2 : path2;
  path2 = path2[path2.length - 1] === "/" ? path2.substr(0, path2.length - 1) : path2;
  return path2;
};
const _$timeAgo = function(timestamp) {
  let minutes, hours, days, seconds, mouth, year;
  const timeNow = parseInt(new Date().getTime() / 1e3);
  seconds = timeNow - timestamp;
  if (seconds > 86400 * 30 * 12) {
    year = parseInt(seconds / (86400 * 30 * 12));
  } else {
    year = 0;
  }
  if (seconds > 86400 * 30) {
    mouth = parseInt(seconds / (86400 * 30));
  } else {
    mouth = 0;
  }
  if (seconds > 86400) {
    days = parseInt(seconds / 86400);
  } else {
    days = 0;
  }
  if (seconds > 3600) {
    hours = parseInt(seconds / 3600);
  } else {
    hours = 0;
  }
  minutes = parseInt(seconds / 60);
  if (year > 0) {
    return year + "\u5E74\u524D";
  } else if (mouth > 0 && year <= 0) {
    return mouth + "\u6708\u524D";
  } else if (days > 0 && mouth <= 0) {
    return days + "\u5929\u524D";
  } else if (days <= 0 && hours > 0) {
    return hours + "\u5C0F\u65F6\u524D";
  } else if (hours <= 0 && minutes > 0) {
    return minutes + "\u5206\u949F\u524D";
  } else if (minutes <= 0 && seconds > 0) {
    if (seconds < 30) {
      return "\u521A\u521A";
    } else {
      return seconds + "\u79D2\u524D";
    }
  } else {
    return "\u521A\u521A";
  }
};
const _$arrayChangeIndex = (arr, dragId, dropId) => {
  arr = JSON.parse(JSON.stringify(arr));
  const findBy = {
    _id: dragId
  };
  const dragItem = xU.find(arr, findBy);
  const dragIndex = xU.findIndex(arr, findBy);
  const dropIndex = xU.findIndex(arr, {
    _id: dropId
  });
  if (dragIndex > -1 && dropIndex > -1) {
    arr[dragIndex] = null;
    arr.splice(dropIndex, 0, dragItem);
    let index2 = 0;
    return xU.reduce(arr, (_arr, item) => {
      if (item) {
        _arr.push({
          id: item._id,
          index: index2++
        });
      }
      return _arr;
    }, []);
  } else {
    return [];
  }
};
function _isSlot$4(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const xItem_ProjectColor = (options = {}) => {
  const [value] = _$randomValueAndProp(PROJECT_COLOR);
  return {
    value,
    prop: "color",
    itemType: "Select",
    label: State_UI.$t("icon\u80CC\u666F\u989C\u8272").label,
    rules: [FormRules.required()],
    options: xU.map(PROJECT_COLOR, (background) => {
      return {
        label: createVNode("span", {
          "style": {
            background,
            color: "transparent"
          }
        }, [createTextVNode("_______________")]),
        value: background
      };
    })
  };
};
const xItem_ProjectIcon = (options = {}) => {
  const [value] = _$randomValueAndProp(optionsXIcon);
  return {
    value,
    prop: "icon",
    itemType: "Select",
    label: State_UI.$t("\u56FE\u6807").label,
    rules: [FormRules.required()],
    options: xU.map(optionsXIcon, (value2) => {
      return {
        label: createVNode("span", null, [createVNode(resolveComponent("xIcon"), {
          "icon": value2
        }, null), createVNode("span", {
          "class": "ml10"
        }, [value2])]),
        value: value2
      };
    })
  };
};
const xItem_ProjectName = (options = {}) => {
  const value = options.value || "";
  const prop = options.prop || "name";
  const appendRules = options.appendRules;
  const rules2 = [FormRules.required("\u8BF7\u8F93\u5165\u9879\u76EE\u540D\u79F0"), FormRules.nameLength({
    label: State_UI.$t("\u9879\u76EE").label
  })];
  if (xU.isArray(appendRules)) {
    rules2.concat(appendRules);
  }
  return {
    itemType: "Input",
    label: "\u9879\u76EE\u540D\u79F0",
    prop,
    value,
    rules: rules2
  };
};
const DialogAddProject = defineComponent({
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  setup() {
    return {
      State_App: _State_App
    };
  },
  data() {
    const vm = this;
    return {
      dataXItem: {
        ...defItem({
          value: vm.propDialogOptions.groupId || "",
          prop: "group_id",
          label: "\u6240\u5C5E\u5206\u7EC4",
          placeholder: "\u8BF7\u9009\u62E9\u9879\u76EE\u6240\u5C5E\u7684\u5206\u7EC4",
          itemType: "Select",
          options: [],
          rules: [FormRules.required("\u8BF7\u9009\u62E9\u9879\u76EE\u6240\u5C5E\u7684\u5206\u7EC4!")],
          once() {
            vm.$watch("State_App.groupList", (groupList) => {
              vm.dataXItem.group_id.options = xU.map(groupList, (i2) => {
                return {
                  label: i2.group_name,
                  value: String(i2._id),
                  disabled: !["dev", "owner", "admin"].includes(i2.role)
                };
              });
            }, {
              immediate: true
            });
          }
        }),
        ...defItem(xItem_ProjectName()),
        ...defItem(xItem_ProjectIcon()),
        ...defItem(xItem_ProjectColor()),
        ...defItem({
          value: "/",
          prop: "basepath",
          label: defItem.labelWithTips({
            label: "\u57FA\u672C\u8DEF\u5F84",
            tips: "\u63A5\u53E3\u57FA\u672C\u8DEF\u5F84\uFF0C\u9ED8\u8BA4\u662F/",
            icon: createVNode(resolveComponent("xIcon"), {
              "icon": "question"
            }, null)
          }),
          placeholder: "\u63A5\u53E3\u57FA\u672C\u8DEF\u5F84\uFF0C\u9ED8\u8BA4\u662F/",
          rules: [FormRules.required("\u8BF7\u8F93\u5165\u9879\u76EE\u57FA\u672C\u8DEF\u5F84!")]
        }),
        ...defItem({
          value: "",
          prop: "desc",
          label: "\u63CF\u8FF0",
          isTextarea: true,
          placeholder: "\u63CF\u8FF0\u4E0D\u8D85\u8FC7144\u5B57!",
          showCount: true,
          maxlength: 144
        }),
        ...defItem({
          itemType: "RadioGroup",
          value: "private",
          prop: "project_type",
          label: "\u6743\u9650",
          options: [{
            label: createVNode(resolveComponent("aTooltip"), {
              "title": "\u53EA\u6709\u7EC4\u957F\u548C\u9879\u76EE\u5F00\u53D1\u8005\u53EF\u4EE5\u7D22\u5F15\u5E76\u67E5\u770B\u9879\u76EE\u4FE1\u606F"
            }, {
              default: () => [createVNode("span", {
                "class": "flex middle"
              }, [createVNode(resolveComponent("xIcon"), {
                "icon": "lockStrok"
              }, null), createVNode("span", null, [createTextVNode("\u79C1\u6709")])])]
            }),
            value: "private"
          }, {
            label: createVNode(resolveComponent("aTooltip"), {
              "title": "\u4EFB\u4F55\u4EBA\u90FD\u53EF\u4EE5\u7D22\u5F15\u5E76\u67E5\u770B\u9879\u76EE\u4FE1\u606F"
            }, {
              default: () => [createVNode("span", {
                "class": "flex middle"
              }, [createVNode(resolveComponent("xIcon"), {
                "icon": "unlock"
              }, null), createVNode("span", null, [createTextVNode("\u516C\u5F00")])])]
            }),
            value: "public"
          }]
        })
      },
      state: {
        groupList: []
      }
    };
  },
  mounted() {
    this.init();
  },
  methods: {
    async init() {
      Methods_App.setBreadcrumb([{
        name: "\u65B0\u5EFA\u9879\u76EE"
      }]);
      if (!_State_App.currGroup._id) {
        await Methods_App.fetchGroupList();
      }
      if (_State_App.groupList.length === 0) {
        return null;
      }
    },
    async submit() {
      const vm = this;
      try {
        const validateResults = await validateForm(vm.dataXItem);
        if (AllWasWell(validateResults)) {
          const formData = pickValueFrom(vm.dataXItem);
          const {
            data: data9
          } = await API.project.addProject(formData);
          UI.notification.success("\u521B\u5EFA\u6210\u529F! ");
          return true;
        } else {
          throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
        }
      } catch (e2) {
        console.error(e2);
      }
    },
    _$handlePath(e2) {
      let val = e2.target.value;
      this.props.form.setFieldsValue({
        basepath: _$handlePath(val)
      });
    }
  },
  render() {
    let _slot;
    return createVNode(Fragment, null, [createVNode("div", {
      "class": "g-row flex1 height100"
    }, [createVNode("div", {
      "class": "g-row m-container"
    }, [createVNode(resolveComponent("xForm"), {
      "class": "flex vertical",
      "labelStyle": {
        "min-width": "120px",
        width: "unset"
      }
    }, _isSlot$4(_slot = xU.map(this.dataXItem, (configs, prop) => {
      return createVNode(Fragment, null, [createVNode(resolveComponent("xGap"), {
        "t": "10"
      }, null), createVNode(resolveComponent("xItem"), {
        "configs": configs
      }, null)]);
    })) ? _slot : {
      default: () => [_slot]
    })])]), createVNode(resolveComponent("xDialogFooter"), {
      "configs": {
        onCancel: this.propDialogOptions.closeDialog,
        onOk: async () => {
          const res = await this.submit();
          if (res) {
            this.propDialogOptions.updateProjectList();
            this.propDialogOptions.closeDialog();
          }
        }
      }
    }, null)]);
  }
});
const _sfc_main$2 = defineComponent({
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  methods: {
    async onOk() {
      const validateResults = await validateForm(this.formItems);
      if (AllWasWell(validateResults)) {
        const {
          name: name2,
          icon
        } = pickValueFrom(this.formItems);
        try {
          await this.propDialogOptions.copyProject({
            newProjectName: name2,
            icon
          });
          this.propDialogOptions.closeDialog();
        } catch (error) {
          console.error(error);
          UI.message.error("\u590D\u5236\u5931\u8D25");
        }
      } else {
        throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
      }
    }
  },
  computed: {
    propProjectName() {
      var _a2;
      return String(((_a2 = this.propDialogOptions) == null ? void 0 : _a2.projectName) || "");
    },
    dialogDefautBtn() {
      return {
        textOk: this.$t("\u590D\u5236").label,
        onCancel: this.propDialogOptions.closeDialog,
        onOk: this.onOk
      };
    }
  },
  data() {
    const vm = this;
    return {
      alertMessage: `\u8BE5\u64CD\u4F5C\u5C06\u4F1A\u590D\u5236 ${this.propProjectName} \u4E0B\u7684\u6240\u6709\u63A5\u53E3\u96C6\u5408\uFF0C\u4F46\u4E0D\u5305\u62EC\u6D4B\u8BD5\u96C6\u5408\u4E2D\u7684\u63A5\u53E3`,
      formItems: {
        ...defItem(xItem_ProjectName({
          value: this.propProjectName,
          appendRules: [FormRules.custom({
            validator(value, {
              configs,
              rule
            }) {
              if (value === vm.propDialogOptions.projectName) {
                rule.msg = "\u4E0D\u80FD\u4E0E\u539F\u9879\u76EE\u540D\u76F8\u540C";
                return FormRules.FAIL;
              } else {
                return FormRules.SUCCESS;
              }
            }
          })]
        })),
        ...defItem(xItem_ProjectIcon())
      }
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_aAlert = resolveComponent("aAlert");
  const _component_xGap = resolveComponent("xGap");
  const _component_xItem = resolveComponent("xItem");
  const _component_xForm = resolveComponent("xForm");
  const _component_aCard = resolveComponent("aCard");
  const _component_xDialogFooter = resolveComponent("xDialogFooter");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_aCard, { class: "flex1" }, {
      default: withCtx(() => [
        createVNode(_component_aAlert, {
          message: _ctx.alertMessage,
          type: "info"
        }, null, 8, ["message"]),
        createVNode(_component_xForm, {
          class: "flex vertical",
          "label-style": { "min-width": "120px", width: "unset" }
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formItems, (item, prop) => {
              return openBlock(), createElementBlock(Fragment, { key: prop }, [
                createVNode(_component_xGap, { t: "10" }),
                createVNode(_component_xItem, { configs: item }, null, 8, ["configs"])
              ], 64);
            }), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_xDialogFooter, { configs: _ctx.dialogDefautBtn }, null, 8, ["configs"])
  ], 64);
}
const ViewCopyProject = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const ProjectCard = defineComponent({
  props: ["projectData", "uid", "inFollowPage", "callbackResult", "isShow", "getProject", "checkProjectName", "currPage"],
  setup() {
    return {
      State_App: _State_App,
      Cpt_url
    };
  },
  methods: {
    showCopyProjectDialog() {
      UI.dialog.component({
        title: `\u590D\u5236\u9879\u76EE${this.projectData.name}`,
        component: ViewCopyProject,
        copyProject: this.copyProject,
        projectName: this.projectData.name
      });
    },
    async copyProject({
      newProjectName,
      icon
    }) {
      const id = this.projectData._id;
      let {
        data: data9
      } = await API.project.getProjectById(id);
      data9 = xU.merge(data9, {
        icon
      }, {
        name: newProjectName
      }, {
        preName: data9.name
      });
      await API.project.copyProjectMsg(data9);
      UI.message.success("\u9879\u76EE\u590D\u5236\u6210\u529F");
      this.callbackResult();
    },
    async goToProject() {
      this.Cpt_url.go("/project/interface/all", {
        project_id: this.projectData._id,
        group_id: this.Cpt_url.query.group_id
      });
    },
    add: xU.debounce(async function() {
      try {
        const {
          projectData
        } = this;
        const uid2 = this.State_App.user.uid;
        const param = {
          uid: uid2,
          projectid: projectData._id,
          projectname: projectData.name,
          icon: projectData.icon,
          color: projectData.color
        };
        await API.project.addFollow(param);
      } catch (error) {
        console.error(error);
      } finally {
        this.callbackResult();
      }
    }, 300),
    del: xU.debounce(async function() {
      try {
        const id = this.projectData.projectid || this.projectData._id;
        await API.project.delFollow(id);
      } catch (error) {
        console.error(error);
      } finally {
        this.callbackResult();
      }
    }, 300)
  },
  computed: {
    followIcon() {
      return createVNode("span", {
        "class": "pointer",
        "onClick": this.followIconClickHandler
      }, [createVNode(resolveComponent("aTooltip"), {
        "placement": "rightTop",
        "title": this.followIconTitle
      }, {
        default: () => [createVNode(resolveComponent("xIcon"), {
          "icon": this.followIconIcon,
          "style": {
            color: "#faad14"
          }
        }, null)]
      })]);
    },
    copyIcon() {
      if (this.isShow) {
        return createVNode("span", {
          "class": "pointer icon-copy",
          "onClick": this.showCopyProjectDialog
        }, [createVNode(resolveComponent("aTooltip"), {
          "placement": "rightTop",
          "title": "\u590D\u5236\u9879\u76EE"
        }, {
          default: () => [createVNode(resolveComponent("xIcon"), {
            "icon": "copy",
            "style": {
              color: "#232426"
            }
          }, null)]
        })]);
      }
      return null;
    },
    iconStyle() {
      return {
        color: "white",
        width: "84px",
        height: "84px",
        borderRadius: "16px",
        backgroundColor: this.projectData.color
      };
    },
    isFollowStatus() {
      return Boolean(this.projectData.follow || this.inFollowPage);
    },
    followIconTitle() {
      return this.isFollowStatus ? "\u53D6\u6D88\u5173\u6CE8" : "\u6DFB\u52A0\u5173\u6CE8";
    },
    followIconIcon() {
      return this.isFollowStatus ? "follow" : "unfollow";
    },
    followIconClickHandler() {
      return this.isFollowStatus ? this.del : this.add;
    },
    logo() {
      return createVNode(resolveComponent("xIcon"), {
        "class": "ui-logo",
        "icon": this.projectData.icon,
        "style": this.iconStyle,
        "onClick": this.goToProject
      }, null);
    },
    title() {
      return createVNode("h4", {
        "class": "ui-title"
      }, [createVNode("span", {
        "class": "mr10"
      }, [this.projectData._id]), createVNode("span", null, [this.projectData.name || this.projectData.projectname])]);
    }
  },
  render() {
    return createVNode("div", {
      "class": "card-container",
      "style": "width:200px;"
    }, [createVNode(resolveComponent("aCard"), {
      "hoverable": true,
      "class": "m-card"
    }, {
      default: () => [this.logo, this.title]
    }), createVNode("div", {
      "class": "card-btns flex"
    }, [this.copyIcon, createVNode(resolveComponent("xGap"), {
      "l": "10"
    }, null), this.followIcon])]);
  }
});
const ProjectList = "";
const GroupProjectList = defineComponent({
  setup() {
    return {
      State_App: _State_App,
      Cpt_url
    };
  },
  data() {
    const vm = this;
    vm.fetchProjectList = xU.debounce(async function() {
      await Methods_App.fetchProjectList(vm.Cpt_url.query.group_id);
      vm.isLoading = false;
    });
    vm.updateProjectList = () => {
      vm.isLoading = true;
      vm.fetchProjectList();
    };
    return {
      configs: {},
      isLoading: false,
      state: {
        visible: false,
        protocol: "http://",
        projectData: []
      }
    };
  },
  computed: {
    vDomAddProjectButton() {
      if (this.isAuthAddProject) {
        return createVNode(resolveComponent("aButton"), {
          "type": "primary",
          "onClick": this.showAddProjectDialog
        }, {
          default: () => [createTextVNode("\u6DFB\u52A0\u9879\u76EE")]
        });
      } else {
        return createVNode(resolveComponent("aTooltip"), {
          "title": "\u60A8\u6CA1\u6709\u6743\u9650,\u8BF7\u8054\u7CFB\u8BE5\u5206\u7EC4\u7EC4\u957F\u6216\u7BA1\u7406\u5458"
        }, {
          default: () => [createVNode(resolveComponent("aButton"), {
            "type": "primary",
            "disabled": true
          }, {
            default: () => [createTextVNode("\u6DFB\u52A0\u9879\u76EE")]
          })]
        });
      }
    },
    vDomNoFollowPanel() {
      const isUnfollow = (project2) => !project2.follow;
      let unfollowArray = xU.sortBy(xU.filter(this.projectData, isUnfollow), ["up_time"]);
      if (xU.isArrayFill(unfollowArray)) {
        return createVNode("div", {
          "style": {
            borderBottom: "1px solid #eee",
            marginBottom: "15px"
          }
        }, [createVNode("h3", {
          "class": "owner-type"
        }, [createTextVNode("\u6211\u7684\u9879\u76EE")]), this.genProjectCard(unfollowArray, this.isAuthAddProject)]);
      }
      return null;
    },
    vDomFollowPanel() {
      const isFollow = (project2) => !!project2.follow;
      let followProject = xU.sortBy(xU.filter(this.projectData, isFollow), ["up_time"]);
      if (xU.isArrayFill(followProject)) {
        return createVNode("div", {
          "style": {
            borderBottom: "1px solid #eee",
            marginBottom: "15px"
          }
        }, [createVNode("h3", {
          "class": "owner-type"
        }, [createTextVNode("\u6211\u7684\u5173\u6CE8")]), this.genProjectCard(followProject)]);
      } else {
        return null;
      }
    },
    vDomOwnerSpace() {
      return this.projectData.length ? createVNode("div", {
        "class": "flex1 height100 overflow-auto"
      }, [this.vDomNoFollowPanel, this.vDomFollowPanel]) : createVNode(ErrMsg, {
        "type": "noProject"
      }, null);
    },
    vDomSpaceProject() {
      if (this.State_App.currGroup.type === "private") {
        return this.vDomOwnerSpace;
      } else {
        if (this.projectData.length) {
          return this.genProjectCard(this.projectData, this.isAuthAddProject);
        } else {
          return createVNode("div", {
            "class": "flex center width100"
          }, [createVNode(ErrMsg, {
            "type": "noProject"
          }, null)]);
        }
      }
    },
    projectData() {
      return this.State_App.projectList;
    },
    isAuthAddProject() {
      var _a2, _b;
      const isGroupRoleAuth = ["admin", "owner"].includes((_b = (_a2 = this.State_App) == null ? void 0 : _a2.currGroup) == null ? void 0 : _b.role);
      const _isShow = isGroupRoleAuth || ["admin", "owner"].includes(this.State_App.user.role);
      if (!_isShow) {
        xU("isAuthAddProject", this.State_App.user.role);
      }
      return _isShow;
    }
  },
  watch: {
    "Cpt_url.query.group_id": {
      immediate: true,
      handler() {
        this.isLoading = true;
        this.updateProjectList();
      }
    }
  },
  methods: {
    genProjectCard(projectItems, isShow = false) {
      return createVNode("div", {
        "class": "flex like-float"
      }, [xU.map(projectItems, (item, index2) => {
        return createVNode(ProjectCard, {
          "isShow": isShow,
          "index": index2,
          "projectData": item,
          "callbackResult": this.updateProjectList
        }, null);
      })]);
    },
    showAddProjectDialog() {
      const vm = this;
      UI.dialog.component({
        title: "\u6DFB\u52A0\u9879\u76EE",
        component: DialogAddProject,
        groupId: vm.Cpt_url.query.group_id,
        updateProjectList: vm.updateProjectList
      });
    },
    protocolChange(value) {
      this.setState({
        protocol: value
      });
    }
  },
  render() {
    return withDirectives(createVNode("div", {
      "style": {
        paddingTop: "24px"
      },
      "class": "m-panel card-panel card-panel-s project-list height100 flex vertical"
    }, [createVNode(resolveComponent("aRow"), {
      "class": "project-list-header"
    }, {
      default: () => [createVNode(resolveComponent("aCol"), {
        "span": 16,
        "style": {
          textAlign: "left"
        }
      }, {
        default: () => [createVNode("span", null, [createTextVNode("\u5171")]), createVNode("span", null, [createTextVNode(" "), this.State_App.projectList.length, createTextVNode(" ")]), createVNode("span", null, [createTextVNode("\u4E2A\u9879\u76EE")])]
      }), createVNode(resolveComponent("aCol"), {
        "span": 8,
        "class": "flex end flex1"
      }, {
        default: () => [this.vDomAddProjectButton]
      })]
    }), this.vDomSpaceProject]), [[resolveDirective("loading"), this.isLoading]]);
  }
});
const annotated$1 = "";
const html$1 = "";
const TimeLine$1 = "";
var diffMatchPatch = { exports: {} };
(function(module2) {
  var diff_match_patch2 = function() {
    this.Diff_Timeout = 1;
    this.Diff_EditCost = 4;
    this.Match_Threshold = 0.5;
    this.Match_Distance = 1e3;
    this.Patch_DeleteThreshold = 0.5;
    this.Patch_Margin = 4;
    this.Match_MaxBits = 32;
  };
  var DIFF_DELETE = -1;
  var DIFF_INSERT = 1;
  var DIFF_EQUAL = 0;
  diff_match_patch2.Diff = function(op, text) {
    return [op, text];
  };
  diff_match_patch2.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
    if (typeof opt_deadline == "undefined") {
      if (this.Diff_Timeout <= 0) {
        opt_deadline = Number.MAX_VALUE;
      } else {
        opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
      }
    }
    var deadline = opt_deadline;
    if (text1 == null || text2 == null) {
      throw new Error("Null input. (diff_main)");
    }
    if (text1 == text2) {
      if (text1) {
        return [new diff_match_patch2.Diff(DIFF_EQUAL, text1)];
      }
      return [];
    }
    if (typeof opt_checklines == "undefined") {
      opt_checklines = true;
    }
    var checklines = opt_checklines;
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);
    if (commonprefix) {
      diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, commonprefix));
    }
    if (commonsuffix) {
      diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, commonsuffix));
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
  };
  diff_match_patch2.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
    var diffs;
    if (!text1) {
      return [new diff_match_patch2.Diff(DIFF_INSERT, text2)];
    }
    if (!text2) {
      return [new diff_match_patch2.Diff(DIFF_DELETE, text1)];
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i2 = longtext.indexOf(shorttext);
    if (i2 != -1) {
      diffs = [
        new diff_match_patch2.Diff(DIFF_INSERT, longtext.substring(0, i2)),
        new diff_match_patch2.Diff(DIFF_EQUAL, shorttext),
        new diff_match_patch2.Diff(
          DIFF_INSERT,
          longtext.substring(i2 + shorttext.length)
        )
      ];
      if (text1.length > text2.length) {
        diffs[0][0] = diffs[2][0] = DIFF_DELETE;
      }
      return diffs;
    }
    if (shorttext.length == 1) {
      return [
        new diff_match_patch2.Diff(DIFF_DELETE, text1),
        new diff_match_patch2.Diff(DIFF_INSERT, text2)
      ];
    }
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
      var text1_a = hm[0];
      var text1_b = hm[1];
      var text2_a = hm[2];
      var text2_b = hm[3];
      var mid_common = hm[4];
      var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
      var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
      return diffs_a.concat(
        [new diff_match_patch2.Diff(DIFF_EQUAL, mid_common)],
        diffs_b
      );
    }
    if (checklines && text1.length > 100 && text2.length > 100) {
      return this.diff_lineMode_(text1, text2, deadline);
    }
    return this.diff_bisect_(text1, text2, deadline);
  };
  diff_match_patch2.prototype.diff_lineMode_ = function(text1, text2, deadline) {
    var a2 = this.diff_linesToChars_(text1, text2);
    text1 = a2.chars1;
    text2 = a2.chars2;
    var linearray = a2.lineArray;
    var diffs = this.diff_main(text1, text2, false, deadline);
    this.diff_charsToLines_(diffs, linearray);
    this.diff_cleanupSemantic(diffs);
    diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          break;
        case DIFF_EQUAL:
          if (count_delete >= 1 && count_insert >= 1) {
            diffs.splice(
              pointer - count_delete - count_insert,
              count_delete + count_insert
            );
            pointer = pointer - count_delete - count_insert;
            var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
            for (var j2 = subDiff.length - 1; j2 >= 0; j2--) {
              diffs.splice(pointer, 0, subDiff[j2]);
            }
            pointer = pointer + subDiff.length;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
      pointer++;
    }
    diffs.pop();
    return diffs;
  };
  diff_match_patch2.prototype.diff_bisect_ = function(text1, text2, deadline) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    for (var x2 = 0; x2 < v_length; x2++) {
      v1[x2] = -1;
      v2[x2] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    var front = delta % 2 != 0;
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d2 = 0; d2 < max_d; d2++) {
      if (new Date().getTime() > deadline) {
        break;
      }
      for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
        var k1_offset = v_offset + k1;
        var x1;
        if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
          x1 = v1[k1_offset + 1];
        } else {
          x1 = v1[k1_offset - 1] + 1;
        }
        var y1 = x1 - k1;
        while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
          x1++;
          y1++;
        }
        v1[k1_offset] = x1;
        if (x1 > text1_length) {
          k1end += 2;
        } else if (y1 > text2_length) {
          k1start += 2;
        } else if (front) {
          var k2_offset = v_offset + delta - k1;
          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
            var x22 = text1_length - v2[k2_offset];
            if (x1 >= x22) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
      for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
        var k2_offset = v_offset + k2;
        var x22;
        if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
          x22 = v2[k2_offset + 1];
        } else {
          x22 = v2[k2_offset - 1] + 1;
        }
        var y2 = x22 - k2;
        while (x22 < text1_length && y2 < text2_length && text1.charAt(text1_length - x22 - 1) == text2.charAt(text2_length - y2 - 1)) {
          x22++;
          y2++;
        }
        v2[k2_offset] = x22;
        if (x22 > text1_length) {
          k2end += 2;
        } else if (y2 > text2_length) {
          k2start += 2;
        } else if (!front) {
          var k1_offset = v_offset + delta - k2;
          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
            var x1 = v1[k1_offset];
            var y1 = v_offset + x1 - k1_offset;
            x22 = text1_length - x22;
            if (x1 >= x22) {
              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
            }
          }
        }
      }
    }
    return [
      new diff_match_patch2.Diff(DIFF_DELETE, text1),
      new diff_match_patch2.Diff(DIFF_INSERT, text2)
    ];
  };
  diff_match_patch2.prototype.diff_bisectSplit_ = function(text1, text2, x2, y2, deadline) {
    var text1a = text1.substring(0, x2);
    var text2a = text2.substring(0, y2);
    var text1b = text1.substring(x2);
    var text2b = text2.substring(y2);
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);
    return diffs.concat(diffsb);
  };
  diff_match_patch2.prototype.diff_linesToChars_ = function(text1, text2) {
    var lineArray = [];
    var lineHash = {};
    lineArray[0] = "";
    function diff_linesToCharsMunge_(text) {
      var chars = "";
      var lineStart = 0;
      var lineEnd = -1;
      var lineArrayLength = lineArray.length;
      while (lineEnd < text.length - 1) {
        lineEnd = text.indexOf("\n", lineStart);
        if (lineEnd == -1) {
          lineEnd = text.length - 1;
        }
        var line2 = text.substring(lineStart, lineEnd + 1);
        if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line2) : lineHash[line2] !== void 0) {
          chars += String.fromCharCode(lineHash[line2]);
        } else {
          if (lineArrayLength == maxLines) {
            line2 = text.substring(lineStart);
            lineEnd = text.length;
          }
          chars += String.fromCharCode(lineArrayLength);
          lineHash[line2] = lineArrayLength;
          lineArray[lineArrayLength++] = line2;
        }
        lineStart = lineEnd + 1;
      }
      return chars;
    }
    var maxLines = 4e4;
    var chars1 = diff_linesToCharsMunge_(text1);
    maxLines = 65535;
    var chars2 = diff_linesToCharsMunge_(text2);
    return { chars1, chars2, lineArray };
  };
  diff_match_patch2.prototype.diff_charsToLines_ = function(diffs, lineArray) {
    for (var i2 = 0; i2 < diffs.length; i2++) {
      var chars = diffs[i2][1];
      var text = [];
      for (var j2 = 0; j2 < chars.length; j2++) {
        text[j2] = lineArray[chars.charCodeAt(j2)];
      }
      diffs[i2][1] = text.join("");
    }
  };
  diff_match_patch2.prototype.diff_commonPrefix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
      if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
        pointermin = pointermid;
        pointerstart = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch2.prototype.diff_commonSuffix = function(text1, text2) {
    if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
      return 0;
    }
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
      if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
        pointermin = pointermid;
        pointerend = pointermin;
      } else {
        pointermax = pointermid;
      }
      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
  };
  diff_match_patch2.prototype.diff_commonOverlap_ = function(text1, text2) {
    var text1_length = text1.length;
    var text2_length = text2.length;
    if (text1_length == 0 || text2_length == 0) {
      return 0;
    }
    if (text1_length > text2_length) {
      text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
      text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    if (text1 == text2) {
      return text_length;
    }
    var best = 0;
    var length = 1;
    while (true) {
      var pattern4 = text1.substring(text_length - length);
      var found = text2.indexOf(pattern4);
      if (found == -1) {
        return best;
      }
      length += found;
      if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
        best = length;
        length++;
      }
    }
  };
  diff_match_patch2.prototype.diff_halfMatch_ = function(text1, text2) {
    if (this.Diff_Timeout <= 0) {
      return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
      return null;
    }
    var dmp2 = this;
    function diff_halfMatchI_(longtext2, shorttext2, i2) {
      var seed2 = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
      var j2 = -1;
      var best_common = "";
      var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
      while ((j2 = shorttext2.indexOf(seed2, j2 + 1)) != -1) {
        var prefixLength = dmp2.diff_commonPrefix(
          longtext2.substring(i2),
          shorttext2.substring(j2)
        );
        var suffixLength = dmp2.diff_commonSuffix(
          longtext2.substring(0, i2),
          shorttext2.substring(0, j2)
        );
        if (best_common.length < suffixLength + prefixLength) {
          best_common = shorttext2.substring(j2 - suffixLength, j2) + shorttext2.substring(j2, j2 + prefixLength);
          best_longtext_a = longtext2.substring(0, i2 - suffixLength);
          best_longtext_b = longtext2.substring(i2 + prefixLength);
          best_shorttext_a = shorttext2.substring(0, j2 - suffixLength);
          best_shorttext_b = shorttext2.substring(j2 + prefixLength);
        }
      }
      if (best_common.length * 2 >= longtext2.length) {
        return [
          best_longtext_a,
          best_longtext_b,
          best_shorttext_a,
          best_shorttext_b,
          best_common
        ];
      } else {
        return null;
      }
    }
    var hm1 = diff_halfMatchI_(
      longtext,
      shorttext,
      Math.ceil(longtext.length / 4)
    );
    var hm2 = diff_halfMatchI_(
      longtext,
      shorttext,
      Math.ceil(longtext.length / 2)
    );
    var hm;
    if (!hm1 && !hm2) {
      return null;
    } else if (!hm2) {
      hm = hm1;
    } else if (!hm1) {
      hm = hm2;
    } else {
      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
      text1_a = hm[0];
      text1_b = hm[1];
      text2_a = hm[2];
      text2_b = hm[3];
    } else {
      text2_a = hm[0];
      text2_b = hm[1];
      text1_a = hm[2];
      text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
  };
  diff_match_patch2.prototype.diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        equalities[equalitiesLength++] = pointer;
        length_insertions1 = length_insertions2;
        length_deletions1 = length_deletions2;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = diffs[pointer][1];
      } else {
        if (diffs[pointer][0] == DIFF_INSERT) {
          length_insertions2 += diffs[pointer][1].length;
        } else {
          length_deletions2 += diffs[pointer][1].length;
        }
        if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
          length_insertions2,
          length_deletions2
        )) {
          diffs.splice(
            equalities[equalitiesLength - 1],
            0,
            new diff_match_patch2.Diff(DIFF_DELETE, lastEquality)
          );
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          length_insertions1 = 0;
          length_deletions1 = 0;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = null;
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);
    pointer = 1;
    while (pointer < diffs.length) {
      if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
        var deletion = diffs[pointer - 1][1];
        var insertion = diffs[pointer][1];
        var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
        var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
        if (overlap_length1 >= overlap_length2) {
          if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch2.Diff(
              DIFF_EQUAL,
              insertion.substring(0, overlap_length1)
            ));
            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
            diffs[pointer + 1][1] = insertion.substring(overlap_length1);
            pointer++;
          }
        } else {
          if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
            diffs.splice(pointer, 0, new diff_match_patch2.Diff(
              DIFF_EQUAL,
              deletion.substring(0, overlap_length2)
            ));
            diffs[pointer - 1][0] = DIFF_INSERT;
            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
            diffs[pointer + 1][0] = DIFF_DELETE;
            diffs[pointer + 1][1] = deletion.substring(overlap_length2);
            pointer++;
          }
        }
        pointer++;
      }
      pointer++;
    }
  };
  diff_match_patch2.prototype.diff_cleanupSemanticLossless = function(diffs) {
    function diff_cleanupSemanticScore_(one, two) {
      if (!one || !two) {
        return 6;
      }
      var char1 = one.charAt(one.length - 1);
      var char2 = two.charAt(0);
      var nonAlphaNumeric1 = char1.match(diff_match_patch2.nonAlphaNumericRegex_);
      var nonAlphaNumeric2 = char2.match(diff_match_patch2.nonAlphaNumericRegex_);
      var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch2.whitespaceRegex_);
      var whitespace22 = nonAlphaNumeric2 && char2.match(diff_match_patch2.whitespaceRegex_);
      var lineBreak1 = whitespace1 && char1.match(diff_match_patch2.linebreakRegex_);
      var lineBreak2 = whitespace22 && char2.match(diff_match_patch2.linebreakRegex_);
      var blankLine1 = lineBreak1 && one.match(diff_match_patch2.blanklineEndRegex_);
      var blankLine2 = lineBreak2 && two.match(diff_match_patch2.blanklineStartRegex_);
      if (blankLine1 || blankLine2) {
        return 5;
      } else if (lineBreak1 || lineBreak2) {
        return 4;
      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace22) {
        return 3;
      } else if (whitespace1 || whitespace22) {
        return 2;
      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
        return 1;
      }
      return 0;
    }
    var pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        var equality1 = diffs[pointer - 1][1];
        var edit = diffs[pointer][1];
        var equality2 = diffs[pointer + 1][1];
        var commonOffset = this.diff_commonSuffix(equality1, edit);
        if (commonOffset) {
          var commonString = edit.substring(edit.length - commonOffset);
          equality1 = equality1.substring(0, equality1.length - commonOffset);
          edit = commonString + edit.substring(0, edit.length - commonOffset);
          equality2 = commonString + equality2;
        }
        var bestEquality1 = equality1;
        var bestEdit = edit;
        var bestEquality2 = equality2;
        var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        while (edit.charAt(0) === equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }
        if (diffs[pointer - 1][1] != bestEquality1) {
          if (bestEquality1) {
            diffs[pointer - 1][1] = bestEquality1;
          } else {
            diffs.splice(pointer - 1, 1);
            pointer--;
          }
          diffs[pointer][1] = bestEdit;
          if (bestEquality2) {
            diffs[pointer + 1][1] = bestEquality2;
          } else {
            diffs.splice(pointer + 1, 1);
            pointer--;
          }
        }
      }
      pointer++;
    }
  };
  diff_match_patch2.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
  diff_match_patch2.whitespaceRegex_ = /\s/;
  diff_match_patch2.linebreakRegex_ = /[\r\n]/;
  diff_match_patch2.blanklineEndRegex_ = /\n\r?\n$/;
  diff_match_patch2.blanklineStartRegex_ = /^\r?\n\r?\n/;
  diff_match_patch2.prototype.diff_cleanupEfficiency = function(diffs) {
    var changes = false;
    var equalities = [];
    var equalitiesLength = 0;
    var lastEquality = null;
    var pointer = 0;
    var pre_ins = false;
    var pre_del = false;
    var post_ins = false;
    var post_del = false;
    while (pointer < diffs.length) {
      if (diffs[pointer][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
          equalities[equalitiesLength++] = pointer;
          pre_ins = post_ins;
          pre_del = post_del;
          lastEquality = diffs[pointer][1];
        } else {
          equalitiesLength = 0;
          lastEquality = null;
        }
        post_ins = post_del = false;
      } else {
        if (diffs[pointer][0] == DIFF_DELETE) {
          post_del = true;
        } else {
          post_ins = true;
        }
        if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
          diffs.splice(
            equalities[equalitiesLength - 1],
            0,
            new diff_match_patch2.Diff(DIFF_DELETE, lastEquality)
          );
          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
          equalitiesLength--;
          lastEquality = null;
          if (pre_ins && pre_del) {
            post_ins = post_del = true;
            equalitiesLength = 0;
          } else {
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            post_ins = post_del = false;
          }
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch2.prototype.diff_cleanupMerge = function(diffs) {
    diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, ""));
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = "";
    var text_insert = "";
    var commonlength;
    while (pointer < diffs.length) {
      switch (diffs[pointer][0]) {
        case DIFF_INSERT:
          count_insert++;
          text_insert += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_DELETE:
          count_delete++;
          text_delete += diffs[pointer][1];
          pointer++;
          break;
        case DIFF_EQUAL:
          if (count_delete + count_insert > 1) {
            if (count_delete !== 0 && count_insert !== 0) {
              commonlength = this.diff_commonPrefix(text_insert, text_delete);
              if (commonlength !== 0) {
                if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                  diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                } else {
                  diffs.splice(0, 0, new diff_match_patch2.Diff(
                    DIFF_EQUAL,
                    text_insert.substring(0, commonlength)
                  ));
                  pointer++;
                }
                text_insert = text_insert.substring(commonlength);
                text_delete = text_delete.substring(commonlength);
              }
              commonlength = this.diff_commonSuffix(text_insert, text_delete);
              if (commonlength !== 0) {
                diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                text_insert = text_insert.substring(0, text_insert.length - commonlength);
                text_delete = text_delete.substring(0, text_delete.length - commonlength);
              }
            }
            pointer -= count_delete + count_insert;
            diffs.splice(pointer, count_delete + count_insert);
            if (text_delete.length) {
              diffs.splice(
                pointer,
                0,
                new diff_match_patch2.Diff(DIFF_DELETE, text_delete)
              );
              pointer++;
            }
            if (text_insert.length) {
              diffs.splice(
                pointer,
                0,
                new diff_match_patch2.Diff(DIFF_INSERT, text_insert)
              );
              pointer++;
            }
            pointer++;
          } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
            diffs[pointer - 1][1] += diffs[pointer][1];
            diffs.splice(pointer, 1);
          } else {
            pointer++;
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = "";
          text_insert = "";
          break;
      }
    }
    if (diffs[diffs.length - 1][1] === "") {
      diffs.pop();
    }
    var changes = false;
    pointer = 1;
    while (pointer < diffs.length - 1) {
      if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
        if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
          diffs.splice(pointer - 1, 1);
          changes = true;
        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
          diffs[pointer - 1][1] += diffs[pointer + 1][1];
          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
          diffs.splice(pointer + 1, 1);
          changes = true;
        }
      }
      pointer++;
    }
    if (changes) {
      this.diff_cleanupMerge(diffs);
    }
  };
  diff_match_patch2.prototype.diff_xIndex = function(diffs, loc) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x2;
    for (x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_INSERT) {
        chars1 += diffs[x2][1].length;
      }
      if (diffs[x2][0] !== DIFF_DELETE) {
        chars2 += diffs[x2][1].length;
      }
      if (chars1 > loc) {
        break;
      }
      last_chars1 = chars1;
      last_chars2 = chars2;
    }
    if (diffs.length != x2 && diffs[x2][0] === DIFF_DELETE) {
      return last_chars2;
    }
    return last_chars2 + (loc - last_chars1);
  };
  diff_match_patch2.prototype.diff_prettyHtml = function(diffs) {
    var html2 = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var op = diffs[x2][0];
      var data9 = diffs[x2][1];
      var text = data9.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
      switch (op) {
        case DIFF_INSERT:
          html2[x2] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
          break;
        case DIFF_DELETE:
          html2[x2] = '<del style="background:#ffe6e6;">' + text + "</del>";
          break;
        case DIFF_EQUAL:
          html2[x2] = "<span>" + text + "</span>";
          break;
      }
    }
    return html2.join("");
  };
  diff_match_patch2.prototype.diff_text1 = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_INSERT) {
        text[x2] = diffs[x2][1];
      }
    }
    return text.join("");
  };
  diff_match_patch2.prototype.diff_text2 = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      if (diffs[x2][0] !== DIFF_DELETE) {
        text[x2] = diffs[x2][1];
      }
    }
    return text.join("");
  };
  diff_match_patch2.prototype.diff_levenshtein = function(diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var op = diffs[x2][0];
      var data9 = diffs[x2][1];
      switch (op) {
        case DIFF_INSERT:
          insertions += data9.length;
          break;
        case DIFF_DELETE:
          deletions += data9.length;
          break;
        case DIFF_EQUAL:
          levenshtein += Math.max(insertions, deletions);
          insertions = 0;
          deletions = 0;
          break;
      }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
  };
  diff_match_patch2.prototype.diff_toDelta = function(diffs) {
    var text = [];
    for (var x2 = 0; x2 < diffs.length; x2++) {
      switch (diffs[x2][0]) {
        case DIFF_INSERT:
          text[x2] = "+" + encodeURI(diffs[x2][1]);
          break;
        case DIFF_DELETE:
          text[x2] = "-" + diffs[x2][1].length;
          break;
        case DIFF_EQUAL:
          text[x2] = "=" + diffs[x2][1].length;
          break;
      }
    }
    return text.join("	").replace(/%20/g, " ");
  };
  diff_match_patch2.prototype.diff_fromDelta = function(text1, delta) {
    var diffs = [];
    var diffsLength = 0;
    var pointer = 0;
    var tokens = delta.split(/\t/g);
    for (var x2 = 0; x2 < tokens.length; x2++) {
      var param = tokens[x2].substring(1);
      switch (tokens[x2].charAt(0)) {
        case "+":
          try {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_INSERT, decodeURI(param));
          } catch (ex) {
            throw new Error("Illegal escape in diff_fromDelta: " + param);
          }
          break;
        case "-":
        case "=":
          var n2 = parseInt(param, 10);
          if (isNaN(n2) || n2 < 0) {
            throw new Error("Invalid number in diff_fromDelta: " + param);
          }
          var text = text1.substring(pointer, pointer += n2);
          if (tokens[x2].charAt(0) == "=") {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_EQUAL, text);
          } else {
            diffs[diffsLength++] = new diff_match_patch2.Diff(DIFF_DELETE, text);
          }
          break;
        default:
          if (tokens[x2]) {
            throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x2]);
          }
      }
    }
    if (pointer != text1.length) {
      throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
    }
    return diffs;
  };
  diff_match_patch2.prototype.match_main = function(text, pattern4, loc) {
    if (text == null || pattern4 == null || loc == null) {
      throw new Error("Null input. (match_main)");
    }
    loc = Math.max(0, Math.min(loc, text.length));
    if (text == pattern4) {
      return 0;
    } else if (!text.length) {
      return -1;
    } else if (text.substring(loc, loc + pattern4.length) == pattern4) {
      return loc;
    } else {
      return this.match_bitap_(text, pattern4, loc);
    }
  };
  diff_match_patch2.prototype.match_bitap_ = function(text, pattern4, loc) {
    if (pattern4.length > this.Match_MaxBits) {
      throw new Error("Pattern too long for this browser.");
    }
    var s2 = this.match_alphabet_(pattern4);
    var dmp2 = this;
    function match_bitapScore_(e2, x2) {
      var accuracy = e2 / pattern4.length;
      var proximity = Math.abs(loc - x2);
      if (!dmp2.Match_Distance) {
        return proximity ? 1 : accuracy;
      }
      return accuracy + proximity / dmp2.Match_Distance;
    }
    var score_threshold = this.Match_Threshold;
    var best_loc = text.indexOf(pattern4, loc);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      best_loc = text.lastIndexOf(pattern4, loc + pattern4.length);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
      }
    }
    var matchmask = 1 << pattern4.length - 1;
    best_loc = -1;
    var bin_min, bin_mid;
    var bin_max = pattern4.length + text.length;
    var last_rd;
    for (var d2 = 0; d2 < pattern4.length; d2++) {
      bin_min = 0;
      bin_mid = bin_max;
      while (bin_min < bin_mid) {
        if (match_bitapScore_(d2, loc + bin_mid) <= score_threshold) {
          bin_min = bin_mid;
        } else {
          bin_max = bin_mid;
        }
        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
      }
      bin_max = bin_mid;
      var start = Math.max(1, loc - bin_mid + 1);
      var finish = Math.min(loc + bin_mid, text.length) + pattern4.length;
      var rd = Array(finish + 2);
      rd[finish + 1] = (1 << d2) - 1;
      for (var j2 = finish; j2 >= start; j2--) {
        var charMatch = s2[text.charAt(j2 - 1)];
        if (d2 === 0) {
          rd[j2] = (rd[j2 + 1] << 1 | 1) & charMatch;
        } else {
          rd[j2] = (rd[j2 + 1] << 1 | 1) & charMatch | ((last_rd[j2 + 1] | last_rd[j2]) << 1 | 1) | last_rd[j2 + 1];
        }
        if (rd[j2] & matchmask) {
          var score = match_bitapScore_(d2, j2 - 1);
          if (score <= score_threshold) {
            score_threshold = score;
            best_loc = j2 - 1;
            if (best_loc > loc) {
              start = Math.max(1, 2 * loc - best_loc);
            } else {
              break;
            }
          }
        }
      }
      if (match_bitapScore_(d2 + 1, loc) > score_threshold) {
        break;
      }
      last_rd = rd;
    }
    return best_loc;
  };
  diff_match_patch2.prototype.match_alphabet_ = function(pattern4) {
    var s2 = {};
    for (var i2 = 0; i2 < pattern4.length; i2++) {
      s2[pattern4.charAt(i2)] = 0;
    }
    for (var i2 = 0; i2 < pattern4.length; i2++) {
      s2[pattern4.charAt(i2)] |= 1 << pattern4.length - i2 - 1;
    }
    return s2;
  };
  diff_match_patch2.prototype.patch_addContext_ = function(patch2, text) {
    if (text.length == 0) {
      return;
    }
    if (patch2.start2 === null) {
      throw Error("patch not initialized");
    }
    var pattern4 = text.substring(patch2.start2, patch2.start2 + patch2.length1);
    var padding = 0;
    while (text.indexOf(pattern4) != text.lastIndexOf(pattern4) && pattern4.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
      padding += this.Patch_Margin;
      pattern4 = text.substring(
        patch2.start2 - padding,
        patch2.start2 + patch2.length1 + padding
      );
    }
    padding += this.Patch_Margin;
    var prefix = text.substring(patch2.start2 - padding, patch2.start2);
    if (prefix) {
      patch2.diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, prefix));
    }
    var suffix = text.substring(
      patch2.start2 + patch2.length1,
      patch2.start2 + patch2.length1 + padding
    );
    if (suffix) {
      patch2.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, suffix));
    }
    patch2.start1 -= prefix.length;
    patch2.start2 -= prefix.length;
    patch2.length1 += prefix.length + suffix.length;
    patch2.length2 += prefix.length + suffix.length;
  };
  diff_match_patch2.prototype.patch_make = function(a2, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a2 == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
      text1 = a2;
      diffs = this.diff_main(text1, opt_b, true);
      if (diffs.length > 2) {
        this.diff_cleanupSemantic(diffs);
        this.diff_cleanupEfficiency(diffs);
      }
    } else if (a2 && typeof a2 == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
      diffs = a2;
      text1 = this.diff_text1(diffs);
    } else if (typeof a2 == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
      text1 = a2;
      diffs = opt_b;
    } else if (typeof a2 == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
      text1 = a2;
      diffs = opt_c;
    } else {
      throw new Error("Unknown call format to patch_make.");
    }
    if (diffs.length === 0) {
      return [];
    }
    var patches = [];
    var patch2 = new diff_match_patch2.patch_obj();
    var patchDiffLength = 0;
    var char_count1 = 0;
    var char_count2 = 0;
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x2 = 0; x2 < diffs.length; x2++) {
      var diff_type = diffs[x2][0];
      var diff_text = diffs[x2][1];
      if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
        patch2.start1 = char_count1;
        patch2.start2 = char_count2;
      }
      switch (diff_type) {
        case DIFF_INSERT:
          patch2.diffs[patchDiffLength++] = diffs[x2];
          patch2.length2 += diff_text.length;
          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
          break;
        case DIFF_DELETE:
          patch2.length1 += diff_text.length;
          patch2.diffs[patchDiffLength++] = diffs[x2];
          postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
          break;
        case DIFF_EQUAL:
          if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x2 + 1) {
            patch2.diffs[patchDiffLength++] = diffs[x2];
            patch2.length1 += diff_text.length;
            patch2.length2 += diff_text.length;
          } else if (diff_text.length >= 2 * this.Patch_Margin) {
            if (patchDiffLength) {
              this.patch_addContext_(patch2, prepatch_text);
              patches.push(patch2);
              patch2 = new diff_match_patch2.patch_obj();
              patchDiffLength = 0;
              prepatch_text = postpatch_text;
              char_count1 = char_count2;
            }
          }
          break;
      }
      if (diff_type !== DIFF_INSERT) {
        char_count1 += diff_text.length;
      }
      if (diff_type !== DIFF_DELETE) {
        char_count2 += diff_text.length;
      }
    }
    if (patchDiffLength) {
      this.patch_addContext_(patch2, prepatch_text);
      patches.push(patch2);
    }
    return patches;
  };
  diff_match_patch2.prototype.patch_deepCopy = function(patches) {
    var patchesCopy = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      var patch2 = patches[x2];
      var patchCopy = new diff_match_patch2.patch_obj();
      patchCopy.diffs = [];
      for (var y2 = 0; y2 < patch2.diffs.length; y2++) {
        patchCopy.diffs[y2] = new diff_match_patch2.Diff(patch2.diffs[y2][0], patch2.diffs[y2][1]);
      }
      patchCopy.start1 = patch2.start1;
      patchCopy.start2 = patch2.start2;
      patchCopy.length1 = patch2.length1;
      patchCopy.length2 = patch2.length2;
      patchesCopy[x2] = patchCopy;
    }
    return patchesCopy;
  };
  diff_match_patch2.prototype.patch_apply = function(patches, text) {
    if (patches.length == 0) {
      return [text, []];
    }
    patches = this.patch_deepCopy(patches);
    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;
    this.patch_splitMax(patches);
    var delta = 0;
    var results = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      var expected_loc = patches[x2].start2 + delta;
      var text1 = this.diff_text1(patches[x2].diffs);
      var start_loc;
      var end_loc = -1;
      if (text1.length > this.Match_MaxBits) {
        start_loc = this.match_main(
          text,
          text1.substring(0, this.Match_MaxBits),
          expected_loc
        );
        if (start_loc != -1) {
          end_loc = this.match_main(
            text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits
          );
          if (end_loc == -1 || start_loc >= end_loc) {
            start_loc = -1;
          }
        }
      } else {
        start_loc = this.match_main(text, text1, expected_loc);
      }
      if (start_loc == -1) {
        results[x2] = false;
        delta -= patches[x2].length2 - patches[x2].length1;
      } else {
        results[x2] = true;
        delta = start_loc - expected_loc;
        var text2;
        if (end_loc == -1) {
          text2 = text.substring(start_loc, start_loc + text1.length);
        } else {
          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
        }
        if (text1 == text2) {
          text = text.substring(0, start_loc) + this.diff_text2(patches[x2].diffs) + text.substring(start_loc + text1.length);
        } else {
          var diffs = this.diff_main(text1, text2, false);
          if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
            results[x2] = false;
          } else {
            this.diff_cleanupSemanticLossless(diffs);
            var index1 = 0;
            var index2;
            for (var y2 = 0; y2 < patches[x2].diffs.length; y2++) {
              var mod = patches[x2].diffs[y2];
              if (mod[0] !== DIFF_EQUAL) {
                index2 = this.diff_xIndex(diffs, index1);
              }
              if (mod[0] === DIFF_INSERT) {
                text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
              } else if (mod[0] === DIFF_DELETE) {
                text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(
                  diffs,
                  index1 + mod[1].length
                ));
              }
              if (mod[0] !== DIFF_DELETE) {
                index1 += mod[1].length;
              }
            }
          }
        }
      }
    }
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
  };
  diff_match_patch2.prototype.patch_addPadding = function(patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = "";
    for (var x2 = 1; x2 <= paddingLength; x2++) {
      nullPadding += String.fromCharCode(x2);
    }
    for (var x2 = 0; x2 < patches.length; x2++) {
      patches[x2].start1 += paddingLength;
      patches[x2].start2 += paddingLength;
    }
    var patch2 = patches[0];
    var diffs = patch2.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
      diffs.unshift(new diff_match_patch2.Diff(DIFF_EQUAL, nullPadding));
      patch2.start1 -= paddingLength;
      patch2.start2 -= paddingLength;
      patch2.length1 += paddingLength;
      patch2.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
      var extraLength = paddingLength - diffs[0][1].length;
      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
      patch2.start1 -= extraLength;
      patch2.start2 -= extraLength;
      patch2.length1 += extraLength;
      patch2.length2 += extraLength;
    }
    patch2 = patches[patches.length - 1];
    diffs = patch2.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
      diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, nullPadding));
      patch2.length1 += paddingLength;
      patch2.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
      var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
      patch2.length1 += extraLength;
      patch2.length2 += extraLength;
    }
    return nullPadding;
  };
  diff_match_patch2.prototype.patch_splitMax = function(patches) {
    var patch_size = this.Match_MaxBits;
    for (var x2 = 0; x2 < patches.length; x2++) {
      if (patches[x2].length1 <= patch_size) {
        continue;
      }
      var bigpatch = patches[x2];
      patches.splice(x2--, 1);
      var start1 = bigpatch.start1;
      var start2 = bigpatch.start2;
      var precontext = "";
      while (bigpatch.diffs.length !== 0) {
        var patch2 = new diff_match_patch2.patch_obj();
        var empty2 = true;
        patch2.start1 = start1 - precontext.length;
        patch2.start2 = start2 - precontext.length;
        if (precontext !== "") {
          patch2.length1 = patch2.length2 = precontext.length;
          patch2.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, precontext));
        }
        while (bigpatch.diffs.length !== 0 && patch2.length1 < patch_size - this.Patch_Margin) {
          var diff_type = bigpatch.diffs[0][0];
          var diff_text = bigpatch.diffs[0][1];
          if (diff_type === DIFF_INSERT) {
            patch2.length2 += diff_text.length;
            start2 += diff_text.length;
            patch2.diffs.push(bigpatch.diffs.shift());
            empty2 = false;
          } else if (diff_type === DIFF_DELETE && patch2.diffs.length == 1 && patch2.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
            patch2.length1 += diff_text.length;
            start1 += diff_text.length;
            empty2 = false;
            patch2.diffs.push(new diff_match_patch2.Diff(diff_type, diff_text));
            bigpatch.diffs.shift();
          } else {
            diff_text = diff_text.substring(
              0,
              patch_size - patch2.length1 - this.Patch_Margin
            );
            patch2.length1 += diff_text.length;
            start1 += diff_text.length;
            if (diff_type === DIFF_EQUAL) {
              patch2.length2 += diff_text.length;
              start2 += diff_text.length;
            } else {
              empty2 = false;
            }
            patch2.diffs.push(new diff_match_patch2.Diff(diff_type, diff_text));
            if (diff_text == bigpatch.diffs[0][1]) {
              bigpatch.diffs.shift();
            } else {
              bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
            }
          }
        }
        precontext = this.diff_text2(patch2.diffs);
        precontext = precontext.substring(precontext.length - this.Patch_Margin);
        var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
        if (postcontext !== "") {
          patch2.length1 += postcontext.length;
          patch2.length2 += postcontext.length;
          if (patch2.diffs.length !== 0 && patch2.diffs[patch2.diffs.length - 1][0] === DIFF_EQUAL) {
            patch2.diffs[patch2.diffs.length - 1][1] += postcontext;
          } else {
            patch2.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, postcontext));
          }
        }
        if (!empty2) {
          patches.splice(++x2, 0, patch2);
        }
      }
    }
  };
  diff_match_patch2.prototype.patch_toText = function(patches) {
    var text = [];
    for (var x2 = 0; x2 < patches.length; x2++) {
      text[x2] = patches[x2];
    }
    return text.join("");
  };
  diff_match_patch2.prototype.patch_fromText = function(textline) {
    var patches = [];
    if (!textline) {
      return patches;
    }
    var text = textline.split("\n");
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
      var m2 = text[textPointer].match(patchHeader);
      if (!m2) {
        throw new Error("Invalid patch string: " + text[textPointer]);
      }
      var patch2 = new diff_match_patch2.patch_obj();
      patches.push(patch2);
      patch2.start1 = parseInt(m2[1], 10);
      if (m2[2] === "") {
        patch2.start1--;
        patch2.length1 = 1;
      } else if (m2[2] == "0") {
        patch2.length1 = 0;
      } else {
        patch2.start1--;
        patch2.length1 = parseInt(m2[2], 10);
      }
      patch2.start2 = parseInt(m2[3], 10);
      if (m2[4] === "") {
        patch2.start2--;
        patch2.length2 = 1;
      } else if (m2[4] == "0") {
        patch2.length2 = 0;
      } else {
        patch2.start2--;
        patch2.length2 = parseInt(m2[4], 10);
      }
      textPointer++;
      while (textPointer < text.length) {
        var sign2 = text[textPointer].charAt(0);
        try {
          var line2 = decodeURI(text[textPointer].substring(1));
        } catch (ex) {
          throw new Error("Illegal escape in patch_fromText: " + line2);
        }
        if (sign2 == "-") {
          patch2.diffs.push(new diff_match_patch2.Diff(DIFF_DELETE, line2));
        } else if (sign2 == "+") {
          patch2.diffs.push(new diff_match_patch2.Diff(DIFF_INSERT, line2));
        } else if (sign2 == " ") {
          patch2.diffs.push(new diff_match_patch2.Diff(DIFF_EQUAL, line2));
        } else if (sign2 == "@") {
          break;
        } else if (sign2 === "")
          ;
        else {
          throw new Error('Invalid patch mode "' + sign2 + '" in: ' + line2);
        }
        textPointer++;
      }
    }
    return patches;
  };
  diff_match_patch2.patch_obj = function() {
    this.diffs = [];
    this.start1 = null;
    this.start2 = null;
    this.length1 = 0;
    this.length2 = 0;
  };
  diff_match_patch2.patch_obj.prototype.toString = function() {
    var coords1, coords2;
    if (this.length1 === 0) {
      coords1 = this.start1 + ",0";
    } else if (this.length1 == 1) {
      coords1 = this.start1 + 1;
    } else {
      coords1 = this.start1 + 1 + "," + this.length1;
    }
    if (this.length2 === 0) {
      coords2 = this.start2 + ",0";
    } else if (this.length2 == 1) {
      coords2 = this.start2 + 1;
    } else {
      coords2 = this.start2 + 1 + "," + this.length2;
    }
    var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
    var op;
    for (var x2 = 0; x2 < this.diffs.length; x2++) {
      switch (this.diffs[x2][0]) {
        case DIFF_INSERT:
          op = "+";
          break;
        case DIFF_DELETE:
          op = "-";
          break;
        case DIFF_EQUAL:
          op = " ";
          break;
      }
      text[x2 + 1] = op + encodeURI(this.diffs[x2][1]) + "\n";
    }
    return text.join("").replace(/%20/g, " ");
  };
  module2.exports = diff_match_patch2;
  module2.exports["diff_match_patch"] = diff_match_patch2;
  module2.exports["DIFF_DELETE"] = DIFF_DELETE;
  module2.exports["DIFF_INSERT"] = DIFF_INSERT;
  module2.exports["DIFF_EQUAL"] = DIFF_EQUAL;
})(diffMatchPatch);
const dmp = diffMatchPatch.exports;
var chalk$1 = { exports: {} };
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  return str.replace(matchOperatorsRe, "\\$&");
};
var ansiStyles = { exports: {} };
var conversions$2 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var cssKeywords = colorName;
var reverseKeywords = {};
for (var key$1 in cssKeywords) {
  if (cssKeywords.hasOwnProperty(key$1)) {
    reverseKeywords[cssKeywords[key$1]] = key$1;
  }
}
var convert$1 = conversions$2.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var model in convert$1) {
  if (convert$1.hasOwnProperty(model)) {
    if (!("channels" in convert$1[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert$1[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert$1[model].labels.length !== convert$1[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    var channels = convert$1[model].channels;
    var labels = convert$1[model].labels;
    delete convert$1[model].channels;
    delete convert$1[model].labels;
    Object.defineProperty(convert$1[model], "channels", { value: channels });
    Object.defineProperty(convert$1[model], "labels", { value: labels });
  }
}
convert$1.rgb.hsl = function(rgb) {
  var r2 = rgb[0] / 255;
  var g2 = rgb[1] / 255;
  var b2 = rgb[2] / 255;
  var min3 = Math.min(r2, g2, b2);
  var max3 = Math.max(r2, g2, b2);
  var delta = max3 - min3;
  var h2;
  var s2;
  var l2;
  if (max3 === min3) {
    h2 = 0;
  } else if (r2 === max3) {
    h2 = (g2 - b2) / delta;
  } else if (g2 === max3) {
    h2 = 2 + (b2 - r2) / delta;
  } else if (b2 === max3) {
    h2 = 4 + (r2 - g2) / delta;
  }
  h2 = Math.min(h2 * 60, 360);
  if (h2 < 0) {
    h2 += 360;
  }
  l2 = (min3 + max3) / 2;
  if (max3 === min3) {
    s2 = 0;
  } else if (l2 <= 0.5) {
    s2 = delta / (max3 + min3);
  } else {
    s2 = delta / (2 - max3 - min3);
  }
  return [h2, s2 * 100, l2 * 100];
};
convert$1.rgb.hsv = function(rgb) {
  var rdif;
  var gdif;
  var bdif;
  var h2;
  var s2;
  var r2 = rgb[0] / 255;
  var g2 = rgb[1] / 255;
  var b2 = rgb[2] / 255;
  var v2 = Math.max(r2, g2, b2);
  var diff2 = v2 - Math.min(r2, g2, b2);
  var diffc = function(c2) {
    return (v2 - c2) / 6 / diff2 + 1 / 2;
  };
  if (diff2 === 0) {
    h2 = s2 = 0;
  } else {
    s2 = diff2 / v2;
    rdif = diffc(r2);
    gdif = diffc(g2);
    bdif = diffc(b2);
    if (r2 === v2) {
      h2 = bdif - gdif;
    } else if (g2 === v2) {
      h2 = 1 / 3 + rdif - bdif;
    } else if (b2 === v2) {
      h2 = 2 / 3 + gdif - rdif;
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return [
    h2 * 360,
    s2 * 100,
    v2 * 100
  ];
};
convert$1.rgb.hwb = function(rgb) {
  var r2 = rgb[0];
  var g2 = rgb[1];
  var b2 = rgb[2];
  var h2 = convert$1.rgb.hsl(rgb)[0];
  var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
  b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
  return [h2, w2 * 100, b2 * 100];
};
convert$1.rgb.cmyk = function(rgb) {
  var r2 = rgb[0] / 255;
  var g2 = rgb[1] / 255;
  var b2 = rgb[2] / 255;
  var c2;
  var m2;
  var y2;
  var k2;
  k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
  c2 = (1 - r2 - k2) / (1 - k2) || 0;
  m2 = (1 - g2 - k2) / (1 - k2) || 0;
  y2 = (1 - b2 - k2) / (1 - k2) || 0;
  return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
};
function comparativeDistance(x2, y2) {
  return Math.pow(x2[0] - y2[0], 2) + Math.pow(x2[1] - y2[1], 2) + Math.pow(x2[2] - y2[2], 2);
}
convert$1.rgb.keyword = function(rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  var currentClosestDistance = Infinity;
  var currentClosestKeyword;
  for (var keyword in cssKeywords) {
    if (cssKeywords.hasOwnProperty(keyword)) {
      var value = cssKeywords[keyword];
      var distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
  }
  return currentClosestKeyword;
};
convert$1.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};
convert$1.rgb.xyz = function(rgb) {
  var r2 = rgb[0] / 255;
  var g2 = rgb[1] / 255;
  var b2 = rgb[2] / 255;
  r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
  g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
  b2 = b2 > 0.04045 ? Math.pow((b2 + 0.055) / 1.055, 2.4) : b2 / 12.92;
  var x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
  var y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
  var z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
  return [x2 * 100, y2 * 100, z2 * 100];
};
convert$1.rgb.lab = function(rgb) {
  var xyz = convert$1.rgb.xyz(rgb);
  var x2 = xyz[0];
  var y2 = xyz[1];
  var z2 = xyz[2];
  var l2;
  var a2;
  var b2;
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
  l2 = 116 * y2 - 16;
  a2 = 500 * (x2 - y2);
  b2 = 200 * (y2 - z2);
  return [l2, a2, b2];
};
convert$1.hsl.rgb = function(hsl) {
  var h2 = hsl[0] / 360;
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var t1;
  var t2;
  var t3;
  var rgb;
  var val;
  if (s2 === 0) {
    val = l2 * 255;
    return [val, val, val];
  }
  if (l2 < 0.5) {
    t2 = l2 * (1 + s2);
  } else {
    t2 = l2 + s2 - l2 * s2;
  }
  t1 = 2 * l2 - t2;
  rgb = [0, 0, 0];
  for (var i2 = 0; i2 < 3; i2++) {
    t3 = h2 + 1 / 3 * -(i2 - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i2] = val * 255;
  }
  return rgb;
};
convert$1.hsl.hsv = function(hsl) {
  var h2 = hsl[0];
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var smin = s2;
  var lmin = Math.max(l2, 0.01);
  var sv;
  var v2;
  l2 *= 2;
  s2 *= l2 <= 1 ? l2 : 2 - l2;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v2 = (l2 + s2) / 2;
  sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
  return [h2, sv * 100, v2 * 100];
};
convert$1.hsv.rgb = function(hsv) {
  var h2 = hsv[0] / 60;
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var hi = Math.floor(h2) % 6;
  var f2 = h2 - Math.floor(h2);
  var p2 = 255 * v2 * (1 - s2);
  var q2 = 255 * v2 * (1 - s2 * f2);
  var t2 = 255 * v2 * (1 - s2 * (1 - f2));
  v2 *= 255;
  switch (hi) {
    case 0:
      return [v2, t2, p2];
    case 1:
      return [q2, v2, p2];
    case 2:
      return [p2, v2, t2];
    case 3:
      return [p2, q2, v2];
    case 4:
      return [t2, p2, v2];
    case 5:
      return [v2, p2, q2];
  }
};
convert$1.hsv.hsl = function(hsv) {
  var h2 = hsv[0];
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var vmin = Math.max(v2, 0.01);
  var lmin;
  var sl;
  var l2;
  l2 = (2 - s2) * v2;
  lmin = (2 - s2) * vmin;
  sl = s2 * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l2 /= 2;
  return [h2, sl * 100, l2 * 100];
};
convert$1.hwb.rgb = function(hwb) {
  var h2 = hwb[0] / 360;
  var wh = hwb[1] / 100;
  var bl = hwb[2] / 100;
  var ratio = wh + bl;
  var i2;
  var v2;
  var f2;
  var n2;
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  i2 = Math.floor(6 * h2);
  v2 = 1 - bl;
  f2 = 6 * h2 - i2;
  if ((i2 & 1) !== 0) {
    f2 = 1 - f2;
  }
  n2 = wh + f2 * (v2 - wh);
  var r2;
  var g2;
  var b2;
  switch (i2) {
    default:
    case 6:
    case 0:
      r2 = v2;
      g2 = n2;
      b2 = wh;
      break;
    case 1:
      r2 = n2;
      g2 = v2;
      b2 = wh;
      break;
    case 2:
      r2 = wh;
      g2 = v2;
      b2 = n2;
      break;
    case 3:
      r2 = wh;
      g2 = n2;
      b2 = v2;
      break;
    case 4:
      r2 = n2;
      g2 = wh;
      b2 = v2;
      break;
    case 5:
      r2 = v2;
      g2 = wh;
      b2 = n2;
      break;
  }
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$1.cmyk.rgb = function(cmyk) {
  var c2 = cmyk[0] / 100;
  var m2 = cmyk[1] / 100;
  var y2 = cmyk[2] / 100;
  var k2 = cmyk[3] / 100;
  var r2;
  var g2;
  var b2;
  r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
  g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
  b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$1.xyz.rgb = function(xyz) {
  var x2 = xyz[0] / 100;
  var y2 = xyz[1] / 100;
  var z2 = xyz[2] / 100;
  var r2;
  var g2;
  var b2;
  r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
  g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
  b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
  r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
  g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
  b2 = b2 > 31308e-7 ? 1.055 * Math.pow(b2, 1 / 2.4) - 0.055 : b2 * 12.92;
  r2 = Math.min(Math.max(0, r2), 1);
  g2 = Math.min(Math.max(0, g2), 1);
  b2 = Math.min(Math.max(0, b2), 1);
  return [r2 * 255, g2 * 255, b2 * 255];
};
convert$1.xyz.lab = function(xyz) {
  var x2 = xyz[0];
  var y2 = xyz[1];
  var z2 = xyz[2];
  var l2;
  var a2;
  var b2;
  x2 /= 95.047;
  y2 /= 100;
  z2 /= 108.883;
  x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
  y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
  z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
  l2 = 116 * y2 - 16;
  a2 = 500 * (x2 - y2);
  b2 = 200 * (y2 - z2);
  return [l2, a2, b2];
};
convert$1.lab.xyz = function(lab) {
  var l2 = lab[0];
  var a2 = lab[1];
  var b2 = lab[2];
  var x2;
  var y2;
  var z2;
  y2 = (l2 + 16) / 116;
  x2 = a2 / 500 + y2;
  z2 = y2 - b2 / 200;
  var y22 = Math.pow(y2, 3);
  var x22 = Math.pow(x2, 3);
  var z22 = Math.pow(z2, 3);
  y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
  x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
  z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
  x2 *= 95.047;
  y2 *= 100;
  z2 *= 108.883;
  return [x2, y2, z2];
};
convert$1.lab.lch = function(lab) {
  var l2 = lab[0];
  var a2 = lab[1];
  var b2 = lab[2];
  var hr;
  var h2;
  var c2;
  hr = Math.atan2(b2, a2);
  h2 = hr * 360 / 2 / Math.PI;
  if (h2 < 0) {
    h2 += 360;
  }
  c2 = Math.sqrt(a2 * a2 + b2 * b2);
  return [l2, c2, h2];
};
convert$1.lch.lab = function(lch) {
  var l2 = lch[0];
  var c2 = lch[1];
  var h2 = lch[2];
  var a2;
  var b2;
  var hr;
  hr = h2 / 360 * 2 * Math.PI;
  a2 = c2 * Math.cos(hr);
  b2 = c2 * Math.sin(hr);
  return [l2, a2, b2];
};
convert$1.rgb.ansi16 = function(args2) {
  var r2 = args2[0];
  var g2 = args2[1];
  var b2 = args2[2];
  var value = 1 in arguments ? arguments[1] : convert$1.rgb.hsv(args2)[2];
  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  var ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert$1.hsv.ansi16 = function(args2) {
  return convert$1.rgb.ansi16(convert$1.hsv.rgb(args2), args2[2]);
};
convert$1.rgb.ansi256 = function(args2) {
  var r2 = args2[0];
  var g2 = args2[1];
  var b2 = args2[2];
  if (r2 === g2 && g2 === b2) {
    if (r2 < 8) {
      return 16;
    }
    if (r2 > 248) {
      return 231;
    }
    return Math.round((r2 - 8) / 247 * 24) + 232;
  }
  var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
  return ansi;
};
convert$1.ansi16.rgb = function(args2) {
  var color = args2 % 10;
  if (color === 0 || color === 7) {
    if (args2 > 50) {
      color += 3.5;
    }
    color = color / 10.5 * 255;
    return [color, color, color];
  }
  var mult = (~~(args2 > 50) + 1) * 0.5;
  var r2 = (color & 1) * mult * 255;
  var g2 = (color >> 1 & 1) * mult * 255;
  var b2 = (color >> 2 & 1) * mult * 255;
  return [r2, g2, b2];
};
convert$1.ansi256.rgb = function(args2) {
  if (args2 >= 232) {
    var c2 = (args2 - 232) * 10 + 8;
    return [c2, c2, c2];
  }
  args2 -= 16;
  var rem;
  var r2 = Math.floor(args2 / 36) / 5 * 255;
  var g2 = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
  var b2 = rem % 6 / 5 * 255;
  return [r2, g2, b2];
};
convert$1.rgb.hex = function(args2) {
  var integer4 = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
  var string3 = integer4.toString(16).toUpperCase();
  return "000000".substring(string3.length) + string3;
};
convert$1.hex.rgb = function(args2) {
  var match2 = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match2) {
    return [0, 0, 0];
  }
  var colorString = match2[0];
  if (match2[0].length === 3) {
    colorString = colorString.split("").map(function(char) {
      return char + char;
    }).join("");
  }
  var integer4 = parseInt(colorString, 16);
  var r2 = integer4 >> 16 & 255;
  var g2 = integer4 >> 8 & 255;
  var b2 = integer4 & 255;
  return [r2, g2, b2];
};
convert$1.rgb.hcg = function(rgb) {
  var r2 = rgb[0] / 255;
  var g2 = rgb[1] / 255;
  var b2 = rgb[2] / 255;
  var max3 = Math.max(Math.max(r2, g2), b2);
  var min3 = Math.min(Math.min(r2, g2), b2);
  var chroma = max3 - min3;
  var grayscale;
  var hue;
  if (chroma < 1) {
    grayscale = min3 / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max3 === r2) {
    hue = (g2 - b2) / chroma % 6;
  } else if (max3 === g2) {
    hue = 2 + (b2 - r2) / chroma;
  } else {
    hue = 4 + (r2 - g2) / chroma + 4;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert$1.hsl.hcg = function(hsl) {
  var s2 = hsl[1] / 100;
  var l2 = hsl[2] / 100;
  var c2 = 1;
  var f2 = 0;
  if (l2 < 0.5) {
    c2 = 2 * s2 * l2;
  } else {
    c2 = 2 * s2 * (1 - l2);
  }
  if (c2 < 1) {
    f2 = (l2 - 0.5 * c2) / (1 - c2);
  }
  return [hsl[0], c2 * 100, f2 * 100];
};
convert$1.hsv.hcg = function(hsv) {
  var s2 = hsv[1] / 100;
  var v2 = hsv[2] / 100;
  var c2 = s2 * v2;
  var f2 = 0;
  if (c2 < 1) {
    f2 = (v2 - c2) / (1 - c2);
  }
  return [hsv[0], c2 * 100, f2 * 100];
};
convert$1.hcg.rgb = function(hcg) {
  var h2 = hcg[0] / 360;
  var c2 = hcg[1] / 100;
  var g2 = hcg[2] / 100;
  if (c2 === 0) {
    return [g2 * 255, g2 * 255, g2 * 255];
  }
  var pure = [0, 0, 0];
  var hi = h2 % 1 * 6;
  var v2 = hi % 1;
  var w2 = 1 - v2;
  var mg = 0;
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v2;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w2;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v2;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w2;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v2;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w2;
  }
  mg = (1 - c2) * g2;
  return [
    (c2 * pure[0] + mg) * 255,
    (c2 * pure[1] + mg) * 255,
    (c2 * pure[2] + mg) * 255
  ];
};
convert$1.hcg.hsv = function(hcg) {
  var c2 = hcg[1] / 100;
  var g2 = hcg[2] / 100;
  var v2 = c2 + g2 * (1 - c2);
  var f2 = 0;
  if (v2 > 0) {
    f2 = c2 / v2;
  }
  return [hcg[0], f2 * 100, v2 * 100];
};
convert$1.hcg.hsl = function(hcg) {
  var c2 = hcg[1] / 100;
  var g2 = hcg[2] / 100;
  var l2 = g2 * (1 - c2) + 0.5 * c2;
  var s2 = 0;
  if (l2 > 0 && l2 < 0.5) {
    s2 = c2 / (2 * l2);
  } else if (l2 >= 0.5 && l2 < 1) {
    s2 = c2 / (2 * (1 - l2));
  }
  return [hcg[0], s2 * 100, l2 * 100];
};
convert$1.hcg.hwb = function(hcg) {
  var c2 = hcg[1] / 100;
  var g2 = hcg[2] / 100;
  var v2 = c2 + g2 * (1 - c2);
  return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
};
convert$1.hwb.hcg = function(hwb) {
  var w2 = hwb[1] / 100;
  var b2 = hwb[2] / 100;
  var v2 = 1 - b2;
  var c2 = v2 - w2;
  var g2 = 0;
  if (c2 < 1) {
    g2 = (v2 - c2) / (1 - c2);
  }
  return [hwb[0], c2 * 100, g2 * 100];
};
convert$1.apple.rgb = function(apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert$1.rgb.apple = function(rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert$1.gray.rgb = function(args2) {
  return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
};
convert$1.gray.hsl = convert$1.gray.hsv = function(args2) {
  return [0, 0, args2[0]];
};
convert$1.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};
convert$1.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};
convert$1.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};
convert$1.gray.hex = function(gray) {
  var val = Math.round(gray[0] / 100 * 255) & 255;
  var integer4 = (val << 16) + (val << 8) + val;
  var string3 = integer4.toString(16).toUpperCase();
  return "000000".substring(string3.length) + string3;
};
convert$1.rgb.gray = function(rgb) {
  var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};
var conversions$1 = conversions$2.exports;
function buildGraph() {
  var graph = {};
  var models2 = Object.keys(conversions$1);
  for (var len = models2.length, i2 = 0; i2 < len; i2++) {
    graph[models2[i2]] = {
      distance: -1,
      parent: null
    };
  }
  return graph;
}
function deriveBFS(fromModel) {
  var graph = buildGraph();
  var queue2 = [fromModel];
  graph[fromModel].distance = 0;
  while (queue2.length) {
    var current2 = queue2.pop();
    var adjacents = Object.keys(conversions$1[current2]);
    for (var len = adjacents.length, i2 = 0; i2 < len; i2++) {
      var adjacent = adjacents[i2];
      var node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current2].distance + 1;
        node.parent = current2;
        queue2.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function(args2) {
    return to(from(args2));
  };
}
function wrapConversion(toModel, graph) {
  var path2 = [graph[toModel].parent, toModel];
  var fn = conversions$1[graph[toModel].parent][toModel];
  var cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path2.unshift(graph[cur].parent);
    fn = link(conversions$1[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path2;
  return fn;
}
var route$1 = function(fromModel) {
  var graph = deriveBFS(fromModel);
  var conversion = {};
  var models2 = Object.keys(graph);
  for (var len = models2.length, i2 = 0; i2 < len; i2++) {
    var toModel = models2[i2];
    var node = graph[toModel];
    if (node.parent === null) {
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};
var conversions = conversions$2.exports;
var route = route$1;
var convert = {};
var models = Object.keys(conversions);
function wrapRaw(fn) {
  var wrappedFn = function(args2) {
    if (args2 === void 0 || args2 === null) {
      return args2;
    }
    if (arguments.length > 1) {
      args2 = Array.prototype.slice.call(arguments);
    }
    return fn(args2);
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  var wrappedFn = function(args2) {
    if (args2 === void 0 || args2 === null) {
      return args2;
    }
    if (arguments.length > 1) {
      args2 = Array.prototype.slice.call(arguments);
    }
    var result = fn(args2);
    if (typeof result === "object") {
      for (var len = result.length, i2 = 0; i2 < len; i2++) {
        result[i2] = Math.round(result[i2]);
      }
    }
    return result;
  };
  if ("conversion" in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(function(fromModel) {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
  Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
  var routes2 = route(fromModel);
  var routeModels = Object.keys(routes2);
  routeModels.forEach(function(toModel) {
    var fn = routes2[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
var colorConvert = convert;
(function(module2) {
  const colorConvert$1 = colorConvert;
  const wrapAnsi16 = (fn, offset3) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${code + offset3}m`;
  };
  const wrapAnsi256 = (fn, offset3) => function() {
    const code = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset3};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset3) => function() {
    const rgb = fn.apply(colorConvert$1, arguments);
    return `\x1B[${38 + offset3};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group2 = styles[groupName];
      for (const styleName of Object.keys(group2)) {
        const style2 = group2[styleName];
        styles[styleName] = {
          open: `\x1B[${style2[0]}m`,
          close: `\x1B[${style2[1]}m`
        };
        group2[styleName] = styles[styleName];
        codes.set(style2[0], style2[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group2,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n2) => n2;
    const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key2 of Object.keys(colorConvert$1)) {
      if (typeof colorConvert$1[key2] !== "object") {
        continue;
      }
      const suite = colorConvert$1[key2];
      if (key2 === "ansi16") {
        key2 = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key2] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key2] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key2] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key2] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key2] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key2] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles);
var browser = {
  stdout: false,
  stderr: false
};
const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = /* @__PURE__ */ new Map([
  ["n", "\n"],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function unescape$1(c2) {
  if (c2[0] === "u" && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
    return String.fromCharCode(parseInt(c2.slice(1), 16));
  }
  return ESCAPES.get(c2) || c2;
}
function parseArguments(name2, args2) {
  const results = [];
  const chunks = args2.trim().split(/\s*,\s*/g);
  let matches2;
  for (const chunk of chunks) {
    if (!isNaN(chunk)) {
      results.push(Number(chunk));
    } else if (matches2 = chunk.match(STRING_REGEX)) {
      results.push(matches2[2].replace(ESCAPE_REGEX, (m2, escape2, chr) => escape2 ? unescape$1(escape2) : chr));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
    }
  }
  return results;
}
function parseStyle(style2) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches2;
  while ((matches2 = STYLE_REGEX.exec(style2)) !== null) {
    const name2 = matches2[1];
    if (matches2[2]) {
      const args2 = parseArguments(name2, matches2[2]);
      results.push([name2].concat(args2));
    } else {
      results.push([name2]);
    }
  }
  return results;
}
function buildStyle(chalk2, styles) {
  const enabled = {};
  for (const layer of styles) {
    for (const style2 of layer.styles) {
      enabled[style2[0]] = layer.inverse ? null : style2.slice(1);
    }
  }
  let current2 = chalk2;
  for (const styleName of Object.keys(enabled)) {
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current2)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      if (enabled[styleName].length > 0) {
        current2 = current2[styleName].apply(current2, enabled[styleName]);
      } else {
        current2 = current2[styleName];
      }
    }
  }
  return current2;
}
var templates = (chalk2, tmp) => {
  const styles = [];
  const chunks = [];
  let chunk = [];
  tmp.replace(TEMPLATE_REGEX, (m2, escapeChar, inverse, style2, close3, chr) => {
    if (escapeChar) {
      chunk.push(unescape$1(escapeChar));
    } else if (style2) {
      const str = chunk.join("");
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk2, styles)(str));
      styles.push({ inverse, styles: parseStyle(style2) });
    } else if (close3) {
      if (styles.length === 0) {
        throw new Error("Found extraneous } in Chalk template literal");
      }
      chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(chr);
    }
  });
  chunks.push(chunk.join(""));
  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(errMsg);
  }
  return chunks.join("");
};
(function(module2) {
  const escapeStringRegexp$1 = escapeStringRegexp;
  const ansiStyles$1 = ansiStyles.exports;
  const stdoutColor = browser.stdout;
  const template = templates;
  const isSimpleWindowsTerm = process.platform === "win32" && !({}.TERM || "").toLowerCase().startsWith("xterm");
  const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  const skipModels = /* @__PURE__ */ new Set(["gray"]);
  const styles = /* @__PURE__ */ Object.create(null);
  function applyOptions2(obj, options) {
    options = options || {};
    const scLevel = 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk2 = {};
      applyOptions2(chalk2, options);
      chalk2.template = function() {
        const args2 = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk2.template].concat(args2));
      };
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = Chalk;
      return chalk2.template;
    }
    applyOptions2(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles$1.blue.open = "\x1B[94m";
  }
  for (const key2 of Object.keys(ansiStyles$1)) {
    ansiStyles$1[key2].closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1[key2].close), "g");
    styles[key2] = {
      get() {
        const codes = ansiStyles$1[key2];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key2);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles$1.color.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1.color.close), "g");
  for (const model of Object.keys(ansiStyles$1.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open2 = ansiStyles$1.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open2,
            close: ansiStyles$1.color.close,
            closeRe: ansiStyles$1.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles$1.bgColor.closeRe = new RegExp(escapeStringRegexp$1(ansiStyles$1.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles$1.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open2 = ansiStyles$1.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open: open2,
            close: ansiStyles$1.bgColor.close,
            closeRe: ansiStyles$1.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key2) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self2 = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self2.level;
      },
      set(level) {
        self2.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self2.enabled;
      },
      set(enabled) {
        self2.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key2 === "gray" || key2 === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args2 = arguments;
    const argsLen = args2.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a2 = 1; a2 < argsLen; a2++) {
        str += " " + args2[a2];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles$1.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles$1.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles$1.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk2, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args2 = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i2 = 1; i2 < strings.length; i2++) {
      parts.push(String(args2[i2 - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i2]));
    }
    return template(chalk2, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
})(chalk$1);
const chalk = chalk$1.exports;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props3) {
    for (var i2 = 0; i2 < props3.length; i2++) {
      var descriptor = props3[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var get = function get2(object4, property2, receiver) {
  if (object4 === null)
    object4 = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object4, property2);
  if (desc === void 0) {
    var parent2 = Object.getPrototypeOf(object4);
    if (parent2 === null) {
      return void 0;
    } else {
      return get2(parent2, property2, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === void 0) {
      return void 0;
    }
    return getter.call(receiver);
  }
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self2, call2) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
};
var slicedToArray = function() {
  function sliceIterator(arr, i2) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i2) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i2);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var toConsumableArray = function(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  } else {
    return Array.from(arr);
  }
};
var Processor = function() {
  function Processor2(options) {
    classCallCheck(this, Processor2);
    this.selfOptions = options || {};
    this.pipes = {};
  }
  createClass(Processor2, [{
    key: "options",
    value: function options(_options) {
      if (_options) {
        this.selfOptions = _options;
      }
      return this.selfOptions;
    }
  }, {
    key: "pipe",
    value: function pipe(name2, pipeArg) {
      var pipe2 = pipeArg;
      if (typeof name2 === "string") {
        if (typeof pipe2 === "undefined") {
          return this.pipes[name2];
        } else {
          this.pipes[name2] = pipe2;
        }
      }
      if (name2 && name2.name) {
        pipe2 = name2;
        if (pipe2.processor === this) {
          return pipe2;
        }
        this.pipes[pipe2.name] = pipe2;
      }
      pipe2.processor = this;
      return pipe2;
    }
  }, {
    key: "process",
    value: function process2(input, pipe) {
      var context2 = input;
      context2.options = this.options();
      var nextPipe = pipe || input.pipe || "default";
      var lastPipe = void 0;
      var lastContext = void 0;
      while (nextPipe) {
        if (typeof context2.nextAfterChildren !== "undefined") {
          context2.next = context2.nextAfterChildren;
          context2.nextAfterChildren = null;
        }
        if (typeof nextPipe === "string") {
          nextPipe = this.pipe(nextPipe);
        }
        nextPipe.process(context2);
        lastContext = context2;
        lastPipe = nextPipe;
        nextPipe = null;
        if (context2) {
          if (context2.next) {
            context2 = context2.next;
            nextPipe = lastContext.nextPipe || context2.pipe || lastPipe;
          }
        }
      }
      return context2.hasResult ? context2.result : void 0;
    }
  }]);
  return Processor2;
}();
var Pipe = function() {
  function Pipe2(name2) {
    classCallCheck(this, Pipe2);
    this.name = name2;
    this.filters = [];
  }
  createClass(Pipe2, [{
    key: "process",
    value: function process2(input) {
      if (!this.processor) {
        throw new Error("add this pipe to a processor before using it");
      }
      var debug = this.debug;
      var length = this.filters.length;
      var context2 = input;
      for (var index2 = 0; index2 < length; index2++) {
        var filter = this.filters[index2];
        if (debug) {
          this.log("filter: " + filter.filterName);
        }
        filter(context2);
        if ((typeof context2 === "undefined" ? "undefined" : _typeof(context2)) === "object" && context2.exiting) {
          context2.exiting = false;
          break;
        }
      }
      if (!context2.next && this.resultCheck) {
        this.resultCheck(context2);
      }
    }
  }, {
    key: "log",
    value: function log3(msg) {
      console.log("[jsondiffpatch] " + this.name + " pipe, " + msg);
    }
  }, {
    key: "append",
    value: function append() {
      var _filters;
      (_filters = this.filters).push.apply(_filters, arguments);
      return this;
    }
  }, {
    key: "prepend",
    value: function prepend() {
      var _filters2;
      (_filters2 = this.filters).unshift.apply(_filters2, arguments);
      return this;
    }
  }, {
    key: "indexOf",
    value: function indexOf2(filterName) {
      if (!filterName) {
        throw new Error("a filter name is required");
      }
      for (var index2 = 0; index2 < this.filters.length; index2++) {
        var filter = this.filters[index2];
        if (filter.filterName === filterName) {
          return index2;
        }
      }
      throw new Error("filter not found: " + filterName);
    }
  }, {
    key: "list",
    value: function list() {
      return this.filters.map(function(f2) {
        return f2.filterName;
      });
    }
  }, {
    key: "after",
    value: function after(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2 + 1, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "before",
    value: function before(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2, 0);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "replace",
    value: function replace2(filterName) {
      var index2 = this.indexOf(filterName);
      var params = Array.prototype.slice.call(arguments, 1);
      if (!params.length) {
        throw new Error("a filter is required");
      }
      params.unshift(index2, 1);
      Array.prototype.splice.apply(this.filters, params);
      return this;
    }
  }, {
    key: "remove",
    value: function remove2(filterName) {
      var index2 = this.indexOf(filterName);
      this.filters.splice(index2, 1);
      return this;
    }
  }, {
    key: "clear",
    value: function clear2() {
      this.filters.length = 0;
      return this;
    }
  }, {
    key: "shouldHaveResult",
    value: function shouldHaveResult(should) {
      if (should === false) {
        this.resultCheck = null;
        return;
      }
      if (this.resultCheck) {
        return;
      }
      var pipe = this;
      this.resultCheck = function(context2) {
        if (!context2.hasResult) {
          console.log(context2);
          var error = new Error(pipe.name + " failed");
          error.noResult = true;
          throw error;
        }
      };
      return this;
    }
  }]);
  return Pipe2;
}();
var Context = function() {
  function Context2() {
    classCallCheck(this, Context2);
  }
  createClass(Context2, [{
    key: "setResult",
    value: function setResult(result) {
      this.result = result;
      this.hasResult = true;
      return this;
    }
  }, {
    key: "exit",
    value: function exit() {
      this.exiting = true;
      return this;
    }
  }, {
    key: "switchTo",
    value: function switchTo(next2, pipe) {
      if (typeof next2 === "string" || next2 instanceof Pipe) {
        this.nextPipe = next2;
      } else {
        this.next = next2;
        if (pipe) {
          this.nextPipe = pipe;
        }
      }
      return this;
    }
  }, {
    key: "push",
    value: function push2(child, name2) {
      child.parent = this;
      if (typeof name2 !== "undefined") {
        child.childName = name2;
      }
      child.root = this.root || this;
      child.options = child.options || this.options;
      if (!this.children) {
        this.children = [child];
        this.nextAfterChildren = this.next || null;
        this.next = child;
      } else {
        this.children[this.children.length - 1].next = child;
        this.children.push(child);
      }
      child.next = this;
      return this;
    }
  }]);
  return Context2;
}();
var isArray = typeof Array.isArray === "function" ? Array.isArray : function(a2) {
  return a2 instanceof Array;
};
function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}
function clone2(arg) {
  if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) !== "object") {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone2);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name2 in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name2)) {
      cloned[name2] = clone2(arg[name2]);
    }
  }
  return cloned;
}
var DiffContext = function(_Context) {
  inherits(DiffContext2, _Context);
  function DiffContext2(left, right) {
    classCallCheck(this, DiffContext2);
    var _this = possibleConstructorReturn(this, (DiffContext2.__proto__ || Object.getPrototypeOf(DiffContext2)).call(this));
    _this.left = left;
    _this.right = right;
    _this.pipe = "diff";
    return _this;
  }
  createClass(DiffContext2, [{
    key: "setResult",
    value: function setResult(result) {
      if (this.options.cloneDiffValues && (typeof result === "undefined" ? "undefined" : _typeof(result)) === "object") {
        var clone$$1 = typeof this.options.cloneDiffValues === "function" ? this.options.cloneDiffValues : clone2;
        if (_typeof(result[0]) === "object") {
          result[0] = clone$$1(result[0]);
        }
        if (_typeof(result[1]) === "object") {
          result[1] = clone$$1(result[1]);
        }
      }
      return Context.prototype.setResult.apply(this, arguments);
    }
  }]);
  return DiffContext2;
}(Context);
var PatchContext = function(_Context) {
  inherits(PatchContext2, _Context);
  function PatchContext2(left, delta) {
    classCallCheck(this, PatchContext2);
    var _this = possibleConstructorReturn(this, (PatchContext2.__proto__ || Object.getPrototypeOf(PatchContext2)).call(this));
    _this.left = left;
    _this.delta = delta;
    _this.pipe = "patch";
    return _this;
  }
  return PatchContext2;
}(Context);
var ReverseContext = function(_Context) {
  inherits(ReverseContext2, _Context);
  function ReverseContext2(delta) {
    classCallCheck(this, ReverseContext2);
    var _this = possibleConstructorReturn(this, (ReverseContext2.__proto__ || Object.getPrototypeOf(ReverseContext2)).call(this));
    _this.delta = delta;
    _this.pipe = "reverse";
    return _this;
  }
  return ReverseContext2;
}(Context);
var isArray$1 = typeof Array.isArray === "function" ? Array.isArray : function(a2) {
  return a2 instanceof Array;
};
var diffFilter = function trivialMatchesDiffFilter(context2) {
  if (context2.left === context2.right) {
    context2.setResult(void 0).exit();
    return;
  }
  if (typeof context2.left === "undefined") {
    if (typeof context2.right === "function") {
      throw new Error("functions are not supported");
    }
    context2.setResult([context2.right]).exit();
    return;
  }
  if (typeof context2.right === "undefined") {
    context2.setResult([context2.left, 0, 0]).exit();
    return;
  }
  if (typeof context2.left === "function" || typeof context2.right === "function") {
    throw new Error("functions are not supported");
  }
  context2.leftType = context2.left === null ? "null" : _typeof(context2.left);
  context2.rightType = context2.right === null ? "null" : _typeof(context2.right);
  if (context2.leftType !== context2.rightType) {
    context2.setResult([context2.left, context2.right]).exit();
    return;
  }
  if (context2.leftType === "boolean" || context2.leftType === "number") {
    context2.setResult([context2.left, context2.right]).exit();
    return;
  }
  if (context2.leftType === "object") {
    context2.leftIsArray = isArray$1(context2.left);
  }
  if (context2.rightType === "object") {
    context2.rightIsArray = isArray$1(context2.right);
  }
  if (context2.leftIsArray !== context2.rightIsArray) {
    context2.setResult([context2.left, context2.right]).exit();
    return;
  }
  if (context2.left instanceof RegExp) {
    if (context2.right instanceof RegExp) {
      context2.setResult([context2.left.toString(), context2.right.toString()]).exit();
    } else {
      context2.setResult([context2.left, context2.right]).exit();
    }
  }
};
diffFilter.filterName = "trivial";
var patchFilter = function trivialMatchesPatchFilter(context2) {
  if (typeof context2.delta === "undefined") {
    context2.setResult(context2.left).exit();
    return;
  }
  context2.nested = !isArray$1(context2.delta);
  if (context2.nested) {
    return;
  }
  if (context2.delta.length === 1) {
    context2.setResult(context2.delta[0]).exit();
    return;
  }
  if (context2.delta.length === 2) {
    if (context2.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context2.delta[1]);
      if (regexArgs) {
        context2.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context2.setResult(context2.delta[1]).exit();
    return;
  }
  if (context2.delta.length === 3 && context2.delta[2] === 0) {
    context2.setResult(void 0).exit();
  }
};
patchFilter.filterName = "trivial";
var reverseFilter = function trivialReferseFilter(context2) {
  if (typeof context2.delta === "undefined") {
    context2.setResult(context2.delta).exit();
    return;
  }
  context2.nested = !isArray$1(context2.delta);
  if (context2.nested) {
    return;
  }
  if (context2.delta.length === 1) {
    context2.setResult([context2.delta[0], 0, 0]).exit();
    return;
  }
  if (context2.delta.length === 2) {
    context2.setResult([context2.delta[1], context2.delta[0]]).exit();
    return;
  }
  if (context2.delta.length === 3 && context2.delta[2] === 0) {
    context2.setResult([context2.delta[0]]).exit();
  }
};
reverseFilter.filterName = "trivial";
function collectChildrenDiffFilter(context2) {
  if (!context2 || !context2.children) {
    return;
  }
  var length = context2.children.length;
  var child = void 0;
  var result = context2.result;
  for (var index2 = 0; index2 < length; index2++) {
    child = context2.children[index2];
    if (typeof child.result === "undefined") {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context2.leftIsArray) {
    result._t = "a";
  }
  context2.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = "collectChildren";
function objectsDiffFilter(context2) {
  if (context2.leftIsArray || context2.leftType !== "object") {
    return;
  }
  var name2 = void 0;
  var child = void 0;
  var propertyFilter = context2.options.propertyFilter;
  for (name2 in context2.left) {
    if (!Object.prototype.hasOwnProperty.call(context2.left, name2)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name2, context2)) {
      continue;
    }
    child = new DiffContext(context2.left[name2], context2.right[name2]);
    context2.push(child, name2);
  }
  for (name2 in context2.right) {
    if (!Object.prototype.hasOwnProperty.call(context2.right, name2)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name2, context2)) {
      continue;
    }
    if (typeof context2.left[name2] === "undefined") {
      child = new DiffContext(void 0, context2.right[name2]);
      context2.push(child, name2);
    }
  }
  if (!context2.children || context2.children.length === 0) {
    context2.setResult(void 0).exit();
    return;
  }
  context2.exit();
}
objectsDiffFilter.filterName = "objects";
var patchFilter$1 = function nestedPatchFilter(context2) {
  if (!context2.nested) {
    return;
  }
  if (context2.delta._t) {
    return;
  }
  var name2 = void 0;
  var child = void 0;
  for (name2 in context2.delta) {
    child = new PatchContext(context2.left[name2], context2.delta[name2]);
    context2.push(child, name2);
  }
  context2.exit();
};
patchFilter$1.filterName = "objects";
var collectChildrenPatchFilter = function collectChildrenPatchFilter2(context2) {
  if (!context2 || !context2.children) {
    return;
  }
  if (context2.delta._t) {
    return;
  }
  var length = context2.children.length;
  var child = void 0;
  for (var index2 = 0; index2 < length; index2++) {
    child = context2.children[index2];
    if (Object.prototype.hasOwnProperty.call(context2.left, child.childName) && child.result === void 0) {
      delete context2.left[child.childName];
    } else if (context2.left[child.childName] !== child.result) {
      context2.left[child.childName] = child.result;
    }
  }
  context2.setResult(context2.left).exit();
};
collectChildrenPatchFilter.filterName = "collectChildren";
var reverseFilter$1 = function nestedReverseFilter(context2) {
  if (!context2.nested) {
    return;
  }
  if (context2.delta._t) {
    return;
  }
  var name2 = void 0;
  var child = void 0;
  for (name2 in context2.delta) {
    child = new ReverseContext(context2.delta[name2]);
    context2.push(child, name2);
  }
  context2.exit();
};
reverseFilter$1.filterName = "objects";
function collectChildrenReverseFilter(context2) {
  if (!context2 || !context2.children) {
    return;
  }
  if (context2.delta._t) {
    return;
  }
  var length = context2.children.length;
  var child = void 0;
  var delta = {};
  for (var index2 = 0; index2 < length; index2++) {
    child = context2.children[index2];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context2.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = "collectChildren";
var defaultMatch = function defaultMatch2(array1, array22, index1, index2) {
  return array1[index1] === array22[index2];
};
var lengthMatrix = function lengthMatrix2(array1, array22, match2, context2) {
  var len1 = array1.length;
  var len2 = array22.length;
  var x2 = void 0, y2 = void 0;
  var matrix = [len1 + 1];
  for (x2 = 0; x2 < len1 + 1; x2++) {
    matrix[x2] = [len2 + 1];
    for (y2 = 0; y2 < len2 + 1; y2++) {
      matrix[x2][y2] = 0;
    }
  }
  matrix.match = match2;
  for (x2 = 1; x2 < len1 + 1; x2++) {
    for (y2 = 1; y2 < len2 + 1; y2++) {
      if (match2(array1, array22, x2 - 1, y2 - 1, context2)) {
        matrix[x2][y2] = matrix[x2 - 1][y2 - 1] + 1;
      } else {
        matrix[x2][y2] = Math.max(matrix[x2 - 1][y2], matrix[x2][y2 - 1]);
      }
    }
  }
  return matrix;
};
var backtrack = function backtrack2(matrix, array1, array22, context2) {
  var index1 = array1.length;
  var index2 = array22.length;
  var subsequence = {
    sequence: [],
    indices1: [],
    indices2: []
  };
  while (index1 !== 0 && index2 !== 0) {
    var sameLetter = matrix.match(array1, array22, index1 - 1, index2 - 1, context2);
    if (sameLetter) {
      subsequence.sequence.unshift(array1[index1 - 1]);
      subsequence.indices1.unshift(index1 - 1);
      subsequence.indices2.unshift(index2 - 1);
      --index1;
      --index2;
    } else {
      var valueAtMatrixAbove = matrix[index1][index2 - 1];
      var valueAtMatrixLeft = matrix[index1 - 1][index2];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --index2;
      } else {
        --index1;
      }
    }
  }
  return subsequence;
};
var get$1 = function get3(array1, array22, match2, context2) {
  var innerContext = context2 || {};
  var matrix = lengthMatrix(array1, array22, match2 || defaultMatch, innerContext);
  var result = backtrack(matrix, array1, array22, innerContext);
  if (typeof array1 === "string" && typeof array22 === "string") {
    result.sequence = result.sequence.join("");
  }
  return result;
};
var lcs = {
  get: get$1
};
var ARRAY_MOVE = 3;
var isArray$2 = typeof Array.isArray === "function" ? Array.isArray : function(a2) {
  return a2 instanceof Array;
};
var arrayIndexOf = typeof Array.prototype.indexOf === "function" ? function(array4, item) {
  return array4.indexOf(item);
} : function(array4, item) {
  var length = array4.length;
  for (var i2 = 0; i2 < length; i2++) {
    if (array4[i2] === item) {
      return i2;
    }
  }
  return -1;
};
function arraysHaveMatchByRef(array1, array22, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array22[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}
function matchItems(array1, array22, index1, index2, context2) {
  var value1 = array1[index1];
  var value2 = array22[index2];
  if (value1 === value2) {
    return true;
  }
  if ((typeof value1 === "undefined" ? "undefined" : _typeof(value1)) !== "object" || (typeof value2 === "undefined" ? "undefined" : _typeof(value2)) !== "object") {
    return false;
  }
  var objectHash = context2.objectHash;
  if (!objectHash) {
    return context2.matchByPosition && index1 === index2;
  }
  var hash1 = void 0;
  var hash2 = void 0;
  if (typeof index1 === "number") {
    context2.hashCache1 = context2.hashCache1 || [];
    hash1 = context2.hashCache1[index1];
    if (typeof hash1 === "undefined") {
      context2.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === "undefined") {
    return false;
  }
  if (typeof index2 === "number") {
    context2.hashCache2 = context2.hashCache2 || [];
    hash2 = context2.hashCache2[index2];
    if (typeof hash2 === "undefined") {
      context2.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === "undefined") {
    return false;
  }
  return hash1 === hash2;
}
var diffFilter$1 = function arraysDiffFilter(context2) {
  if (!context2.leftIsArray) {
    return;
  }
  var matchContext = {
    objectHash: context2.options && context2.options.objectHash,
    matchByPosition: context2.options && context2.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index2 = void 0;
  var index1 = void 0;
  var index22 = void 0;
  var array1 = context2.left;
  var array22 = context2.right;
  var len1 = array1.length;
  var len2 = array22.length;
  var child = void 0;
  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== "boolean") {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array22, len1, len2);
  }
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array22, commonHead, commonHead, matchContext)) {
    index2 = commonHead;
    child = new DiffContext(context2.left[index2], context2.right[index2]);
    context2.push(child, index2);
    commonHead++;
  }
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(array1, array22, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index22 = len2 - 1 - commonTail;
    child = new DiffContext(context2.left[index1], context2.right[index22]);
    context2.push(child, index22);
    commonTail++;
  }
  var result = void 0;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      context2.setResult(void 0).exit();
      return;
    }
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
      result[index2] = [array22[index2]];
    }
    context2.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    result = result || {
      _t: "a"
    };
    for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
      result["_" + index2] = [array1[index2], 0, 0];
    }
    context2.setResult(result).exit();
    return;
  }
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array22.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(trimmed1, trimmed2, matchItems, matchContext);
  var removedItems = [];
  result = result || {
    _t: "a"
  };
  for (index2 = commonHead; index2 < len1 - commonTail; index2++) {
    if (arrayIndexOf(seq.indices1, index2 - commonHead) < 0) {
      result["_" + index2] = [array1[index2], 0, 0];
      removedItems.push(index2);
    }
  }
  var detectMove = true;
  if (context2.options && context2.options.arrays && context2.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context2.options && context2.options.arrays && context2.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }
  var removedItemsLength = removedItems.length;
  for (index2 = commonHead; index2 < len2 - commonTail; index2++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index2 - commonHead);
    if (indexOnArray2 < 0) {
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead, index2 - commonHead, matchContext)) {
            result["_" + index1].splice(1, 2, index2, ARRAY_MOVE);
            if (!includeValueOnMove) {
              result["_" + index1][0] = "";
            }
            index22 = index2;
            child = new DiffContext(context2.left[index1], context2.right[index22]);
            context2.push(child, index22);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        result[index2] = [array22[index2]];
      }
    } else {
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index22 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context2.left[index1], context2.right[index22]);
      context2.push(child, index22);
    }
  }
  context2.setResult(result).exit();
};
diffFilter$1.filterName = "arrays";
var compare = {
  numerically: function numerically(a2, b2) {
    return a2 - b2;
  },
  numericallyBy: function numericallyBy(name2) {
    return function(a2, b2) {
      return a2[name2] - b2[name2];
    };
  }
};
var patchFilter$2 = function nestedPatchFilter2(context2) {
  if (!context2.nested) {
    return;
  }
  if (context2.delta._t !== "a") {
    return;
  }
  var index2 = void 0;
  var index1 = void 0;
  var delta = context2.delta;
  var array4 = context2.left;
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index2 in delta) {
    if (index2 !== "_t") {
      if (index2[0] === "_") {
        if (delta[index2][2] === 0 || delta[index2][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index2.slice(1), 10));
        } else {
          throw new Error("only removal or move can be applied at original array indices," + (" invalid diff type: " + delta[index2][2]));
        }
      } else {
        if (delta[index2].length === 1) {
          toInsert.push({
            index: parseInt(index2, 10),
            value: delta[index2][0]
          });
        } else {
          toModify.push({
            index: parseInt(index2, 10),
            delta: delta[index2]
          });
        }
      }
    }
  }
  toRemove = toRemove.sort(compare.numerically);
  for (index2 = toRemove.length - 1; index2 >= 0; index2--) {
    index1 = toRemove[index2];
    var indexDiff = delta["_" + index1];
    var removedValue = array4.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }
  toInsert = toInsert.sort(compare.numericallyBy("index"));
  var toInsertLength = toInsert.length;
  for (index2 = 0; index2 < toInsertLength; index2++) {
    var insertion = toInsert[index2];
    array4.splice(insertion.index, 0, insertion.value);
  }
  var toModifyLength = toModify.length;
  var child = void 0;
  if (toModifyLength > 0) {
    for (index2 = 0; index2 < toModifyLength; index2++) {
      var modification = toModify[index2];
      child = new PatchContext(context2.left[modification.index], modification.delta);
      context2.push(child, modification.index);
    }
  }
  if (!context2.children) {
    context2.setResult(context2.left).exit();
    return;
  }
  context2.exit();
};
patchFilter$2.filterName = "arrays";
var collectChildrenPatchFilter$1 = function collectChildrenPatchFilter3(context2) {
  if (!context2 || !context2.children) {
    return;
  }
  if (context2.delta._t !== "a") {
    return;
  }
  var length = context2.children.length;
  var child = void 0;
  for (var index2 = 0; index2 < length; index2++) {
    child = context2.children[index2];
    context2.left[child.childName] = child.result;
  }
  context2.setResult(context2.left).exit();
};
collectChildrenPatchFilter$1.filterName = "arraysCollectChildren";
var reverseFilter$2 = function arraysReverseFilter(context2) {
  if (!context2.nested) {
    if (context2.delta[2] === ARRAY_MOVE) {
      context2.newName = "_" + context2.delta[1];
      context2.setResult([context2.delta[0], parseInt(context2.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context2.delta._t !== "a") {
    return;
  }
  var name2 = void 0;
  var child = void 0;
  for (name2 in context2.delta) {
    if (name2 === "_t") {
      continue;
    }
    child = new ReverseContext(context2.delta[name2]);
    context2.push(child, name2);
  }
  context2.exit();
};
reverseFilter$2.filterName = "arrays";
var reverseArrayDeltaIndex = function reverseArrayDeltaIndex2(delta, index2, itemDelta) {
  if (typeof index2 === "string" && index2[0] === "_") {
    return parseInt(index2.substr(1), 10);
  } else if (isArray$2(itemDelta) && itemDelta[2] === 0) {
    return "_" + index2;
  }
  var reverseIndex = +index2;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray$2(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index2) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }
  return reverseIndex;
};
function collectChildrenReverseFilter$1(context2) {
  if (!context2 || !context2.children) {
    return;
  }
  if (context2.delta._t !== "a") {
    return;
  }
  var length = context2.children.length;
  var child = void 0;
  var delta = {
    _t: "a"
  };
  for (var index2 = 0; index2 < length; index2++) {
    child = context2.children[index2];
    var name2 = child.newName;
    if (typeof name2 === "undefined") {
      name2 = reverseArrayDeltaIndex(context2.delta, child.childName, child.result);
    }
    if (delta[name2] !== child.result) {
      delta[name2] = child.result;
    }
  }
  context2.setResult(delta).exit();
}
collectChildrenReverseFilter$1.filterName = "arraysCollectChildren";
var diffFilter$2 = function datesDiffFilter(context2) {
  if (context2.left instanceof Date) {
    if (context2.right instanceof Date) {
      if (context2.left.getTime() !== context2.right.getTime()) {
        context2.setResult([context2.left, context2.right]);
      } else {
        context2.setResult(void 0);
      }
    } else {
      context2.setResult([context2.left, context2.right]);
    }
    context2.exit();
  } else if (context2.right instanceof Date) {
    context2.setResult([context2.left, context2.right]).exit();
  }
};
diffFilter$2.filterName = "dates";
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;
var getDiffMatchPatch = function getDiffMatchPatch2(required4) {
  if (!cachedDiffPatch) {
    var instance = void 0;
    if (typeof diff_match_patch !== "undefined") {
      instance = typeof diff_match_patch === "function" ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (dmp) {
      try {
        instance = dmp && new dmp();
      } catch (err) {
        instance = null;
      }
    }
    if (!instance) {
      if (!required4) {
        return null;
      }
      var error = new Error("text diff_match_patch library not found");
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function diff2(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function patch2(txt1, _patch) {
        var results = instance.patch_apply(instance.patch_fromText(_patch), txt1);
        for (var i2 = 0; i2 < results[1].length; i2++) {
          if (!results[1][i2]) {
            var _error = new Error("text patch failed");
            _error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};
var diffFilter$3 = function textsDiffFilter(context2) {
  if (context2.leftType !== "string") {
    return;
  }
  var minLength = context2.options && context2.options.textDiff && context2.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context2.left.length < minLength || context2.right.length < minLength) {
    context2.setResult([context2.left, context2.right]).exit();
    return;
  }
  var diffMatchPatch2 = getDiffMatchPatch();
  if (!diffMatchPatch2) {
    context2.setResult([context2.left, context2.right]).exit();
    return;
  }
  var diff2 = diffMatchPatch2.diff;
  context2.setResult([diff2(context2.left, context2.right), 0, TEXT_DIFF]).exit();
};
diffFilter$3.filterName = "texts";
var patchFilter$3 = function textsPatchFilter(context2) {
  if (context2.nested) {
    return;
  }
  if (context2.delta[2] !== TEXT_DIFF) {
    return;
  }
  var patch2 = getDiffMatchPatch(true).patch;
  context2.setResult(patch2(context2.left, context2.delta[0])).exit();
};
patchFilter$3.filterName = "texts";
var textDeltaReverse = function textDeltaReverse2(delta) {
  var i2 = void 0;
  var l2 = void 0;
  var lines = void 0;
  var line2 = void 0;
  var lineTmp = void 0;
  var header = null;
  var headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  var lineHeader = void 0;
  lines = delta.split("\n");
  for (i2 = 0, l2 = lines.length; i2 < l2; i2++) {
    line2 = lines[i2];
    var lineStart = line2.slice(0, 1);
    if (lineStart === "@") {
      header = headerRegex.exec(line2);
      lineHeader = i2;
      lines[lineHeader] = "@@ -" + header[3] + "," + header[4] + " +" + header[1] + "," + header[2] + " @@";
    } else if (lineStart === "+") {
      lines[i2] = "-" + lines[i2].slice(1);
      if (lines[i2 - 1].slice(0, 1) === "+") {
        lineTmp = lines[i2];
        lines[i2] = lines[i2 - 1];
        lines[i2 - 1] = lineTmp;
      }
    } else if (lineStart === "-") {
      lines[i2] = "+" + lines[i2].slice(1);
    }
  }
  return lines.join("\n");
};
var reverseFilter$3 = function textsReverseFilter(context2) {
  if (context2.nested) {
    return;
  }
  if (context2.delta[2] !== TEXT_DIFF) {
    return;
  }
  context2.setResult([textDeltaReverse(context2.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter$3.filterName = "texts";
var DiffPatcher = function() {
  function DiffPatcher2(options) {
    classCallCheck(this, DiffPatcher2);
    this.processor = new Processor(options);
    this.processor.pipe(new Pipe("diff").append(collectChildrenDiffFilter, diffFilter, diffFilter$2, diffFilter$3, objectsDiffFilter, diffFilter$1).shouldHaveResult());
    this.processor.pipe(new Pipe("patch").append(collectChildrenPatchFilter, collectChildrenPatchFilter$1, patchFilter, patchFilter$3, patchFilter$1, patchFilter$2).shouldHaveResult());
    this.processor.pipe(new Pipe("reverse").append(collectChildrenReverseFilter, collectChildrenReverseFilter$1, reverseFilter, reverseFilter$3, reverseFilter$1, reverseFilter$2).shouldHaveResult());
  }
  createClass(DiffPatcher2, [{
    key: "options",
    value: function options() {
      var _processor;
      return (_processor = this.processor).options.apply(_processor, arguments);
    }
  }, {
    key: "diff",
    value: function diff2(left, right) {
      return this.processor.process(new DiffContext(left, right));
    }
  }, {
    key: "patch",
    value: function patch2(left, delta) {
      return this.processor.process(new PatchContext(left, delta));
    }
  }, {
    key: "reverse",
    value: function reverse2(delta) {
      return this.processor.process(new ReverseContext(delta));
    }
  }, {
    key: "unpatch",
    value: function unpatch2(right, delta) {
      return this.patch(right, this.reverse(delta));
    }
  }, {
    key: "clone",
    value: function clone$$1(value) {
      return clone2(value);
    }
  }]);
  return DiffPatcher2;
}();
var isArray$3 = typeof Array.isArray === "function" ? Array.isArray : function(a2) {
  return a2 instanceof Array;
};
var getObjectKeys = typeof Object.keys === "function" ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var names2 = [];
  for (var property2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property2)) {
      names2.push(property2);
    }
  }
  return names2;
};
var trimUnderscore = function trimUnderscore2(str) {
  if (str.substr(0, 1) === "_") {
    return str.slice(1);
  }
  return str;
};
var arrayKeyToSortNumber = function arrayKeyToSortNumber2(key2) {
  if (key2 === "_t") {
    return -1;
  } else {
    if (key2.substr(0, 1) === "_") {
      return parseInt(key2.slice(1), 10);
    } else {
      return parseInt(key2, 10) + 0.1;
    }
  }
};
var arrayKeyComparer = function arrayKeyComparer2(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};
var BaseFormatter = function() {
  function BaseFormatter2() {
    classCallCheck(this, BaseFormatter2);
  }
  createClass(BaseFormatter2, [{
    key: "format",
    value: function format5(delta, left) {
      var context2 = {};
      this.prepareContext(context2);
      this.recurse(context2, delta, left);
      return this.finalize(context2);
    }
  }, {
    key: "prepareContext",
    value: function prepareContext(context2) {
      context2.buffer = [];
      context2.out = function() {
        var _buffer;
        (_buffer = this.buffer).push.apply(_buffer, arguments);
      };
    }
  }, {
    key: "typeFormattterNotFound",
    value: function typeFormattterNotFound(context2, deltaType) {
      throw new Error("cannot format delta type: " + deltaType);
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context2, err) {
      return err.toString();
    }
  }, {
    key: "finalize",
    value: function finalize(_ref) {
      var buffer2 = _ref.buffer;
      if (isArray$3(buffer2)) {
        return buffer2.join("");
      }
    }
  }, {
    key: "recurse",
    value: function recurse(context2, delta, left, key2, leftKey, movedFrom, isLast) {
      var useMoveOriginHere = delta && movedFrom;
      var leftValue = useMoveOriginHere ? movedFrom.value : left;
      if (typeof delta === "undefined" && typeof key2 === "undefined") {
        return void 0;
      }
      var type4 = this.getDeltaType(delta, movedFrom);
      var nodeType = type4 === "node" ? delta._t === "a" ? "array" : "object" : "";
      if (typeof key2 !== "undefined") {
        this.nodeBegin(context2, key2, leftKey, type4, nodeType, isLast);
      } else {
        this.rootBegin(context2, type4, nodeType);
      }
      var typeFormattter = void 0;
      try {
        typeFormattter = this["format_" + type4] || this.typeFormattterNotFound(context2, type4);
        typeFormattter.call(this, context2, delta, leftValue, key2, leftKey, movedFrom);
      } catch (err) {
        this.typeFormattterErrorFormatter(context2, err, delta, leftValue, key2, leftKey, movedFrom);
        if (typeof console !== "undefined" && console.error) {
          console.error(err.stack);
        }
      }
      if (typeof key2 !== "undefined") {
        this.nodeEnd(context2, key2, leftKey, type4, nodeType, isLast);
      } else {
        this.rootEnd(context2, type4, nodeType);
      }
    }
  }, {
    key: "formatDeltaChildren",
    value: function formatDeltaChildren(context2, delta, left) {
      var self2 = this;
      this.forEachDeltaKey(delta, left, function(key2, leftKey, movedFrom, isLast) {
        self2.recurse(context2, delta[key2], left ? left[leftKey] : void 0, key2, leftKey, movedFrom, isLast);
      });
    }
  }, {
    key: "forEachDeltaKey",
    value: function forEachDeltaKey(delta, left, fn) {
      var keys2 = getObjectKeys(delta);
      var arrayKeys = delta._t === "a";
      var moveDestinations = {};
      var name2 = void 0;
      if (typeof left !== "undefined") {
        for (name2 in left) {
          if (Object.prototype.hasOwnProperty.call(left, name2)) {
            if (typeof delta[name2] === "undefined" && (!arrayKeys || typeof delta["_" + name2] === "undefined")) {
              keys2.push(name2);
            }
          }
        }
      }
      for (name2 in delta) {
        if (Object.prototype.hasOwnProperty.call(delta, name2)) {
          var value = delta[name2];
          if (isArray$3(value) && value[2] === 3) {
            moveDestinations[value[1].toString()] = {
              key: name2,
              value: left && left[parseInt(name2.substr(1))]
            };
            if (this.includeMoveDestinations !== false) {
              if (typeof left === "undefined" && typeof delta[value[1]] === "undefined") {
                keys2.push(value[1].toString());
              }
            }
          }
        }
      }
      if (arrayKeys) {
        keys2.sort(arrayKeyComparer);
      } else {
        keys2.sort();
      }
      for (var index2 = 0, length = keys2.length; index2 < length; index2++) {
        var key2 = keys2[index2];
        if (arrayKeys && key2 === "_t") {
          continue;
        }
        var leftKey = arrayKeys ? typeof key2 === "number" ? key2 : parseInt(trimUnderscore(key2), 10) : key2;
        var isLast = index2 === length - 1;
        fn(key2, leftKey, moveDestinations[leftKey], isLast);
      }
    }
  }, {
    key: "getDeltaType",
    value: function getDeltaType(delta, movedFrom) {
      if (typeof delta === "undefined") {
        if (typeof movedFrom !== "undefined") {
          return "movedestination";
        }
        return "unchanged";
      }
      if (isArray$3(delta)) {
        if (delta.length === 1) {
          return "added";
        }
        if (delta.length === 2) {
          return "modified";
        }
        if (delta.length === 3 && delta[2] === 0) {
          return "deleted";
        }
        if (delta.length === 3 && delta[2] === 2) {
          return "textdiff";
        }
        if (delta.length === 3 && delta[2] === 3) {
          return "moved";
        }
      } else if ((typeof delta === "undefined" ? "undefined" : _typeof(delta)) === "object") {
        return "node";
      }
      return "unknown";
    }
  }, {
    key: "parseTextDiff",
    value: function parseTextDiff(value) {
      var output = [];
      var lines = value.split("\n@@ ");
      for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        var line2 = lines[i2];
        var lineOutput = {
          pieces: []
        };
        var location2 = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line2).slice(1);
        lineOutput.location = {
          line: location2[0],
          chr: location2[1]
        };
        var pieces = line2.split("\n").slice(1);
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          if (!piece.length) {
            continue;
          }
          var pieceOutput = {
            type: "context"
          };
          if (piece.substr(0, 1) === "+") {
            pieceOutput.type = "added";
          } else if (piece.substr(0, 1) === "-") {
            pieceOutput.type = "deleted";
          }
          pieceOutput.text = piece.slice(1);
          lineOutput.pieces.push(pieceOutput);
        }
        output.push(lineOutput);
      }
      return output;
    }
  }]);
  return BaseFormatter2;
}();
var base = Object.freeze({
  default: BaseFormatter
});
var HtmlFormatter = function(_BaseFormatter) {
  inherits(HtmlFormatter2, _BaseFormatter);
  function HtmlFormatter2() {
    classCallCheck(this, HtmlFormatter2);
    return possibleConstructorReturn(this, (HtmlFormatter2.__proto__ || Object.getPrototypeOf(HtmlFormatter2)).apply(this, arguments));
  }
  createClass(HtmlFormatter2, [{
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context2, err) {
      context2.out('<pre class="jsondiffpatch-error">' + err + "</pre>");
    }
  }, {
    key: "formatValue",
    value: function formatValue2(context2, value) {
      context2.out("<pre>" + htmlEscape(JSON.stringify(value, null, 2)) + "</pre>");
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context2, value) {
      var lines = this.parseTextDiff(value);
      context2.out('<ul class="jsondiffpatch-textdiff">');
      for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        var line2 = lines[i2];
        context2.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line2.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line2.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line2.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context2.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + htmlEscape(decodeURI(piece.text)) + "</span>");
        }
        context2.out("</div></li>");
      }
      context2.out("</ul>");
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context2, type4, nodeType) {
      var nodeClass = "jsondiffpatch-" + type4 + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
      context2.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context2) {
      context2.out("</div>" + (context2.hasArrows ? '<script type="text/javascript">setTimeout(' + (adjustArrows.toString() + ",10);<\/script>") : ""));
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context2, key2, leftKey, type4, nodeType) {
      var nodeClass = "jsondiffpatch-" + type4 + (nodeType ? " jsondiffpatch-child-node-type-" + nodeType : "");
      context2.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' + ('<div class="jsondiffpatch-property-name">' + leftKey + "</div>"));
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context2) {
      context2.out("</li>");
    }
  }, {
    key: "format_unchanged",
    value: function format_unchanged(context2, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      context2.out('<div class="jsondiffpatch-value">');
      this.formatValue(context2, left);
      context2.out("</div>");
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination(context2, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      context2.out('<div class="jsondiffpatch-value">');
      this.formatValue(context2, left);
      context2.out("</div>");
    }
  }, {
    key: "format_node",
    value: function format_node(context2, delta, left) {
      var nodeType = delta._t === "a" ? "array" : "object";
      context2.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
      this.formatDeltaChildren(context2, delta, left);
      context2.out("</ul>");
    }
  }, {
    key: "format_added",
    value: function format_added(context2, delta) {
      context2.out('<div class="jsondiffpatch-value">');
      this.formatValue(context2, delta[0]);
      context2.out("</div>");
    }
  }, {
    key: "format_modified",
    value: function format_modified(context2, delta) {
      context2.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
      this.formatValue(context2, delta[0]);
      context2.out('</div><div class="jsondiffpatch-value jsondiffpatch-right-value">');
      this.formatValue(context2, delta[1]);
      context2.out("</div>");
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context2, delta) {
      context2.out('<div class="jsondiffpatch-value">');
      this.formatValue(context2, delta[0]);
      context2.out("</div>");
    }
  }, {
    key: "format_moved",
    value: function format_moved(context2, delta) {
      context2.out('<div class="jsondiffpatch-value">');
      this.formatValue(context2, delta[0]);
      context2.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + "</div>");
      context2.out(
        '<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\n          <svg width="30" height="60" style="position: absolute; display: none;">\n          <defs>\n              <marker id="markerArrow" markerWidth="8" markerHeight="8"\n                 refx="2" refy="4"\n                     orient="auto" markerUnits="userSpaceOnUse">\n                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\n              </marker>\n          </defs>\n          <path d="M30,0 Q-10,25 26,50"\n            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"\n          ></path>\n          </svg>\n      </div>'
      );
      context2.hasArrows = true;
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff(context2, delta) {
      context2.out('<div class="jsondiffpatch-value">');
      this.formatTextDiffString(context2, delta[0]);
      context2.out("</div>");
    }
  }]);
  return HtmlFormatter2;
}(BaseFormatter);
function htmlEscape(text) {
  var html2 = text;
  var replacements = [[/&/g, "&amp;"], [/</g, "&lt;"], [/>/g, "&gt;"], [/'/g, "&apos;"], [/"/g, "&quot;"]];
  for (var i2 = 0; i2 < replacements.length; i2++) {
    html2 = html2.replace(replacements[i2][0], replacements[i2][1]);
  }
  return html2;
}
var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  var node = nodeArg || document;
  var getElementText = function getElementText2(_ref) {
    var textContent = _ref.textContent, innerText = _ref.innerText;
    return textContent || innerText;
  };
  var eachByQuery = function eachByQuery2(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i2 = 0, l2 = elems.length; i2 < l2; i2++) {
      fn(elems[i2]);
    }
  };
  var eachChildren = function eachChildren2(_ref2, fn) {
    var children = _ref2.children;
    for (var i2 = 0, l2 = children.length; i2 < l2; i2++) {
      fn(children[i2], i2);
    }
  };
  eachByQuery(node, ".jsondiffpatch-arrow", function(_ref3) {
    var parentNode = _ref3.parentNode, children = _ref3.children, style2 = _ref3.style;
    var arrowParent = parentNode;
    var svg = children[0];
    var path2 = svg.children[1];
    svg.style.display = "none";
    var destination = getElementText(arrowParent.querySelector(".jsondiffpatch-moved-destination"));
    var container = arrowParent.parentNode;
    var destinationElem = void 0;
    eachChildren(container, function(child) {
      if (child.getAttribute("data-key") === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute("height", Math.abs(distance) + 6);
      style2.top = -8 + (distance > 0 ? 0 : distance) + "px";
      var curve = distance > 0 ? "M30,0 Q-10," + Math.round(distance / 2) + " 26," + (distance - 4) : "M30," + -distance + " Q-10," + Math.round(-distance / 2) + " 26,4";
      path2.setAttribute("d", curve);
      svg.style.display = "";
    } catch (err) {
    }
  });
};
var showUnchanged = function showUnchanged2(show, node, delay) {
  var el = node || document.body;
  var prefix = "jsondiffpatch-unchanged-";
  var classes = {
    showing: prefix + "showing",
    hiding: prefix + "hiding",
    visible: prefix + "visible",
    hidden: prefix + "hidden"
  };
  var list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(function() {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  var intervalId = setInterval(function() {
    adjustArrows(el);
  }, 100);
  setTimeout(function() {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(function() {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};
var hideUnchanged = function hideUnchanged2(node, delay) {
  return showUnchanged(false, node, delay);
};
var defaultInstance = void 0;
function format2(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
}
var html = Object.freeze({
  showUnchanged,
  hideUnchanged,
  default: HtmlFormatter,
  format: format2
});
var AnnotatedFormatter = function(_BaseFormatter) {
  inherits(AnnotatedFormatter2, _BaseFormatter);
  function AnnotatedFormatter2() {
    classCallCheck(this, AnnotatedFormatter2);
    var _this = possibleConstructorReturn(this, (AnnotatedFormatter2.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2)).call(this));
    _this.includeMoveDestinations = false;
    return _this;
  }
  createClass(AnnotatedFormatter2, [{
    key: "prepareContext",
    value: function prepareContext(context2) {
      get(AnnotatedFormatter2.prototype.__proto__ || Object.getPrototypeOf(AnnotatedFormatter2.prototype), "prepareContext", this).call(this, context2);
      context2.indent = function(levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join("&nbsp;&nbsp;");
      };
      context2.row = function(json, htmlNote) {
        context2.out('<tr><td style="white-space: nowrap;"><pre class="jsondiffpatch-annotated-indent" style="display: inline-block">');
        context2.out(context2.indentPad);
        context2.out('</pre><pre style="display: inline-block">');
        context2.out(json);
        context2.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
        context2.out(htmlNote);
        context2.out("</div></td></tr>");
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context2, err) {
      context2.row("", '<pre class="jsondiffpatch-error">' + err + "</pre>");
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context2, value) {
      var lines = this.parseTextDiff(value);
      context2.out('<ul class="jsondiffpatch-textdiff">');
      for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        var line2 = lines[i2];
        context2.out('<li><div class="jsondiffpatch-textdiff-location">' + ('<span class="jsondiffpatch-textdiff-line-number">' + line2.location.line + '</span><span class="jsondiffpatch-textdiff-char">' + line2.location.chr + '</span></div><div class="jsondiffpatch-textdiff-line">'));
        var pieces = line2.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context2.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' + piece.text + "</span>");
        }
        context2.out("</div></li>");
      }
      context2.out("</ul>");
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context2, type4, nodeType) {
      context2.out('<table class="jsondiffpatch-annotated-delta">');
      if (type4 === "node") {
        context2.row("{");
        context2.indent();
      }
      if (nodeType === "array") {
        context2.row('"_t": "a",', "Array delta (member names indicate array indices)");
      }
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context2, type4) {
      if (type4 === "node") {
        context2.indent(-1);
        context2.row("}");
      }
      context2.out("</table>");
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context2, key2, leftKey, type4, nodeType) {
      context2.row("&quot;" + key2 + "&quot;: {");
      if (type4 === "node") {
        context2.indent();
      }
      if (nodeType === "array") {
        context2.row('"_t": "a",', "Array delta (member names indicate array indices)");
      }
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context2, key2, leftKey, type4, nodeType, isLast) {
      if (type4 === "node") {
        context2.indent(-1);
      }
      context2.row("}" + (isLast ? "" : ","));
    }
  }, {
    key: "format_unchanged",
    value: function format_unchanged() {
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination() {
    }
  }, {
    key: "format_node",
    value: function format_node(context2, delta, left) {
      this.formatDeltaChildren(context2, delta, left);
    }
  }]);
  return AnnotatedFormatter2;
}(BaseFormatter);
var wrapPropertyName = function wrapPropertyName2(name2) {
  return '<pre style="display:inline-block">&quot;' + name2 + "&quot;</pre>";
};
var deltaAnnotations = {
  added: function added(delta, left, key2, leftKey) {
    var formatLegend = " <pre>([newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return "new value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "insert at index " + leftKey + formatLegend;
    }
    return "add property " + wrapPropertyName(leftKey) + formatLegend;
  },
  modified: function modified(delta, left, key2, leftKey) {
    var formatLegend = " <pre>([previousValue, newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return "modify value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "modify at index " + leftKey + formatLegend;
    }
    return "modify property " + wrapPropertyName(leftKey) + formatLegend;
  },
  deleted: function deleted(delta, left, key2, leftKey) {
    var formatLegend = " <pre>([previousValue, 0, 0])</pre>";
    if (typeof leftKey === "undefined") {
      return "delete value" + formatLegend;
    }
    if (typeof leftKey === "number") {
      return "remove index " + leftKey + formatLegend;
    }
    return "delete property " + wrapPropertyName(leftKey) + formatLegend;
  },
  moved: function moved(delta, left, key2, leftKey) {
    return 'move from <span title="(position to remove at original state)">' + ("index " + leftKey + '</span> to <span title="(position to insert at final') + (' state)">index ' + delta[1] + "</span>");
  },
  textdiff: function textdiff(delta, left, key2, leftKey) {
    var location2 = typeof leftKey === "undefined" ? "" : typeof leftKey === "number" ? " at index " + leftKey : " at property " + wrapPropertyName(leftKey);
    return "text diff" + location2 + ', format is <a href="https://code.google.com/p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>';
  }
};
var formatAnyChange = function formatAnyChange2(context2, delta) {
  var deltaType = this.getDeltaType(delta);
  var annotator = deltaAnnotations[deltaType];
  var htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  var json = JSON.stringify(delta, null, 2);
  if (deltaType === "textdiff") {
    json = json.split("\\n").join('\\n"+\n   "');
  }
  context2.indent();
  context2.row(json, htmlNote);
  context2.indent(-1);
};
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var defaultInstance$1 = void 0;
function format$1(delta, left) {
  if (!defaultInstance$1) {
    defaultInstance$1 = new AnnotatedFormatter();
  }
  return defaultInstance$1.format(delta, left);
}
var annotated = Object.freeze({
  default: AnnotatedFormatter,
  format: format$1
});
var OPERATIONS = {
  add: "add",
  remove: "remove",
  replace: "replace",
  move: "move"
};
var JSONFormatter = function(_BaseFormatter) {
  inherits(JSONFormatter2, _BaseFormatter);
  function JSONFormatter2() {
    classCallCheck(this, JSONFormatter2);
    var _this = possibleConstructorReturn(this, (JSONFormatter2.__proto__ || Object.getPrototypeOf(JSONFormatter2)).call(this));
    _this.includeMoveDestinations = true;
    return _this;
  }
  createClass(JSONFormatter2, [{
    key: "prepareContext",
    value: function prepareContext(context2) {
      get(JSONFormatter2.prototype.__proto__ || Object.getPrototypeOf(JSONFormatter2.prototype), "prepareContext", this).call(this, context2);
      context2.result = [];
      context2.path = [];
      context2.pushCurrentOp = function(obj) {
        var op = obj.op, value = obj.value;
        var val = {
          op,
          path: this.currentPath()
        };
        if (typeof value !== "undefined") {
          val.value = value;
        }
        this.result.push(val);
      };
      context2.pushMoveOp = function(to) {
        var from = this.currentPath();
        this.result.push({
          op: OPERATIONS.move,
          from,
          path: this.toPath(to)
        });
      };
      context2.currentPath = function() {
        return "/" + this.path.join("/");
      };
      context2.toPath = function(toPath) {
        var to = this.path.slice();
        to[to.length - 1] = toPath;
        return "/" + to.join("/");
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context2, err) {
      context2.out("[ERROR] " + err);
    }
  }, {
    key: "rootBegin",
    value: function rootBegin() {
    }
  }, {
    key: "rootEnd",
    value: function rootEnd() {
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(_ref, key2, leftKey) {
      var path2 = _ref.path;
      path2.push(leftKey);
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(_ref2) {
      var path2 = _ref2.path;
      path2.pop();
    }
  }, {
    key: "format_unchanged",
    value: function format_unchanged() {
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination() {
    }
  }, {
    key: "format_node",
    value: function format_node(context2, delta, left) {
      this.formatDeltaChildren(context2, delta, left);
    }
  }, {
    key: "format_added",
    value: function format_added(context2, delta) {
      context2.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
    }
  }, {
    key: "format_modified",
    value: function format_modified(context2, delta) {
      context2.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context2) {
      context2.pushCurrentOp({ op: OPERATIONS.remove });
    }
  }, {
    key: "format_moved",
    value: function format_moved(context2, delta) {
      var to = delta[1];
      context2.pushMoveOp(to);
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff() {
      throw new Error("Not implemented");
    }
  }, {
    key: "format",
    value: function format5(delta, left) {
      var context2 = {};
      this.prepareContext(context2);
      this.recurse(context2, delta, left);
      return context2.result;
    }
  }]);
  return JSONFormatter2;
}(BaseFormatter);
var last = function last2(arr) {
  return arr[arr.length - 1];
};
var sortBy = function sortBy2(arr, pred) {
  arr.sort(pred);
  return arr;
};
var compareByIndexDesc = function compareByIndexDesc2(indexA, indexB) {
  var lastA = parseInt(indexA, 10);
  var lastB = parseInt(indexB, 10);
  if (!(isNaN(lastA) || isNaN(lastB))) {
    return lastB - lastA;
  } else {
    return 0;
  }
};
var opsByDescendingOrder = function opsByDescendingOrder2(removeOps) {
  return sortBy(removeOps, function(a2, b2) {
    var splitA = a2.path.split("/");
    var splitB = b2.path.split("/");
    if (splitA.length !== splitB.length) {
      return splitA.length - splitB.length;
    } else {
      return compareByIndexDesc(last(splitA), last(splitB));
    }
  });
};
var partitionOps = function partitionOps2(arr, fns) {
  var initArr = Array(fns.length + 1).fill().map(function() {
    return [];
  });
  return arr.map(function(item) {
    var position = fns.map(function(fn) {
      return fn(item);
    }).indexOf(true);
    if (position < 0) {
      position = fns.length;
    }
    return { item, position };
  }).reduce(function(acc, item) {
    acc[item.position].push(item.item);
    return acc;
  }, initArr);
};
var isMoveOp = function isMoveOp2(_ref3) {
  var op = _ref3.op;
  return op === "move";
};
var isRemoveOp = function isRemoveOp2(_ref4) {
  var op = _ref4.op;
  return op === "remove";
};
var reorderOps = function reorderOps2(diff2) {
  var _partitionOps = partitionOps(diff2, [isMoveOp, isRemoveOp]), _partitionOps2 = slicedToArray(_partitionOps, 3), moveOps = _partitionOps2[0], removedOps = _partitionOps2[1], restOps = _partitionOps2[2];
  var removeOpsReverse = opsByDescendingOrder(removedOps);
  return [].concat(toConsumableArray(removeOpsReverse), toConsumableArray(moveOps), toConsumableArray(restOps));
};
var defaultInstance$2 = void 0;
var format$2 = function format3(delta, left) {
  if (!defaultInstance$2) {
    defaultInstance$2 = new JSONFormatter();
  }
  return reorderOps(defaultInstance$2.format(delta, left));
};
var log = function log2(delta, left) {
  console.log(format$2(delta, left));
};
var jsonpatch = Object.freeze({
  default: JSONFormatter,
  partitionOps,
  format: format$2,
  log
});
function chalkColor(name2) {
  return chalk && chalk[name2] || function() {
    for (var _len = arguments.length, args2 = Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }
    return args2;
  };
}
var colors = {
  added: chalkColor("green"),
  deleted: chalkColor("red"),
  movedestination: chalkColor("gray"),
  moved: chalkColor("yellow"),
  unchanged: chalkColor("gray"),
  error: chalkColor("white.bgRed"),
  textDiffLine: chalkColor("gray")
};
var ConsoleFormatter = function(_BaseFormatter) {
  inherits(ConsoleFormatter2, _BaseFormatter);
  function ConsoleFormatter2() {
    classCallCheck(this, ConsoleFormatter2);
    var _this = possibleConstructorReturn(this, (ConsoleFormatter2.__proto__ || Object.getPrototypeOf(ConsoleFormatter2)).call(this));
    _this.includeMoveDestinations = false;
    return _this;
  }
  createClass(ConsoleFormatter2, [{
    key: "prepareContext",
    value: function prepareContext(context2) {
      get(ConsoleFormatter2.prototype.__proto__ || Object.getPrototypeOf(ConsoleFormatter2.prototype), "prepareContext", this).call(this, context2);
      context2.indent = function(levels) {
        this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
        this.indentPad = new Array(this.indentLevel + 1).join("  ");
        this.outLine();
      };
      context2.outLine = function() {
        this.buffer.push("\n" + (this.indentPad || ""));
      };
      context2.out = function() {
        for (var _len2 = arguments.length, args2 = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args2[_key2] = arguments[_key2];
        }
        for (var i2 = 0, l2 = args2.length; i2 < l2; i2++) {
          var lines = args2[i2].split("\n");
          var text = lines.join("\n" + (this.indentPad || ""));
          if (this.color && this.color[0]) {
            text = this.color[0](text);
          }
          this.buffer.push(text);
        }
      };
      context2.pushColor = function(color) {
        this.color = this.color || [];
        this.color.unshift(color);
      };
      context2.popColor = function() {
        this.color = this.color || [];
        this.color.shift();
      };
    }
  }, {
    key: "typeFormattterErrorFormatter",
    value: function typeFormattterErrorFormatter(context2, err) {
      context2.pushColor(colors.error);
      context2.out("[ERROR]" + err);
      context2.popColor();
    }
  }, {
    key: "formatValue",
    value: function formatValue2(context2, value) {
      context2.out(JSON.stringify(value, null, 2));
    }
  }, {
    key: "formatTextDiffString",
    value: function formatTextDiffString(context2, value) {
      var lines = this.parseTextDiff(value);
      context2.indent();
      for (var i2 = 0, l2 = lines.length; i2 < l2; i2++) {
        var line2 = lines[i2];
        context2.pushColor(colors.textDiffLine);
        context2.out(line2.location.line + "," + line2.location.chr + " ");
        context2.popColor();
        var pieces = line2.pieces;
        for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
          var piece = pieces[pieceIndex];
          context2.pushColor(colors[piece.type]);
          context2.out(piece.text);
          context2.popColor();
        }
        if (i2 < l2 - 1) {
          context2.outLine();
        }
      }
      context2.indent(-1);
    }
  }, {
    key: "rootBegin",
    value: function rootBegin(context2, type4, nodeType) {
      context2.pushColor(colors[type4]);
      if (type4 === "node") {
        context2.out(nodeType === "array" ? "[" : "{");
        context2.indent();
      }
    }
  }, {
    key: "rootEnd",
    value: function rootEnd(context2, type4, nodeType) {
      if (type4 === "node") {
        context2.indent(-1);
        context2.out(nodeType === "array" ? "]" : "}");
      }
      context2.popColor();
    }
  }, {
    key: "nodeBegin",
    value: function nodeBegin(context2, key2, leftKey, type4, nodeType) {
      context2.pushColor(colors[type4]);
      context2.out(leftKey + ": ");
      if (type4 === "node") {
        context2.out(nodeType === "array" ? "[" : "{");
        context2.indent();
      }
    }
  }, {
    key: "nodeEnd",
    value: function nodeEnd(context2, key2, leftKey, type4, nodeType, isLast) {
      if (type4 === "node") {
        context2.indent(-1);
        context2.out(nodeType === "array" ? "]" : "}" + (isLast ? "" : ","));
      }
      if (!isLast) {
        context2.outLine();
      }
      context2.popColor();
    }
  }, {
    key: "format_unchanged",
    value: function format_unchanged(context2, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      this.formatValue(context2, left);
    }
  }, {
    key: "format_movedestination",
    value: function format_movedestination(context2, delta, left) {
      if (typeof left === "undefined") {
        return;
      }
      this.formatValue(context2, left);
    }
  }, {
    key: "format_node",
    value: function format_node(context2, delta, left) {
      this.formatDeltaChildren(context2, delta, left);
    }
  }, {
    key: "format_added",
    value: function format_added(context2, delta) {
      this.formatValue(context2, delta[0]);
    }
  }, {
    key: "format_modified",
    value: function format_modified(context2, delta) {
      context2.pushColor(colors.deleted);
      this.formatValue(context2, delta[0]);
      context2.popColor();
      context2.out(" => ");
      context2.pushColor(colors.added);
      this.formatValue(context2, delta[1]);
      context2.popColor();
    }
  }, {
    key: "format_deleted",
    value: function format_deleted(context2, delta) {
      this.formatValue(context2, delta[0]);
    }
  }, {
    key: "format_moved",
    value: function format_moved(context2, delta) {
      context2.out("==> " + delta[1]);
    }
  }, {
    key: "format_textdiff",
    value: function format_textdiff(context2, delta) {
      this.formatTextDiffString(context2, delta[0]);
    }
  }]);
  return ConsoleFormatter2;
}(BaseFormatter);
var defaultInstance$3 = void 0;
var format$3 = function format4(delta, left) {
  if (!defaultInstance$3) {
    defaultInstance$3 = new ConsoleFormatter();
  }
  return defaultInstance$3.format(delta, left);
};
function log$1(delta, left) {
  console.log(format$3(delta, left));
}
var console$1 = Object.freeze({
  default: ConsoleFormatter,
  format: format$3,
  log: log$1
});
var index = Object.freeze({
  base,
  html,
  annotated,
  jsonpatch,
  console: console$1
});
function dateReviver(key2, value) {
  var parts = void 0;
  if (typeof value === "string") {
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
}
function create(options) {
  return new DiffPatcher(options);
}
var defaultInstance$4 = void 0;
function diff() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.diff.apply(defaultInstance$4, arguments);
}
function patch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.patch.apply(defaultInstance$4, arguments);
}
function unpatch() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.unpatch.apply(defaultInstance$4, arguments);
}
function reverse() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.reverse.apply(defaultInstance$4, arguments);
}
function clone$1() {
  if (!defaultInstance$4) {
    defaultInstance$4 = new DiffPatcher();
  }
  return defaultInstance$4.clone.apply(defaultInstance$4, arguments);
}
const jsondiffpatch = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DiffPatcher,
  formatters: index,
  console: console$1,
  create,
  dateReviver,
  diff,
  patch,
  unpatch,
  reverse,
  clone: clone$1
}, Symbol.toStringTag, { value: "Module" }));
const DialogShowApiModify = defineComponent({
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  setup() {
    return {
      State_App: _State_App
    };
  },
  computed: {
    propDiffView() {
      var _a2;
      return ((_a2 = this.propDialogOptions) == null ? void 0 : _a2.diffView) || [];
    },
    vDomContentItem() {
      if (this.propDiffView.length === 0) {
        return createVNode(resolveComponent("ErrMsg"), {
          "type": "noChange"
        }, null);
      } else {
        return xU.map(this.propDiffView, (item, index2) => {
          if (!item.content) {
            return null;
          }
          return createVNode("div", {
            "class": "item-content"
          }, [createVNode("h3", {
            "class": "title"
          }, [item.title]), createVNode("div", {
            "innerHTML": item.content
          }, null)]);
        });
      }
    }
  },
  render() {
    return createVNode("div", {
      "class": "flex vertical flex1",
      "id": "ViewApiModify"
    }, [createVNode("div", {
      "class": "padding20"
    }, [createVNode(resolveComponent("aAlert"), {
      "message": this.$t("\u6CE8\uFF1A \u7EFF\u8272\u4EE3\u8868\u65B0\u589E\u5185\u5BB9\uFF0C\u7EA2\u8272\u4EE3\u8868\u5220\u9664\u5185\u5BB9").label,
      "type": "info",
      "closable": true,
      "className": "width100"
    }, null)]), createVNode("div", {
      "class": "project-interface-change-content flex1 padding20"
    }, [this.vDomContentItem])]);
  }
});
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse2 = function parse3(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name2, reviver) {
  const value = holder[name2];
  if (value != null && typeof value === "object") {
    for (const key2 in value) {
      const replacement = internalize(value, key2, reviver);
      if (replacement === void 0) {
        delete value[key2];
      } else {
        value[key2] = replacement;
      }
    }
  }
  return reviver.call(holder, name2, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u2 = unicodeEscape();
    switch (u2) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u2)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u2;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u2 = unicodeEscape();
    switch (u2) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util.isIdContinueChar(u2)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u2;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape$1();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type4, value) {
  return {
    type: type4,
    value,
    line,
    column
  };
}
function literal(s2) {
  for (const c2 of s2) {
    const p2 = peek();
    if (p2 !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape$1() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent2 = stack[stack.length - 1];
    if (Array.isArray(parent2)) {
      parent2.push(value);
    } else {
      parent2[key] = value;
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current2 = stack[stack.length - 1];
    if (current2 == null) {
      parseState = "end";
    } else if (Array.isArray(current2)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current2 = stack[stack.length - 1];
  if (current2 == null) {
    parseState = "end";
  } else if (Array.isArray(current2)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message2) {
  const err = new SyntaxError(message2);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify2 = function stringify3(value, replacer2, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote2;
  if (replacer2 != null && typeof replacer2 === "object" && !Array.isArray(replacer2)) {
    space = replacer2.space;
    quote2 = replacer2.quote;
    replacer2 = replacer2.replacer;
  }
  if (typeof replacer2 === "function") {
    replacerFunc = replacer2;
  } else if (Array.isArray(replacer2)) {
    propertyList = [];
    for (const v2 of replacer2) {
      let item;
      if (typeof v2 === "string") {
        item = v2;
      } else if (typeof v2 === "number" || v2 instanceof String || v2 instanceof Number) {
        item = String(v2);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i2 = 0; i2 < value2.length; i2++) {
      const c2 = value2[i2];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value2[i2 + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote2 || Object.keys(quotes).reduce((a2, b2) => quotes[a2] < quotes[b2] ? a2 : b2);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys2 = propertyList || Object.keys(value2);
    let partial = [];
    for (const key2 of keys2) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial.push(member);
      }
    }
    let final;
    if (partial.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i2 = firstChar.length; i2 < key2.length; i2++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i2)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial = [];
    for (let i2 = 0; i2 < value2.length; i2++) {
      const propertyString = serializeProperty(String(i2), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
const JSON5 = {
  parse: parse2,
  stringify: stringify2
};
var lib = JSON5;
const diffMessage = function(jsondiffpatch2, formattersHtml2, curDiffData) {
  const json5_parse = (json) => {
    if (typeof json === "object" && json)
      return json;
    try {
      return lib.parse(json);
    } catch (err) {
      return json;
    }
  };
  const diffText = (left, right) => {
    left = left || "";
    right = right || "";
    if (left == right) {
      return null;
    }
    var delta = jsondiffpatch2.diff(left, right);
    let result = formattersHtml2.format(delta, left);
    return result;
  };
  const diffJson = (left, right) => {
    left = json5_parse(left);
    right = json5_parse(right);
    let delta = jsondiffpatch2.diff(left, right);
    return formattersHtml2.format(delta, left);
  };
  const valueMaps = {
    1: "\u5FC5\u9700",
    0: "\u975E\u5FC5\u9700",
    text: "\u6587\u672C",
    file: "\u6587\u4EF6",
    undone: "\u672A\u5B8C\u6210",
    done: "\u5DF2\u5B8C\u6210"
  };
  const handleParams = (item) => {
    let newItem = Object.assign({}, item);
    newItem._id = void 0;
    Object.keys(newItem).forEach((key2) => {
      switch (key2) {
        case "required":
          newItem[key2] = valueMaps[newItem[key2]];
          break;
        case "type":
          newItem[key2] = valueMaps[newItem[key2]];
          break;
      }
    });
    return newItem;
  };
  const diffArray = (arr1, arr2) => {
    arr1 = arr1 || [];
    arr2 = arr2 || [];
    arr1 = arr1.map(handleParams);
    arr2 = arr2.map(handleParams);
    return diffJson(arr1, arr2);
  };
  let diffView = [];
  if (curDiffData && typeof curDiffData === "object" && curDiffData.current) {
    const {
      current: current2,
      old,
      type: type4
    } = curDiffData;
    if (type4 === "wiki") {
      if (current2 != old) {
        diffView.push({
          title: "wiki\u66F4\u65B0",
          content: diffText(old, current2)
        });
      }
      return diffView = diffView.filter((item) => item.content);
    }
    if (current2.path != old.path) {
      diffView.push({
        title: "Api \u8DEF\u5F84",
        content: diffText(old.path, current2.path)
      });
    }
    if (current2.title != old.title) {
      diffView.push({
        title: "Api \u540D\u79F0",
        content: diffText(old.title, current2.title)
      });
    }
    if (current2.method != old.method) {
      diffView.push({
        title: "Method",
        content: diffText(old.method, current2.method)
      });
    }
    if (current2.catid != old.catid) {
      diffView.push({
        title: "\u5206\u7C7B id",
        content: diffText(old.catid, current2.catid)
      });
    }
    if (current2.status != old.status) {
      diffView.push({
        title: "\u63A5\u53E3\u72B6\u6001",
        content: diffText(valueMaps[old.status], valueMaps[current2.status])
      });
    }
    if (current2.tag !== old.tag) {
      diffView.push({
        title: "\u63A5\u53E3tag",
        content: diffText(old.tag, current2.tag)
      });
    }
    diffView.push({
      title: "Request Path Params",
      content: diffArray(old.req_params, current2.req_params)
    });
    diffView.push({
      title: "Request Query",
      content: diffArray(old.req_query, current2.req_query)
    });
    diffView.push({
      title: "Request Header",
      content: diffArray(old.req_headers, current2.req_headers)
    });
    let oldValue = current2.req_body_type === "form" ? old.req_body_form : old.req_body_other;
    if (current2.req_body_type !== old.req_body_type) {
      diffView.push({
        title: "Request Type",
        content: diffText(old.req_body_type, current2.req_body_type)
      });
      oldValue = null;
    }
    if (current2.req_body_type === "json") {
      diffView.push({
        title: "Request Body",
        content: diffJson(oldValue, current2.req_body_other)
      });
    } else if (current2.req_body_type === "form") {
      diffView.push({
        title: "Request Form Body",
        content: diffArray(oldValue, current2.req_body_form)
      });
    } else {
      diffView.push({
        title: "Request Raw Body",
        content: diffText(oldValue, current2.req_body_other)
      });
    }
    let oldResValue = old.res_body;
    if (current2.res_body_type !== old.res_body_type) {
      diffView.push({
        title: "Response Type",
        content: diffText(old.res_body_type, current2.res_body_type)
      });
      oldResValue = "";
    }
    if (current2.res_body_type === "json") {
      diffView.push({
        title: "Response Body",
        content: diffJson(oldResValue, current2.res_body)
      });
    } else {
      diffView.push({
        title: "Response Body",
        content: diffText(oldResValue, current2.res_body)
      });
    }
  }
  return diffView = diffView.filter((item) => item.content);
};
function _isSlot$3(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const {
  $t: $t$4
} = State_UI;
const formattersHtml = index.html;
const TimeLine = defineComponent({
  props: ["fetchNewsData", "setLoading", "loading", "typeid", "curUid", "type", "fetchInterfaceList"],
  setup() {
    return {
      State_App: _State_App
    };
  },
  data() {
    return {
      newsWillShow: [],
      curSelectValue: "",
      pagination: defPagination(),
      state: {
        bidden: "",
        loading: false,
        apiList: []
      }
    };
  },
  async mounted() {
    if (this.type === "project") {
      await this.getApiList();
    }
    await this.getMore();
  },
  methods: {
    async getMore() {
      this.state.loading = true;
      try {
        const {
          data: data9
        } = await API.news.getLogList({
          typeid: this.typeid,
          type: this.type,
          page: this.pagination.page,
          limit: this.pagination.size,
          selectValue: this.curSelectValue
        });
        const {
          list,
          total: total3
        } = data9 || {};
        if (list && total3) {
          this.newsWillShow = list;
          this.pagination.total = total3;
        }
      } catch (error) {
      } finally {
        this.state.loading = false;
      }
    },
    handleCancel() {
      this.setState({
        visible: false
      });
    },
    showDiffLogDialog(data9) {
      UI.dialog.component({
        title: $t$4("Api \u6539\u52A8\u65E5\u5FD7(Esc \u5173\u95ED\u5F39\u7A97)").label,
        component: DialogShowApiModify,
        maxmin: true,
        fullscreen: true,
        diffView: diffMessage(jsondiffpatch, formattersHtml, data9)
      });
    },
    async getApiList() {
      let result = await API.project.fetchInterfaceList({
        project_id: this.typeid,
        limit: "all"
      });
      this.state.apiList = result.records;
    },
    handleSelectApi(selectValue) {
      this.curSelectValue = selectValue;
      Methods_App.fetchNewsData({
        id: this.typeid,
        type: this.type
      });
    }
  },
  computed: {
    vDomProjectChildren() {
      const children = this.state.apiList.map((item) => {
        let methodColor = METHOD_COLOR[item.method ? item.method.toLowerCase() : "get"];
        return createVNode(resolveComponent("Option"), {
          "title": item.title,
          "value": item._id + "",
          "path": item.path,
          "key": item._id
        }, {
          default: () => [item.title, " ", createVNode(resolveComponent("aTag"), {
            "style": {
              color: methodColor ? methodColor.color : "#cfefdf",
              backgroundColor: methodColor ? methodColor.bac : "#00a854",
              border: "unset"
            }
          }, {
            default: () => [item.method]
          })]
        });
      });
      children.unshift(createVNode(resolveComponent("Option"), {
        "value": "",
        "key": "all"
      }, {
        default: () => [createTextVNode("\u9009\u62E9\u5168\u90E8")]
      }));
      return children;
    },
    vDomSectionProject() {
      if (this.type === "project") {
        return createVNode(resolveComponent("aRow"), {
          "class": "news-search"
        }, {
          default: () => [createVNode(resolveComponent("aCol"), {
            "span": "3"
          }, {
            default: () => [$t$4("\u9009\u62E9\u67E5\u8BE2\u7684 Api").label, createTextVNode("\uFF1A")]
          }), createVNode(resolveComponent("aCol"), {
            "span": "10"
          }, {
            default: () => [createVNode(resolveComponent("aAutoComplete"), {
              "onSelect": this.handleSelectApi,
              "style": {
                width: "100%"
              },
              "placeholder": "Select Api",
              "optionLabelProp": "title",
              "filterOption": (inputValue, options) => {
                if (options.props.value == "")
                  return true;
                if (options.props.path.indexOf(inputValue) !== -1 || options.props.title.indexOf(inputValue) !== -1) {
                  return true;
                }
                return false;
              }
            }, {
              default: () => [createVNode(resolveComponent("OptGroup"), {
                "label": "other"
              }, {
                default: () => [createVNode(resolveComponent("Option"), {
                  "value": "wiki",
                  "path": "",
                  "title": "wiki"
                }, {
                  default: () => [createTextVNode("wiki")]
                })]
              }), createVNode(resolveComponent("OptGroup"), {
                "label": "api"
              }, {
                default: () => [this.vDomProjectChildren]
              })]
            })]
          })]
        });
      }
      return null;
    },
    vDomSectionRecords() {
      let records = createVNode(resolveComponent("ErrMsg"), {
        "type": "noData"
      }, null);
      if (this.newsWillShow.length) {
        const vDomTimeLineItem = xU.map(this.newsWillShow, (newsItem, i2) => {
          let interfaceDiff = xU.isPlainObject(newsItem.data);
          const addTime = xU.dateFormat(newsItem.add_time, 1);
          return createVNode(resolveComponent("aTimelineItem"), {
            "dot": createVNode(resolveComponent("aAvatar"), {
              "class": "pointer",
              "src": `/api/user/avatar?uid=${newsItem.uid}`,
              "onClick": () => Cpt_url.value.go(`/user/profile/${newsItem.uid}`)
            }, null),
            "key": i2
          }, {
            default: () => [createVNode("div", {
              "class": "logMesHeade"
            }, [createVNode("span", {
              "class": "logo_$timeAgo"
            }, [_$timeAgo(newsItem.add_time)]), createVNode("span", {
              "class": "logtype"
            }, [LOG_TYPE[newsItem.type], createTextVNode("\u52A8\u6001")]), createVNode("span", {
              "class": "logtime"
            }, [addTime])]), createVNode("span", {
              "class": "logcontent",
              "innerHTML": newsItem.content
            }, null), createVNode("div", {
              "style": {
                padding: "10px 0 0 10px"
              }
            }, [interfaceDiff && createVNode(resolveComponent("aButton"), {
              "onClick": () => this.showDiffLogDialog(newsItem.data)
            }, {
              default: () => [createTextVNode("\u6539\u52A8\u8BE6\u60C5")]
            })])]
          });
        });
        records = createVNode(resolveComponent("aTimeline"), {
          "class": "TimeLine_news-content"
        }, _isSlot$3(vDomTimeLineItem) ? vDomTimeLineItem : {
          default: () => [vDomTimeLineItem]
        });
      }
      return records;
    }
  },
  render() {
    return createVNode(Fragment, null, [createVNode("section", {
      "class": "news-timeline flex1"
    }, [this.vDomSectionProject, this.vDomSectionRecords]), createVNode("div", {
      "class": "flex end padding20"
    }, [createVNode(resolveComponent("xPagination"), {
      "pagination": this.pagination,
      "onPaginationChange": this.getMore
    }, null)])]);
  }
});
const GroupLog = defineComponent({
  props: ["match"],
  setup() {
    return {
      State_App: _State_App
    };
  },
  render() {
    return createVNode("section", {
      "class": "news-box flex vertical"
    }, [createVNode(TimeLine, {
      "type": "group",
      "typeid": this.State_App.currGroup._id
    }, null)]);
  }
});
const MemberList = "";
const {
  $t: $t$3
} = State_UI;
const _sfc_main$1 = defineComponent({
  props: {
    propDialogOptions: {
      type: Object,
      default() {
        return {
          __elId: false
        };
      }
    }
  },
  data() {
    return {
      formItems: {
        ...defItem({
          value: [],
          prop: "member_uids",
          itemType: ItemUAC,
          label: $t$3("\u7528\u6237\u540D").label,
          rules: [FormRules.required()]
        }),
        ...defItem({
          value: "dev",
          prop: "role",
          itemType: "Select",
          label: $t$3("\u6743\u9650").label,
          rules: [FormRules.required()],
          options: [{
            label: "\u7EC4\u957F",
            value: "owner"
          }, {
            label: "\u5F00\u53D1\u8005",
            value: "dev"
          }, {
            label: "\u8BBF\u5BA2",
            value: "guest"
          }]
        })
      }
    };
  },
  computed: {
    dialogDefautBtn() {
      return {
        onCancel: this.propDialogOptions.closeDialog,
        onOk: () => {
          this.propDialogOptions.onOk({
            formItems: this.formItems,
            closeDialog: this.propDialogOptions.closeDialog
          });
        }
      };
    }
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_xGap = resolveComponent("xGap");
  const _component_xItem = resolveComponent("xItem");
  const _component_xForm = resolveComponent("xForm");
  const _component_aCard = resolveComponent("aCard");
  const _component_xDialogFooter = resolveComponent("xDialogFooter");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_aCard, { class: "flex1" }, {
      default: withCtx(() => [
        createVNode(_component_xForm, {
          class: "flex vertical",
          "label-style": { "min-width": "120px", width: "unset" }
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.formItems, (item, prop) => {
              return openBlock(), createElementBlock(Fragment, { key: prop }, [
                createVNode(_component_xGap, { t: "10" }),
                createVNode(_component_xItem, { configs: item }, null, 8, ["configs"])
              ], 64);
            }), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_xDialogFooter, { configs: _ctx.dialogDefautBtn }, null, 8, ["configs"])
  ], 64);
}
const ViewAddMember = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
function arrayAddKey(arr) {
  return arr.map((item, index2) => {
    return {
      ...item,
      key: index2
    };
  });
}
const GroupMemberList = defineComponent({
  props: ["uid"],
  setup() {
    return {
      State_App: _State_App
    };
  },
  data() {
    return {
      state: {
        userInfo: [],
        role: ""
      },
      configs_table: defDataGridOption({
        isHidePagination: true,
        async queryTableList(params) {
        },
        dataSource: [],
        columns: {}
      })
    };
  },
  async mounted() {
    this.initTableColumns();
  },
  watch: {
    "State_App.currGroup._id": {
      immediate: true,
      handler() {
        this.fetchGroupMemberList();
      }
    }
  },
  methods: {
    initTableColumns() {
      const vm = this;
      const isAuth = ["owner", "admin"].includes(vm.State_App.currGroup.role);
      this.configs_table.columns = {
        ...defCol({
          prop: "name",
          label: `\u6210\u5458 ${vm.configs_table.dataSource.length} \u4EBA`,
          renderCell({
            record
          }) {
            const text = record.username;
            const imgSrc = `${location.protocol}//${location.host}/api/user/avatar?uid=${record.uid}`;
            return createVNode("div", {
              "class": "m-user"
            }, [createVNode("div", {
              "to": `/user/profile/${record.uid}`
            }, [createVNode("img", {
              "src": imgSrc,
              "class": "m-user-img"
            }, null)]), createVNode("div", {
              "to": `/user/profile/${record.uid}`
            }, [createVNode("p", {
              "class": "m-user-name"
            }, [createVNode("span", null, [text])])])]);
          }
        }),
        ...defCol({
          prop: "action",
          label: (() => {
            if (isAuth) {
              return createVNode("div", {
                "class": "btn-container"
              }, [createVNode(resolveComponent("aButton"), {
                "className": "btn",
                "type": "primary",
                "onClick": vm.showAddMemberDialog
              }, {
                default: () => [createTextVNode("\u6DFB\u52A0\u6210\u5458")]
              })]);
            } else {
              return "";
            }
          })(),
          renderCell({
            record
          }) {
            if (isAuth) {
              const configs = {
                deleteBtn: {
                  text: "\u5220\u9664",
                  class: "ml10",
                  async onClick() {
                    try {
                      await UI.dialog.delete({
                        title: "\u5220\u9664\u786E\u8BA4",
                        content: "\u4F60\u786E\u5B9A\u8981\u5220\u9664\u5417?"
                      });
                      vm.delMember(record.uid);
                    } catch (e2) {
                      console.log("\u53D6\u6D88\u5220\u9664");
                    }
                  }
                }
              };
              return createVNode("div", {
                "class": "flex"
              }, [createVNode(resolveComponent("aSelect"), {
                "value": record.role,
                "onChange": (role) => {
                  vm.changeUserRole({
                    member_uid: record.uid,
                    role
                  });
                },
                "options": [{
                  label: "\u7EC4\u957F",
                  value: "owner"
                }, {
                  label: "\u5F00\u53D1\u8005",
                  value: "dev"
                }, {
                  label: "\u8BBF\u5BA2",
                  value: "guest"
                }]
              }, null), createVNode(resolveComponent("xButton"), {
                "configs": configs.deleteBtn
              }, null)]);
            } else {
              const ROLE_MAP = {
                owner: vm.$t("\u7EC4\u957F").label,
                dev: vm.$t("\u5F00\u53D1\u8005").label,
                guest: vm.$t("\u8BBF\u5BA2").label
              };
              return ROLE_MAP[record.role];
            }
          }
        })
      };
    },
    showAddMemberDialog() {
      UI.dialog.component({
        title: State_UI.$t("\u6DFB\u52A0\u6210\u5458").label,
        component: ViewAddMember,
        area: ["480px", "260px"],
        onOk: async ({
          formItems,
          closeDialog
        }) => {
          const validateResults = await validateForm(formItems);
          if (AllWasWell(validateResults)) {
            const {
              member_uids,
              role
            } = pickValueFrom(formItems);
            try {
              await this.addMember({
                member_uids,
                role
              });
              closeDialog();
            } catch (error) {
              UI.message.error("\u6DFB\u52A0\u5931\u8D25");
            }
          } else {
            throw new Error("\u672A\u901A\u8FC7\u9A8C\u8BC1");
          }
        }
      });
    },
    async fetchGroupMemberList() {
      const menber = await Methods_App.fetchGroupMemberList(this.State_App.currGroup._id);
      this.state.userInfo = arrayAddKey(menber);
    },
    async addMember({
      member_uids,
      role
    }) {
      const {
        data: data9
      } = await Methods_App.addMember({
        id: this.State_App.currGroup._id,
        member_uids,
        role
      });
      const {
        add_members,
        exist_members
      } = data9;
      const addLength = add_members.length;
      const existLength = exist_members.length;
      UI.message.success(`\u65B0\u589E ${addLength} \u4EBA\uFF0C ${existLength} \u4EBA\u5DF2\u5B58\u5728`);
      this.fetchGroupMemberList();
    },
    async delMember(member_uid) {
      const id = this.State_App.currGroup._id;
      const index2 = UI.layer.loading();
      try {
        await Methods_App.delMember({
          id,
          member_uid
        });
        UI.notification.success("\u4FEE\u6539\u6210\u529F");
        this.fetchGroupMemberList();
      } catch (e2) {
        console.error(e2);
      } finally {
        UI.layer.loading(index2);
      }
    },
    async changeUserRole({
      member_uid,
      role
    }) {
      const id = this.State_App.currGroup._id;
      const index2 = UI.layer.loading();
      try {
        await Methods_App.changeMemberRole({
          id,
          member_uid,
          role
        });
        UI.notification.success("\u4FEE\u6539\u6210\u529F");
        this.fetchGroupMemberList();
      } catch (e2) {
        console.error(e2);
      } finally {
        UI.layer.loading(index2);
      }
    }
  },
  render() {
    var _a2;
    let userinfo = this.state.userInfo;
    let ownerinfo = [];
    let devinfo = [];
    let guestinfo = [];
    for (let i2 = 0; i2 < userinfo.length; i2++) {
      if (userinfo[i2].role === "owner") {
        ownerinfo.push(userinfo[i2]);
      }
      if (userinfo[i2].role === "dev") {
        devinfo.push(userinfo[i2]);
      }
      if (userinfo[i2].role === "guest") {
        guestinfo.push(userinfo[i2]);
      }
    }
    userinfo = [...ownerinfo, ...devinfo, ...guestinfo];
    this.configs_table.dataSource = userinfo;
    if ((_a2 = this.configs_table.columns) == null ? void 0 : _a2.name) {
      this.configs_table.columns.name.title = `\u6210\u5458 ${userinfo.length} \u4EBA`;
    }
    return createVNode("div", {
      "class": "m-panel"
    }, [createVNode(resolveComponent("xDataGrid"), {
      "configs": this.configs_table
    }, null)]);
  }
});
const TAB_KEY_PROJECT_LIST = "\u9879\u76EE\u5217\u8868";
const TAB_KEY_MEMBER_LIST = "\u6210\u5458\u5217\u8868";
const TAB_KEY_GROUP_LOG = "\u5206\u7EC4\u52A8\u6001";
const TAB_KEY_ARRAY = [TAB_KEY_PROJECT_LIST, TAB_KEY_MEMBER_LIST, TAB_KEY_GROUP_LOG];
const ViewGroup = defineComponent({
  setup() {
    return {
      Cpt_url,
      State_App: _State_App,
      fnShowUpsertGroupDialog,
      fnUpsertGroupInfo
    };
  },
  data() {
    return {
      state: {}
    };
  },
  mounted() {
    this.ifUrlNoGroupIdGetAndAddIdToUrl();
    if (!this.Cpt_url.query.group_tab) {
      this.Cpt_url.query.group_tab = TAB_KEY_PROJECT_LIST;
    }
  },
  beforeUnmount() {
    if (this.timmer) {
      clearTimeout(this.timmer);
    }
  },
  methods: {
    async ifUrlNoGroupIdGetAndAddIdToUrl() {
      try {
        if (!this.groupId) {
          let {
            data: group2
          } = await API.group.getMyGroup();
          this.Cpt_url.query.group_id = group2._id;
        } else {
          await Methods_App.setCurrGroup(this.groupId);
        }
      } catch (e2) {
        console.error(e2);
        this.timmer = setTimeout(() => {
          this.ifUrlNoGroupIdGetAndAddIdToUrl();
        }, 1e3);
      }
    }
  },
  computed: {
    groupId() {
      return this.Cpt_url.query.group_id || false;
    },
    tabActiveKey: {
      set(group_tab) {
        this.Cpt_url.query.group_tab = group_tab;
      },
      get() {
        const {
          group_tab
        } = this.Cpt_url.query;
        if (TAB_KEY_ARRAY.includes(group_tab)) {
          return group_tab;
        }
        return TAB_KEY_PROJECT_LIST;
      }
    },
    vDomTabMember() {
      if (this.State_App.currGroup.type === "public") {
        return createVNode(resolveComponent("aTabPane"), {
          "tab": TAB_KEY_MEMBER_LIST,
          "key": TAB_KEY_MEMBER_LIST
        }, {
          default: () => [createVNode(GroupMemberList, null, null)]
        });
      } else {
        return null;
      }
    },
    vDomTabGroupLog() {
      var _a2, _b;
      const isGroupRoleAuth = ["admin", "owner"].includes((_b = (_a2 = this.State_App) == null ? void 0 : _a2.currGroup) == null ? void 0 : _b.role);
      const isUserRoleAuth = ["admin", "owner", "guest", "dev"].includes(this.State_App.user.role);
      if (isGroupRoleAuth || isUserRoleAuth) {
        return createVNode(resolveComponent("aTabPane"), {
          "tab": TAB_KEY_GROUP_LOG,
          "key": TAB_KEY_GROUP_LOG
        }, {
          default: () => [createVNode(GroupLog, null, null)]
        });
      } else {
        return null;
      }
    },
    stylePanel() {
      const isFooterFold = this.State_App.isFooterFold;
      return {
        "flex vertical": true,
        "footer-fold elevation-4": isFooterFold,
        "elevation-8": !isFooterFold
      };
    },
    styleContent() {
      return {
        height: "100%",
        margin: "0 24px 0 16px",
        overflow: "initial",
        backgroundColor: "#fff"
      };
    },
    vDomGroupName() {
      let _vDomGroupName = createVNode("div", {
        "class": "name"
      }, [this.State_App.currGroup.group_name]);
      if (this.State_App.currGroup.group_desc) {
        return createVNode(resolveComponent("aPopover"), {
          "trigger": "hover"
        }, {
          content: () => createVNode("p", {
            "style": {
              maxWidth: "600px"
            }
          }, [this.State_App.currGroup.group_desc]),
          default: () => _vDomGroupName
        });
      } else {
        return _vDomGroupName;
      }
    },
    vDomEditIcon() {
      const isGroupRoleAuth = this.State_App.currGroup.role === "owner";
      const isUserRoleAuth = this.State_App.user.role === "admin";
      const isGroupPrivate = this.State_App.currGroup.type === "private";
      if (isGroupPrivate) {
        return null;
      }
      if (isGroupRoleAuth || isUserRoleAuth) {
        return withDirectives(createVNode(resolveComponent("xIcon"), {
          "class": "btn editSet pointer",
          "icon": "edit",
          "onClick": () => this.fnShowUpsertGroupDialog(this.State_App.currGroup),
          "style": "width:16px;"
        }, null), [[resolveDirective("uiPopover"), {
          content: "\u4FEE\u6539\u5206\u7EC4\u4FE1\u606F",
          placement: "bottom",
          delay: 1500
        }]]);
      }
    },
    vDomEditGroupInfo() {
      return createVNode("div", {
        "class": "curr-group-name"
      }, [createVNode("div", {
        "class": "curr-group-name_title elevation-1"
      }, [this.vDomGroupName, this.vDomEditIcon])]);
    }
  },
  render() {
    if (!this.groupId) {
      return createVNode(resolveComponent("aSpin"), {
        "class": "flex vertical middle center height100"
      }, null);
    }
    return createVNode(resolveComponent("aLayout"), {
      "id": "GroupView",
      "class": "padding20"
    }, {
      default: () => [createVNode(resolveComponent("aLayoutSider"), {
        "id": "ViewGroup_sider",
        "class": this.stylePanel,
        "width": "300"
      }, {
        default: () => [createVNode(GroupLeftSider, null, null)]
      }), createVNode(resolveComponent("aLayout"), null, {
        default: () => [createVNode(resolveComponent("aLayoutContent"), {
          "data-app-position": "Group-layout-content",
          "style": this.styleContent
        }, {
          default: () => [createVNode(resolveComponent("aTabs"), {
            "id": "Group-layout-content-tabs",
            "activeKey": this.tabActiveKey,
            "onUpdate:activeKey": ($event) => this.tabActiveKey = $event,
            "type": "card",
            "centered": true,
            "class": "m-tab tabs-large height100"
          }, {
            leftExtra: () => {
              return this.vDomEditGroupInfo;
            },
            default: () => {
              return createVNode(Fragment, null, [createVNode(resolveComponent("aTabPane"), {
                "tab": TAB_KEY_PROJECT_LIST,
                "key": TAB_KEY_PROJECT_LIST
              }, {
                default: () => [createVNode(GroupProjectList, null, null)]
              }), this.vDomTabMember, this.vDomTabGroupLog]);
            }
          })]
        })]
      })]
    });
  }
});
const {
  $t: $t$2
} = State_UI;
const routes = [{
  path: `/login`,
  componentName: "LoginContainer",
  component: () => __vitePreload(() => import("./LoginContainer.3d1fd44c.js"), true ? ["./LoginContainer.3d1fd44c.js","./LoginContainer.02d8757a.css"] : void 0, import.meta.url),
  meta: {
    title: $t$2("\u7528\u6237\u767B\u5F55").label
  }
}, {
  path: `/group`,
  componentName: "ViewGroup",
  component: ViewGroup,
  meta: {
    title: $t$2("\u5206\u7EC4").label
  }
}, {
  path: `/project`,
  componentName: "ViewProject",
  component: () => __vitePreload(() => import("./ViewProject.614b282d.js"), true ? [] : void 0, import.meta.url),
  meta: {
    title: $t$2("\u9879\u76EE").label
  }
}, {
  label: $t$2("\u63A5\u53E3").label,
  path: "/project/interface",
  componentName: "ProjectInterface",
  component: () => __vitePreload(() => import("./ProjectInterface.1e1b1f9d.js"), true ? ["./ProjectInterface.1e1b1f9d.js","./ProjectInterface.6a4d7119.css"] : void 0, import.meta.url),
  meta: {
    title: $t$2("\u63A5\u53E3").label
  }
}, {
  label: $t$2("\u63A5\u53E3-\u5168\u90E8").label,
  path: "/project/interface/all",
  componentName: "InterfaceAll",
  component: () => __vitePreload(() => import("./InterfaceAll.ccb6e017.js"), true ? [] : void 0, import.meta.url)
}, {
  label: $t$2("\u63A5\u53E3-\u5206\u7C7B").label,
  path: "/project/interface/category",
  componentName: "InterfaceCategory",
  component: () => __vitePreload(() => import("./InterfaceCategory.8aa03e48.js"), true ? [] : void 0, import.meta.url)
}, {
  label: $t$2("\u63A5\u53E3-\u8BE6\u60C5").label,
  path: "/project/interface/detail",
  componentName: "InterfaceDetail",
  component: () => __vitePreload(() => import("./InterfaceDetail.32dc3e6c.js"), true ? ["./InterfaceDetail.32dc3e6c.js","./InterfaceDetail.9b709bfa.css"] : void 0, import.meta.url)
}, {
  label: $t$2("\u81EA\u52A8\u5316\u6D4B\u8BD5").label,
  path: "/project/test_case",
  componentName: "InterfaceDetail",
  component: () => __vitePreload(() => import("./InterfaceDetail.32dc3e6c.js"), true ? ["./InterfaceDetail.32dc3e6c.js","./InterfaceDetail.9b709bfa.css"] : void 0, import.meta.url),
  meta: {
    title: $t$2("\u63A5\u53E3").label
  }
}, {
  label: $t$2("\u52A8\u6001").label,
  path: "/project/activity",
  component: ViewNotFound,
  meta: {
    title: $t$2("\u52A8\u6001").label
  }
}, {
  label: $t$2("\u6570\u636E\u7BA1\u7406").label,
  path: "/project/data",
  component: ViewNotFound,
  meta: {
    title: $t$2("\u6570\u636E\u7BA1\u7406").label
  }
}, {
  label: $t$2("\u6210\u5458\u7BA1\u7406").label,
  path: "/project/members",
  component: ViewNotFound,
  meta: {
    title: $t$2("\u6210\u5458\u7BA1\u7406").label
  }
}, {
  label: $t$2("\u8BBE\u7F6E").label,
  path: "/project/setting",
  component: ViewNotFound,
  meta: {
    title: $t$2("\u8BBE\u7F6E").label
  }
}, {
  path: "/:pathMatch(.*)*",
  component: ViewNotFound,
  meta: {
    title: $t$2("NotFound").label
  }
}];
const ProjectChildren = routes.filter((route2) => {
  const res = route2.path.split("/");
  if (res.length === 3 && res[1] === "project") {
    return true;
  } else {
    return false;
  }
});
const Cpt_url = computed(() => {
  const urlHash = _State_App.urlHash || "/";
  const {
    origin
  } = location;
  let _url = {};
  try {
    _url = new URL(urlHash.replace("#", ""), origin);
  } catch (e2) {
    console.log(urlHash, origin);
    console.error(e2);
  }
  let query = {};
  for (var pair of _url.searchParams.entries()) {
    query[pair[0]] = pair[1];
  }
  query = new Proxy(query, {
    get(obj, prop) {
      return obj[prop];
    },
    set(_query, prop, val) {
      _query[prop] = val;
      onlyModifyQuery(xU.merge({}, _query));
      return true;
    }
  });
  const _Cpt_url = new Proxy(_url, {
    get(obj, prop) {
      if (prop === "query") {
        return query;
      }
      if (prop === "go") {
        return modifyPathname;
      }
      if (prop === "refresh") {
        return onlyModifyQuery;
      }
      return _url[prop];
    },
    set(obj, prop, val) {
      if (prop === "path")
        return true;
    }
  });
  return _Cpt_url;
});
function transToUrl(urlLike, query) {
  const _url = new URL(String(urlLike).replace("#", ""), location.origin);
  _url.search = new URLSearchParams(query).toString();
  const {
    pathname,
    search
  } = _url;
  return {
    href: `${pathname}${search}`,
    url: _url
  };
}
async function setLocationHash(href, url2) {
  var _a2;
  try {
    if (!await Methods_App.checkLoginState()) {
      return;
    }
    if (["/login"].includes(url2.pathname)) {
      href = "/";
    }
    const route2 = xU.find(routes, {
      path: url2.pathname
    });
    if ((_a2 = route2 == null ? void 0 : route2.meta) == null ? void 0 : _a2.title) {
      setDocumentTitle(route2.meta.title);
    } else {
      setDocumentTitle("YApi-\u9AD8\u6548\u3001\u6613\u7528\u3001\u529F\u80FD\u5F3A\u5927\u7684\u53EF\u89C6\u5316\u63A5\u53E3\u7BA1\u7406\u5E73\u53F0");
    }
  } catch (error) {
    console.error(error);
  } finally {
    window.location.hash = href;
  }
}
function modifyPathname(path2, _query = {}) {
  const {
    href,
    url: url2
  } = transToUrl(path2, _query);
  setLocationHash(href, url2);
}
function onlyModifyQuery(_query) {
  const {
    href,
    url: url2
  } = transToUrl(location.hash, _query);
  setLocationHash(href, url2);
}
const {
  $t: $t$1
} = State_UI;
const LOADING_STATUS = 0;
const GUEST_STATUS = 1;
const MEMBER_STATUS = 2;
let _State_App = {
  baseURL: `http://localhost:3010`,
  isFooterFold: false,
  urlHash: window.location.hash,
  user: {
    isLogin: false,
    canRegister: true,
    isLDAP: false,
    userName: null,
    uid: null,
    email: "",
    loginState: LOADING_STATUS,
    loginWrapActiveKey: "1",
    role: "",
    type: "",
    breadcrumb: [],
    studyTip: 0,
    study: false,
    imageUrl: ""
  },
  news: {
    newsData: {
      list: [],
      total: 0
    },
    curpage: 1
  },
  groupList: [],
  currGroup: {
    role: "",
    group_name: "",
    group_desc: "",
    custom_field1: {
      name: "",
      enable: false
    }
  },
  projectList: [],
  currProject: {
    currPage: "",
    userInfo: "",
    tableLoading: ""
  }
};
_State_App = reactive(xU.merge(_State_App, lStorage.State_App));
_State_App.urlHash = window.location.hash;
const Methods_App = {
  toggleFooterFold() {
    _State_App.isFooterFold = !_State_App.isFooterFold;
  },
  setMenu(menu) {
    _State_App.menu = Object.assign({}, _State_App.menu, menu);
  },
  setUser(user2) {
    _State_App.user = Object.assign({}, _State_App.user, user2);
  },
  setNews(news2) {
    _State_App.news = Object.assign({}, _State_App.news, news2);
  },
  setBreadcrumb(breadcrumb) {
    Methods_App.setUser({
      breadcrumb
    });
  },
  async checkLoginState() {
    if (_State_App.user.role && _State_App.user.isLogin) {
      return true;
    }
    try {
      const {
        data: data9,
        response
      } = await API.user.getUserStatus();
      Methods_App.setUser({
        isLogin: response.data.errcode == 0,
        isLDAP: response.data.ladp,
        canRegister: response.data.canRegister,
        role: data9 ? data9.role : null,
        loginState: response.data.errcode == 0 ? MEMBER_STATUS : GUEST_STATUS,
        userName: data9 ? data9.username : null,
        uid: data9 ? data9._id : null,
        type: data9 ? data9.type : null,
        study: data9 ? data9.study : false
      });
    } catch (error) {
      console.error(error);
    } finally {
      return _State_App.user.isLogin;
    }
  },
  async fetchGroupList() {
    const {
      data: groupList
    } = await API.group.getMyGroupList();
    _State_App.groupList = groupList;
  },
  async setCurrGroup(group_id) {
    if (!xU.isInput(group_id)) {
      _State_App.currGroup = {};
    }
    if (_State_App.currGroup._id === group_id) {
      return;
    }
    const {
      data: currGroup
    } = await API.group.getMyGroupBy(group_id);
    _State_App.currGroup = currGroup;
  },
  async setCurrProject(project_id, options = {}) {
    let {
      isEnforce
    } = options;
    isEnforce = isEnforce || false;
    if (!xU.isInput(project_id)) {
      _State_App.currProject = {};
    }
    if (!isEnforce && _State_App.currProject._id === project_id) {
      return;
    }
    let {
      data: data9
    } = await API.project.getProjectById(Number(project_id));
    _State_App.currProject = data9;
  },
  async fetchNewsData({
    id,
    type: type4,
    page: page2 = 1,
    size: size2 = 10,
    selectValue = ""
  }) {
    try {
      const {
        data: data9
      } = await API.news.getLogList({
        typeid: id,
        type: type4,
        page: page2,
        limit: size2,
        selectValue
      });
      Methods_App.setNews({
        curpage: 1,
        newsData: {
          total: data9.total,
          list: xU.sortBy(data9.list, (a2, b2) => {
            if (a2 && b2) {
              return b2.add_time - a2.add_time;
            }
            return false;
          })
        }
      });
    } catch (error) {
      console.error(error);
    }
  },
  async changeStudyTip() {
    _State_App.user.studyTip++;
  },
  async finishStudy() {
    Methods_App.setUser({
      study: true,
      studyTip: 0
    });
  },
  async logoutActions() {
    try {
      const {
        data: data9
      } = await API.user.logoutActions();
      Methods_App.setUser({
        isLogin: false,
        loginState: GUEST_STATUS,
        userName: null,
        uid: null,
        role: "",
        type: ""
      });
      if (data9 === "ok") {
        Cpt_url.value.go("/login");
        UI.notification.success($t$1("\u9000\u51FA\u6210\u529F! ").label);
      }
    } catch (error) {
      console.error(error);
    }
  },
  async fetchInterfaceListMenu() {
  },
  async fetchProjectList(groupId) {
    if (!groupId)
      return;
    groupId = Number(groupId);
    const {
      data: data9
    } = await API.project.list(groupId);
    _State_App.projectList = data9.list;
    console.log("State_App.projectList", _State_App.projectList);
  },
  getProject() {
  },
  async changeMenuItem() {
  },
  async loginActions() {
  },
  async loginLdapActions() {
  },
  async fetchGroupMemberList(groupId) {
    const {
      data: member
    } = await API.group.getMemberListBy(groupId);
    _State_App.currGroup.member = member;
    return member;
  },
  async addMember(data9) {
    return API.group.addMember(data9);
  },
  async delMember(data9) {
    return API.group.delMember(data9);
  },
  async changeMemberRole(data9) {
    return API.group.changeMemberRole(data9);
  },
  async fetchMoreNews() {
  },
  async fetchInterfaceList() {
  },
  async addProject() {
  },
  async delProject() {
  },
  async changeUpdateModal() {
  },
  checkProjectName() {
  },
  loginTypeAction() {
  }
};
watch(_State_App, xU.debounce(function() {
  lStorage.State_App = _State_App;
}), 100);
watch(() => Cpt_url.value.query.group_id, xU.debounce(async (group_id) => {
  await Methods_App.setCurrGroup(group_id);
}), 100);
watch(() => Cpt_url.value.query.project_id, xU.debounce(async (project_id) => {
  await Methods_App.setCurrProject(project_id);
}), 100);
window.addEventListener("hashchange", xU.debounce(function() {
  _State_App.urlHash = window.location.hash;
}, 60));
function _isSlot$2(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const version = Date.now();
const FootItem = ({
  linkList,
  title,
  iconType
}) => {
  return createVNode(resolveComponent("aCol"), {
    "span": 6
  }, {
    default: () => [createVNode("h4", {
      "class": "title flex horizon middle"
    }, [iconType ? createVNode(resolveComponent("xIcon"), {
      "icon": iconType,
      "style": "width: 24px;height: 24px;display: inline-block;"
    }, null) : "", title]), linkList.map((item, i2) => {
      return createVNode("p", {
        "key": i2
      }, [createVNode("a", {
        "href": item.itemLink,
        "class": "link"
      }, [item.itemTitle])]);
    })]
  });
};
const AppFooter = defineComponent({
  setup() {
    return {
      State_App: _State_App,
      Cpt_url
    };
  },
  data() {
    return {
      isFooterFold: true,
      footList: [{
        title: "GitHub",
        iconType: "github",
        linkList: [{
          itemTitle: "YApi \u6E90\u7801\u4ED3\u5E93",
          itemLink: "https://github.com/YMFE/yapi"
        }]
      }, {
        title: "\u56E2\u961F",
        iconType: "team",
        linkList: [{
          itemTitle: "YMFE",
          itemLink: "https://ymfe.org"
        }]
      }, {
        title: "\u53CD\u9988",
        iconType: "feedback",
        linkList: [{
          itemTitle: "Github Issues",
          itemLink: "https://github.com/YMFE/yapi/issues"
        }, {
          itemTitle: "Github Pull Requests",
          itemLink: "https://github.com/YMFE/yapi/pulls"
        }]
      }, {
        title: `Copyright \xA9 2018-${new Date().getFullYear()} YMFE`,
        linkList: [{
          itemTitle: `\u7248\u672C: ${version} `,
          itemLink: "https://github.com/YMFE/yapi/blob/master/CHANGELOG.md"
        }, {
          itemTitle: "\u4F7F\u7528\u6587\u6863",
          itemLink: "https://hellosean1025.github.io/yapi/"
        }]
      }]
    };
  },
  mounted() {
    $$1("#app").addClass("flex vertical");
  },
  unmounted() {
    $$1("#app").removeClass("flex vertical");
  },
  computed: {
    wrapperStyle() {
      if (this.State_App.isFooterFold) {
        return {
          height: "192px"
        };
      } else {
        return {
          height: "0"
        };
      }
    },
    contentStyle() {
      if (this.State_App.isFooterFold) {
        return {
          display: "flex"
        };
      } else {
        return {
          display: "none"
        };
      }
    },
    toggleText() {
      if (this.State_App.isFooterFold) {
        return "\u6298\u53E0";
      } else {
        return "\u5C55\u5F00";
      }
    },
    toggleFoldBtn() {
      return {
        type: "primary",
        class: {
          "toggle-fold-btn footer-toggle": true,
          unfold: this.State_App.isFooterFold
        },
        text: this.toggleText,
        isHide: true,
        onClick: Methods_App.toggleFooterFold
      };
    }
  },
  render() {
    let _slot;
    return createVNode(Fragment, null, [createVNode(resolveComponent("xButton"), {
      "configs": this.toggleFoldBtn
    }, null), createVNode("div", {
      "class": "footer-wrapper",
      "style": this.wrapperStyle,
      "id": "ViewAppFooter"
    }, [createVNode(resolveComponent("aRow"), {
      "class": "footer-container",
      "style": this.contentStyle
    }, _isSlot$2(_slot = this.footList.map((item, i2) => {
      return createVNode(FootItem, {
        "key": i2,
        "linkList": item.linkList,
        "title": item.title,
        "iconType": item.iconType
      }, null);
    })) ? _slot : {
      default: () => [_slot]
    })])]);
  }
});
const Header = "";
const Search = "";
const Option3 = AutoComplete$1.Option;
const Srch = defineComponent({
  props: ["groupList", "projectList", "router", "history", "location", "setCurrGroup", "changeMenuItem", "fetchInterfaceListMenu"],
  data() {
    return {
      state: {
        dataSource: []
      }
    };
  },
  methods: {
    async onSelect(value, option) {
      if (option.props.type === "\u5206\u7EC4") {
        this.props.changeMenuItem("/group");
        this.$router.push({
          path: "/group/" + option.props["id"]
        });
        Methods_App.setCurrGroup(ption.props["id"] - 0);
      } else if (option.props.type === "\u9879\u76EE") {
        await Methods_App.setCurrGroup(option.props["groupId"]);
        this.$router.push({
          path: "/project/" + option.props["id"]
        });
      } else if (option.props.type === "\u63A5\u53E3") {
        await this.props.fetchInterfaceListMenu(option.props["projectId"]);
        this.props.history.push("/project/" + option.props["projectId"] + "/interface/api/" + option.props["id"]);
      }
    },
    handleSearch(value) {
      axios.get("/api/project/search?q=" + value).then((res) => {
        if (res.data && res.data.errcode === 0) {
          const dataSource = [];
          for (let title in res.data.data) {
            res.data.data[title].map((item) => {
              switch (title) {
                case "group":
                  dataSource.push(createVNode(Option3, {
                    "key": `\u5206\u7EC4${item._id}`,
                    "type": "\u5206\u7EC4",
                    "value": `${item.groupName}`,
                    "id": `${item._id}`
                  }, {
                    default: () => [`\u5206\u7EC4: ${item.groupName}`]
                  }));
                  break;
                case "project":
                  dataSource.push(createVNode(Option3, {
                    "key": `\u9879\u76EE${item._id}`,
                    "type": "\u9879\u76EE",
                    "id": `${item._id}`,
                    "groupId": `${item.groupId}`
                  }, {
                    default: () => [`\u9879\u76EE: ${item.name}`]
                  }));
                  break;
                case "interface":
                  dataSource.push(createVNode(Option3, {
                    "key": `\u63A5\u53E3${item._id}`,
                    "type": "\u63A5\u53E3",
                    "id": `${item._id}`,
                    "projectId": `${item.projectId}`
                  }, {
                    default: () => [`\u63A5\u53E3: ${item.title}`]
                  }));
                  break;
              }
            });
          }
          this.setState({
            dataSource
          });
        } else {
          console.log("\u67E5\u8BE2\u9879\u76EE\u6216\u5206\u7EC4\u5931\u8D25");
        }
      }).catch((err) => {
        console.log(err);
      });
    }
  },
  render() {
    const {
      dataSource
    } = this.state;
    return createVNode("div", {
      "class": "search-wrapper"
    }, [createVNode(AutoComplete$1, {
      "class": "search-dropdown",
      "dataSource": dataSource,
      "style": {
        width: "100%"
      },
      "defaultActiveFirstOption": false,
      "onSelect": this.onSelect,
      "onSearch": this.handleSearch
    }, {
      default: () => [createVNode(resolveComponent("aInput"), {
        "prefix": createVNode(resolveComponent("xIcon"), {
          "icon": "search",
          "class": "srch-icon"
        }, null),
        "placeholder": "\u641C\u7D22\u5206\u7EC4/\u9879\u76EE/\u63A5\u53E3",
        "class": "search-input"
      }, null)]
    })]);
  }
});
const Breadcrumb = "";
const BreadcrumbNavigation = defineComponent({
  setup() {
    return {
      Cpt_url,
      State_App: _State_App
    };
  },
  computed: {
    breadcrumbItems() {
      return xU.map([this.State_App.currGroup, this.State_App.currProject], (item, index2) => {
        if (!item) {
          return null;
        }
        if (this.Cpt_url.pathname === "/group") {
          return null;
        }
        return createVNode(resolveComponent("aBreadcrumbItem"), {
          "key": index2
        }, {
          default: () => [item.group_name || item.name]
        });
      });
    }
  },
  render() {
    return createVNode("div", {
      "class": "breadcrumb-container"
    }, [createVNode(resolveComponent("aBreadcrumb"), null, {
      default: () => [this.breadcrumbItems]
    })]);
  }
});
function _isSlot$1(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
createVNode("div", {
  "class": "title-container"
}, [createVNode("h3", {
  "class": "title"
}, [createVNode(resolveComponent("xIcon"), {
  "icon": "star"
}, null), createTextVNode("\u5173\u6CE8")]), createVNode("p", null, [createTextVNode("\u8FD9\u91CC\u662F\u4F60\u7684\u4E13\u5C5E\u6536\u85CF\u5939\uFF0C\u4FBF\u4E8E\u4F60\u627E\u5230\u81EA\u5DF1\u7684\u9879\u76EE")])]);
createVNode("div", {
  "class": "title-container"
}, [createVNode("h3", {
  "class": "title"
}, [createVNode(resolveComponent("xIcon"), {
  "icon": "plus-circle"
}, null), createTextVNode("\u65B0\u5EFA\u9879\u76EE")]), createVNode("p", null, [createTextVNode("\u5728\u4EFB\u4F55\u9875\u9762\u90FD\u53EF\u4EE5\u5FEB\u901F\u65B0\u5EFA\u9879\u76EE")])]);
createVNode("div", {
  "class": "title-container"
}, [createVNode("h3", {
  "class": "title"
}, [createTextVNode("\u4F7F\u7528\u6587\u6863 "), createVNode(resolveComponent("aTag"), {
  "color": "orange"
}, {
  default: () => [createTextVNode("\u63A8\u8350!")]
})]), createVNode("p", null, [createTextVNode("\u521D\u6B21\u4F7F\u7528 YApi\uFF0C\u5F3A\u70C8\u5EFA\u8BAE\u4F60\u9605\u8BFB"), " ", createVNode("a", {
  "target": "_blank",
  "href": "https://hellosean1025.github.io/yapi/",
  "rel": "noopener noreferrer"
}, [createTextVNode("\u4F7F\u7528\u6587\u6863")]), createTextVNode("\uFF0C\u6211\u4EEC\u4E3A\u4F60\u63D0\u4F9B\u4E86\u901A\u4FD7\u6613\u61C2\u7684\u5FEB\u901F\u5165\u95E8\u6559\u7A0B\uFF0C\u66F4\u6709\u8BE6\u7EC6\u7684\u4F7F\u7528\u8BF4\u660E\uFF0C\u6B22\u8FCE\u9605\u8BFB\uFF01"), " "])]);
const AppHeader = defineComponent({
  props: ["router", "user", "msg", "uid", "role", "login", "logoutActions", "loginTypeAction", "changeMenuItem", "history", "location", "study", "studyTip", "imageUrl"],
  setup() {
    return {
      State_App: _State_App,
      Cpt_url
    };
  },
  methods: {
    goToGroup() {
      this.Cpt_url.go("/group", {
        group_id: this.Cpt_url.query.group_id
      });
    },
    linkTo(e2) {
      if (e2.key != "/doc") {
        this.props.changeMenuItem(e2.key);
        if (!this.props.login) {
          UI.notification.info("\u8BF7\u5148\u767B\u5F55");
        }
      }
    },
    relieveLink() {
      this.props.changeMenuItem("");
    },
    handleLogin(e2) {
      e2.preventDefault();
      this.props.loginTypeAction("1");
    },
    handleReg(e2) {
      e2.preventDefault();
      this.props.loginTypeAction("2");
    }
  },
  computed: {
    icon() {
      if (this.Cpt_url.pathname === "/group") {
        return "yapi_logo";
      }
      return "back_group";
    },
    ToolUser() {
      let {
        imageUrl,
        uid: uid2,
        groupList,
        study,
        studyTip,
        user: user2,
        msg,
        role,
        logout,
        isLogin
      } = this.State_App.user;
      if (!isLogin) {
        return null;
      }
      imageUrl = imageUrl ? imageUrl : `/api/user/avatar?uid=${uid2}`;
      const items = [{
        content: "\u6211\u7684\u5173\u6CE8",
        path: "/follow",
        icon: "star"
      }, {
        content: "\u65B0\u5EFA\u9879\u76EE",
        path: "/follow",
        icon: "add"
      }, {
        content: "\u4F7F\u7528\u6587\u6863",
        href: "https://hellosean1025.github.io/yapi",
        icon: "question"
      }].map((i2) => {
        let link2 = null;
        const iconStyle = {
          fontSize: 16,
          color: "white"
        };
        if (i2.path) {
          link2 = createVNode(resolveComponent("xIcon"), {
            "icon": i2.icon,
            "style": iconStyle,
            "onClick": () => this.Cpt_url.go(i2.path)
          }, null);
        }
        if (i2.href) {
          link2 = createVNode("a", {
            "target": "_blank",
            "href": i2.href,
            "rel": "noopener noreferrer"
          }, [createVNode(resolveComponent("xIcon"), {
            "icon": i2.icon,
            "style": iconStyle
          }, null)]);
        }
        const configsPopover = {
          content: i2.content,
          placement: "bottom"
        };
        return withDirectives(createVNode("div", {
          "class": "toolbar-li"
        }, [link2]), [[resolveDirective("uiPopover"), configsPopover]]);
      });
      const avatarUrl = imageUrl ? imageUrl : `/api/user/avatar?uid=${uid2}`;
      return createVNode("div", {
        "class": "user-toolbar flex"
      }, [createVNode("div", {
        "class": "toolbar-li item-search"
      }, [createVNode(Srch, {
        "groupList": groupList
      }, null)]), items, createVNode("div", {
        "class": "toolbar-li"
      }, [createVNode(resolveComponent("aDropdown"), {
        "trigger": ["click"]
      }, {
        default: () => createVNode("a", {
          "class": "dropdown-link"
        }, [createVNode(resolveComponent("aAvatar"), {
          "src": avatarUrl
        }, null)]),
        overlay: () => this.MenuUser
      })])]);
    },
    MenuUser() {
      let _slot;
      const {
        uid: uid2,
        role
      } = this.State_App.user;
      return createVNode(resolveComponent("aMenu"), {
        "class": "user-menu",
        "onClick": ({
          key: key2
        }) => {
          if (key2 === "logout") {
            Methods_App.logoutActions();
          }
        }
      }, _isSlot$1(_slot = xU.map({
        user: {
          path: `/user/profile/${uid2}`,
          name: "\u4E2A\u4EBA\u4E2D\u5FC3",
          icon: "user",
          adminFlag: false
        },
        solution: {
          path: "/user/list",
          name: "\u7528\u6237\u7BA1\u7406",
          icon: "solution",
          adminFlag: true
        },
        logout: {
          name: "\u9000\u51FA",
          icon: "logout"
        }
      }, (item, key2) => {
        const isAdmin = role === "admin";
        if (item.adminFlag && !isAdmin) {
          return null;
        }
        const menuContent = createVNode(Fragment, null, [createVNode(resolveComponent("xIcon"), {
          "icon": item.icon
        }, null), createVNode("span", {
          "class": "ml4"
        }, [item.name])]);
        let menuLink = createVNode("a", {
          "to": item.path || "",
          "class": "flex horizon"
        }, [menuContent]);
        if (key2 === "logout") {
          createVNode("div", {
            "class": "flex horizon"
          }, [menuContent]);
        }
        return createVNode(resolveComponent("aMenuItem"), {
          "key": key2
        }, _isSlot$1(menuLink) ? menuLink : {
          default: () => [menuLink]
        });
      })) ? _slot : {
        default: () => [_slot]
      });
    }
  },
  data() {
    return {
      styleLogo: {
        width: "32px",
        height: "32px"
      }
    };
  },
  render() {
    return createVNode(resolveComponent("aLayoutHeader"), {
      "class": "header-box m-header elevation-4"
    }, {
      default: () => [createVNode("div", {
        "class": "content g-row flex middle"
      }, [createVNode("span", {
        "onClick": this.goToGroup,
        "class": "flex middle pointer"
      }, [createVNode(resolveComponent("xIcon"), {
        "icon": this.icon,
        "style": this.styleLogo
      }, null)]), createVNode(BreadcrumbNavigation, null, null), createVNode("span", {
        "class": "flex1"
      }, null), this.ToolUser])]
    });
  }
});
function _isSlot(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const {
  $t
} = State_UI;
const defautlValue = () => ({
  isLoading: false,
  list: [],
  filterText: "",
  allInterface: [],
  allTags: [],
  allCategory: [],
  expandedKeys: []
});
function resetStateInterface() {
  xU.map(defautlValue(), (value, prop) => {
    State_Project[prop] = value;
  });
  return State_Project;
}
const _State_Project = defautlValue();
const State_Project = reactive(_State_Project);
const Methods_Project = {
  setExpand: xU.debounce(function() {
    const {
      pathname,
      query
    } = Cpt_url.value;
    if ("/project/interface/detail" === pathname) {
      State_Project.expandedKeys = [Number(query.category_id)];
    } else {
      State_Project.expandedKeys = [];
    }
  }, 500),
  resetURL: xU.debounce(function() {
    const {
      pathname,
      query
    } = Cpt_url.value;
    const {
      category_id,
      interface_id
    } = query;
    const fnStrategyMap = {
      "/project/interface/all": () => {
        Cpt_url.value.go("/project/interface/all", xU.pick(Cpt_url.value.query, ["group_id", "project_id"]));
      },
      "/project/interface/category": () => {
        if (!category_id) {
          fnStrategyMap["/project/interface/all"]();
        }
      },
      "/project/interface/detail": () => {
        if (!interface_id) {
          fnStrategyMap["/project/interface/all"]();
        }
      }
    };
    const fn = fnStrategyMap[pathname];
    if (fn) {
      fn();
    } else {
      fnStrategyMap["/project/interface/all"]();
    }
  }, 100),
  async updateInterfaceMenuList() {
    var _a2, _b;
    const projectId = Number((_b = (_a2 = Cpt_url.value) == null ? void 0 : _a2.query) == null ? void 0 : _b.project_id);
    if (!projectId) {
      debugger;
      console.error("miss project_id in url");
      return;
    }
    const {
      data: data9
    } = await API.project.fetchInterfaceListMenu(projectId);
    if (data9) {
      const allCategory = data9.map((category) => {
        const list = xU.map(category.list, (i2) => {
          return {
            ...i2,
            menuType: "interface",
            categoryName: category.title,
            categoryId: category._id
          };
        });
        return {
          ...category,
          list,
          isCategory: true,
          categoryName: category.title,
          categoryId: category._id,
          menuType: "category",
          title: category.name,
          value: category._id,
          label: category.name
        };
      });
      State_Project.allCategory = allCategory;
      State_Project.allInterface = xU.reduce(allCategory, (dataSource, i2) => {
        if (xU.isArrayFill(i2.list)) {
          dataSource = dataSource.concat(i2.list);
        }
        return dataSource;
      }, []);
      const _allTags = xU.reduce(State_Project.allInterface, (allTags, i2) => {
        return allTags.concat(i2.tag);
      }, []);
      State_Project.allTags = xU.uniqBy(_allTags);
      return State_Project.allCategory;
    }
  }
};
watch(() => {
  const {
    pathname,
    query
  } = Cpt_url.value;
  return pathname + query.category_id;
}, () => {
  Methods_Project.setExpand();
});
function useInterfaceTableConfigs(isAll = false) {
  const filterParams = reactive({
    name: "",
    path: "",
    catid: [],
    status: "",
    tag: []
  });
  const configs_interfaceTable = reactive(defXVirTableConfigs({
    rowHeight: 72,
    dataSource: [],
    selectedConfigs: {
      prop: "_id"
    },
    columns: {
      ...(() => {
        if (isAll) {
          return defCol({
            label: "\u63A5\u53E3\u5206\u7C7B",
            prop: "catid",
            renderHeader({
              label
            }) {
              return createVNode("div", {
                "class": "flex"
              }, [createVNode("span", {
                "class": "flex1"
              }, [createVNode("span", null, [label]), xU.isArrayFill(filterParams.catid) ? createVNode(resolveComponent("aTag"), {
                "class": "ml10"
              }, {
                default: () => [filterParams.catid.length]
              }) : null]), createVNode(resolveComponent("aPopover"), {
                "placement": "bottomRight",
                "trigger": "click"
              }, {
                default() {
                  return createVNode(resolveComponent("xIcon"), {
                    "icon": "iconFilter",
                    "class": "pointer"
                  }, null);
                },
                content() {
                  let _slot;
                  return createVNode("div", {
                    "style": "padding: 8px"
                  }, [createVNode(resolveComponent("aSelect"), {
                    "allowClear": true,
                    "mode": "multiple",
                    "style": "min-width: 400px",
                    "value": filterParams.catid,
                    "onUpdate:value": ($event) => filterParams.catid = $event,
                    "class": "select"
                  }, _isSlot(_slot = xU.map(State_Project.allCategory, (i2) => {
                    return createVNode(resolveComponent("aSelectOption"), {
                      "value": i2.value
                    }, {
                      default: () => [createVNode("span", {
                        "class": "tag-status " + i2.value
                      }, [i2.label])]
                    });
                  })) ? _slot : {
                    default: () => [_slot]
                  })]);
                }
              })]);
            },
            renderCell({
              cell
            }) {
              const item = xU.find(State_Project.allCategory, {
                value: cell
              });
              return item ? createVNode("span", {
                "class": "ml10 tag-status " + item.value
              }, [item.label]) : null;
            }
          });
        }
        return {};
      })(),
      ...defCol({
        label: "\u63A5\u53E3\u540D\u79F0",
        prop: "title",
        renderHeader({
          label
        }) {
          return createVNode("div", {
            "class": "flex"
          }, [createVNode("span", {
            "class": "flex1"
          }, [createVNode("span", null, [label]), xU.isInput(filterParams.title) ? createVNode(resolveComponent("aTag"), {
            "color": "cyan",
            "class": "ml10"
          }, {
            default: () => [filterParams.title]
          }) : null]), createVNode(resolveComponent("aPopover"), {
            "placement": "bottomRight",
            "trigger": "click"
          }, {
            default() {
              return createVNode(resolveComponent("xIcon"), {
                "icon": "iconFilter",
                "class": "pointer"
              }, null);
            },
            content() {
              return createVNode("div", {
                "style": "padding: 8px"
              }, [createVNode(resolveComponent("aTextarea"), {
                "auto-size": {
                  minRows: 3,
                  maxRows: 5
                },
                "placeholder": $t("\u63A5\u53E3\u540D\u79F0").label,
                "value": filterParams.title,
                "onUpdate:value": ($event) => filterParams.title = $event,
                "allowClear": true,
                "style": "width: 400px"
              }, null)]);
            }
          })]);
        },
        renderCell({
          record,
          cell,
          index: index2
        }) {
          return createVNode("a", {
            "onClick": () => {
              Cpt_url.value.go("/project/interface/detail", {
                ...Cpt_url.value.query,
                category_id: record.categoryId,
                interface_id: record._id
              });
            }
          }, [cell]);
        }
      }),
      ...defCol({
        label: "\u8BF7\u6C42\u65B9\u6CD5",
        prop: "method",
        width: "100px",
        minWidth: "100px",
        renderCell({
          cell
        }) {
          return createVNode("div", {
            "class": "flex end width100"
          }, [ITEM_OPTIONS_VDOM.httpMethod(cell)]);
        }
      }),
      ...defCol({
        label: "\u63A5\u53E3\u8DEF\u5F84",
        prop: "path",
        renderHeader({
          label
        }) {
          return createVNode("div", {
            "class": "flex"
          }, [createVNode("span", {
            "class": "flex1"
          }, [createVNode("span", null, [label]), xU.isInput(filterParams.path) ? createVNode(resolveComponent("aTag"), {
            "color": "cyan",
            "class": "ml10"
          }, {
            default: () => [filterParams.path]
          }) : null]), createVNode(resolveComponent("aPopover"), {
            "placement": "bottomRight",
            "trigger": "click"
          }, {
            default() {
              return createVNode(resolveComponent("xIcon"), {
                "icon": "iconFilter",
                "class": "pointer"
              }, null);
            },
            content() {
              return createVNode("div", {
                "style": "padding: 8px"
              }, [createVNode(resolveComponent("aTextarea"), {
                "auto-size": {
                  minRows: 3,
                  maxRows: 5
                },
                "placeholder": $t("\u63A5\u53E3\u8DEF\u5F84").label,
                "value": filterParams.path,
                "onUpdate:value": ($event) => filterParams.path = $event,
                "allowClear": true,
                "style": "min-width: 400px"
              }, null)]);
            }
          })]);
        },
        renderCell({
          cell
        }) {
          return withDirectives(createVNode("p", {
            "class": "ellipsis",
            "key": cell
          }, [" ", cell]), [[resolveDirective("uiPopover"), {
            onlyEllipsis: true
          }]]);
        }
      }),
      ...defCol({
        label: "\u72B6\u6001",
        prop: "status",
        width: "160px",
        renderHeader({
          label
        }) {
          return createVNode("div", {
            "class": "flex"
          }, [createVNode("span", {
            "class": "flex1"
          }, [createVNode("span", null, [label]), ITEM_OPTIONS_VDOM.status(filterParams.status)]), createVNode(resolveComponent("aPopover"), {
            "placement": "bottomRight",
            "trigger": "click"
          }, {
            default() {
              return createVNode(resolveComponent("xIcon"), {
                "icon": "iconFilter",
                "class": "pointer"
              }, null);
            },
            content() {
              let _slot2;
              return createVNode("div", {
                "style": "padding: 8px"
              }, [createVNode(resolveComponent("aSelect"), {
                "allowClear": true,
                "style": "min-width: 100px",
                "value": filterParams.status,
                "onUpdate:value": ($event) => filterParams.status = $event,
                "class": "select"
              }, _isSlot(_slot2 = xU.map(ITEM_OPTIONS.interfaceStatus, (i2) => {
                return createVNode(resolveComponent("aSelectOption"), {
                  "value": i2.value
                }, {
                  default: () => [createVNode("span", {
                    "class": "tag-status " + i2.value
                  }, [i2.label])]
                });
              })) ? _slot2 : {
                default: () => [_slot2]
              })]);
            }
          })]);
        },
        renderCell({
          cell
        }) {
          return ITEM_OPTIONS_VDOM.status(cell);
        }
      }),
      ...defCol({
        label: "tag",
        prop: "tag",
        renderHeader({
          label
        }) {
          return createVNode("div", {
            "class": "flex"
          }, [createVNode("span", {
            "class": "flex1"
          }, [createVNode("span", null, [label]), xU.isArrayFill(filterParams.tag) ? createVNode(resolveComponent("aTag"), {
            "class": "ml10"
          }, {
            default: () => [filterParams.tag.length]
          }) : null]), createVNode(resolveComponent("aPopover"), {
            "placement": "bottomRight",
            "trigger": "click"
          }, {
            default() {
              return createVNode(resolveComponent("xIcon"), {
                "icon": "iconFilter",
                "class": "pointer"
              }, null);
            },
            content() {
              let _slot3;
              return createVNode("div", {
                "style": "padding: 8px"
              }, [createVNode(resolveComponent("aSelect"), {
                "allowClear": true,
                "mode": "multiple",
                "style": "width: 400px",
                "value": filterParams.tag,
                "onUpdate:value": ($event) => filterParams.tag = $event,
                "class": "select"
              }, _isSlot(_slot3 = xU.map(State_Project.allTags, (i2) => {
                return createVNode(resolveComponent("aSelectOption"), {
                  "value": i2
                }, _isSlot(i2) ? i2 : {
                  default: () => [i2]
                });
              })) ? _slot3 : {
                default: () => [_slot3]
              })]);
            }
          })]);
        },
        renderCell({
          cell
        }) {
          return createVNode(Fragment, null, [ITEM_OPTIONS_VDOM.tags(cell)]);
        }
      })
    }
  }));
  const fnUpdateListForShow = xU.debounce(function() {
    const {
      allInterface
    } = State_Project;
    let interfaceForShow = xU.isArrayFill(allInterface) ? allInterface : [];
    let paramKeys = Object.keys(filterParams);
    let prop = paramKeys.pop();
    while (prop) {
      const search = filterParams[prop];
      if (xU.isInput(search)) {
        console.log("interfaceForShow.length", interfaceForShow.length);
        interfaceForShow = xU.filter(interfaceForShow, (i2) => {
          if (prop == "status") {
            return i2.status === search;
          } else if (prop == "catid") {
            return search.includes(i2.catid);
          } else if (prop == "tag") {
            return xU.some(i2.tag, (tag) => search.includes(tag));
          } else {
            return new RegExp(search, "i").test(i2[prop]);
          }
        });
        console.log("interfaceForShow.length", interfaceForShow.length);
      }
      prop = paramKeys.pop();
    }
    configs_interfaceTable.dataSource = interfaceForShow;
    setTimeout(() => {
      State_Project.isLoading = false;
    }, 100);
  }, 500);
  return {
    filterParams,
    configs_interfaceTable,
    fnUpdateListForShow
  };
}
const App_less_vue_type_style_index_0_src_true_lang = "";
const Home_scss_vue_type_style_index_1_src_true_lang = "";
const _sfc_main = defineComponent({
  components: { AppFooter, AppHeader },
  setup() {
    return {
      Cpt_url,
      State_App: _State_App
    };
  },
  data() {
    return {
      isLoading: true
    };
  },
  mounted() {
    this.onAfterRefresh();
  },
  methods: {
    async onAfterRefresh() {
      try {
        await Methods_App.checkLoginState();
        await Methods_App.fetchGroupList();
        if (this.Cpt_url.query.group_id) {
          await Methods_App.setCurrGroup(this.Cpt_url.query.group_id);
          await Methods_App.fetchProjectList(this.Cpt_url.query.group_id);
          if (this.Cpt_url.query.project_id) {
            await Methods_App.setCurrProject(this.Cpt_url.query.project_id);
            await Methods_Project.updateInterfaceMenuList();
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        this.isLoading = false;
      }
    }
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AppHeader = resolveComponent("AppHeader");
  const _component_aSpin = resolveComponent("aSpin");
  const _component_RouterView = resolveComponent("RouterView");
  const _component_AppFooter = resolveComponent("AppFooter");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.State_App.user.isLogin ? (openBlock(), createBlock(_component_AppHeader, { key: 0 })) : createCommentVNode("", true),
    _ctx.isLoading ? (openBlock(), createBlock(_component_aSpin, {
      key: 1,
      spinning: true,
      class: "flex1 flex middle center"
    })) : (openBlock(), createBlock(_component_RouterView, { key: 2 })),
    createVNode(_component_AppFooter)
  ], 64);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
if (window.electronAPI) {
  (function(document2) {
    localStorage.cookies || (localStorage.cookies = "{}");
    document2.__defineGetter__("cookie", function() {
      debugger;
      var cookieName, cookies2, output, res, val, validName;
      cookies2 = JSON.parse(localStorage.cookies || "{}");
      output = [];
      for (cookieName in cookies2) {
        val = cookies2[cookieName];
        validName = cookieName && cookieName.length > 0;
        res = validName ? cookieName + "=" + val : val;
        output.push(res);
      }
      return output.join("; ");
    });
    document2.__defineSetter__("cookie", function(s2) {
      debugger;
      var cookies2, key2, parts, value;
      parts = s2.split("=");
      if (parts.length === 2) {
        key2 = parts[0], value = parts[1];
      } else {
        value = parts[0];
        key2 = "";
      }
      cookies2 = JSON.parse(localStorage.cookies || "{}");
      cookies2[key2] = value;
      localStorage.cookies = JSON.stringify(cookies2);
      return key2 + "=" + value;
    });
    document2.clearCookies = function() {
      return delete localStorage.cookies;
    };
  })(window.document);
  

  
  window.electronAPI.onNotification((_event, message) => {
    console.log(message);
  });

  window.electronAPI.onChangePort((_event, port) => {
    _State_App.baseURL = `http://localhost:${port}`;
  });
}
async function main() {
  createApp(App).use(appPlugins, {
    dependState: _State_App
  }).mount("#app");
}
main();
export {
  $$1 as $,
  AllWasWell as A,
  compositionAPI as B,
  Cpt_url as C,
  DefaultInterfaceMenu as D,
  EVENT_TYPE as E,
  FormRules as F,
  useInterfaceTableConfigs as G,
  diff as H,
  ITEM_OPTIONS as I,
  defXVirTableConfigs as J,
  defCol as K,
  ITEM_OPTIONS_VDOM as L,
  Methods_App as M,
  inject as N,
  h$1 as O,
  ProjectChildren as P,
  components as Q,
  lib as R,
  State_UI as S,
  MonacoEditor as T,
  UI as U,
  HTTP_REQUEST_HEADER as V,
  compileVNode as W,
  QUERY as X,
  GET as Y,
  HTTP_METHOD as Z,
  _export_sfc as _,
  defItem as a,
  BODY as a0,
  defineAsyncComponent as a1,
  VNodeCollection as a2,
  _$handlePath as a3,
  defDataGridOption as a4,
  copyToClipboard as a5,
  makeAhref as a6,
  InfoCard as a7,
  API as b,
  createElementBlock as c,
  defineComponent as d,
  createVNode as e,
  createBaseVNode as f,
  _State_App as g,
  createTextVNode as h,
  resetStateInterface as i,
  State_Project as j,
  isVNode as k,
  lStorage as l,
  Methods_Project as m,
  Fragment as n,
  openBlock as o,
  pickValueFrom as p,
  markRaw as q,
  resolveComponent as r,
  setValueTo as s,
  ALL as t,
  _$arrayChangeIndex as u,
  validateForm as v,
  withKeys as w,
  xU as x,
  withDirectives as y,
  resolveDirective as z
};